<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>时隔两个月，来一份总结【文末彩蛋】</title>
      <link href="posts/20210506/"/>
      <url>posts/20210506/</url>
      
        <content type="html"><![CDATA[<p>两个月来，基本上没有总结输出博客了，说实话，鸽都是有原因的（嘿嘿），今天刚收拾整理完新家，马不停蹄地来总结一下这两个月来的所见，所想。</p><blockquote><p>每一次总结都能见证自己的成长。</p></blockquote><h2 id="初来深圳"><a href="#初来深圳" class="headerlink" title="初来深圳"></a>初来深圳</h2><p>20年下半年秋招签了腾云扣钉之后，就决定以后要去 <code>深圳</code> 这个城市了，21年过年之后，早早地就和女友一起乘着高铁来到了深圳，说一句见笑的话，我当时还穿着秋裤，行李箱里还带了毛衣…</p><p>在高铁路上，披着我老爸的外套（实在是没从学校带薄外套回家），出发当天长沙天气感觉有点冷，所以又多加了一条秋裤在里，一回想到这里就感觉快笑出了声 hhh</p><p>下了高铁，那叫一个热啊，前几个小时还在长沙穿着秋裤披着小风衣出门，来到深圳北站我只想找个空调地舒舒服服躺着，啊这啊这，这也太热了。</p><p>难道这就是所谓往南飞，会发现自己衣服一件件脱嘛，是这个道理嘛？</p><h3 id="租房事情"><a href="#租房事情" class="headerlink" title="租房事情"></a>租房事情</h3><p>来到深圳，第一件事当然是要租房啦，没房子就流浪街头咯，但在租房这件事情上，没错，我踩坑了，虽然说是损失不大，房子租的也还算舒适，但觉得还是亏了（因为自己没有白嫖一点的感觉），刚开始因为是过来实习，没有直接考虑长久居住的打算，自己找房也挺费时间，所以就找了公寓。</p><p>当初找房时几乎能下的 app，从各渠道了解到的小程序、公众号都翻了个遍，最后还是选择了豆瓣上小组看房，也正是从这里踩了坑，看到 <code>房东直租</code>三个字样，就以为是房东，当初也对租房里面一些潜规则也不太了解，就加了豆瓣上的管家，现在也算是明白了，所谓的管家就是中介！就是中介！他们同样会有佣金，只是不是从你这里拿，让你觉得好像没有收中介费，实际上你交的押金，比如说是押二付一，那个 <code>二</code> 里面的 <code>一</code> 房东就把佣金给了管家，然而管家因此为了收益更多，就会抬高房价让你租。这算是管家帮房东拉租客，给的一笔佣金，一般中介都会拿到1个月左右佣金，说不定真有中介会来看我的这篇文章，只能说与我了解的八九不离十吧，我只能说把公屏打在保护上，对于一些喜欢杠的兄弟，我无需回答，你觉得你对你就是对的。现在豆瓣上中介几乎垄断了，各位小伙伴们也得多注意哈。</p><p>我之前租的房子也是因为当天看了太多太多房，一直看到了晚上，整个人都处于身心疲惫的状态，最后算是看上了不错的房子，然而对于这块租金也不是特别熟悉，感觉上和网上了解的价格也差不了多少，当时对于砍价这块也不是很擅长（砍价这块一直觉得也是需要点勇气和技巧），在和女友、家里人沟通之后，还是选择签下了，方便确实是方便，拎包直接入住了，房间自己用量尺量了一下，大概有 36 平方米，在住了 1 个多月之后，还是觉得房子有点小了，毕竟我们家里就有两台大的显示器，一个大长桌，之后毕业之后还有养猫的打算，所以经过综合考虑之后，还是打算换房了…</p><p>有了之前的经验，这次找房我们目的就很明确，我们把我们需要的罗列了出来，以及对于之前房子不好的点，注意事项也都列举了出来。</p><p>对于现在这里的房子，我们都很满意，感觉东西放下之后，还是很空（毕竟是有两房大一厅了），目前也还在置办一下家居，让房子看起来更加温馨，同样也在为猫猫而做考虑（直接给了一个房养猫）。</p><p>不知不觉，原本打算这个优先级不是很高的部分还是说了这么多，关于租房这块，我也不知道大家爱不爱看（感觉与我这个技术博主有点不搭 hhh），大家如果有想了解的也都可以联系我。</p><p>关于租房这块，我就先介绍这么多吧，后续毕业之后我会拍一个我租房的一个过程讲述视频给大家，我觉得这个是我很想做的，觉得这样应该能帮助很多人吧。</p><p>那么这一节就到此结束，期待我们后续接着聊。</p><blockquote><p>总结：现在赚钱难，省钱更难，远离中介！</p></blockquote><h3 id="学会了砍价"><a href="#学会了砍价" class="headerlink" title="学会了砍价"></a>学会了砍价</h3><p>在上一节我提到了租房砍价，来到深圳，你还别说，还真摸清了一些套路和技巧，在学校里可能会觉得自己上班了会与生活联系就没那么密切了，平常就好好上班就行了，周末就安心休息，当然这是理想状况，我们最后还是得回归生活，面对生活带来的历练。</p><p>在生活当中，我们不得不与人打交道，比如租房与房东商议租金事宜，去百货店与店老板砍个价，便宜出给你，转租自己房子时，如何向租户更好地介绍自己房子优点，商量双方能够觉得合理的事情。</p><p>来到深圳之后，对于自己想要购买的商品或者租房方面，至少有了底气和勇气与商家或者房东砍价了。</p><blockquote><p>总结：砍价就好像追女生一样，赖着脸皮去表达就是！</p></blockquote><h2 id="实习总结"><a href="#实习总结" class="headerlink" title="实习总结"></a>实习总结</h2><p>虽然是短短两个月，但是真是经历了许多，这比我在某电子公司实习感悟要多许多，但今天时间与思考有限，后续继续补充吧。</p><p>关于公司内部一切这里我就不详细说了，就说说自己对于技术方面的成长吧：</p><p>前端这一块的话，实习这两个月更多参与的还是与静态页面相关，交互的业务比较少，毕竟是实习嘛，dddd（懂的都懂）。原本校招准备方面对于 css 这块不是很多，实习阶段没想到写了好几千行 css ，独立实现官网的页面，包括移动端适配，在过去一直觉得移动端适配就是一个很高大上的东西，现在觉得好像也不是很难。</p><p>然后因为毕设原因，有一段时间也比较忙，反手学了 React ，正是公司需要，并且毕设一部分代码也是基于 React 来写的，而 React 中语法方面主要是以 hooks 为主，于是就顺手学了 hooks，当初学 hooks 的时候，和大部分前端er一样，想说：hooks 太香了！谁用谁知道！</p><blockquote><p>总结：能学的知识还有很多，持续学习ing！</p></blockquote><h2 id="毕设"><a href="#毕设" class="headerlink" title="毕设"></a>毕设</h2><p>说到毕设，4月份那段日子还是有一点着急的，上班回来还要赶着写毕设，好在平常保持学习，学会了写样式，这对于我毕设界面设计轻松了许多，不会因为一个小页面样式找资料找半天还没有结果。</p><p>除开设计了，还有论文嘛，一提到论文，想必大家应该会联想到去重，看论文，修改论文等等，而在去重与阅读文献方面都还是有一点技术，学校要求对于初稿需要 30% ，和大部分同学一样，在网上一些免费查重网站上试了一下，大概 24% 样子，然后照着重复率高的部分段落通过我了解到的技术改了改，再次试了一下， 20% 左右也差不多了，于是乎，第一次提交系统居然是 31%，所以网上一些免费查重网站并不可靠，毕竟免费嘛，库存资料也没有那么多，算法也不是那么严格。</p><p>后续没多久，降到了 14% ，算是通过了初稿环节，这后续5月下旬快要来到定稿环节了，又得忙一阵子咯。</p><blockquote><p>总结：免费查重网站仅作参考！</p></blockquote><h2 id="后续想法"><a href="#后续想法" class="headerlink" title="后续想法"></a>后续想法</h2><p>之前觉得 <code>CSDN</code> 对于我的流量感觉支持不够大，而且总感觉我的文章被转来转去的，总是看到网上一搜同样标题就有了我的文章在其他地方，当时觉得有点气，还没有别人转的流量多。</p><p>现在，想了想，其实问题也并不是很大，既然我的文章是要发表的，那么在哪看也都是看，我自己也可以添加一些文章出处就好了，总之，无论你是从哪里看到我的文章，最后应该都会知道这是我写的。</p><p>之后，希望能够在公众号及 <code>CSDN</code> 平台好好发展吧，吸收越来越多的粉丝，遇见一些有趣的人，如果你觉得我的文章有趣，快来找到我吧，<code>公众号：小狮子前端</code> 欢迎小狮子们的加入~</p><p>之后，我会尽量保持日更，当然文章不仅限于技术了，因为毕设之后我就是实实在在的社会人了 hhh，在外工作，除开技术，还有生活嘛，希望能遇见你们~</p><p>同时，文章的内容创作也不仅限于我个人，这样基本上就能保持上日更了，并且会以 React 为主要核心技术栈。</p><p>当然，除开了文章创作，还有生活上的拍摄以及技术上项目制作等等，这些都在我下半年的考虑之中，希望能在 #公众号：小狮子前端 里丰富多彩一点。</p><blockquote><p>这里是小狮子前端，不是只会写业务代码的前端攻城狮，持续学习！</p></blockquote><h2 id="彩蛋"><a href="#彩蛋" class="headerlink" title="彩蛋"></a>彩蛋</h2><p>这两个月来，在 <code>CSDN</code> 平台没想到涨粉还挺多的，已经有了 6000 多粉了，说不定今年就 1万粉了呢，在公众号里面，也有一些粉丝默默支持我的文章，尽管都是转载的别人的文章，但之后我会每周保证原创文章的篇幅，希望能够用简单的话语让你明白一些知识点，大家一起进步。</p><blockquote><p>我知道，可能有些小伙伴不太在意我上面说的，嘿嘿，就想直接看彩蛋，这次是一次小的回馈福利吧，具体福利可以在 <code>公众号：小狮子前端</code> 阅读 5 月 6日文章哈，仅限今天！</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 福利 </tag>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>15个前端攻城狮必备的学习网站 | 你知道几个？（附视频介绍）</title>
      <link href="posts/50975/"/>
      <url>posts/50975/</url>
      
        <content type="html"><![CDATA[<h2 id="前端开发所需掌握知识点概要"><a href="#前端开发所需掌握知识点概要" class="headerlink" title="前端开发所需掌握知识点概要"></a>前端开发所需掌握知识点概要</h2><ul><li><p>HTML&amp;CSS：</p><p>  对Web标准的理解（结构、表现、行为）、浏览器内核、渲染原理、依赖管理、兼容性、CSS语法、层次关系，常用属性、布局、选择器、权重、盒模型、Hack、CSS预处理器、<br>  CSS3、Flexbox、CSS Modules、Document flow、BFC、HTML5（离线 &amp; 存储、Histoy,多媒体、WebGL\SVG\Canvas）；        </p></li><li><p>JavaScript：</p><p>  数据类型、运算、对象、Function、继承、闭包、作用域、事件、Prototype、RegExp、JSON、Ajax、DOM、BOM、<br>  内存泄漏、跨域、异步请求、模板引擎、模块化、Flux、同构、算法、ECMAScript6、Nodejs、HTTP、</p></li><li><p>其他：</p><p>  主流MVVM框架(React\Vue\Angular)、Hybrid App\React Native\Weex、TypeScript、RESTFul、WEB安全、前端工程化、依赖管理、性能优化、<br>  重构、团队协作、可维护、易用性、SEO、UED、前端技术选型、快速学习能力等；</p></li></ul><h2 id="视频介绍"><a href="#视频介绍" class="headerlink" title="视频介绍"></a>视频介绍</h2><p><a href="https://www.bilibili.com/video/BV1mk4y1d7Vm">视频传送门~</a></p><h2 id="前端学习网站推荐"><a href="#前端学习网站推荐" class="headerlink" title="前端学习网站推荐"></a>前端学习网站推荐</h2><p>以下排名不分先后</p><ul><li><p>OSCHINA：     <a href=" https://www.oschina.net/">https://www.oschina.net/</a>（中文开源技术交流社区）</p></li><li><p>九章算法：    <a href="https://www.jiuzhang.com/"> https://www.jiuzhang.com/</a>（硅谷顶尖IT人员教授面试技巧）</p></li><li><p>LintCode：    <a href=" https://www.lintcode.com/"> https://www.lintcode.com/</a>（空前强大的在线刷题系统）</p></li></ul><ul><li><p>CSDN ：   <a href=" https://chocolate.blog.csdn.net/"> https://chocolate.blog.csdn.net/</a>（优秀的博客）</p></li><li><p>掘金： <a href="https://juejin.im/">https://juejin.im/</a>（帮助开发者成长的社区）</p></li><li><p>开源社区_深度开源：<a href="https://www.open-open.com/">https://www.open-open.com/</a>（一切开源）</p></li><li><p>慕课网：       <a href=" http://www.imooc.com/">http://www.imooc.com/</a>（程序员的梦工厂）</p></li><li><p>div.io：         <a href=" http://div.io">http://div.io</a>（高质量前端资源汇聚）</p></li><li><p>推酷： <a href="https://www.tuicool.com/">https://www.tuicool.com/ </a> （IT人专属个性阅读社区）</p></li><li><p>Hacker News： <a href="https://news.ycombinator.com/news">https://news.ycombinator.com/news</a>（新闻）</p></li><li><p>InfoQ：       <a href=" https://www.infoq.cn/">https://www.infoq.cn/</a>（软件开发及领域知识传播-中文版）</p></li><li><p>w3cplus：    <a href=" http://www.w3cplus.com/"> http://www.w3cplus.com/</a>（国内前端行业的技术博客）</p></li><li><p>Stack Overflow： <a href=" http://stackoverflow.com/">http://stackoverflow.com/</a>（为开发人员提供支持）</p></li><li><p>w3school：    <a href=" http://www.w3school.com.cn/">http://www.w3school.com.cn/</a>（领先的 Web 技术教程 - 全部免费）</p></li><li><p>MDN：     <a href=" https://developer.mozilla.org/zh-CN/docs/Web/">https://developer.mozilla.org/zh-CN/docs/Web/</a>（Web 开发技术分享）</p></li></ul><h2 id="官方文档推荐"><a href="#官方文档推荐" class="headerlink" title="官方文档推荐"></a>官方文档推荐</h2><ul><li><a href="https://docs.huihoo.com/jquery/jquery-fundamentals/zh-cn/index.html">jQuery 基本原理</a></li><li><a href="https://es6.ruanyifeng.com/">ECMAScript 6 入门 作者：阮一峰</a></li><li><a href="http://bonsaiden.github.io/JavaScript-Garden/zh/">JavaScript 秘密花园</a></li><li><a href="http://css.doyoe.com/">web前端开发参考手册系列之CSS参考手册</a></li><li><a href="https://wangdoc.com/javascript/">JavaScript 教程</a></li></ul><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>笔记分享：<a href="https://github.com/Chocolate1999/Front-end-learning-to-organize-notes">传送门</a></p><p>或者关注微信公众号：【小狮子前端】 回复【笔记】即可获取礼包</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 网站推荐 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>某跳动面试官：说说微信扫码登录背后的实现原理？</title>
      <link href="posts/20201009/"/>
      <url>posts/20201009/</url>
      
        <content type="html"><![CDATA[<p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20201009203226222.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70#pic_center" alt=""></p><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>这个问题我是在今年8月份的时候被问到过，当时一脸懵，当面试官一提出这个问题，我当场回答这个没接触过，可能不知道。面试官笑了笑：这是一个设计题，如果你原本就会的话，我就不会要你来设计了。</p><p>我：（苦笑…）凭借三寸不烂之舌和面试官讨论了起来，说完之后信心满满，但结果反手就收到了一份正式地感谢信。</p><p>当时，面试官问你还有什么想要问我的吗？ 我请教了这个问题，面试官回答说，你其实也猜到了一点，但是我想要的那个逻辑你没理清楚，然后吧啦吧啦引导了一下，告知可以待会学习一下，这个也挺多人讨论的。</p><hr/><p>直到今天，又收到了一份“新”的感谢信后，我突然回想到了这个问题，想了想，这个问题不能一直丢着不管，我不去学习，当然不会自然就明白其中原理，下面我们一起来探讨一下吧。</p><p>如若有帮助到您，请<strong>一键三连</strong>，当然，本文表述有问题的地方，欢迎读者指正，也是一个学习的过程，谢谢~</p><h2 id="基本技术原理"><a href="#基本技术原理" class="headerlink" title="基本技术原理"></a>基本技术原理</h2><h3 id="扫码登录功能到底是什么样的？"><a href="#扫码登录功能到底是什么样的？" class="headerlink" title="扫码登录功能到底是什么样的？"></a>扫码登录功能到底是什么样的？</h3><p>现在大部分手机上都装有微信、qq和淘宝这一类的软件。而这些app都有他们相对应的网页端。为了让用户在使用他们的网页时登录更加方便和安全，使用手机扫一扫就可以登录的服务，就显得自然而然了。</p><p>扫码登录时的界面效果如下：</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20201009190220160.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70#pic_center" alt=""></p><p>那么，此时问题来了，我们访问某个网页，这个网页怎么就出现了这个二维码呢？有了这个二维码了，它怎么知道是我扫的，还是其它人扫的呢？好神奇啊！当时面试完之后，我就有这个疑惑，下文我们逐一解答。</p><h3 id="二维码是怎么出现的？"><a href="#二维码是怎么出现的？" class="headerlink" title="二维码是怎么出现的？"></a>二维码是怎么出现的？</h3><p>首先，用户打开网站的登录首页的时候，浏览器就会向对应网页服务器发送获取<strong>登录二维码</strong>的请求，服务器收到请求后，会随机生成一个 <code>uuid</code>，将这个 <code>uuid</code> 作为key值存入redis服务器，同时设置一个过期时间，一旦过期后，用户登录二维码需要进行刷新重新获取。</p><p>同时，将这个key值和公司的验证字符串合在一起，通过二维码生成接口，生成一个二维码的图片。然后，将二维码图片和 <code>uuid</code> 一起返回给用户浏览器。</p><p>例如，对于某个登录的网页（我打开的是力扣的微信登录地址），我们习惯性地打开了浏览器的开发者工具，我发现当我在登录页面停滞一小会（大概30秒样子），请求链接会不断发生变化，如下图所示：</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20201009191855452.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70#pic_center" alt=""></p><p>其中就有一个字段 <code>uuid</code>，伴随着链接的更新而自增变化。这就很好解释了上文，服务器端会通过这个 <code>uuid</code> 调用相关接口来返回给浏览器一个二维码。</p><p>所以，二维码是谁生成的呢？别急，继续分析：</p><ul><li><p>当用户打开网站后，网站后台根据微信 <code>OAuth2.0</code> 协议向微信开发平台请求授权登录，并传递事先在微信开发平台中审核通过的 <code>AppID</code> 和 <code>AppSecrect</code> 等参数</p></li><li><p>微信开发平台对AppID等参数进行验证，并向网站后台返回二维码</p></li><li><p>网站后台将二维码传送至网站前端进行显示</p></li></ul><p>原来，还有微信开发平台参与，由它来生成我们的二维码，OK，我们接着下一个问题的思考。</p><h3 id="怎么知道是我扫了这个二维码？"><a href="#怎么知道是我扫了这个二维码？" class="headerlink" title="怎么知道是我扫了这个二维码？"></a>怎么知道是我扫了这个二维码？</h3><p>上文我们了解到了二维码的生成，并且在将 <code>uuid</code> 作为key值存入redis服务器，那么只有这个 <code>key</code> 值，哪里来的用户相关信息呢？带着这个思考，继续探讨吧。</p><p>上文我们获取了网页二维码，现在来到了用户扫这个二维码的时候了，当用户拿出手机扫描二维码，就可以得到一个验证信息和一个 <code>uuid</code>。由于手机端已经进行过了登录，在访问手机端的服务器的时候，参数中都会携带一个用户的token，手机端服务器可以从中解析到用户的 <code>userId</code>（这里从token中取值而不是手机端直接传userid是为了安全，直接传userid可能会被截获和修改，token是加密的，被修改的风险会小很多）。</p><p>手机端将解析到的数据与微信账号绑定，向微信开发平台发送<strong>登录验证</strong>请求，微信开发平台验证绑定数据，调用网站后台的回调接口，发送授权临时票据 <code>code</code> ，如果授权成功，返回一个确认信息给手机端。</p><p>手机端收到返回后，将<strong>登录确认框</strong>显示给用户（防止用户误操作，同时使登录更加人性化）。用户确认是进行的登录操作后，手机再次发送请求。服务器拿到 <code>uuId</code> 和 <code>userId</code> 后，<strong>将用户的userid作为value值存入redis中以uuid作为key的键值对中</strong>。</p><ul><li>网站后台接收到code，表明微信开发平台同意数据请求</li><li>网站后台根据code参数，再加上AppID和AppSecret请求微信开发平台换取 <code>access_token</code></li><li>微信开发平台验证参数，并返回 <code>access_token</code></li><li>网站后台收到 <code>access_token</code> 后即可进行参数分析获得用户账号数据</li></ul><p>这里，我们就拿到了用户的相关信息了。</p><ul><li>AppID：应用唯一标识，在微信开放平台提交应用审核通过后获得</li><li>AppSecret：应用密钥，在微信开放平台提交应用审核通过后获得</li><li>code：授权临时票据，第三方通过code进行获取access_token的时候需要用到，code的超时时间为10分钟，一个code只能成功换取一次access_token 即失效。code的临时性和一次性保障了微信授权登录的安全性。</li><li>access_token：用户授权第三方应用发起接口调用的凭证</li></ul><p>整个过程从网站后台向微信开发平台请求授权登录开始，最终目的是为了获得 <code>access_token</code>。</p><p>在获得了 <code>access_token</code> 后就可以解析用户的一些基本信息，包括头像、用户名、性别、城市等。这样一来，整个微信扫描登录的过程就完成了。</p><h3 id="整个过程流程图"><a href="#整个过程流程图" class="headerlink" title="整个过程流程图"></a>整个过程流程图</h3><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20201009200411341.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70#pic_center" alt=""></p><h2 id="本文参考"><a href="#本文参考" class="headerlink" title="本文参考"></a>本文参考</h2><p><a href="https://blog.csdn.net/qq_25827845/article/details/78823861">冷血之心的博客：微信扫码登录原理解析</a></p><p><a href="https://cloud.tencent.com/developer/article/1589934">乔戈里：阿里面试官：分别说说微信和淘宝扫码登录背后的实现原理？</a></p><p><a href="https://blog.csdn.net/windforce828/article/details/104607286">微信扫码登录的几秒钟里，到底发生了什么</a></p><blockquote><p>感谢以上大佬的文章，尊重劳动成果，特此提出原本链接。</p></blockquote><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>文章产出不易，还望各位小伙伴们支持一波！</p><p>往期精选：</p><p><a href="https://github.com/Chocolate1999/Front-end-learning-to-organize-notes">小狮子前端の笔记仓库</a></p><p><a href="https://github.com/Chocolate1999/leetcode-javascript">leetcode-javascript：LeetCode 力扣的 JavaScript 解题仓库，前端刷题路线（思维导图）</a></p><p>小伙伴们可以在Issues中提交自己的解题代码，🤝 欢迎Contributing，可打卡刷题，Give a ⭐️ if this project helped you!</p><p><a href="https://yangchaoyi.vip/">访问超逸の博客</a>，方便小伙伴阅读玩耍~</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/2020090211491121.png#pic_center" alt=""></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">学如逆水行舟，不进则退</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端知识梳理之webpack篇</title>
      <link href="posts/20541/"/>
      <url>posts/20541/</url>
      
        <content type="html"><![CDATA[<h2 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h2><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200504214722871.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><h3 id="前端代码为何要进行构建和打包？"><a href="#前端代码为何要进行构建和打包？" class="headerlink" title="前端代码为何要进行构建和打包？"></a>前端代码为何要进行构建和打包？</h3><p><strong>第一点，代码层面：</strong></p><ul><li>体积更小（<code>Tree-Shaking</code> 、压缩、合并），加载更快</li><li>编译高级语言或语法（<code>TS</code>、<code>ES6+</code>、模块化、<code>scss</code>）</li><li>兼容性和错误检查（<code>Polyfill</code>、<code>postcss</code>、<code>eslint</code>）</li></ul><p><strong>第二点，研发流程方面：</strong></p><ul><li>统一、高效的开发环境</li><li>统一的构建流程、产出标准</li><li>集成公司构建规范（提测、上线等）<h3 id="module-chunk-bundle分别什么意思，有何区别？"><a href="#module-chunk-bundle分别什么意思，有何区别？" class="headerlink" title="module chunk bundle分别什么意思，有何区别？"></a>module chunk bundle分别什么意思，有何区别？</h3></li><li><code>module</code> —— 各个源码文件，webpack中一切皆模块</li><li><code>chunk</code> —— 多模块合并成的，如 <code>entry</code> <code>import()</code> <code>splitChunk</code></li><li><code>bundle</code> —— 最终的输出文件<h3 id="loader-和-plugin-的区别？"><a href="#loader-和-plugin-的区别？" class="headerlink" title="loader 和 plugin 的区别？"></a>loader 和 plugin 的区别？</h3></li><li><code>loader</code> 模块转换器，如 less -&gt; css 。常见 <code>loader</code> : json-loader、cache-loader、babel-loader、html,css,less,imports…</li><li><code>plugin</code> 拓展插件，如 <code>HtmlWebpackPlugin</code>，把 <code>js</code> 或 <code>css</code> 塞进 <code>html</code> 文件里。常见 <code>puglin</code>：DefinePlugin、BannerPlugin、DllPlugin、IgnorePlugin等</li></ul><h3 id="babel-和-webpack-的区别？"><a href="#babel-和-webpack-的区别？" class="headerlink" title="babel 和 webpack 的区别？"></a>babel 和 webpack 的区别？</h3><ul><li><code>babel</code> —— <code>JS</code> 新语法编译工具、不关心<code>api</code>、不关心模块化</li><li><code>webpack</code> —— 打包构建工具，是多个 <code>loader</code>、<code>Plugin</code> 的集合</li></ul><h3 id="如何产出一个lib？"><a href="#如何产出一个lib？" class="headerlink" title="如何产出一个lib？"></a>如何产出一个lib？</h3><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200504173141618.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><h3 id="webpack如何实现懒加载？"><a href="#webpack如何实现懒加载？" class="headerlink" title="webpack如何实现懒加载？"></a>webpack如何实现懒加载？</h3><ul><li>imort()</li><li>结合 <code>Vue</code> <code>React</code> 异步组件</li><li>结合 <code>Vue-router</code> <code>React-router</code> 异步加载路由</li></ul><h3 id="为何Proxy-不能被-Ployfill"><a href="#为何Proxy-不能被-Ployfill" class="headerlink" title="为何Proxy 不能被 Ployfill"></a>为何Proxy 不能被 Ployfill</h3><ul><li>如 <code>class</code> 可以用 <code>function</code> 模拟</li><li>如 <code>Promise</code> 可以用 <code>callback</code> 来模拟</li><li>但 <code>Proxy</code> 的功能用 <code>Object.defineProperty</code> 无法模拟</li></ul><h3 id="babel-runtime-和-babel-ployfill的区别？"><a href="#babel-runtime-和-babel-ployfill的区别？" class="headerlink" title="babel-runtime 和 babel-ployfill的区别？"></a>babel-runtime 和 babel-ployfill的区别？</h3><ul><li><code>babel-ployfill</code> 会污染全局</li><li><code>babel-runtime</code> 不会污染全局</li><li>产出第三方 <code>lib</code> 需要用 <code>babel-runtime</code></li></ul><h3 id="webpack常见性能优化？"><a href="#webpack常见性能优化？" class="headerlink" title="webpack常见性能优化？"></a>webpack常见性能优化？</h3><h4 id="构建速度优化"><a href="#构建速度优化" class="headerlink" title="构建速度优化"></a>构建速度优化</h4><ul><li>优化 <code>babel-loader</code>：<code>babel</code> 编译 <code>ES6+</code> 到 <code>ES5</code> 过程会有较大消耗<br>  <img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200504092703180.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></li><li><code>IgnorePlugin</code>：避免一些<code>Plugin</code></li><li><code>noParse</code>：不去解析哪些</li><li><code>happyPack</code>（开发和生成环境均可）：多进程打包工具<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200504093219974.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""><br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200504093252536.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></li><li><code>ParallelUglifyPlugin</code>（仅生产环境）：开启多进程并进行<code>JS</code>代码压缩<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200504093437514.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">例如:</span><br><span class="line"><span class="keyword">var</span> a=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> b=<span class="number">20</span>;</span><br><span class="line"><span class="keyword">var</span> c=a+b;</span><br><span class="line">优化之后: <span class="keyword">var</span> c=<span class="number">30</span>;</span><br></pre></td></tr></table></figure><p><strong>关于开启多进程</strong></p><p>项目较大，打包较慢，开启多进程能够提高速度<br>项目较小，打包很快，开启多进程会降低速度（增加进程开销）<br>因此，按需使用</p><ul><li><p>自动刷新（<strong>不用于生产环境</strong>）：保存之后，编译完成后，浏览器会自动刷新（默认开启）<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200504094617307.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p></li><li><p>热更新（<strong>不用于生产环境</strong>）：自动刷新升级版，修改后，浏览器不用刷新，代码就生效</p><p>   关于自动刷新的问题：整个网页全部刷新，速度较慢，状态会丢失，另外，对于<code>SPA</code>网页，如果有深层路由的话，一旦代码修改，路由就会返回首页。<br>   而热更新的好处是，新代码生效，网页不刷新，状态不丢失。</p></li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200504112504302.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""><br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200504112707334.png" alt=""></p><ul><li><code>DllPlugin</code>（动态链接库插件，<strong>不用于生产环境</strong>）：针对比较大的第三方插件，没有必要每次打包都要让它打包一遍，可以优先打包好后，即打包 <code>dll</code> 文件，然后再引用它，具体使用通过 <code>DllReferencePlugin</code> 来使用 <code>dll</code> 文件。</li></ul><h4 id="产出代码优化"><a href="#产出代码优化" class="headerlink" title="产出代码优化"></a>产出代码优化</h4><p>为了达到如下效果：</p><ul><li>体积更小</li><li>合理分包，不重复加载</li><li>速度更快、内容使用更少</li></ul><p>处理：</p><ul><li><p>小图片 <code>base64</code> 编码，减少网络请求</p></li><li><p><code>bundle</code> 加 <code>hash</code></p></li><li><p>懒加载</p></li><li><p>提取公共代码</p></li><li><p><code>IgnorePlugin</code></p></li><li><p>使用 <code>CDN</code> 加速</p></li><li><p>使用 <code>production</code></p><p>  自动开启压缩代码<br>  <code>Vue</code> <code>React</code> 等会自动删掉调试代码（如开发环境的 <code>warning</code>）<br>  （<code>ES6 Module</code> 才能让 <code>tree-shaking</code> 生效，而 <code>commonjs</code> 不行，因为只有静态引用才可生效，见下文区别）</p></li><li><p><code>Scope Hosting</code><br>  代码体积更小<br>  创建函数作用域更少<br>  代码可读性更好<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200504131854442.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p></li></ul><p><strong>ES6 Module 和 Commonjs 区别</strong></p><ul><li>ES6 Module 静态引入，编译时引入（直接引用，不能用代码变量判断是否引用）</li><li>Commonjs 动态引入，执行时引入</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200504131642495.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><h2 id="彩蛋"><a href="#彩蛋" class="headerlink" title="彩蛋"></a>彩蛋</h2><p>之前一直折腾美团那个项目，在视频介绍有说过，做完项目就继续整理我的笔记仓库。如下图所示，自己还是觉得有不错的回应吧，建立仓库之初还没有想过会有人给我 <code>star</code>，更别说 <code>fork</code> 之后 <code>pull request</code> 了。诶，没想到还真有，✿✿ヽ(°▽°)ノ✿</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200504215017221.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""><br><a href="https://github.com/Chocolate1999/Front-end-learning-to-organize-notes">:sunny:小狮子前端の学习:cloud:整理笔记:heart:（传送门）</a></p><p><a href="https://github.com/Chocolate1999/Vue-family-bucket-SSR-Koa2-full-stack-development-from-Meituan">Vue全家桶+SSR+Koa2全栈开发:cloud:（传送门）</a></p><p>如果您觉得不错，那么请毫不留情地给个 <code>star</code> 吧，您的支持是我继续创作的动力！<code>star</code> 数越多，就会有更多的小伙伴能够看到，或许更多的人在前端有了方向不是。</p><p>目前，可以说前端知识梳理篇正式出炉啦，请读者跟上俺的步伐，一起学习前端知识吧，不妨关注一波不迷路~</p><p>此外，我的微信公众号：<code>小狮子前端Vue</code> 也运作啦，目前已经开设前端每日一题专栏，每天会发布一篇文章，具体如下图所示，仅需几分钟，就能获得知识，岂不是白嫖的感觉~<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200504214831255.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><p>此次灵感也是来自于在微信 <code>看一看</code> ，我看到了考研大军的激情，有着每日一句的专栏，每天可能就只需要那么几分钟的时间，就能学习英语。我觉得是挺不错的，那我也想尝试这样做，一方面，我能每天整理一点学习笔记来，另一方面，也算是自己每天学习打卡。<strong>一小步或许就是未来一大步</strong>，要来一起打卡吗✿✿ヽ(°▽°)ノ✿</p><p>最后，没啥要总结的了，小狮子笔记仓库会一直更新下去，每日一题专栏我也会坚持记录。我想，能影响一些人就已经不错啦，曾经也是受过很多dalao影响，目前也是在回馈开源。好啦，下期再见，一个不是只会写业务代码的前端攻城狮在下一期又会写什么呢？</p><p>点赞收藏评论，三连支持，下期早点见哈哈哈哈哈~</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">学如逆水行舟，不进则退</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端知识梳理之Vue篇</title>
      <link href="posts/205511/"/>
      <url>posts/205511/</url>
      
        <content type="html"><![CDATA[<h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><h3 id="v-show和v-if有什么区别"><a href="#v-show和v-if有什么区别" class="headerlink" title="v-show和v-if有什么区别"></a>v-show和v-if有什么区别</h3><ul><li><code>v-show</code> 通过 <code>CSS</code> <code>display</code> 控制显示和隐藏</li><li><code>v-if</code> 组件真正的渲染和销毁，而不是显示和隐藏</li></ul><h3 id="为何在v-for使用key"><a href="#为何在v-for使用key" class="headerlink" title="为何在v-for使用key"></a>为何在v-for使用key</h3><ul><li>必须用 <code>key</code> ， 且不能是 <code>index</code> 和 <code>random</code></li><li><code>diff</code> 算法中通过 <code>tag</code> 和 <code>key</code> 来判断，是否是 <code>sameNode</code></li><li>减少渲染次数，提升渲染性能</li></ul><h3 id="Vue-组件生命周期（包括父子组件）"><a href="#Vue-组件生命周期（包括父子组件）" class="headerlink" title="Vue 组件生命周期（包括父子组件）"></a>Vue 组件生命周期（包括父子组件）</h3><p><a href="https://www.cnblogs.com/gagag/p/6246493.html">参考：Vue生命周期</a></p><h3 id="Vue-组件如何通信（常见）"><a href="#Vue-组件如何通信（常见）" class="headerlink" title="Vue 组件如何通信（常见）"></a>Vue 组件如何通信（常见）</h3><ul><li>父子组件 <code>props</code> 和 <code>this.$emit</code></li><li>自定义事件 <code>event.$no</code>  <code>event.$off</code>   <code>event.$emit</code></li><li><code>vuex</code></li></ul><h3 id="描述组件渲染和更新的过程"><a href="#描述组件渲染和更新的过程" class="headerlink" title="描述组件渲染和更新的过程"></a>描述组件渲染和更新的过程</h3><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200505091121253.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""><br>如上图所示，vue原理三大模块：响应式、模板渲染、vdom</p><p><strong>初次渲染过程</strong></p><ul><li>解析模板为 <code>render</code> 函数 （或在开发环境已完成，<code>vue-loader</code>）</li><li>触发响应式，监听 <code>data</code> 属性 <code>getter</code>、 <code>setter</code></li><li>执行 <code>render</code> 函数，生成 <code>vnode</code> ，<code>patch(elem,vnode)</code></li></ul><p><strong>更新过程</strong></p><ul><li>修改 <code>data</code>，触发 <code>setter</code>（此前在 <code>getter</code> 中已被监听）</li><li>重新执行 <code>render</code> 函数，生成 <code>newVnode</code></li><li><code>patch(vnode,newVnode)</code></li></ul><h3 id="with-语法"><a href="#with-语法" class="headerlink" title="with 语法"></a>with 语法</h3><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/2020050509462587.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><ul><li>改变 { } 内自由变量的查找规则，当做 <code>obj</code> 属性来查找</li><li>如果找不到匹配的 <code>obj</code> 属性，就会报错</li><li><code>with</code> 要慎用，它打破了作用域规则，易读性变差 </li></ul><h3 id="vue为何是异步渲染"><a href="#vue为何是异步渲染" class="headerlink" title="vue为何是异步渲染"></a>vue为何是异步渲染</h3><ul><li>减少 <code>DOM</code> 操作次数，提高性能</li></ul><p><code>$nextTick</code> 待 <code>DOM</code> 渲染完后再回调，页面渲染时会将 <code>data</code> 的修改做整合，多次 <code>data</code> 修改只会渲染一次。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200505094049883.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><h3 id="双向数据绑定-v-model-的实现原理"><a href="#双向数据绑定-v-model-的实现原理" class="headerlink" title="双向数据绑定 v-model 的实现原理"></a>双向数据绑定 v-model 的实现原理</h3><ul><li><code>input</code> 元素的 value = this.name</li><li>绑定 input 事件 this.name = $event.target.value</li><li>data 更新触发 <code>re-render</code></li></ul><h3 id="对-MVVM-的理解"><a href="#对-MVVM-的理解" class="headerlink" title="对 MVVM 的理解"></a>对 MVVM 的理解</h3><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200505100528243.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><h3 id="computed-有何特点"><a href="#computed-有何特点" class="headerlink" title="computed 有何特点"></a>computed 有何特点</h3><ul><li>缓存，data 不变不会重新计算</li><li>提高性能</li></ul><h3 id="为何组件-data-必须是一个函数"><a href="#为何组件-data-必须是一个函数" class="headerlink" title="为何组件 data 必须是一个函数"></a>为何组件 data 必须是一个函数</h3><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200505100654826.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""><br>如上图所示，这个不是 <code>vue</code> 相关问题，而是关于 <code>js</code> 方面问题。<code>vue</code> 文件编译之后实际上是 <code>class</code> ，是一个类。而对组件使用的时候，相当于对组件进行了实例化。如果 <code>data</code> 不是一个函数的话，那每一个组件实例就共享了，就会造成数据污染问题。而函数的话，就会形成闭包，保护变量，不会造成影响。</p><h3 id="ajax-请求应该放在哪个生命周期"><a href="#ajax-请求应该放在哪个生命周期" class="headerlink" title="ajax 请求应该放在哪个生命周期"></a>ajax 请求应该放在哪个生命周期</h3><ul><li>mounted</li><li>JS 是单线程的，ajax 异步获取数据</li><li>放在 mounted 之前没有用，只会让逻辑更加混乱</li></ul><h3 id="如何将组件所有-props-传递给子组件"><a href="#如何将组件所有-props-传递给子组件" class="headerlink" title="如何将组件所有 props 传递给子组件"></a>如何将组件所有 props 传递给子组件</h3><ul><li>$pros</li><li>用法：</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;User v-bind=<span class="string">&quot;$props&quot;</span>/&gt;</span><br></pre></td></tr></table></figure><h3 id="如何自己实现-v-model"><a href="#如何自己实现-v-model" class="headerlink" title="如何自己实现 v-model"></a>如何自己实现 v-model</h3><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200505101451463.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><h3 id="多个组件有相同的逻辑，如何抽离"><a href="#多个组件有相同的逻辑，如何抽离" class="headerlink" title="多个组件有相同的逻辑，如何抽离"></a>多个组件有相同的逻辑，如何抽离</h3><ul><li>mixin</li></ul><h3 id="何时要使用异步组件"><a href="#何时要使用异步组件" class="headerlink" title="何时要使用异步组件"></a>何时要使用异步组件</h3><ul><li>加载大文件</li><li>路由异步加载</li><li>优化性能<h3 id="何时使用-keep-alive"><a href="#何时使用-keep-alive" class="headerlink" title="何时使用 keep-alive"></a>何时使用 keep-alive</h3></li><li>缓存组件，不需要重复渲染</li><li>如多个静态 <code>tab</code> 页的切换</li><li>优化性能</li></ul><h3 id="何时需要使用-beforeDestory"><a href="#何时需要使用-beforeDestory" class="headerlink" title="何时需要使用 beforeDestory"></a>何时需要使用 beforeDestory</h3><ul><li>解绑自定义事件 <code>event.$off</code></li><li>清除定时器</li><li>解绑自定义的 <code>DOM</code> 事件，如<code>window scroll</code> 等</li></ul><h3 id="什么是作用域插槽"><a href="#什么是作用域插槽" class="headerlink" title="什么是作用域插槽"></a>什么是作用域插槽</h3><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200505102221943.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""><br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200505102237428.png" alt=""></p><h3 id="Vuex-中-action-和-mutation-有何区别"><a href="#Vuex-中-action-和-mutation-有何区别" class="headerlink" title="Vuex 中 action 和 mutation 有何区别"></a>Vuex 中 action 和 mutation 有何区别</h3><ul><li>action 中处理异步，mutation 不可以</li><li>mutation 做原子操作（每次就做一个操作）</li><li>action 可以整个多个 mutation</li></ul><h3 id="Vue-router-常用的路由模式"><a href="#Vue-router-常用的路由模式" class="headerlink" title="Vue-router 常用的路由模式"></a>Vue-router 常用的路由模式</h3><ul><li>hash 默认</li><li>H5 history（需要服务端支持）</li></ul><h3 id="如何配置-Vue-router-异步加载"><a href="#如何配置-Vue-router-异步加载" class="headerlink" title="如何配置 Vue-router 异步加载"></a>如何配置 Vue-router 异步加载</h3><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200505102650619.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><h3 id="请用-vnode-描述一个-DOM-结构"><a href="#请用-vnode-描述一个-DOM-结构" class="headerlink" title="请用 vnode 描述一个 DOM 结构"></a>请用 vnode 描述一个 DOM 结构</h3><p>场景：<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200505104236415.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""><br>vnode:<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/2020050510425981.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><h3 id="diff-算法的时间复杂度"><a href="#diff-算法的时间复杂度" class="headerlink" title="diff 算法的时间复杂度"></a>diff 算法的时间复杂度</h3><ul><li>O(n)</li><li>在O(n^3)上做了优化</li></ul><h3 id="简述-diff-算法过程"><a href="#简述-diff-算法过程" class="headerlink" title="简述 diff 算法过程"></a>简述 diff 算法过程</h3><ul><li>patch ( elem , vnode ) 和 patch ( vnode , newVnode )</li><li>patchVnode 和 addVnodes 和 removeVnodes</li><li>updateChildren （key的重要性）</li></ul><h3 id="vue-常见性能优化方式"><a href="#vue-常见性能优化方式" class="headerlink" title="vue 常见性能优化方式"></a>vue 常见性能优化方式</h3><ul><li>合理使用 <code>v-show</code> 和 <code>v-if</code></li><li>合理使用 <code>computed</code></li><li><code>v-for</code> 时加 <code>key</code>，以及避免和 <code>v-if</code> 同时使用</li><li>自定义事件、<code>DOM</code>事件及时销毁</li><li>合理使用异步组件</li><li>合理使用 <code>keep-alive</code></li><li><code>data</code> 层级不要太深</li><li>使用 <code>vue-loader</code> 在开发环境做模板编译（预编译）</li><li>webpack层面的优化（<a href="https://blog.csdn.net/weixin_42429718/article/details/105902005">传送门</a>）</li><li>使用<code>SSR</code></li></ul><h2 id="彩蛋"><a href="#彩蛋" class="headerlink" title="彩蛋"></a>彩蛋</h2><p>之前一直折腾美团那个项目，在视频介绍有说过，做完项目就继续整理我的笔记仓库。如下图所示，自己还是觉得有不错的回应吧，建立仓库之初还没有想过会有人给我 <code>star</code>，更别说 <code>fork</code> 之后 <code>pull request</code> 了。诶，没想到还真有，✿✿ヽ(°▽°)ノ✿</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200504215017221.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""><br><a href="https://github.com/Chocolate1999/Front-end-learning-to-organize-notes">:sunny:小狮子前端の学习:cloud:整理笔记:heart:（传送门）</a></p><p><a href="https://github.com/Chocolate1999/Vue-family-bucket-SSR-Koa2-full-stack-development-from-Meituan">Vue全家桶+SSR+Koa2全栈开发:cloud:（传送门）</a></p><p>如果您觉得不错，那么请毫不留情地给个 <code>star</code> 吧，您的支持是我继续创作的动力！<code>star</code> 数越多，就会有更多的小伙伴能够看到，或许更多的人在前端有了方向不是。</p><p>目前，可以说前端知识梳理篇正式出炉啦，请读者跟上俺的步伐，一起学习前端知识吧，不妨关注一波不迷路~</p><p>此外，我的微信公众号：<code>小狮子前端Vue</code> 也运作啦，目前已经开设前端每日一题专栏，每天会发布一篇文章，具体如下图所示，仅需几分钟，就能获得知识，岂不是白嫖的感觉~<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200504214831255.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><p>此次灵感也是来自于在微信 <code>看一看</code> ，我看到了考研大军的激情，有着每日一句的专栏，每天可能就只需要那么几分钟的时间，就能学习英语。我觉得是挺不错的，那我也想尝试这样做，一方面，我能每天整理一点学习笔记来，另一方面，也算是自己每天学习打卡。<strong>一小步或许就是未来一大步</strong>，要来一起打卡吗✿✿ヽ(°▽°)ノ✿</p><p>最后，没啥要总结的了，小狮子笔记仓库会一直更新下去，每日一题专栏我也会坚持记录。我想，能影响一些人就已经不错啦，曾经也是受过很多dalao影响，目前也是在回馈开源。好啦，下期再见，一个不是只会写业务代码的前端攻城狮在下一期又会写什么呢？</p><p>点赞收藏评论，三连支持，下期早点见哈哈哈哈哈~</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">学如逆水行舟，不进则退</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端知识梳理之HTML篇</title>
      <link href="posts/20542/"/>
      <url>posts/20542/</url>
      
        <content type="html"><![CDATA[<h2 id="html5有哪些新特性、移除了那些元素？"><a href="#html5有哪些新特性、移除了那些元素？" class="headerlink" title="html5有哪些新特性、移除了那些元素？"></a>html5有哪些新特性、移除了那些元素？</h2><ul><li><p><code>HTML5</code> 现在已经不是 <code>SGML</code> 的子集，主要是关于图像，位置，存储，多任务等功能的增加</p><p>  绘画 <code>canvas</code><br>  用于媒介回放的<code>video</code> 和 <code>audio</code> 元素<br>  本地离线存储<code>localStorage</code> 长期存储数据，浏览器关闭后数据不丢失<br>  <code>sessionStorage</code> 的数据在浏览器关闭后自动删除<br>  语意化更好的内容元素，比如<code>article</code>、<code>footer</code>、<code>header</code>、<code>nav</code>、<code>section</code><br>  表单控件，<code>calendar</code>、<code>date</code>、<code>time</code>、<code>email</code>、<code>url</code>、<code>search</code><br>  新的技术<code>webworker</code>、<code>websocket</code>、 <code>Geolocation</code></p></li><li><p><code>移除</code> 的元素：</p><p>  纯表现的元素：<code>basefont</code>、<code>big</code>、<code>center</code>、<code>font</code>、 <code>s</code>、<code>strike</code>、<code>tt</code>、<code>u</code><br>  对可用性产生负面影响的元素：<code>frame</code>、<code>frameset</code>、<code>noframes</code></p></li><li><p>支持<code>HTML5</code>新标签：</p><p>  IE8/IE7/IE6支持通过<code>document.createElement</code>方法产生的标签<br>  可以利用这一特性让这些浏览器支持<code>HTML5</code>新标签<br>  浏览器支持新标签后，还需要添加标签默认的样式</p></li><li><p>当然也可以直接使用成熟的框架、比如<code>html5shim</code></p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!--[<span class="keyword">if</span> lt IE <span class="number">9</span>]&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script&gt; src=<span class="string">&quot;http://html5shim.googlecode.com/svn/trunk/html5.js&quot;</span>&lt;/script&gt;</span><br><span class="line"> </span><br><span class="line">&lt;![endif]--&gt;</span><br></pre></td></tr></table></figure><h2 id="前端注意哪些SEO"><a href="#前端注意哪些SEO" class="headerlink" title="前端注意哪些SEO?"></a>前端注意哪些SEO?</h2><ul><li>合理的<code>title</code>、<code>description</code>、<code>keywords</code>：搜索对着三项的权重逐个减小，<code>title</code>值强调重点即可，重要关键词出现不要超过2次，而且要靠前，不同页面<code>title</code>要有所不同；<code>description</code>把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面<code>description</code>有所不同；<code>keywords</code>列举出重要关键词即可</li><li>语义化的<code>HTML</code>代码，符合W3C规范：语义化代码让搜索引擎容易理解网页</li><li>重要内容<code>HTML</code>代码放在最前：搜索引擎抓取<code>HTML</code>顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取</li><li>重要内容不要用<code>js</code>输出：爬虫不会执行js获取内容</li><li>少用<code>iframe</code>：搜索引擎不会抓取<code>iframe</code>中的内容</li><li>非装饰性图片必须加<code>alt</code></li><li>提高网站速度：网站速度是搜索引擎排序的一个重要指标</li></ul><h2 id="从浏览器地址栏输入url到显示页面的步骤"><a href="#从浏览器地址栏输入url到显示页面的步骤" class="headerlink" title="从浏览器地址栏输入url到显示页面的步骤"></a>从浏览器地址栏输入url到显示页面的步骤</h2><p><strong>简略回答</strong></p><ul><li>浏览器根据请求的<code>URL</code>交给<code>DNS</code>域名解析，找到真实<code>IP</code>，向服务器发起请求；</li><li>服务器交给后台处理完成后返回数据，浏览器接收文件（<code>HTML、JS、CSS</code>、图象等）；</li><li>浏览器对加载到的资源（HTML、JS、CSS等）进行语法解析，建立相应的内部数据结构（如HTML的DOM）；</li><li>载入解析到的资源文件，渲染页面，完成。</li></ul><p><strong>详细回答</strong></p><ol><li>从浏览器接收<code>url</code>到开启网络请求线程（这一部分可以展开浏览器的机制以及进程与线程之间的关系）</li><li>开启网络线程到发出一个完整的<code>HTTP</code>请求（这一部分涉及到dns查询，<code>TCP/IP</code>请求，五层因特网协议栈等知识）</li><li>从服务器接收到请求到对应后台接收到请求（这一部分可能涉及到负载均衡，安全拦截以及后台内部的处理等等）</li><li>后台和前台的<code>HTTP</code>交互（这一部分包括<code>HTTP</code>头部、响应码、报文结构、<code>cookie</code>等知识，可以提下静态资源的<code>cookie</code>优化，以及编码解码，如<code>gzip</code>压缩等）</li><li>单独拎出来的缓存问题，<code>HTTP</code>的缓存（这部分包括http缓存头部，<code>ETag</code>，<code>catch-control</code>等）</li><li>浏览器接收到<code>HTTP</code>数据包后的解析流程（解析<code>html</code>-词法分析然后解析成<code>dom</code>树、解析<code>css</code>生成<code>css规则树</code>、合并成<code>render</code>树，然后<code>layout、painting</code>渲染、复合图层的合成、<code>GPU</code>绘制、外链资源的处理、<code>loaded</code>和<code>DOMContentLoaded</code>等）</li><li><code>CSS</code>的可视化格式模型（元素的渲染规则，如包含块，控制框，<code>BFC</code>，<code>IFC</code>等概念）</li><li><code>JS</code>引擎解析过程（<code>JS</code>的解释阶段，预处理阶段，执行阶段生成执行上下文，<code>VO</code>，作用域链、回收机制等等）</li><li>其它（可以拓展不同的知识模块，如<code>跨域</code>，<code>web安全</code>，<code>hybrid</code>模式等等内容）</li></ol><h2 id="如何进行网站性能优化"><a href="#如何进行网站性能优化" class="headerlink" title="如何进行网站性能优化"></a>如何进行网站性能优化</h2><ul><li><p><code>content</code> 方面</p><p>  减少<code>HTTP</code>请求：合并文件、<code>CSS</code>精灵、<code>inline Image</code><br>  减少<code>DNS</code>查询：<code>DNS</code>缓存、将资源分布到恰当数量的主机名<br>  减少<code>DOM</code>元素数量</p></li><li><p><code>Cookie</code> 方面</p><p>  减小<code>cookie</code>大小</p></li><li><p><code>Server</code> 方面</p><p>  使用<code>CDN</code><br>  配置<code>ETag</code><br>  对组件使用<code>Gzip</code>压缩</p></li><li><p><code>图片</code> 方面</p><p>  优化图片：根据实际颜色需要选择色深、压缩<br>  优化<code>css</code>精灵<br>  不要在<code>HTML</code>中拉伸图片</p></li><li><p><code>css</code> 方面</p><p>   将样式表放到页面顶部<br>  不使用<code>CSS</code>表达式<br>  使用<code>&lt;link&gt;</code>不使用<code>@import</code></p></li><li><p><code>js</code> 方面</p><p>  将脚本放到页面底部<br>  将<code>javascript</code>和<code>css</code>从外部引入<br>  压缩<code>javascript</code>和<code>css</code><br>  删除不需要的脚本<br>  减少<code>DOM</code>访问</p></li></ul><h2 id="语义化的理解"><a href="#语义化的理解" class="headerlink" title="语义化的理解"></a>语义化的理解</h2><ul><li>简单来说：用正确的标签做正确的事情！</li><li><code>HTML</code>语义化就是让页面的内容结构化，便于对浏览器、搜索引擎解析；</li><li>在没有样式<code>CSS</code>情况下也以一种文档格式显示，并且是容易阅读的。</li><li>搜索引擎的爬虫依赖于标记来确定上下文和各个关键字的权重，利于 <code>SEO</code>。</li><li>使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解</li></ul><h2 id="对浏览器内核的理解"><a href="#对浏览器内核的理解" class="headerlink" title="对浏览器内核的理解"></a>对浏览器内核的理解</h2><ul><li><p>主要分成两部分：渲染引擎(<code>layout engineer</code>或<code>Rendering Engine</code>)和<code>JS</code>引擎</p></li><li><p>渲染引擎：负责取得网页的内容（<code>HTML</code>、<code>XML</code>、图像等等）、整理讯息（例如加入<code>CSS</code>等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核</p></li><li><p><code>JS</code>引擎则：解析和执行<code>javascript</code>来实现网页的动态效果</p></li><li><p>最开始渲染引擎和<code>JS</code>引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎</p></li></ul><h2 id="请描述一下-cookies，sessionStorage-和-localStorage-的区别？"><a href="#请描述一下-cookies，sessionStorage-和-localStorage-的区别？" class="headerlink" title="请描述一下 cookies，sessionStorage 和 localStorage 的区别？"></a>请描述一下 cookies，sessionStorage 和 localStorage 的区别？</h2><ul><li><p><code>cookie</code>是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）</p></li><li><p><code>cookie</code>数据始终在同源的http请求中携带（即使不需要），即会在浏览器和服务器间来回传递</p></li><li><p><code>sessionStorage</code>和<code>localStorage</code>不会自动把数据发给服务器，仅在本地保存</p></li><li><p>存储大小：</p><p>  <code>cookie</code>数据大小不能超过4k<br>  <code>sessionStorage</code>和<code>localStorage</code>虽然也有存储大小的限制，但比<code>cookie</code>大得多，可以达到5M或更大</p></li><li><p>有期时间：</p><p>  <code>localStorage</code> 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据<br>  <code>sessionStorage</code> 数据在当前浏览器窗口关闭后自动删除<br>  <code>cookie</code> 设置的<code>cookie</code>过期时间之前一直有效，即使窗口或浏览器关闭</p></li></ul><h2 id="页面访问cookie的限制条件"><a href="#页面访问cookie的限制条件" class="headerlink" title="页面访问cookie的限制条件"></a>页面访问cookie的限制条件</h2><p>cookie （储存在用户本地终端上的数据）</p><p>cookie 指某些网站为了辨别用户身份、进行 session 跟踪而储存在用户本地终端上的数据。cookie 在网络系统中几乎无处不在，当我们浏览以前访问过的网站时，网页中可能会出现 ：你好 XXX。</p><p><strong>1. 跨域问题：</strong></p><p><code>cookie</code>允许Web开发者保留他们的用户的登录状态。但是当你的站点有一个以上的域名时就会出现问题了。在<code>cookie</code>规范上说，一个<code>cookie</code>只能用于一个域名，不能够发给其它的域名。因此，如果在浏览器中对一个域名设置了一个<code>cookie</code>，这个<code>cookie</code>对于其它的域名将无效。</p><p><strong>解决：</strong></p><ul><li>通过nginx反向代理</li><li>jsonp方式请求</li></ul><p><strong>2. 设置了HTTP only：</strong></p><p>如果在cookie中设置了<code>HttpOnly</code>属性，那么通过程序(JS脚本、Applet等)将无法读取到<code>cookie</code>信息，这样能有效的防止<code>XSS</code>攻击。</p><h2 id="cookie的作用与弊端"><a href="#cookie的作用与弊端" class="headerlink" title="cookie的作用与弊端"></a>cookie的作用与弊端</h2><p><strong>cookie的作用</strong></p><ul><li>可以在客户端上保存用户数据，起到简单的缓存和用户身份识别等作用。</li><li>保存用户的登陆状态，用户进行登陆，成功登陆后，服务器生成特定的cookie返回给客户端，客户端下次访问该域名下的任何页面，将该cookie的信息发送给服务器，服务器经过检验，来判断用户是否登陆。</li><li>记录用户的行为。</li></ul><p><strong>cookie弊端</strong></p><ul><li>增加流量消耗，每次请求都需要带上cookie信息。</li><li>安全性隐患，cookie使用明文传输。如果cookie被人拦截了，那人就可以取得所有的session信息。</li><li>Cookie数量和长度的限制。每个domain最多只能有20条cookie，每个cookie长度不能超过4KB，否则会被截掉</li></ul><h2 id="介绍cookie的属性"><a href="#介绍cookie的属性" class="headerlink" title="介绍cookie的属性"></a>介绍cookie的属性</h2><p>在chrome控制台中的Application选项卡中可以看到cookie的信息。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200328111716129.png" alt=""></p><p>一个域名下面可能存在着很多个<code>cookie</code>对象。但一个<code>cookie</code>只能用于一个域名，不能够发给其它的域名。</p><ul><li><p>Name</p><p>  为一个cookie的名称（用 JavaScript 操作 Cookie 的时候注意对 Value 进行编码处理。）</p></li><li><p>value</p><p>  为一个cookie的值（用 JavaScript 操作 Cookie 的时候注意对 Value 进行编码处理。）</p></li><li><p>Domain<br>  为可以访问此cookie的域名</p></li></ul><p>注：二级域名能读取设置了<code>domain</code>为顶级域名或者自身的cookie，不能读取其他二级域名<code>domain</code>的<code>cookie</code>。所以要想<code>cookie</code>在多个二级域名中共享，需要设置<code>domain</code>为顶级域名，这样就可以在所有二级域名里面获得到这个<code>cookie</code>的值了。</p><p>顶级域名只能获取到<code>domain</code>设置为顶级域名的<code>cookie</code>，其他domain设置为二级域名的无法获取。</p><ul><li>Path</li></ul><p>为可以访问此cookie的页面路径。 比如domain是abc.com,path是/test，那么只有/test路径下的页面可以读取此cookie</p><ul><li>Expires</li></ul><p>字段为此cookie<code>超时时间</code>。若设置其值为一个时间，那么当到达此时间后，此cookie失效。不设置的话<code>默认值是Session</code>，意思是cookie会和session一起失效。当浏览器关闭(不是浏览器标签页，而是整个浏览器) 后，此cookie失效。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Set</span>-Cookie: id=a3fWa; Expires=Wed, <span class="number">21</span> Oct <span class="number">2015</span> <span class="number">07</span>:<span class="number">28</span>:<span class="number">00</span> GMT;</span><br></pre></td></tr></table></figure><p>当为<code>会话性 Cookie</code> 的时候，值保存在客户端内存中，并在用户关闭浏览器时失效。需要注意的是，有些浏览器提供了会话恢复功能，这种情况下即使关闭了浏览器，会话期 Cookie 也会被保留下来，就好像浏览器从来没有关闭一样。</p><p>与会话性 Cookie 相对的是<code>持久性 Cookie</code>，持久性 Cookies 会保存在用户的硬盘中，直至过期或者清除 Cookie。这里值得注意的是，设定的日期和时间只与客户端相关，而不是服务端。</p><ul><li>Max-Age</li></ul><p><code>Max-Age</code>用于设置在 Cookie 失效之前需要经过的<code>秒数</code>。比如：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Set</span>-Cookie: id=a3fWa; Max-Age=<span class="number">604800</span>;</span><br></pre></td></tr></table></figure><p><code>Max-Age</code> 可以为正数、负数、甚至是 0。</p><p>如果 max-Age 属性为<code>正数</code>时，浏览器会将其持久化，即写到对应的 Cookie 文件中。</p><p>当 max-Age 属性为<code>负数</code>，则表示该 Cookie 只是一个会话性 Cookie。</p><p>当 max-Age 为 <code>0</code>时，则会立即删除这个 Cookie。</p><p>假如 <code>Expires</code>和 <code>Max-Age</code> 都存在，<code>Max-Age</code>优先级更高。</p><ul><li><p>Size<br>  此cookie大小</p></li><li><p>HttpOnly</p></li></ul><p>若此属性为<code>true</code>，则只有在http请求头中会带有此cookie的信息，而不能通过<code>document.cookie</code>来访问此cookie。</p><ul><li><p>Secure<br>  设置是否只能通过https来传递此条cookie。使用 <code>HTTPS</code>安全协议，可以保护 Cookie 在浏览器和 Web 服务器间的传输过程中不被窃取和篡改。</p></li><li><p>SameSite<br>(    3月份比较火的一个问题，下面会参考别人文章进行整理）</p></li></ul><h2 id="预测最近面试会考-Cookie-的-SameSite-属性"><a href="#预测最近面试会考-Cookie-的-SameSite-属性" class="headerlink" title="预测最近面试会考 Cookie 的 SameSite 属性"></a>预测最近面试会考 Cookie 的 SameSite 属性</h2><p><a href="https://segmentfault.com/a/1190000022055666">参考文章出处</a></p><p><strong>前言</strong></p><p>2 月份发布的 Chrome 80 版本中默认屏蔽了第三方的 Cookie，在灰度期间，就导致了阿里系的很多应用都产生了问题，为此还专门成立了小组，推动各 BU 进行改造，目前阿里系基本已经改造完成。所有的前端团队估计都收到过通知，也着实加深了一把大家对于 Cookie 的理解，所以很可能就此出个面试题，而即便不是面试题，当问到 HTTP 相关内容的时候，不妨也扯到这件事情来，一能表明你对前端时事的跟进，二还能借此引申到前端安全方面的内容，为你的面试加分。</p><p><strong>HTTP</strong></p><p>一般我们都会说 “HTTP 是一个<code>无状态的协议</code>”，不过要注意这里的 HTTP 其实是指 HTTP 1.x，而所谓无状态协议，简单的理解就是即使同一个客户端连续两次发送请求给服务器，服务器也<code>识别不出这是同一个客户端发送的请求</code>，这导致的问题就比如你加了一个商品到购物车中，但因为识别不出是同一个客户端，你刷新下页面就没有了……</p><p><strong>Cookie</strong></p><p>为了解决 HTTP 无状态导致的问题，后来出现了 Cookie。不过这样说可能会让你产生一些误解，首先无状态并不是不好，有优点，但也会导致一些问题。而 Cookie 的存在也不是为了解决通讯协议无状态的问题，只是为了解决客户端与服务端会话状态的问题，这个状态是指<code>后端服务的状态而非通讯协议的状态</code>。</p><p><strong>Cookie 的设置</strong></p><p>那 Cookie 是怎么设置的呢？简单来说就是</p><ol><li>客户端发送 HTTP 请求到服务器</li><li>当服务器收到 HTTP 请求时，在响应头里面添加一个 Set-Cookie 字段</li><li>浏览器收到响应后保存下 Cookie</li><li>之后对该服务器每一次请求中都通过 Cookie 字段将 Cookie 信息发送给服务器。</li></ol><h2 id="SameSite"><a href="#SameSite" class="headerlink" title="SameSite"></a>SameSite</h2><p>SameSite 是最近非常值得一提的内容，因为 2 月份发布的 Chrome80 版本中默认屏蔽了第三方的 Cookie，这会导致阿里系的很多应用都产生问题，为此还专门成立了问题小组，推动各 BU 进行改造。</p><p><strong>作用</strong></p><p>SameSite 属性可以让<code>Cookie</code>在跨站请求时不会被发送，从而可以阻止跨站请求伪造攻击（<code>CSRF</code>）。</p><p><strong>属性值</strong></p><ul><li><code>Strict</code>仅允许一方请求携带 Cookie，即浏览器将只发送<code>相同站点</code>请求的 Cookie，即当前网页 URL 与请求目标 <code>URL 完全一致</code>。</li><li><code>Lax</code>允许部分第三方请求携带 Cookie</li><li><code>None</code>无论是否跨站都会发送 Cookie</li></ul><p>之前默认是<code>None</code> 的，Chrome80 后默认是 <code>Lax</code>。</p><p><strong>跨域和跨站</strong></p><p>首先要理解的一点就是<code>跨站</code>和<code>跨域</code>是不同的。同站(<code>same-site</code>)/跨站(<code>cross-site</code>)」和第一方(<code>first-party</code>)/第三方(<code>third-party</code>)是等价的。但是与浏览器同源策略（<code>SOP</code>）中的「同源(<code>same-origin</code>)/跨域(<code>cross-origin</code>)」是完全不同的概念。</p><p>同源策略的同源是指两个 URL 的协议/主机名/端口一致。例如，<code>https://www.taobao.com/pages/...</code>，它的协议是<code>https</code>，主机名是<code>www.taobao.com</code>，端口是 <code>443</code>。</p><p>同源策略作为浏览器的安全基石，其「同源」判断是比较严格的，相对而言，<code>Cookie</code>中的「同站」判断就比较宽松：只要两个 URL 的 eTLD+1 相同即可，不需要考虑协议和端口。其中，eTLD 表示有效顶级域名，注册于 Mozilla 维护的公共后缀列表（Public Suffix List）中，例如，.com、.co.uk、.github.io 等。eTLD+1 则表示，有效顶级域名+二级域名，例如taobao.com等</p><p>举几个例子，<code>www.taobao.com</code>和<code>www.baidu.com</code>是跨站，<code>www.a.taobao.com</code>和<code>www.b.taobao.com</code>是同站，<code>a.github.io</code>和<code>b.github.io</code>是跨站(注意是跨站)。</p><p><strong>改变</strong></p><p>接下来看下从 None 改成 Lax 到底影响了哪些地方的 Cookies 的发送？直接来一个图表：</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200328135320693.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""><br>从上图可以看出，对大部分 web 应用而言，Post 表单，iframe，AJAX，Image 这四种情况从以前的跨站会发送三方 Cookie，变成了不发送。</p><p><code>Post表单</code>：应该的，学 CSRF 总会举表单的例子。</p><p><code>iframe</code>：iframe 嵌入的 web 应用有很多是跨站的，都会受到影响。</p><p><code>AJAX</code>：可能会影响部分前端取值的行为和结果。</p><p><code>Image</code>：图片一般放 CDN，大部分情况不需要 Cookie，故影响有限。但如果引用了需要鉴权的图片，可能会受到影响。</p><p>除了这些还有 script 的方式，这种方式也不会发送 Cookie，像淘宝的大部分请求都是 <code>jsonp</code>，如果涉及到跨站也有可能会被影响。</p><p><strong>问题</strong></p><p>我们再看看会出现什么的问题？举几个例子：</p><ul><li>天猫和飞猪的页面靠请求淘宝域名下的接口获取登录信息，由于 Cookie 丢失，用户无法登录，页面还会误判断成是由于用户开启了浏览器的“禁止第三方 Cookie”功能导致而给与错误的提示</li><li>淘宝部分页面内嵌支付宝确认付款和确认收货页面、天猫内嵌淘宝的登录页面等，由于 Cookie 失效，付款、登录等操作都会失败</li><li>阿里妈妈在各大网站比如今日头条，网易，微博等投放的广告，也是用 iframe 嵌入的，没有了 Cookie，就不能准确的进行推荐</li><li>一些埋点系统会把用户 id 信息埋到 Cookie 中，用于日志上报，这种系统一般走的都是单独的域名，与业务域名分开，所以也会受到影响。</li><li>一些用于防止恶意请求的系统，对判断为恶意请求的访问会弹出验证码让用户进行安全验证，通过安全验证后会在请求所在域种一个Cookie，请求中带上这个Cookie之后，短时间内不再弹安全验证码。在Chrome80以上如果因为Samesite的原因请求没办法带上这个Cookie，则会出现一直弹出验证码进行安全验证。</li><li>天猫商家后台请求了跨域的接口，因为没有 Cookie，接口不会返回数据</li><li>……</li></ul><p>如果不解决，影响的系统其实还是很多的……</p><p>解决方案就是<code>设置 SameSite 为 none</code>。</p><h2 id="doctype-的作用？严格模式与混杂模式如何区分？它们有何意义？"><a href="#doctype-的作用？严格模式与混杂模式如何区分？它们有何意义？" class="headerlink" title="doctype 的作用？严格模式与混杂模式如何区分？它们有何意义？"></a>doctype 的作用？严格模式与混杂模式如何区分？它们有何意义？</h2><p>DOCTYPE是<code>document type (文档类型)</code> 的缩写。 &lt; !DOCTYPE &gt; 声明位于文档的最前面，处于标签之前，它不是html标签。主要作用是告诉浏览器的解析器使用哪种HTML规范或者XHTML规范来解析页面。</p><p><code>严格模式</code>和<code>混杂模式</code>都是浏览器的呈现模式，浏览器究竟使用混杂模式还是严格模式呈现页面与网页中的<code>DTD</code>（文件类型定义）有关，DTD里面包含了文档的规则。比如：loose.dtd</p><ul><li>严格模式：又称标准模式，是指浏览器按照<code>W3C</code>标准来解析代码，呈现页面</li><li>混杂模式：又称为怪异模式或者兼容模式，是指浏览器按照自己的方式来解析代码，使用一种比较宽松的向后兼容的方式来显示页面。</li></ul><h2 id="HTML5-为什么只需写-lt-DOCTYPE-HTML-gt"><a href="#HTML5-为什么只需写-lt-DOCTYPE-HTML-gt" class="headerlink" title="HTML5 为什么只需写&lt; !DOCTYPE HTML&gt; ?"></a>HTML5 为什么只需写&lt; !DOCTYPE HTML&gt; ?</h2><p>HTML5不基于<code>SGML</code> （标准通用标记语言），因此不需要对<code>DTD</code>（ DTD 规定了标记语言的规则，这样浏览器才能正确地呈现内容。）进行引用，但是需要doctype来规范浏览器的行为（让浏览器按照它们应该的方式来运行）。</p><p>而HTML4.01基于<code>SGML</code>,所以需要对<code>DTD</code>进行引用，才能告知浏览器文档所使用的文档类型。</p><h2 id="WEB标准以及W3C标准是什么"><a href="#WEB标准以及W3C标准是什么" class="headerlink" title="WEB标准以及W3C标准是什么?"></a>WEB标准以及W3C标准是什么?</h2><p>标签闭合、标签小写、不乱嵌套、使用外链<code>css</code>和<code>js</code>、结构行为表现的分离</p><h2 id="行内元素有哪些？块级元素有哪些？空（void）元素有哪些？"><a href="#行内元素有哪些？块级元素有哪些？空（void）元素有哪些？" class="headerlink" title="行内元素有哪些？块级元素有哪些？空（void）元素有哪些？"></a>行内元素有哪些？块级元素有哪些？空（void）元素有哪些？</h2><p>行内元素不可以设置宽高，不独占一行<br>块级元素可以设置宽高，独占一行</p><ul><li>行内：</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;a&gt;、&lt;abbr&gt;、&lt;acronym&gt;、&lt;b&gt;、&lt;bdo&gt;、&lt;big&gt;、&lt;br&gt;、&lt;cite&gt;、&lt;code&gt;、&lt;dfn&gt;、&lt;em&gt;、&lt;i&gt;、&lt;img&gt;、&lt;input&gt;、&lt;kbd&gt;、&lt;label&gt;、&lt;q&gt;、&lt;samp&gt;、&lt;select&gt;、&lt;small&gt;、&lt;span&gt;、&lt;strong&gt;、&lt;sub&gt;、&lt;sup&gt;、&lt;textarea&gt;、&lt;tt&gt;、&lt;<span class="keyword">var</span>&gt;</span><br></pre></td></tr></table></figure><ul><li>块级：</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;address&gt;、&lt;caption&gt;、&lt;dd&gt;、&lt;div&gt;、&lt;dl&gt;、&lt;dt&gt;、&lt;fieldset&gt;、&lt;form&gt;、&lt;h1&gt;、&lt;h2&gt;、&lt;h3&gt;、&lt;h4&gt;、&lt;h5&gt;、&lt;h6&gt;、&lt;hr&gt;、&lt;legend&gt;、&lt;li&gt;、&lt;noframes&gt;、&lt;noscript&gt;、&lt;ol&gt;、&lt;ul&gt;、&lt;p&gt;、&lt;pre&gt;、&lt;table&gt;、&lt;tbody&gt;、&lt;td&gt;、&lt;tfoot&gt;、&lt;th&gt;、&lt;thead&gt;、&lt;tr&gt;</span><br></pre></td></tr></table></figure><ul><li>空：</li></ul><p>常见的：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;br&gt; &lt;hr&gt; &lt;img&gt; &lt;input&gt; &lt;link&gt; &lt;meta&gt;</span><br></pre></td></tr></table></figure><p>鲜为人知的：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;area&gt; &lt;base&gt; &lt;col&gt; &lt;command&gt; &lt;embed&gt; &lt;link&gt; &lt;meta&gt;&lt;keygen&gt; &lt;param&gt; &lt;source&gt; &lt;track&gt; &lt;wbr&gt;</span><br></pre></td></tr></table></figure><h2 id="xhtml和html有什么区别"><a href="#xhtml和html有什么区别" class="headerlink" title="xhtml和html有什么区别?"></a>xhtml和html有什么区别?</h2><ul><li><p>功能上的差别</p><p>  主要是XHTML可兼容各大浏览器、手机以及PDA，并且浏览器也能快速正确地编译网页</p></li><li><p>书写习惯的差别</p><p>  XHTML 元素必须被正确地嵌套，闭合，区分大小写，文档必须拥有根元素</p></li></ul><h2 id="iframe有那些缺点？"><a href="#iframe有那些缺点？" class="headerlink" title="iframe有那些缺点？"></a>iframe有那些缺点？</h2><ul><li>iframe会阻塞主页面的<code>Onload</code>事件</li><li>搜索引擎的检索程序无法解读这种页面，不利于<code>SEO</code></li><li><code>iframe</code>和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载</li><li>使用<code>iframe</code>之前需要考虑这两个缺点。如果需要使用<code>iframe</code>，最好是通过<code>javascript</code>动态给iframe添加<code>src</code>属性值，这样可以绕开以上两个问题</li></ul><h2 id="网页验证码是干嘛的，是为了解决什么安全问题"><a href="#网页验证码是干嘛的，是为了解决什么安全问题" class="headerlink" title="网页验证码是干嘛的，是为了解决什么安全问题"></a>网页验证码是干嘛的，是为了解决什么安全问题</h2><ul><li>区分用户是计算机还是人的公共全自动程序。可以防止恶意破解密码、刷票、论坛灌水</li><li>有效防止黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试</li></ul><h2 id="title与h1的区别、b与strong的区别、i与em的区别？"><a href="#title与h1的区别、b与strong的区别、i与em的区别？" class="headerlink" title="title与h1的区别、b与strong的区别、i与em的区别？"></a>title与h1的区别、b与strong的区别、i与em的区别？</h2><ul><li><code>title</code>属性没有明确意义只表示是个标题，<code>H1</code>则表示层次明确的标题，对页面信息的抓取也有很大的影响;</li><li><code>strong</code>是标明重点内容，有语气加强的含义，使用阅读设备阅读网络时，<code>&lt;strong&gt;</code> 会重读，而<code>&lt;B&gt;</code>是展示强调内容。</li><li><code>i</code>内容展示为斜体，<code>em</code>表示强调的文本；</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端知识梳理之CSS篇</title>
      <link href="posts/2055211/"/>
      <url>posts/2055211/</url>
      
        <content type="html"><![CDATA[<h2 id="写作背景"><a href="#写作背景" class="headerlink" title="写作背景"></a>写作背景</h2><p>女朋友要我教她CSS，于是我就折腾了一周，终于完成了这篇长文…<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/2020053010255687.jpg" alt=""></p><p>然后，然后？然后当我发布这篇文章的时候，她会感动到哭吗？</p><h2 id="熟悉HTML知识"><a href="#熟悉HTML知识" class="headerlink" title="熟悉HTML知识"></a>熟悉HTML知识</h2><h3 id="HTML常见元素"><a href="#HTML常见元素" class="headerlink" title="HTML常见元素"></a>HTML常见元素</h3><h4 id="head-部分"><a href="#head-部分" class="headerlink" title="head 部分"></a><code>head</code> 部分</h4><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200517135332751.png" alt=""></p><h4 id="body部分"><a href="#body部分" class="headerlink" title="body部分"></a><code>body</code>部分</h4><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200517135355522.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><h3 id="doctype的意义是什么"><a href="#doctype的意义是什么" class="headerlink" title="doctype的意义是什么"></a>doctype的意义是什么</h3><ul><li>让浏览器以标准模式渲染</li><li>让浏览器知道元素的合法性</li></ul><h3 id="HTML、XHTML、HTML5的关系"><a href="#HTML、XHTML、HTML5的关系" class="headerlink" title="HTML、XHTML、HTML5的关系"></a>HTML、XHTML、HTML5的关系</h3><ul><li>HTML属于SGML（标记语言）</li><li>XHTML属于XML，是HTML进行XML严格化的结果</li><li>HTML5不属于SGML或XML，比XHTML宽松<h3 id="HTML5有什么变化"><a href="#HTML5有什么变化" class="headerlink" title="HTML5有什么变化"></a>HTML5有什么变化</h3></li><li>新的语义化元素</li><li>表单增强</li><li>新的API（离线、音视频、图形、实时通信、本地存储、设备能力）</li><li>分类和嵌套变更</li></ul><h3 id="em和-i-有什么区别"><a href="#em和-i-有什么区别" class="headerlink" title="em和 i 有什么区别"></a>em和 i 有什么区别</h3><ul><li>em是语义化的标签，表强调</li><li>i 是纯样式的标签，表斜体</li><li>HTML5中 i 不推荐使用，一般用作图标</li></ul><h3 id="语义化的意义"><a href="#语义化的意义" class="headerlink" title="语义化的意义"></a>语义化的意义</h3><ul><li>开发者容易理解</li><li>机器容易理解（搜索、读屏、软件）</li><li>有利用SEO</li><li>semantic microdata（语义微数据）例电影有评分</li></ul><h3 id="哪些元素可以自闭合"><a href="#哪些元素可以自闭合" class="headerlink" title="哪些元素可以自闭合"></a>哪些元素可以自闭合</h3><ul><li>表单元素 input</li><li>图片 img</li><li>br hr</li><li>meta link</li></ul><h3 id="HTML和DOM关系"><a href="#HTML和DOM关系" class="headerlink" title="HTML和DOM关系"></a>HTML和DOM关系</h3><ul><li>HTML是“死”的（字符串）</li><li>DOM是由HTML解析而来的，是活的</li><li>JS可以维护DOM</li></ul><h3 id="property-和-attritube-区别"><a href="#property-和-attritube-区别" class="headerlink" title="property 和 attritube 区别"></a>property 和 attritube 区别</h3><ul><li>attritube  是“死”的</li><li>property  是活的</li><li>相互之间不会影响</li></ul><h3 id="form的好处"><a href="#form的好处" class="headerlink" title="form的好处"></a>form的好处</h3><ul><li>直接提交表单</li><li>使用 submit / reset 按钮</li><li>便于浏览器保存表单</li><li>第三方库可以整体取值</li><li>第三方库可以进行表单验证</li></ul><h2 id="CSS精华（Cascading-Style-Sheet）层叠样式表"><a href="#CSS精华（Cascading-Style-Sheet）层叠样式表" class="headerlink" title="CSS精华（Cascading Style Sheet）层叠样式表"></a>CSS精华（Cascading Style Sheet）层叠样式表</h2><h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><ul><li>用于适配HTML元素</li><li>分类和权重</li><li>解析方式和性能</li><li>值得关注的选择器</li></ul><h3 id="选择器分类"><a href="#选择器分类" class="headerlink" title="选择器分类"></a>选择器分类</h3><ul><li>元素选择器 <code>a&#123;&#125;</code></li><li>伪元素选择器 <code>::before&#123;&#125;</code></li><li>类元素选择器 <code>.link&#123;&#125;</code></li><li>属性选择器 <code>[type=radio]&#123;&#125;</code></li><li>伪类选择器 <code>:hover&#123;&#125;</code></li><li>ID选择器 <code>#id&#123;&#125;</code></li><li>组合选择器 <code>[type=checkbox] + label&#123;&#125;</code></li><li>否定选择器 <code>:not(.link)&#123;&#125;</code></li><li>通用选择器 <code>*&#123;&#125;</code></li></ul><h3 id="选择器权重（1）"><a href="#选择器权重（1）" class="headerlink" title="选择器权重（1）"></a>选择器权重（1）</h3><ul><li>ID选择器 #id{}+100</li><li>类 属性 伪类 +10</li><li>元素 伪元素 +1</li><li>其它选择器 +0</li></ul><p>例子：计算一个不进位的数字</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#id.link a[href]</span></span><br><span class="line">————————————————</span><br><span class="line">计算过程：</span><br><span class="line"><span class="meta">#id +100</span></span><br><span class="line">.link +<span class="number">10</span></span><br><span class="line">a +<span class="number">1</span></span><br><span class="line">[href] +<span class="number">0</span></span><br><span class="line">结果:<span class="number">111</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#id .link.active</span></span><br><span class="line">————————————————</span><br><span class="line">计算过程：</span><br><span class="line"><span class="meta">#id +100</span></span><br><span class="line">.link +<span class="number">10</span></span><br><span class="line">.active +<span class="number">10</span></span><br><span class="line">结果:<span class="number">120</span></span><br></pre></td></tr></table></figure><p>那么，我们怎么理解 <strong>不进位的数字</strong> 这关键字眼呢？用一个简单例子吧：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;en&quot;</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;meta name=<span class="string">&quot;viewport&quot;</span> content=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;CSS选择器&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        #test1&#123;</span><br><span class="line">            color: red;</span><br><span class="line">        &#125;</span><br><span class="line">        #test1.test1&#123;</span><br><span class="line">            color: blue;</span><br><span class="line">        &#125;</span><br><span class="line">        .test2&#123;</span><br><span class="line">            color: red;</span><br><span class="line">        &#125;</span><br><span class="line">        div.test2&#123;</span><br><span class="line">            color: blue;</span><br><span class="line">        &#125;</span><br><span class="line">        #test3&#123;</span><br><span class="line">            color: red;</span><br><span class="line">        &#125;</span><br><span class="line">        .c1.c2.c3.c4.c5.c6.c7.c8.c9.c10.c11&#123;</span><br><span class="line">            color: blue;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body <span class="class"><span class="keyword">class</span>=</span><span class="string">&quot;body&quot;</span> id=<span class="string">&quot;body&quot;</span>&gt;</span><br><span class="line">    &lt;div id=<span class="string">&quot;test1&quot;</span> class=<span class="string">&quot;test1&quot;</span>&gt;蓝色&lt;/div&gt;</span><br><span class="line">    &lt;div class=<span class="string">&quot;test2&quot;</span>&gt;蓝色&lt;/div&gt;</span><br><span class="line">    &lt;div id=<span class="string">&quot;test3&quot;</span> class=<span class="string">&quot;c1 c2 c3 c4 c5 c6 c7 c8 c9 c10 c11&quot;</span>&gt;红色&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>结果如下图所示：<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200526201651903.png" alt=""><br>不妨发现，最后一个 <code>div</code>，尽管我们类选择器有11个，加起来有110，但是依旧没有 id 选择器优先级高，正是因为这个不进位的数字，简单说：<strong>你大爷还是你大爷！</strong></p><h3 id="选择器权重（2）"><a href="#选择器权重（2）" class="headerlink" title="选择器权重（2）"></a>选择器权重（2）</h3><ul><li>!important 优先级最高</li><li>元素属性 优先级高</li><li>相同权重 后写的生效</li></ul><p>举个栗子：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;en&quot;</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;meta name=<span class="string">&quot;viewport&quot;</span> content=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;CSS选择器&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        .test1&#123;</span><br><span class="line">            color: red;</span><br><span class="line">        &#125;</span><br><span class="line">        .test1&#123;</span><br><span class="line">            color: blue;</span><br><span class="line">        &#125;</span><br><span class="line">        .test2&#123;</span><br><span class="line">            color: red!important;</span><br><span class="line">        &#125;</span><br><span class="line">        .test2&#123;</span><br><span class="line">            color: blue;</span><br><span class="line">        &#125;</span><br><span class="line">        #test3&#123;</span><br><span class="line">            color: red;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body <span class="class"><span class="keyword">class</span>=</span><span class="string">&quot;body&quot;</span> id=<span class="string">&quot;body&quot;</span>&gt;</span><br><span class="line">    &lt;div class=<span class="string">&quot;test1&quot;</span>&gt;蓝色&lt;/div&gt;</span><br><span class="line">    &lt;div class=<span class="string">&quot;test2&quot;</span>&gt;红色&lt;/div&gt;</span><br><span class="line">    &lt;div id=<span class="string">&quot;test3&quot;</span> style=<span class="string">&quot;color: blue;&quot;</span>&gt;蓝色&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>运行结果如下图所示：<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200526202255146.png" alt=""></p><h3 id="非布局样式"><a href="#非布局样式" class="headerlink" title="非布局样式"></a>非布局样式</h3><h4 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h4><ul><li>字体族 例如: serif、monospace（不能添加引号）衬线字体<ul><li>多字体fallback 例如： “monaco”、”Microsoft Yahei”、”PingFang SC”</li><li>网络字体、自定义字体</li><li>iconfont</li></ul></li></ul><h4 id="行高（经典问题）"><a href="#行高（经典问题）" class="headerlink" title="行高（经典问题）"></a>行高（经典问题）</h4><ul><li>行高的构成（由line-box组成，line-box由inline-box组成）</li><li>行高相关的现象和方案（可以通过设置 line-height来实现垂直居中效果）</li><li>行高的调整</li></ul><p><strong>经典问题</strong>：图片下面有空隙，原理是什么？怎样去除？<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200526210039103.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""><br>原理是因为图片按照 inline 进行排版，排版的时候会涉及到字体对齐，默认按照 <code>baseline</code> 对齐，<code>baseline</code>和底线之间是有偏差的，偏差大小是根据字体大小而定，如果是12px字体大小，则图片空隙就是3px左右。这就是经典图片3px空隙问题。</p><p><strong>解决方式</strong>：</p><ul><li>由于默认按照<code>baseline</code>对齐，不妨将 <code>vertical-align</code> 设为 <code>bottom</code>，按照底线对齐。</li><li>设置 <code>display:block</code> 可以解决该问题，但是会独占一行，如下图所示：<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200526210520421.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4></li><li>背景颜色</li><li>渐变色背景</li><li>多背景叠加</li></ul><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;en&quot;</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;meta name=<span class="string">&quot;viewport&quot;</span> content=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;渐变色背景（线性梯度）&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        .div1&#123;</span><br><span class="line">            height: <span class="number">90</span>px;</span><br><span class="line">        &#125;</span><br><span class="line">        .div2&#123;</span><br><span class="line">            height: <span class="number">90</span>px;</span><br><span class="line">            <span class="comment">/*background: linear-gradient(to right,red,green);*/</span></span><br><span class="line">            <span class="comment">/*background: linear-gradient(180deg,red,green);*/</span></span><br><span class="line">            <span class="comment">/*background: linear-gradient(135deg,red 0,green 15%,yellow 50%,blue 90%);*/</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">/*网格线*/</span></span><br><span class="line">            background: linear-gradient(<span class="number">135</span>deg,transparent <span class="number">0</span>,transparent <span class="number">49.5</span>%,green <span class="number">49.5</span>%,green <span class="number">50.5</span>%,transparent <span class="number">50.5</span>%,transparent <span class="number">100</span>%),</span><br><span class="line">                        linear-gradient(<span class="number">45</span>deg,transparent <span class="number">0</span>,transparent <span class="number">49.5</span>%,red <span class="number">49.5</span>%,red <span class="number">50.5</span>%,transparent <span class="number">50.5</span>%,transparent <span class="number">100</span>%);</span><br><span class="line">            background-size: <span class="number">30</span>px <span class="number">30</span>px;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class=&quot;div1&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;div2&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>最后一个例子展示效果：<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200526220315152.png" alt=""></p><ul><li>背景图片和属性（雪碧图）</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">background-repeat: no-repeat;</span><br><span class="line">background-size: <span class="number">30</span>px <span class="number">30</span>px; <span class="comment">//相对于容器偏移</span></span><br><span class="line">background-position: <span class="number">30</span>px <span class="number">30</span>px;</span><br></pre></td></tr></table></figure><p><strong>雪碧图</strong> 就是将很多个图片进行拼接成一个图片，然后通过 <code>background-position</code>等属性进行偏移，在网页中得到对应图片，来达到减少http请求。</p><ul><li><p>base64和性能优化</p><p>  将图片进行base64编码后，就是一个字符文本，缺点之一就是图片的体积会增大 <code>1/3</code> 左右，并且放入css文件中，也会导致css文件变大。另外，虽然能减少http请求，但增大了解码的开销。适用于小图标<code>icon</code>，例如<code>loading</code>文件等。最后，在开发环境一般不采用直接将图片进行 <code>base64</code> 编码，因为对于协同开发来说，无法知晓图片原样，只有一个文本。</p><p>  一般情况下，是在生产环境下，通过打包的方式，将小图片进行 <code>base64</code>编码。</p></li><li><p>多分辨率适配</p></li></ul><h4 id="边框（经典问题）"><a href="#边框（经典问题）" class="headerlink" title="边框（经典问题）"></a>边框（经典问题）</h4><ul><li>边框的属性：线型 大小 颜色</li></ul><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;en&quot;</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;meta name=<span class="string">&quot;viewport&quot;</span> content=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;边框&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        .c1&#123;</span><br><span class="line">            width: <span class="number">400</span>px;</span><br><span class="line">            height: <span class="number">200</span>px;</span><br><span class="line">            border: <span class="number">1</span>px solid red;</span><br><span class="line">            <span class="comment">/*border: 5px solid red;*/</span></span><br><span class="line">            <span class="comment">/*border: 5px dotted red;*/</span></span><br><span class="line">            <span class="comment">/*border: 5px dashed red;*/</span></span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class=&quot;c1&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><ul><li>边框背景图</li></ul><p><strong>经典问题</strong>：九宫格问题，例如下面图片，我们如果想要实现9个不同形式，然后中间放内容，如果用原本9个div方法，那么会非常麻烦，而css3提供了 <code>border</code>方式可以解决上述问题。<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200526232959608.png" alt=""><br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200526233253297.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""><br>在没有在 <code>border-image</code>处设置 <code>round</code>之前，是如上效果，后面 30 是用来切出四个角。</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;en&quot;</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;meta name=<span class="string">&quot;viewport&quot;</span> content=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;边框&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        .c1&#123;</span><br><span class="line">            width: <span class="number">400</span>px;</span><br><span class="line">            height: <span class="number">200</span>px;</span><br><span class="line">            border: <span class="number">30</span>px solid transparent;</span><br><span class="line">            border-image: url(./xx.png) <span class="number">30</span> round; <span class="comment">/*round将图片进行整数个拼接*/</span></span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class=&quot;c1&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>在 <code>border-image</code>处设置 <code>round</code>之后，是如下效果，基本达到我们想要的效果。<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200526232832159.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;en&quot;</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;meta name=<span class="string">&quot;viewport&quot;</span> content=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;边框&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        .c2&#123;</span><br><span class="line">            width: <span class="number">400</span>px;</span><br><span class="line">            height: <span class="number">200</span>px;</span><br><span class="line">            border: <span class="number">30</span>px solid transparent;</span><br><span class="line">            border-image: url(./xx.png) <span class="number">30</span> round; <span class="comment">/*round将图片进行整数个拼接*/</span></span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class=&quot;c2&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><ul><li>边框衔接（三角形）</li></ul><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;en&quot;</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;meta name=<span class="string">&quot;viewport&quot;</span> content=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;边框&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        .c3&#123;</span><br><span class="line">            width: <span class="number">0</span>px;</span><br><span class="line">            height: <span class="number">200</span>px;</span><br><span class="line">            border-bottom: <span class="number">30</span>px solid red;</span><br><span class="line">            border-left: <span class="number">30</span>px solid transparent;</span><br><span class="line">            border-right: <span class="number">30</span>px solid transparent;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class=&quot;c3&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>实现三角形，效果如下：<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200526233958910.png" alt=""></p><h4 id="滚动"><a href="#滚动" class="headerlink" title="滚动"></a>滚动</h4><p>产生滚动的原因：当内容比容器多的时候，即容器装不下内容的时候，就需要滚动。滚动主要包括如下几个方面：</p><ul><li>滚动行为和滚动条<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200527100408454.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""><br><code>overflow</code> 设置<code>auto</code> 和 <code>scroll</code> 区别，auto 是内容多于容器时显示滚动条，反正，不显示。而 scroll 是一直显示滚动条<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200527100654576.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></li></ul><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;en&quot;</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;meta name=<span class="string">&quot;viewport&quot;</span> content=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;滚动&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        .div1&#123;</span><br><span class="line">            background: red;</span><br><span class="line">            height: <span class="number">200</span>px;</span><br><span class="line">            overflow: scroll;  <span class="comment">/*可选值: hidden visible auto scroll*/</span></span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span>=</span><span class="string">&quot;div1&quot;</span>&gt;</span><br><span class="line">        &lt;p&gt;test&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;test&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;test&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;test&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;test&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;test&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;test&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;test&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;test&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;test&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;test&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h4 id="文字折行（经典问题）"><a href="#文字折行（经典问题）" class="headerlink" title="文字折行（经典问题）"></a>文字折行（经典问题）</h4><ul><li>overflow-wrap（word-wrap）通用换行控制（是否保留单词）</li><li>word-break 针对多字节文字（中文句字也是单词）</li><li>white-space 空白处是否断行</li></ul><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;en&quot;</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;meta name=<span class="string">&quot;viewport&quot;</span> content=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;文字折行&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        .div1&#123;</span><br><span class="line">            border: <span class="number">1</span>px solid;</span><br><span class="line">            width: <span class="number">8</span>em;</span><br><span class="line">            overflow-wrap: normal;</span><br><span class="line">            word-<span class="keyword">break</span>: normal;</span><br><span class="line">            white-space: normal;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span>=</span><span class="string">&quot;div1&quot;</span>&gt;</span><br><span class="line">        学如逆水行舟，不进则退！Learning is like sailing against the current, retreating <span class="keyword">if</span> <span class="keyword">not</span> advancing</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>展示效果:<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200527102807870.png" alt=""><br><strong>经典问题</strong>：怎么让一个很长的文本不换行？</p><p>将上述属性设置为 <code>nowrap</code>即可</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">white-space: nowrap;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200527102716363.png" alt=""></p><h4 id="装饰性属性"><a href="#装饰性属性" class="headerlink" title="装饰性属性"></a>装饰性属性</h4><ul><li>字重（粗体）font-weight</li><li>斜体 font-style:itatic</li><li>下划线 text-decoration</li><li>指针 cursor</li></ul><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;en&quot;</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;meta name=<span class="string">&quot;viewport&quot;</span> content=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;font-weight&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        .div1&#123;</span><br><span class="line">            font-weight: normal; <span class="comment">/*400*/</span></span><br><span class="line">            font-weight: bold;   <span class="comment">/*700*/</span></span><br><span class="line">            font-weight: bolder;</span><br><span class="line">            font-weight: lighter;</span><br><span class="line">            font-weight: <span class="number">100</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class=&quot;div1&quot;&gt;学如逆水行舟，不进则退！&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h3 id="CSS-Hack（了解）"><a href="#CSS-Hack（了解）" class="headerlink" title="CSS Hack（了解）"></a>CSS Hack（了解）</h3><h4 id="hack"><a href="#hack" class="headerlink" title="hack"></a>hack</h4><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200527222702460.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""><br>用来<strong>处理浏览器兼容性</strong>做法，好处就是<strong>简单粗暴</strong>。</p><ul><li>Hack即不合法但生效的写法</li><li>主要用于区分不同浏览器</li><li>缺点：难理解 难维护 难失效</li><li>替代方案：特性检测（检测浏览器是否有相关特性，没有的话就针对性处理）</li><li>替代方案：针对性加class（例如检测到 <code>IE6</code>，那么就加<code>IE6</code>的class）</li></ul><h2 id="CSS-面试真题"><a href="#CSS-面试真题" class="headerlink" title="CSS 面试真题"></a>CSS 面试真题</h2><h3 id="css样式（选择器）的优先级"><a href="#css样式（选择器）的优先级" class="headerlink" title="css样式（选择器）的优先级"></a>css样式（选择器）的优先级</h3><ul><li>计算权重确定</li><li>!important</li><li>内联样式</li><li>后写的优先级高</li></ul><h3 id="雪碧图的作用"><a href="#雪碧图的作用" class="headerlink" title="雪碧图的作用"></a>雪碧图的作用</h3><ul><li><strong>雪碧图</strong> 就是将很多个图片进行拼接成一个图片，然后通过 <code>background-position</code>等属性进行偏移，在网页中得到对应图片，来达到减少http请求，提高页面加载性能。</li><li>有一些情况下可以减少图片大小（例如png格式图片，每张图片颜色基本上一样的，有可能总的图片大小是小于每个图片加起来的大小的）</li></ul><h3 id="自定义字体的使用场景"><a href="#自定义字体的使用场景" class="headerlink" title="自定义字体的使用场景"></a>自定义字体的使用场景</h3><ul><li>宣传 / 品牌 / banner 等固定文案</li><li>字体图标（将文字变为图标）</li></ul><h3 id="base64的作用"><a href="#base64的作用" class="headerlink" title="base64的作用"></a>base64的作用</h3><p>将图片进行base64编码后，就是一个字符文本，缺点之一就是图片的体积会增大 <code>1/3</code> 左右，并且放入css文件中，也会导致css文件变大。另外，虽然能减少http请求，但增大了解码的开销。适用于小图标<code>icon</code>，例如<code>loading</code>文件等。最后，在开发环境一般不采用直接将图片进行 <code>base64</code> 编码，因为对于协同开发来说，无法知晓图片原样，只有一个文本。</p><ul><li>用于减少http请求</li><li>适用于小图片</li><li>base64的体积约为原图的 4/3</li></ul><h3 id="伪类和伪元素的区别？"><a href="#伪类和伪元素的区别？" class="headerlink" title="伪类和伪元素的区别？"></a>伪类和伪元素的区别？</h3><ul><li>伪类 表 状态（某元素是个链接 link状态）</li><li>伪元素是真的有元素（<code>::before&#123;&#125;</code>，在页面中会显示内容）</li><li>前者使用单冒号，后者使用双冒号</li></ul><h3 id="如何美化checkbox"><a href="#如何美化checkbox" class="headerlink" title="如何美化checkbox"></a>如何美化checkbox</h3><ul><li>label [for] 和 id</li><li>隐藏原生 input（所有的样式由 <code>label</code> 来搞定）</li><li>:checked + label</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200527225852233.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><h2 id="CSS-布局"><a href="#CSS-布局" class="headerlink" title="CSS 布局"></a>CSS 布局</h2><p>CSS体系知识的重中之重</p><ul><li>早期以 table 为主（简单）</li><li>后来以技巧性布局为主（难）</li><li>现在有 flexbox / grid（偏简单）</li></ul><h3 id="常用布局方式"><a href="#常用布局方式" class="headerlink" title="常用布局方式"></a>常用布局方式</h3><ul><li>table表格布局</li><li>float 浮动+ margin</li><li>inline-block 布局</li><li>flexbox 布局</li></ul><h3 id="布局方式（表格）"><a href="#布局方式（表格）" class="headerlink" title="布局方式（表格）"></a>布局方式（表格）</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;en&quot;</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;meta name=<span class="string">&quot;viewport&quot;</span> content=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;table布局&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        .table&#123;</span><br><span class="line">            margin-top: <span class="number">20</span>px;</span><br><span class="line">            width: <span class="number">500</span>px;</span><br><span class="line">            height: <span class="number">100</span>px;</span><br><span class="line">            display: table;</span><br><span class="line">        &#125;</span><br><span class="line">        .table-row&#123;</span><br><span class="line">            display: table-row;</span><br><span class="line">        &#125;</span><br><span class="line">        .table-cell&#123;</span><br><span class="line">            vertical-align: center;</span><br><span class="line">            display: table-cell;</span><br><span class="line">        &#125;</span><br><span class="line">        .left&#123;</span><br><span class="line">            background: red;</span><br><span class="line">            vertical-align: middle;</span><br><span class="line">        &#125;</span><br><span class="line">        .right&#123;</span><br><span class="line">            background: blue;</span><br><span class="line">            vertical-align: middle;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span>=</span><span class="string">&quot;table&quot;</span>&gt;</span><br><span class="line">        &lt;div <span class="class"><span class="keyword">class</span>=</span><span class="string">&quot;table-row&quot;</span>&gt;</span><br><span class="line">            &lt;div class=&quot;left table-cell&quot;&gt;left&lt;/div&gt;</span><br><span class="line">            &lt;div class=&quot;right table-cell&quot;&gt;right&lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>展示效果如下图所示：<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200528115357438.png" alt=""></p><h3 id="display-position（经典问题）"><a href="#display-position（经典问题）" class="headerlink" title="display / position（经典问题）"></a>display / position（经典问题）</h3><ul><li>display 常用属性值： block（块级） / inline（内联） / inline-block（对内表现为block，可以有宽高，对外表现为inline，可以与其它元素排在同一行）</li><li>position 常用属性值：static（静态） / relative（相对） / absolute（绝对） / fixed（固定）</li></ul><p><strong>display</strong></p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;en&quot;</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;meta name=<span class="string">&quot;viewport&quot;</span> content=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;display&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        .block&#123;</span><br><span class="line">            height: <span class="number">200</span>px;</span><br><span class="line">            background: red;</span><br><span class="line">        &#125;</span><br><span class="line">        .<span class="keyword">inline</span>&#123;</span><br><span class="line">            display: <span class="keyword">inline</span>;</span><br><span class="line">            background: green;</span><br><span class="line">        &#125;</span><br><span class="line">        .<span class="keyword">inline</span>-block&#123;</span><br><span class="line">            display: <span class="keyword">inline</span>-block;</span><br><span class="line">            width: <span class="number">200</span>px;</span><br><span class="line">            height: <span class="number">100</span>px;</span><br><span class="line">            background: blue;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span>=</span><span class="string">&quot;block&quot;</span>&gt;</span><br><span class="line">        block</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;inline&quot;&gt;inline&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;inline-block&quot;&gt;inline-block&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><strong>position</strong></p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;en&quot;</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;meta name=<span class="string">&quot;viewport&quot;</span> content=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;position&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        .p1&#123;</span><br><span class="line">            width: <span class="number">100</span>px;</span><br><span class="line">            height: <span class="number">100</span>px;</span><br><span class="line">            background: red;</span><br><span class="line">        &#125;</span><br><span class="line">        .p2&#123;</span><br><span class="line">            position: relative;</span><br><span class="line">            width: <span class="number">100</span>px;</span><br><span class="line">            height: <span class="number">100</span>px;</span><br><span class="line">            left: <span class="number">20</span>px;</span><br><span class="line">            top: <span class="number">-10</span>px;</span><br><span class="line">            background: blue;</span><br><span class="line">        &#125;</span><br><span class="line">        .p3&#123;</span><br><span class="line">            position: absolute;</span><br><span class="line">            width: <span class="number">100</span>px;</span><br><span class="line">            height: <span class="number">100</span>px;</span><br><span class="line">            left: <span class="number">80</span>px;</span><br><span class="line">            top: <span class="number">30</span>px;</span><br><span class="line">            background: yellow;</span><br><span class="line">        &#125;</span><br><span class="line">        .p4&#123;</span><br><span class="line">            position: fixed;</span><br><span class="line">            width: <span class="number">100</span>px;</span><br><span class="line">            height: <span class="number">100</span>px;</span><br><span class="line">            left: <span class="number">0</span>;</span><br><span class="line">            bottom: <span class="number">10</span>px;</span><br><span class="line">            background: green;</span><br><span class="line">        &#125;</span><br><span class="line">        .p5&#123;</span><br><span class="line">            width: <span class="number">100</span>px;</span><br><span class="line">            height: <span class="number">100</span>px;</span><br><span class="line">            background: pink;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class=&quot;p1&quot;&gt;position:static&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;p2&quot;&gt;position:relative&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;p3&quot;&gt;position:absloute&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;p4&quot;&gt;position:fixed&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;p5&quot;&gt;no position&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>展示效果如下：<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200528164155927.png" alt=""><br>由上图可知，当设置 <code>position</code> 为 <code>relative</code> 后，no position（粉色块） 并没有在蓝色块下面，也就是说设置 <code>position</code> 为 <code>relative</code> 后，占据空间还是按照原来的方式计算的，不会因为偏移而改变布局的计算。</p><p><strong>经典问题</strong>：</p><ul><li><p>绝对定位 <code>absolute</code>，会优先查找父级定位为 <code>absolute</code> 或 <code>relative</code>的进行定位，如果父级没有，找上级，那么最终就会根据 <code>body</code>进行定位，它和 <code>fixed</code>一样，也是脱离了文档流。</p></li><li><p><code>fixed</code>相对于屏幕进行定位</p></li></ul><p><strong>层叠问题</strong> ，因为默认会根据先后顺序显示，因此会有覆盖情况，此时，可以通过设计 <code>z-index</code> 解决，权重越大，优先显示。</p><h3 id="flexbox（圣杯布局）"><a href="#flexbox（圣杯布局）" class="headerlink" title="flexbox（圣杯布局）"></a>flexbox（圣杯布局）</h3><ul><li>弹性盒子</li><li>盒子本来就是并列的</li><li>指定宽度即可</li><li>移动端常用</li></ul><p>（目前用的不是很热的原因是虽然简单方便，但是<strong>兼容性</strong>有点问题）</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;en&quot;</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;meta name=<span class="string">&quot;viewport&quot;</span> content=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;flexbox&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        .container&#123;</span><br><span class="line">            width: <span class="number">800</span>px;</span><br><span class="line">            height: <span class="number">200</span>px;</span><br><span class="line">            display: flex;</span><br><span class="line">            border: <span class="number">1</span>px solid black;</span><br><span class="line">        &#125;</span><br><span class="line">        .flex&#123;</span><br><span class="line">            background: blue;</span><br><span class="line">            flex: <span class="number">1</span>;</span><br><span class="line">            margin: <span class="number">5</span>px;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span>=</span><span class="string">&quot;container&quot;</span>&gt;</span><br><span class="line">        &lt;div class=&quot;flex&quot;&gt;flex&lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;flex&quot;&gt;flex&lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;flex&quot;&gt;flex&lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;flex&quot;&gt;flex&lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;flex&quot;&gt;flex&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>展示效果如下：<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200528170053892.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""><br>由这个很方便的布局，我们可以写一个<strong>圣杯布局</strong>的例子（即左右固定，中间自适应）：</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;en&quot;</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;meta name=<span class="string">&quot;viewport&quot;</span> content=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;圣杯布局-flexbox&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        *&#123;</span><br><span class="line">            margin: <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        .container&#123;</span><br><span class="line">            min-height: <span class="number">200</span>px;</span><br><span class="line">            display: flex;</span><br><span class="line">        &#125;</span><br><span class="line">        .left&#123;</span><br><span class="line">            width: <span class="number">200</span>px;</span><br><span class="line">            display: flex;</span><br><span class="line">            background: red;</span><br><span class="line">        &#125;</span><br><span class="line">        .center&#123;</span><br><span class="line">            background: yellow;</span><br><span class="line">            flex: <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        .right&#123;</span><br><span class="line">            width: <span class="number">200</span>px;</span><br><span class="line">            display: flex;</span><br><span class="line">            background: blue;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span>=</span><span class="string">&quot;container&quot;</span>&gt;</span><br><span class="line">        &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;center&quot;&gt;center&lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;right&quot;&gt;right&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/202005281708036.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><h3 id="float"><a href="#float" class="headerlink" title="float"></a>float</h3><ul><li>元素”浮动”</li><li>脱离文档流（不会对其它元素的布局造成影响）</li><li>但不脱离文本流</li></ul><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;en&quot;</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;meta name=<span class="string">&quot;viewport&quot;</span> content=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;<span class="keyword">float</span>布局&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        .container&#123;</span><br><span class="line">            width: <span class="number">400</span>px;</span><br><span class="line">            background: red;</span><br><span class="line">        &#125;</span><br><span class="line">        .p1&#123;</span><br><span class="line">            width: <span class="number">200</span>px;</span><br><span class="line">            height: <span class="number">80</span>px;</span><br><span class="line">            <span class="keyword">float</span>: left;</span><br><span class="line">            background: pink;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span>=</span><span class="string">&quot;container&quot;</span>&gt;</span><br><span class="line">        &lt;span class=&quot;p1&quot;&gt;float元素&lt;/span&gt;</span><br><span class="line">        &lt;div class=&quot;p2&quot;&gt;很多文字很多文字很多文字很多文字很多文字很多文字很多文字很多文字很多文字很多文字很多文字很多文字很多文字很多文字很多文字&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>展示效果如下：<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/202005281718026.png" alt=""></p><h3 id="float-特性的影响（经典问题）"><a href="#float-特性的影响（经典问题）" class="headerlink" title="float 特性的影响（经典问题）"></a>float 特性的影响（经典问题）</h3><p><strong>float 特性对自己的影响</strong>：</p><ul><li>形成块（BFC，可以使得inline元素能够设置宽高，例如上文代码，原本span元素不能设置宽高的，但通过设置float布局，使得可以设置宽高）</li><li>位置尽量靠上</li><li>位置尽量靠左（右）（对于上述解释，是如果 <code>container</code>宽度够的话，就尽量靠上和靠左，如果不行的话，就往下排了）</li></ul><p>简单例子：<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200528172259918.png" alt=""><br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200528172240259.png" alt=""><br><strong>float 特性对兄弟的影响</strong>：</p><ul><li>上面贴非 float 元素</li><li>旁边贴 float 元素</li><li>不影响其它块级元素位置（不脱离文档流）</li><li>影响其它块级元素内部文本（脱离了文本流）</li></ul><p><strong>float 特性对父级的影响</strong>：</p><ul><li>从布局上 “消失”（父级不会管它的宽高）</li><li><strong>经典问题</strong>：高度塌陷 （假设float元素，原本是 100px 高度，这个时候很期望父级能撑开100个像素，但因为设置了 float，等于消失了，并不会在意这 100个像素，因此，如果没有其它元素支撑高度的话，父级的高度就会设置为0，这就是高度塌陷）</li></ul><h3 id="清楚浮动的方式"><a href="#清楚浮动的方式" class="headerlink" title="清楚浮动的方式"></a>清楚浮动的方式</h3><p><strong>经典问题</strong>：</p><p>清除浮动的方式</p><p>① 当我们设置为 float 后，会将元素设为 BFC，接管自己的宽高，因此我们也可以让父级元素设置为 BFC，来接管自己的宽高。</p><p>初始状态：<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200528174749689.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""><br>在父级元素设置 <code>overflow: auto/hidden;</code></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;en&quot;</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;meta name=<span class="string">&quot;viewport&quot;</span> content=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;清楚浮动&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        .container&#123;</span><br><span class="line">            background: red;</span><br><span class="line">            width: <span class="number">400</span>px;</span><br><span class="line">            overflow: <span class="keyword">auto</span>;</span><br><span class="line">            margin: <span class="number">10</span>px;</span><br><span class="line">        &#125;</span><br><span class="line">        .p1&#123;</span><br><span class="line">            background: pink;</span><br><span class="line">            <span class="keyword">float</span>: left;</span><br><span class="line">            width: <span class="number">200</span>px;</span><br><span class="line">            height: <span class="number">50</span>px;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span>=</span><span class="string">&quot;container&quot;</span>&gt;</span><br><span class="line">        &lt;span&gt;xxxxxx&lt;/span&gt;</span><br><span class="line">        &lt;span class=&quot;p1&quot;&gt;float&lt;/span&gt;</span><br><span class="line">        &lt;span class=&quot;p1&quot;&gt;float&lt;/span&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span>=</span><span class="string">&quot;container&quot;</span> style=<span class="string">&quot;height: 200px; background: blue;&quot;</span>&gt;</span><br><span class="line">        &lt;p&gt;第一行&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;第二行&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;第三行&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>最终状态效果图如下：<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200528174958468.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>② 由于 float 不脱离文档流（不会影响其它元素布局），那么就可以使得元素刚好到达下面位置。就可以通过其它元素将父级撑起来，当父级刚好撑到下方位置时，就可以将浮动清除掉。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200528175222135.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;en&quot;</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;meta name=<span class="string">&quot;viewport&quot;</span> content=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;清楚浮动&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        .container&#123;</span><br><span class="line">            background: red;</span><br><span class="line">            width: <span class="number">400</span>px;</span><br><span class="line">        &#125;</span><br><span class="line">        .p1&#123;</span><br><span class="line">            background: pink;</span><br><span class="line">            <span class="keyword">float</span>: left;</span><br><span class="line">            width: <span class="number">200</span>px;</span><br><span class="line">            height: <span class="number">50</span>px;</span><br><span class="line">        &#125;</span><br><span class="line">        .removeFloat::after&#123;</span><br><span class="line">            content: &#x27;aaa&#x27;;</span><br><span class="line">            clear: both; <span class="comment">/*保证当前元素左右没有浮动元素*/</span></span><br><span class="line">            display: block;</span><br><span class="line">            height: <span class="number">0</span>;</span><br><span class="line">            visibility: hidden;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span>=</span><span class="string">&quot;container removeFloat&quot;</span>&gt;</span><br><span class="line">        &lt;span&gt;xxxxxx&lt;/span&gt;</span><br><span class="line">        &lt;span class=&quot;p1&quot;&gt;float&lt;/span&gt;</span><br><span class="line">        &lt;span class=&quot;p1&quot;&gt;float&lt;/span&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span>=</span><span class="string">&quot;container&quot;</span> style=<span class="string">&quot;height: 200px; background: blue;&quot;</span>&gt;</span><br><span class="line">        &lt;p&gt;第一行&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;第二行&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;第三行&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>经典清除浮动方式，效果图如下：<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200528175659432.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><h3 id="float（圣杯布局）"><a href="#float（圣杯布局）" class="headerlink" title="float（圣杯布局）"></a>float（圣杯布局）</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;en&quot;</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;meta name=<span class="string">&quot;viewport&quot;</span> content=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;圣杯布局-<span class="keyword">float</span>&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        .container&#123;</span><br><span class="line">            min-height: <span class="number">200</span>px;</span><br><span class="line">        &#125;</span><br><span class="line">        .left&#123;</span><br><span class="line">            <span class="keyword">float</span>: left;</span><br><span class="line">            background: red;</span><br><span class="line">            width: <span class="number">200</span>px;</span><br><span class="line">        &#125;</span><br><span class="line">        .center&#123;</span><br><span class="line">            margin-left: <span class="number">200</span>px;</span><br><span class="line">            margin-right: <span class="number">200</span>px;</span><br><span class="line">            background: yellow;</span><br><span class="line">        &#125;</span><br><span class="line">        .right&#123;</span><br><span class="line">            <span class="keyword">float</span>: right;</span><br><span class="line">            background: blue;</span><br><span class="line">            width: <span class="number">200</span>px;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span>=</span><span class="string">&quot;container&quot;</span>&gt;</span><br><span class="line">        &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;right&quot;&gt;right&lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;center&quot;&gt;center&lt;/div&gt;</span><br><span class="line">        </span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>展示效果如下：<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200528184805501.png" alt=""></p><h3 id="inline-block-布局"><a href="#inline-block-布局" class="headerlink" title="inline-block 布局"></a>inline-block 布局</h3><ul><li>像文本一样排block元素</li><li>没有清楚浮动等问题</li><li>需要处理间隙</li></ul><p>例如下图，红蓝之间有一个间隙，是因为 <code>inline-block</code>就像文本一样，我们没办法让两个字紧紧地挨着，于是我们就有了下文所述解决方式：<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200528185802907.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;en&quot;</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;meta name=<span class="string">&quot;viewport&quot;</span> content=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;<span class="keyword">inline</span>-block布局&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        .container&#123;</span><br><span class="line">            width: <span class="number">800</span>px;</span><br><span class="line">            height: <span class="number">200</span>px;</span><br><span class="line">            font-size: <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        .left&#123;</span><br><span class="line">            font-size: <span class="number">15</span>px;</span><br><span class="line">            background: red;</span><br><span class="line">            display: <span class="keyword">inline</span>-block;</span><br><span class="line">            width: <span class="number">200</span>px;</span><br><span class="line">            height: <span class="number">200</span>px;</span><br><span class="line">        &#125;</span><br><span class="line">        .right&#123;</span><br><span class="line">            font-size: <span class="number">15</span>px;</span><br><span class="line">            background: blue;</span><br><span class="line">            display: <span class="keyword">inline</span>-block;</span><br><span class="line">            width: <span class="number">500</span>px;</span><br><span class="line">            height: <span class="number">200</span>px;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span>=</span><span class="string">&quot;container&quot;</span>&gt;</span><br><span class="line">        &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;right&quot;&gt;right&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>展示效果如下：<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200528185937166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""><br>查看上述代码，将父级元素字体大小设置为0即可解决间隙问题，但子元素需要设置自己的字体大小，不然就不会显示。</p><p>因此，做自适应方面会有点麻烦，不像上文 <code>float+margin</code> 那样简单</p><h3 id="响应式设计和布局"><a href="#响应式设计和布局" class="headerlink" title="响应式设计和布局"></a>响应式设计和布局</h3><ul><li>在不同的设备上正常使用</li><li>一般处理屏幕大小问题</li><li>主要方法：隐藏 + 折行 + 自适应空间（rem：通过html的字体大小（即 <code>font-size</code>）来确定元素大小，但不太精确  / viewport：通过 js或手工 确定整个界面放到多大 / media query：媒体查询，根据不同的设备来匹配不同的样式）</li></ul><p>下图含义就是只有在宽度小于 640px 时才会生效，即让移动端进行适配。<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200528191524133.png" alt=""></p><h2 id="CSS-面试真题-1"><a href="#CSS-面试真题-1" class="headerlink" title="CSS 面试真题"></a>CSS 面试真题</h2><h3 id="实现两栏（三栏）布局的方法"><a href="#实现两栏（三栏）布局的方法" class="headerlink" title="实现两栏（三栏）布局的方法"></a>实现两栏（三栏）布局的方法</h3><ul><li>表格布局</li><li>float + margin 布局（兼容性好）</li><li>inline-block 布局（需要处理间隙问题）</li><li>flexbox布局（简单，但兼容性不是很好）</li></ul><h3 id="position-absolute-fixed-有什么区别？"><a href="#position-absolute-fixed-有什么区别？" class="headerlink" title="position:absolute / fixed 有什么区别？"></a>position:absolute / fixed 有什么区别？</h3><p><strong>经典问题</strong>：</p><ul><li><p>绝对定位 <code>absolute</code>，会优先查找父级定位为 <code>absolute</code> 或 <code>relative</code>的进行定位，如果父级没有，找上级，那么最终就会根据 <code>body</code>进行定位，它和 <code>fixed</code>一样，也是脱离了文档流。</p></li><li><p><code>fixed</code>相对于屏幕（viewport）进行定位</p></li></ul><p><strong>层叠问题</strong> ，因为默认会根据先后顺序显示，因此会有覆盖情况，此时，可以通过设计 <code>z-index</code> 解决，权重越大，优先显示。</p><h3 id="display-inline-block-的间隙"><a href="#display-inline-block-的间隙" class="headerlink" title="display:inline-block 的间隙"></a>display:inline-block 的间隙</h3><ul><li>原因：字符间距</li><li>解决：消灭字符（把标签写在一起或者添加注释）或者消灭间距（将<code>font-size</code>设为0）</li></ul><h3 id="如何清除浮动？为什么要清除浮动？"><a href="#如何清除浮动？为什么要清除浮动？" class="headerlink" title="如何清除浮动？为什么要清除浮动？"></a>如何清除浮动？为什么要清除浮动？</h3><p>原因：浮动的元素不会占据父元素的布局空间，也就是父级元素不会管浮动元素，有可能浮动元素会超出父元素，从而对其它元素产生影响。</p><p><strong>经典问题</strong>：</p><p>清除浮动的方式</p><p>① 当我们设置为 float 后，会将元素设为 BFC，接管自己的宽高，因此我们也可以让父级元素设置为 BFC，来接管自己的宽高。</p><p>初始状态：<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200528174749689.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""><br>在父级元素设置 <code>overflow: auto/hidden;</code></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;en&quot;</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;meta name=<span class="string">&quot;viewport&quot;</span> content=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;清楚浮动&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        .container&#123;</span><br><span class="line">            background: red;</span><br><span class="line">            width: <span class="number">400</span>px;</span><br><span class="line">            overflow: <span class="keyword">auto</span>;</span><br><span class="line">            margin: <span class="number">10</span>px;</span><br><span class="line">        &#125;</span><br><span class="line">        .p1&#123;</span><br><span class="line">            background: pink;</span><br><span class="line">            <span class="keyword">float</span>: left;</span><br><span class="line">            width: <span class="number">200</span>px;</span><br><span class="line">            height: <span class="number">50</span>px;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span>=</span><span class="string">&quot;container&quot;</span>&gt;</span><br><span class="line">        &lt;span&gt;xxxxxx&lt;/span&gt;</span><br><span class="line">        &lt;span class=&quot;p1&quot;&gt;float&lt;/span&gt;</span><br><span class="line">        &lt;span class=&quot;p1&quot;&gt;float&lt;/span&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span>=</span><span class="string">&quot;container&quot;</span> style=<span class="string">&quot;height: 200px; background: blue;&quot;</span>&gt;</span><br><span class="line">        &lt;p&gt;第一行&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;第二行&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;第三行&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>最终状态效果图如下：<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200528174958468.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>② 由于 float 不脱离文档流（不会影响其它元素布局），那么就可以使得元素刚好到达下面位置。就可以通过其它元素将父级撑起来，当父级刚好撑到下方位置时，就可以将浮动清除掉。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200528175222135.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;en&quot;</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;meta name=<span class="string">&quot;viewport&quot;</span> content=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;清楚浮动&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        .container&#123;</span><br><span class="line">            background: red;</span><br><span class="line">            width: <span class="number">400</span>px;</span><br><span class="line">        &#125;</span><br><span class="line">        .p1&#123;</span><br><span class="line">            background: pink;</span><br><span class="line">            <span class="keyword">float</span>: left;</span><br><span class="line">            width: <span class="number">200</span>px;</span><br><span class="line">            height: <span class="number">50</span>px;</span><br><span class="line">        &#125;</span><br><span class="line">        .removeFloat::after&#123;</span><br><span class="line">            content: &#x27;aaa&#x27;;</span><br><span class="line">            clear: both; <span class="comment">/*保证当前元素左右没有浮动元素*/</span></span><br><span class="line">            display: block;</span><br><span class="line">            height: <span class="number">0</span>;</span><br><span class="line">            visibility: hidden;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span>=</span><span class="string">&quot;container removeFloat&quot;</span>&gt;</span><br><span class="line">        &lt;span&gt;xxxxxx&lt;/span&gt;</span><br><span class="line">        &lt;span class=&quot;p1&quot;&gt;float&lt;/span&gt;</span><br><span class="line">        &lt;span class=&quot;p1&quot;&gt;float&lt;/span&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span>=</span><span class="string">&quot;container&quot;</span> style=<span class="string">&quot;height: 200px; background: blue;&quot;</span>&gt;</span><br><span class="line">        &lt;p&gt;第一行&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;第二行&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;第三行&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>经典清除浮动方式，效果图如下：<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200528175659432.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><h3 id="如何适配移动端页面？"><a href="#如何适配移动端页面？" class="headerlink" title="如何适配移动端页面？"></a>如何适配移动端页面？</h3><p>主要方法：隐藏 + 折行 + 自适应空间（rem：通过html的字体大小（即 <code>font-size</code>）来确定元素大小，但不太精确  / viewport：通过 js或手工 确定整个界面放到多大 / media query：媒体查询，根据不同的设备来匹配不同的样式）</p><h2 id="效果属性（CSS最出彩的一部分）"><a href="#效果属性（CSS最出彩的一部分）" class="headerlink" title="效果属性（CSS最出彩的一部分）"></a>效果属性（CSS最出彩的一部分）</h2><h3 id="box-shadow"><a href="#box-shadow" class="headerlink" title="box-shadow"></a>box-shadow</h3><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200528195555152.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""><br>属性值介绍：前两个是偏移量，第三个是模糊区域度，第四个是拓展区域度，第五个是颜色（最后一个是透明度）</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">box-shadow: <span class="number">5</span>px <span class="number">5</span>px <span class="number">10</span>px <span class="number">0</span> rgba(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">.2</span>);</span><br></pre></td></tr></table></figure><h3 id="text-shadow"><a href="#text-shadow" class="headerlink" title="text-shadow"></a>text-shadow</h3><ul><li>立体感</li><li>印刷品质感</li></ul><h3 id="border-radius"><a href="#border-radius" class="headerlink" title="border-radius"></a>border-radius</h3><ul><li>圆角矩形</li><li>圆形</li><li>半圆 / 扇形</li><li>一些奇怪的角角</li></ul><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;en&quot;</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;meta name=<span class="string">&quot;viewport&quot;</span> content=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;border-radius&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        .container&#123;</span><br><span class="line">            width: <span class="number">100</span>px;</span><br><span class="line">            height: <span class="number">100</span>px;</span><br><span class="line">            background: red;</span><br><span class="line">            border-radius: <span class="number">50</span>%;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class=&quot;container&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>展示效果如下：<br> <img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200528204159194.png" alt=""></p><h3 id="background"><a href="#background" class="headerlink" title="background"></a>background</h3><ul><li>纹理、图案</li><li>渐变</li><li>雪碧图动画</li><li>背景图尺寸适应<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200528204345120.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""><h3 id="clip-path"><a href="#clip-path" class="headerlink" title="clip-path"></a>clip-path</h3></li><li>对容器进行裁剪</li><li>常见几何图形</li><li>自定义路径</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200528213618716.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><h3 id="3D-transform"><a href="#3D-transform" class="headerlink" title="3D-transform"></a>3D-transform</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;en&quot;</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;meta name=<span class="string">&quot;viewport&quot;</span> content=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;<span class="number">3</span>D-transform&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        .container&#123;</span><br><span class="line">            margin: <span class="number">50</span>px;</span><br><span class="line">            padding: <span class="number">10</span>px;</span><br><span class="line">            border: <span class="number">1</span>px solid red;</span><br><span class="line">            width: <span class="number">200</span>px;</span><br><span class="line">            height: <span class="number">200</span>px;</span><br><span class="line">            position: relative;</span><br><span class="line">            perspective: <span class="number">500</span>px;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">#cube&#123;</span></span><br><span class="line">            width: <span class="number">200</span>px;</span><br><span class="line">            height: <span class="number">200</span>px;</span><br><span class="line">            transform-style: preserve<span class="number">-3</span>d;</span><br><span class="line">            transform: translateZ(<span class="number">-100</span>px);</span><br><span class="line">            transition: transform <span class="number">1</span>s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">#cube:hover&#123;</span></span><br><span class="line">            transform: translateZ(<span class="number">-100</span>px) rotateX(<span class="number">90</span>deg) rotateY(<span class="number">90</span>deg);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">#cube div&#123;</span></span><br><span class="line">            width: <span class="number">200</span>px;</span><br><span class="line">            height: <span class="number">200</span>px;</span><br><span class="line">            position: absolute;</span><br><span class="line">            line-height: <span class="number">200</span>px;</span><br><span class="line">            font-size: <span class="number">50</span>px;</span><br><span class="line">            text-align: center;</span><br><span class="line">        &#125;</span><br><span class="line">        .front&#123;</span><br><span class="line">            background: rgba(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">.3</span>);</span><br><span class="line">            transform: translateZ(<span class="number">100</span>px);</span><br><span class="line">        &#125;</span><br><span class="line">        .back&#123;</span><br><span class="line">            background: rgba(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>, <span class="number">.3</span>);</span><br><span class="line">            transform: translateZ(<span class="number">-100</span>px) rotateY(<span class="number">180</span>deg);</span><br><span class="line">        &#125;</span><br><span class="line">        .left&#123;</span><br><span class="line">            background: rgba(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>, <span class="number">.3</span>);</span><br><span class="line">            transform: translateX(<span class="number">-100</span>px) rotateY(<span class="number">-90</span>deg);</span><br><span class="line">        &#125;</span><br><span class="line">        .right&#123;</span><br><span class="line">            background: rgba(<span class="number">255</span>, <span class="number">255</span>, <span class="number">0</span>, <span class="number">.3</span>);</span><br><span class="line">            transform: translateX(<span class="number">100</span>px) rotateY(<span class="number">90</span>deg);</span><br><span class="line">        &#125;</span><br><span class="line">        .top&#123;</span><br><span class="line">            background: rgba(<span class="number">255</span>, <span class="number">0</span>, <span class="number">255</span>, <span class="number">.3</span>);</span><br><span class="line">            transform: translateY(<span class="number">-100</span>px) rotateX(<span class="number">-90</span>deg);</span><br><span class="line">        &#125;</span><br><span class="line">        .bottom&#123;</span><br><span class="line">            background: rgba(<span class="number">0</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">.3</span>);</span><br><span class="line">            transform: translateY(<span class="number">100</span>px) rotateX(<span class="number">90</span>deg);</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span>=</span><span class="string">&quot;container&quot;</span>&gt;</span><br><span class="line">        &lt;div id=<span class="string">&quot;cube&quot;</span>&gt;</span><br><span class="line">            &lt;div class=<span class="string">&quot;front&quot;</span>&gt;<span class="number">1</span>&lt;/div&gt;</span><br><span class="line">            &lt;div class=<span class="string">&quot;back&quot;</span>&gt;<span class="number">2</span>&lt;/div&gt;</span><br><span class="line">            &lt;div class=<span class="string">&quot;right&quot;</span>&gt;<span class="number">3</span>&lt;/div&gt;</span><br><span class="line">            &lt;div class=<span class="string">&quot;left&quot;</span>&gt;<span class="number">4</span>&lt;/div&gt;</span><br><span class="line">            &lt;div class=<span class="string">&quot;top&quot;</span>&gt;<span class="number">5</span>&lt;/div&gt;</span><br><span class="line">            &lt;div class=<span class="string">&quot;bottom&quot;</span>&gt;<span class="number">6</span>&lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>展示效果图如下：<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200529083411818.gif#pic_center" alt=""></p><h2 id="CSS-面试真题-2"><a href="#CSS-面试真题-2" class="headerlink" title="CSS 面试真题"></a>CSS 面试真题</h2><h3 id="如何用div画一个-xxx"><a href="#如何用div画一个-xxx" class="headerlink" title="如何用div画一个 xxx"></a>如何用div画一个 xxx</h3><ul><li>box-shadow 无限投影</li><li>::before</li><li>::after</li></ul><h3 id="如何产生不占空间的边框"><a href="#如何产生不占空间的边框" class="headerlink" title="如何产生不占空间的边框"></a>如何产生不占空间的边框</h3><ul><li>box-shadow</li><li>outline</li></ul><h3 id="如何实现圆形元素（头像）"><a href="#如何实现圆形元素（头像）" class="headerlink" title="如何实现圆形元素（头像）"></a>如何实现圆形元素（头像）</h3><ul><li>border-radius:50%</li></ul><h3 id="如何实现iOS图标的圆角"><a href="#如何实现iOS图标的圆角" class="headerlink" title="如何实现iOS图标的圆角"></a>如何实现iOS图标的圆角</h3><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200529084619993.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><ul><li>clip-path：(svg)</li></ul><h3 id="如何实现半圆、扇形等图形"><a href="#如何实现半圆、扇形等图形" class="headerlink" title="如何实现半圆、扇形等图形"></a>如何实现半圆、扇形等图形</h3><ul><li>border-radius 组合：有无边框、边框粗细、圆角半径</li></ul><h3 id="如何实现背景图居中显示-不重复-改变大小"><a href="#如何实现背景图居中显示-不重复-改变大小" class="headerlink" title="如何实现背景图居中显示 / 不重复 / 改变大小"></a>如何实现背景图居中显示 / 不重复 / 改变大小</h3><ul><li>background-position</li><li>background-repeat</li><li>background-size（cover / contain）</li></ul><h3 id="如何平移-放大一个元素"><a href="#如何平移-放大一个元素" class="headerlink" title="如何平移 / 放大一个元素"></a>如何平移 / 放大一个元素</h3><ul><li>transform:translateX(100px)</li><li>transform:scale(2)</li><li>transform本身与动画没有关系</li></ul><h3 id="如何实现3D效果"><a href="#如何实现3D效果" class="headerlink" title="如何实现3D效果"></a>如何实现3D效果</h3><ul><li>perspective:500px（指定透视角度）</li><li>transform-style:preserve-3d;（3d效果）</li><li>transform:translate rotate …</li></ul><h2 id="CSS-动画"><a href="#CSS-动画" class="headerlink" title="CSS 动画"></a>CSS 动画</h2><h3 id="动画的原理"><a href="#动画的原理" class="headerlink" title="动画的原理"></a>动画的原理</h3><ul><li>视觉暂留作用：就是说看到的画面，会在脑海中保留一段片段</li><li>画面逐渐变化</li></ul><h3 id="动画的作用"><a href="#动画的作用" class="headerlink" title="动画的作用"></a>动画的作用</h3><ul><li>愉悦感</li><li>引起注意</li><li>反馈（输入密码错误时，登录框晃动）</li><li>掩饰</li></ul><h3 id="CSS中动画的类型"><a href="#CSS中动画的类型" class="headerlink" title="CSS中动画的类型"></a>CSS中动画的类型</h3><ul><li>transition 补间动画（从一个状态到另一个状态，状态切换之间是有动画的）</li><li>keyframe 关键帧动画（指定的每一个状态就是一个关键帧）</li><li>逐帧动画（跳动）</li></ul><h3 id="transition-补间动画"><a href="#transition-补间动画" class="headerlink" title="transition  补间动画"></a>transition  补间动画</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;en&quot;</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;meta name=<span class="string">&quot;viewport&quot;</span> content=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;transition补间动画&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        .container&#123;</span><br><span class="line">            width: <span class="number">100</span>px;</span><br><span class="line">            height: <span class="number">100</span>px;</span><br><span class="line">            background: red;</span><br><span class="line">            transition: width <span class="number">1</span>s, background <span class="number">2</span>s;</span><br><span class="line">        &#125;</span><br><span class="line">        .container:hover&#123;</span><br><span class="line">            width: <span class="number">300</span>px;</span><br><span class="line">            background: blue;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class=&quot;container&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>展示效果如下：<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200529105730631.gif#pic_center" alt=""></p><h3 id="动画进度与时间的关系"><a href="#动画进度与时间的关系" class="headerlink" title="动画进度与时间的关系"></a>动画进度与时间的关系</h3><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200529105848275.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""><br>例子：<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200529110102399.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""><br><a href="https://matthewlein.com/tools/ceaser">推荐：动画进度与时间关系模拟网站</a></p><h3 id="关键帧动画"><a href="#关键帧动画" class="headerlink" title="关键帧动画"></a>关键帧动画</h3><ul><li>相当于多个补间动画</li><li>与元素状态的变化无关</li><li>定义更加灵活</li></ul><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;en&quot;</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;meta name=<span class="string">&quot;viewport&quot;</span> content=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;keyframe关键帧动画&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        .container&#123;</span><br><span class="line">            width: <span class="number">100</span>px;</span><br><span class="line">            height: <span class="number">100</span>px;</span><br><span class="line">            background: red;</span><br><span class="line">            animation: run <span class="number">1</span>s;</span><br><span class="line">            animation-direction: reverse;</span><br><span class="line">            animation-iteration-count: infinite;</span><br><span class="line">            <span class="comment">/*animation-fill-mode: forwards;*/</span></span><br><span class="line">            <span class="comment">/*animation-play-state: paused;*/</span></span><br><span class="line">        &#125;</span><br><span class="line">        @keyframes run &#123;</span><br><span class="line">            <span class="number">0</span>%&#123;</span><br><span class="line">                width: <span class="number">100</span>px;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="number">100</span>%&#123;</span><br><span class="line">                width: <span class="number">800</span>px;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class=&quot;container&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>展示效果：</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200529142723152.gif#pic_center" alt=""></p><h3 id="逐帧动画"><a href="#逐帧动画" class="headerlink" title="逐帧动画"></a>逐帧动画</h3><ul><li>属于关键帧动画特殊的一种</li><li>适用于无法补间计算的动画</li><li>资源较大</li><li>使用 steps() （设置关键帧之间有几个画面，一般设置为1,也可以说是将关键帧去掉补间）</li></ul><p>例如：一个动物跑动的过程，通过将每个动作的图片逐帧显示，形成动画的感觉。<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200529143916273.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><h2 id="CSS-面试真题-3"><a href="#CSS-面试真题-3" class="headerlink" title="CSS 面试真题"></a>CSS 面试真题</h2><h3 id="CSS-动画的实现方式有几种"><a href="#CSS-动画的实现方式有几种" class="headerlink" title="CSS 动画的实现方式有几种"></a>CSS 动画的实现方式有几种</h3><ul><li>transition</li><li>keyframes（animation）</li></ul><h3 id="过渡动画和关键帧动画的区别"><a href="#过渡动画和关键帧动画的区别" class="headerlink" title="过渡动画和关键帧动画的区别"></a>过渡动画和关键帧动画的区别</h3><ul><li>过渡动画需要有状态变化</li><li>关键帧动画不需要状态变化</li><li>关键帧动画能控制更精细</li></ul><h3 id="如何实现逐帧动画"><a href="#如何实现逐帧动画" class="headerlink" title="如何实现逐帧动画"></a>如何实现逐帧动画</h3><ul><li>使用关键帧动画</li><li>去掉补间（steps）</li></ul><h3 id="CSS动画的性能"><a href="#CSS动画的性能" class="headerlink" title="CSS动画的性能"></a>CSS动画的性能</h3><ul><li>性能不坏</li><li>部分情况下优于JS</li><li>但JS可以做的更好</li><li>部分高危属性（例如 <code>box-shadow</code>等）</li></ul><h2 id="CSS-预处理器"><a href="#CSS-预处理器" class="headerlink" title="CSS 预处理器"></a>CSS 预处理器</h2><ul><li>基于CSS的另一种语言</li><li>通过工具编译为CSS</li><li>添加了很多CSS不具备的特性</li><li>能提升CSS文件的组织</li></ul><p>常见的有 <code>less</code>（基于node写的，编译比较快，入门简单）和 <code>sass</code>（基于<code>Ruby</code>写的）</p><ul><li>嵌套 反映层级和约束</li><li>变量和计算 减少重重复代码</li><li>Extend 和 Mxxin 代码片段</li><li>循环 适用于复杂有规律的样式</li><li>import CSS 文件模块化</li></ul><h3 id="less嵌套"><a href="#less嵌套" class="headerlink" title="less嵌套"></a>less嵌套</h3><p>全局安装 <code>less</code></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">npm install less -g</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200529155848221.png" alt=""><br>创建一个 <code>test.less</code> 文件</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">body&#123;</span><br><span class="line">    padding: <span class="number">0</span>;</span><br><span class="line">    margin: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">.wrapper&#123;</span><br><span class="line">    background: white;</span><br><span class="line">    .nav&#123;</span><br><span class="line">        font-size: <span class="number">12</span>px;</span><br><span class="line">    &#125;</span><br><span class="line">    .content&#123;</span><br><span class="line">        font-size: <span class="number">14</span>px;</span><br><span class="line">        &amp;:hover&#123;</span><br><span class="line">            background: red;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在该文件处调用终端，执行以下命令：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">lessc test.less</span><br></pre></td></tr></table></figure><p>输出结果：</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200529160202644.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><p>执行如下命令，输出到 <code>test.css</code> 文件中</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">lessc</span> <span class="selector-tag">test</span><span class="selector-class">.less</span> &gt; <span class="selector-tag">test</span><span class="selector-class">.css</span></span><br></pre></td></tr></table></figure><p>查看 <code>test.css</code> 文件，得到如下结果：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.wrapper</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: white;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.wrapper</span> <span class="selector-class">.nav</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">12px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.wrapper</span> <span class="selector-class">.content</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.wrapper</span> <span class="selector-class">.content</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="sass嵌套"><a href="#sass嵌套" class="headerlink" title="sass嵌套"></a>sass嵌套</h3><p>全局安装 <code>sass</code></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cnpm install node-sass -g</span><br></pre></td></tr></table></figure><p>创建一个 <code>test.scss</code> 文件</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.wrapper</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>: white;</span><br><span class="line">    .nav&#123;</span><br><span class="line">        <span class="selector-tag">font-size</span>: 12<span class="selector-tag">px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.content</span>&#123;</span><br><span class="line">        <span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">        &amp;:hover&#123;</span><br><span class="line">            <span class="selector-tag">background</span>: <span class="selector-tag">red</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行如下命令，查看输出结果：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">node-sass</span> <span class="selector-tag">test</span><span class="selector-class">.scss</span></span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200529162015247.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""><br>执行如下命令，输出到 <code>test-scss.css</code> 文件中</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">node-sass</span> <span class="selector-tag">test</span><span class="selector-class">.scss</span> &gt; <span class="selector-tag">test-scss</span><span class="selector-class">.css</span></span><br></pre></td></tr></table></figure><p>查看  <code>test-scss.css</code> 文件，得到如下结果：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.wrapper</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: white; &#125;</span><br><span class="line">  <span class="selector-class">.wrapper</span> <span class="selector-class">.nav</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">12px</span>; &#125;</span><br><span class="line">  <span class="selector-class">.wrapper</span> <span class="selector-class">.content</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">14px</span>; &#125;</span><br><span class="line">    <span class="selector-class">.wrapper</span> <span class="selector-class">.content</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">      <span class="attribute">background</span>: red; &#125;</span><br></pre></td></tr></table></figure><p>从以上代码来看，sass嵌套会保留原来嵌套样式，对于css观赏性来说，并不是我们特别想要的，于是我们可以执行如下命令，更改输出样式：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">node-sass</span> <span class="selector-tag">--output-style</span> <span class="selector-tag">expanded</span> <span class="selector-tag">test</span><span class="selector-class">.scss</span> &gt; <span class="selector-tag">test-scss</span><span class="selector-class">.css</span></span><br></pre></td></tr></table></figure><p>输出结果就和less嵌套一样了，读者可以自己跑一遍！</p><h3 id="less变量"><a href="#less变量" class="headerlink" title="less变量"></a>less变量</h3><p>创建 <code>variable-less.less</code> 文件</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">@fontSize: 12px;</span><br><span class="line">@bgColor: red;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.wrapper</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">lighten</span>(@bgColor,<span class="number">40%</span>);</span><br><span class="line">    .nav&#123;</span><br><span class="line">        <span class="selector-tag">font-size</span>: <span class="keyword">@fontSize</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.content</span>&#123;</span><br><span class="line">        <span class="attribute">font-size</span>: @fontSize+<span class="number">2px</span>;</span><br><span class="line">        &amp;:hover&#123;</span><br><span class="line">            <span class="selector-tag">background</span>: <span class="keyword">@bgColor</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建 <code>variable-less.css</code> 文件，执行如下命令：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">lessc</span> <span class="selector-tag">variable-less</span><span class="selector-class">.less</span> &gt; <span class="selector-tag">variable-less</span><span class="selector-class">.css</span></span><br></pre></td></tr></table></figure><p>可以得到如下代码：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.wrapper</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#ffcccc</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.wrapper</span> <span class="selector-class">.nav</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">12px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.wrapper</span> <span class="selector-class">.content</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.wrapper</span> <span class="selector-class">.content</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="sass变量"><a href="#sass变量" class="headerlink" title="sass变量"></a>sass变量</h3><p>类似less变量，只需要将 <code>@</code>  改为 <code>$</code> 即可，因为 <code>less</code> 变量命名这样做，是更贴近CSS。而 <code>sass</code>是为了区别CSS。</p><h3 id="less-mixin"><a href="#less-mixin" class="headerlink" title="less mixin"></a>less mixin</h3><p>创建 <code>mixin.less</code> 文件，复制如下代码：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">@fontSize: 12px;</span><br><span class="line">@bgColor: red;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.block</span>(<span class="keyword">@fontSize</span>)&#123;</span><br><span class="line">    <span class="selector-tag">font-size</span>: <span class="keyword">@fontSize</span>;</span><br><span class="line">    <span class="selector-tag">border</span>: 1<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-id">#ccc</span>;</span><br><span class="line">    <span class="selector-tag">border-radius</span>: 4<span class="selector-tag">px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.wrapper</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">lighten</span>(@bgColor,<span class="number">40%</span>);</span><br><span class="line">    .nav&#123;</span><br><span class="line">        <span class="selector-class">.block</span>(<span class="keyword">@fontSize</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.content</span>&#123;</span><br><span class="line">        .block(@fontSize+2px);</span><br><span class="line">        &amp;<span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">            <span class="attribute">background</span>: @bgColor;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建 <code>mixin-less.css</code> 文件，执行如下代码：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">lessc</span> <span class="selector-tag">mixin</span><span class="selector-class">.less</span> &gt; <span class="selector-tag">mixin-less</span><span class="selector-class">.css</span></span><br></pre></td></tr></table></figure><p>查看<code>mixin-less.css</code> 文件，发现 <code>.block</code> 没有了，在CSS内部就完成了样式复用。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.wrapper</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#ffcccc</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.wrapper</span> <span class="selector-class">.nav</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">12px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ccc</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">4px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.wrapper</span> <span class="selector-class">.content</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ccc</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">4px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.wrapper</span> <span class="selector-class">.content</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="sass-mixin"><a href="#sass-mixin" class="headerlink" title="sass mixin"></a>sass mixin</h3><p>创建 <code>mixin.scss</code> 文件，复制如下代码：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">$fontSize: 12px;</span><br><span class="line">$bgColor: red;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@mixin</span> block($fontSize)&#123;</span><br><span class="line">    font-size: $fontSize;</span><br><span class="line">    <span class="selector-tag">border</span>: 1<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-id">#ccc</span>;</span><br><span class="line">    <span class="selector-tag">border-radius</span>: 4<span class="selector-tag">px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.wrapper</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">lighten</span>($bgColor,<span class="number">40%</span>);</span><br><span class="line">    .nav&#123;</span><br><span class="line">        <span class="keyword">@include</span> block($fontSize);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.content</span>&#123;</span><br><span class="line">        @include block($fontSize+2px);</span><br><span class="line">        &amp;<span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">            <span class="attribute">background</span>: $bgColor;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建 <code>mixin-sass.css</code> 文件，执行如下代码：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">node-sass</span> <span class="selector-tag">--output-style</span> <span class="selector-tag">expanded</span> <span class="selector-tag">mixin</span><span class="selector-class">.scss</span> &gt; <span class="selector-tag">mixin-sass</span><span class="selector-class">.css</span></span><br></pre></td></tr></table></figure><p>查看<code>mixin-sass.css</code> 文件，发现 <code>.block</code> 没有了，在CSS内部就完成了样式复用。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.wrapper</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#ffcccc</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.wrapper</span> <span class="selector-class">.nav</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">12px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ccc</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">4px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.wrapper</span> <span class="selector-class">.content</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ccc</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">4px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.wrapper</span> <span class="selector-class">.content</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：从上文对比来看，sass mixin 除了调用变量符号要换为 <code>$</code> 外，抽离公共样式需要使用 <code>@mixin</code> ，此外，调用时还需要使用 <code>@include</code> 。</p><p>那么，mixin还能做什么呢？</p><p>例如，对于布局方面，我们在上文提到了清楚浮动的方式，那么，我们就可以将这段样式进行复用，只需要在需要的元素处引用即可。</p><h3 id="less-extend"><a href="#less-extend" class="headerlink" title="less extend"></a>less extend</h3><p>上文提到过的，使用过 less mixin 抽离之后，我们可以得到如下代码，但是呢，又会有一个小问题，就是我们会有重复样式代码。在生产环境下，就会有大量这样的形式出现，这就会影响到我们的CSS体积了。<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/2020052917481580.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""><br>一种比较好的方式，如下，我们再讲公共样式代码进行抽离，这显然会降低我们的CSS体积。<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200529174929659.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><p>因此，extend就发挥了它的作用</p><p>创建 <code>extend-less.less</code> 文件，复制如下代码：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">@fontSize: 12px;</span><br><span class="line">@bgColor: red;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.block</span>&#123;</span><br><span class="line">    <span class="attribute">font-size</span>: @fontSize;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ccc</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">4px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.wrapper</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">lighten</span>(@bgColor,<span class="number">40%</span>);</span><br><span class="line">    .nav&#123;</span><br><span class="line">        &amp;<span class="selector-pseudo">:extend(.block)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.content</span><span class="selector-pseudo">:extend(.block)</span>&#123;</span><br><span class="line">        &amp;:hover&#123;</span><br><span class="line">            <span class="selector-tag">background</span>: <span class="keyword">@bgColor</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建 <code>extend-less.css</code> 文件，执行如下代码：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">lessc</span> <span class="selector-tag">extend-less</span><span class="selector-class">.less</span> &gt; <span class="selector-tag">extend-less</span><span class="selector-class">.css</span></span><br></pre></td></tr></table></figure><p>查看  <code>extend-less.css</code> 文件，发现代码体积相对减少了。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.block</span>,</span><br><span class="line"><span class="selector-class">.wrapper</span> <span class="selector-class">.nav</span>,</span><br><span class="line"><span class="selector-class">.wrapper</span> <span class="selector-class">.content</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">12px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ccc</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">4px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.wrapper</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#ffcccc</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.wrapper</span> <span class="selector-class">.content</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：mixin 和 extend 区别， mixin 能处理一些复杂逻辑，比如添加变量，但会导致体积增大问题。而 extend的话，是将选择器提取出来，更加简单，不适合处理复杂逻辑，能将体积进行一定减少。</p><h3 id="sass-extend"><a href="#sass-extend" class="headerlink" title="sass extend"></a>sass extend</h3><p>创建 <code>extend-sass.scss</code> 文件，复制如下代码：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">$fontSize: 12px;</span><br><span class="line">$bgColor: red;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.block</span>&#123;</span><br><span class="line">    <span class="attribute">font-size</span>: $fontSize;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ccc</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">4px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.wrapper</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">lighten</span>($bgColor,<span class="number">40%</span>);</span><br><span class="line">    .nav&#123;</span><br><span class="line">        <span class="keyword">@extend</span> .block;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.content</span>&#123;</span><br><span class="line">        @extend .block;</span><br><span class="line">        &amp;<span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">            <span class="attribute">background</span>: $bgColor;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建  <code>extend-sass.css</code> 文件，执行如下代码：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">node-sass</span> <span class="selector-tag">--output-style</span> <span class="selector-tag">expanded</span> <span class="selector-tag">extend-sass</span><span class="selector-class">.scss</span> &gt; <span class="selector-tag">extend-sass</span><span class="selector-class">.css</span></span><br></pre></td></tr></table></figure><p>查看 <code>extend-sass.css</code> 文件，发现代码体积相对减少了。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.block</span>, <span class="selector-class">.wrapper</span> <span class="selector-class">.nav</span>, <span class="selector-class">.wrapper</span> <span class="selector-class">.content</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">12px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ccc</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">4px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.wrapper</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#ffcccc</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.wrapper</span> <span class="selector-class">.content</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="less-loop"><a href="#less-loop" class="headerlink" title="less loop"></a>less loop</h3><p>创建 <code>loop-less.less</code> 文件，复制如下代码</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.gen-col</span>(<span class="keyword">@n</span>) when (@n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="selector-class">.gen-col</span>(<span class="keyword">@n</span> - <span class="number">1</span>);</span><br><span class="line">    <span class="selector-class">.col-</span>@&#123;<span class="selector-tag">n</span>&#125;&#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">1000px</span>/<span class="number">12</span>*@n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.gen-col</span>(12);</span><br></pre></td></tr></table></figure><p>创建 <code>loop-less.css</code> 文件，执行如下代码：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">lessc</span> <span class="selector-tag">loop-less</span><span class="selector-class">.less</span> &gt; <span class="selector-tag">loop-less</span><span class="selector-class">.css</span></span><br></pre></td></tr></table></figure><p>查看 <code>loop-less.css</code> 文件，发现有12个样式</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.col-1</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">83.33333333px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.col-2</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">166.66666667px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.col-3</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">250px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.col-4</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">333.33333333px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.col-5</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">416.66666667px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.col-6</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.col-7</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">583.33333333px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.col-8</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">666.66666667px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.col-9</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">750px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.col-10</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">833.33333333px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.col-11</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">916.66666667px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.col-12</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">1000px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="sass-loop"><a href="#sass-loop" class="headerlink" title="sass loop"></a>sass loop</h3><p>创建 <code>loop-sass.scss</code> 文件，复制如下代码：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@mixin</span> gen-col($n)&#123;</span><br><span class="line">    <span class="keyword">@if</span> $n &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">@include</span> gen-col($n - <span class="number">1</span>);</span><br><span class="line">        .col-#&#123;$n&#125;&#123;</span><br><span class="line">            width: 1000px/12*$n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@include</span> gen-col(<span class="number">12</span>);</span><br></pre></td></tr></table></figure><p>创建 <code>loop-sass.css</code>，执行如下代码：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">node-sass</span> <span class="selector-tag">--output-style</span> <span class="selector-tag">expanded</span> <span class="selector-tag">loop-sass</span><span class="selector-class">.scss</span> &gt; <span class="selector-tag">loop-sass</span><span class="selector-class">.css</span></span><br></pre></td></tr></table></figure><p>查看 <code>loop-sass.css</code> 文件，发现有12个样式</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.col-1</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">83.33333px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.col-2</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">166.66667px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.col-3</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">250px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.col-4</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">333.33333px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.col-5</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">416.66667px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.col-6</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.col-7</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">583.33333px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.col-8</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">666.66667px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.col-9</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">750px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.col-10</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">833.33333px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.col-11</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">916.66667px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.col-12</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">1000px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述版本代码或许是挺复杂的，好在 <code>sass</code>提供了for循环，见如下代码：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@for</span> $i from <span class="number">1</span> through <span class="number">12</span> &#123;</span><br><span class="line">    .col-#&#123;$i&#125; &#123;</span><br><span class="line">        width: 1000px/12*$i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="less-import"><a href="#less-import" class="headerlink" title="less import"></a>less import</h3><p>创建 <code>import-less.less</code> 文件，复制如下代码：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@import</span> <span class="string">&quot;./mixin&quot;</span>;</span><br><span class="line"><span class="keyword">@import</span> <span class="string">&quot;./variable-less&quot;</span>;</span><br></pre></td></tr></table></figure><p>创建 <code>import-less.css</code> 文件，执行如下代码：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">lessc</span> <span class="selector-tag">import-less</span><span class="selector-class">.less</span> &gt; <span class="selector-tag">import-less</span><span class="selector-class">.css</span></span><br></pre></td></tr></table></figure><p>查看 <code>import-less.less</code> 文件</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.wrapper</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#ffcccc</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.wrapper</span> <span class="selector-class">.nav</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">12px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ccc</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">4px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.wrapper</span> <span class="selector-class">.content</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ccc</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">4px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.wrapper</span> <span class="selector-class">.content</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.wrapper</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#ffcccc</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.wrapper</span> <span class="selector-class">.nav</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">12px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.wrapper</span> <span class="selector-class">.content</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.wrapper</span> <span class="selector-class">.content</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="sass-import"><a href="#sass-import" class="headerlink" title="sass import"></a>sass import</h3><p>语法上没有什么变化，注意符号是 <code>$</code></p><h3 id="CSS预处理器框架"><a href="#CSS预处理器框架" class="headerlink" title="CSS预处理器框架"></a>CSS预处理器框架</h3><ul><li>Less - Lesshat / EST（<a href="http://ecomfe.github.io/est/">官网</a>）</li><li>SASS - Compass （<a href="http://compass-style.org/">官网</a>，将有兼容性问题的属性会进行封装成mixin，直接调用就好）</li><li>提供现成的 mixin</li><li>类似 JS  类库 封装常用功能</li></ul><h2 id="CSS-面试真题-4"><a href="#CSS-面试真题-4" class="headerlink" title="CSS 面试真题"></a>CSS 面试真题</h2><h3 id="常见的CSS预处理器"><a href="#常见的CSS预处理器" class="headerlink" title="常见的CSS预处理器"></a>常见的CSS预处理器</h3><ul><li>Less（Node.js）</li><li>Sass（Ruby 有Node版本）</li></ul><h3 id="预处理器的作用"><a href="#预处理器的作用" class="headerlink" title="预处理器的作用"></a>预处理器的作用</h3><ul><li>帮助更好地组织CSS代码</li><li>提高代码复用率</li><li>提升可维护性</li></ul><h3 id="预处理器的能力"><a href="#预处理器的能力" class="headerlink" title="预处理器的能力"></a>预处理器的能力</h3><ul><li>嵌套 反映层级和约束</li><li>变量和计算 减少重重复代码</li><li>Extend 和 Mxxin 代码片段</li><li>循环 适用于复杂有规律的样式（网格系统）</li><li>import CSS 文件模块化（按需拆解CSS文件）</li></ul><h3 id="预处理器的优缺点"><a href="#预处理器的优缺点" class="headerlink" title="预处理器的优缺点"></a>预处理器的优缺点</h3><ul><li>优点：提高代码复用率和可维护性</li><li>缺点：需要引入编译过程 有学习成本</li></ul><h2 id="Bootstrap"><a href="#Bootstrap" class="headerlink" title="Bootstrap"></a>Bootstrap</h2><ul><li>一个CSS框架</li><li>twitter 出品</li><li>提供通用基础样式</li></ul><h3 id="Bootstrap-4"><a href="#Bootstrap-4" class="headerlink" title="Bootstrap 4"></a>Bootstrap 4</h3><ul><li>兼容IE10+</li><li>使用flexbox布局</li><li>抛弃Nomalize.css</li><li>提供布局 和 reboot版本</li><li>（<a href="https://getbootstrap.com/">官网</a>，用sass写）</li><li>可用于后台管理系统</li></ul><h3 id="Bootstrap-JS组件"><a href="#Bootstrap-JS组件" class="headerlink" title="Bootstrap JS组件"></a>Bootstrap JS组件</h3><p>用于组件交互</p><ul><li>dropdown（下拉）</li><li>modal（弹窗）</li><li>…</li></ul><p>基于jquery写的，同时，依赖第三方库 Popper.js和 bootstrap.js</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200530081512499.png" alt=""></p><p>如上图，第二个js文件包含了 Popper.js</p><p>使用方式：</p><ul><li>基于 data-*属性</li><li>基于 JS API</li></ul><h3 id="Bootstrap-响应式布局"><a href="#Bootstrap-响应式布局" class="headerlink" title="Bootstrap 响应式布局"></a>Bootstrap 响应式布局</h3><p>非常精华的部分</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200530082022915.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><h3 id="Bootstrap-定制方法"><a href="#Bootstrap-定制方法" class="headerlink" title="Bootstrap 定制方法"></a>Bootstrap 定制方法</h3><ul><li>使用CSS同名类覆盖（操作简单但）</li><li>修改sass源码重新构建</li><li>引用scss源文件 修改变量（推荐使用，干净）</li></ul><h2 id="CSS-面试真题-5"><a href="#CSS-面试真题-5" class="headerlink" title="CSS 面试真题"></a>CSS 面试真题</h2><h3 id="Bootstrap的优缺点"><a href="#Bootstrap的优缺点" class="headerlink" title="Bootstrap的优缺点"></a>Bootstrap的优缺点</h3><ul><li>优点：CSS代码结构合理，现成的样式可以直接使用</li><li>缺点：定制较为繁琐 体积大</li></ul><h3 id="Bootstrap如何实现响应式布局"><a href="#Bootstrap如何实现响应式布局" class="headerlink" title="Bootstrap如何实现响应式布局"></a>Bootstrap如何实现响应式布局</h3><ul><li>原理：通过 media query 设置不同分辨率的class</li><li>使用：为不同分辨率选择不同的网格class</li></ul><h3 id="如何基于Bootstrap-定制自己的样式"><a href="#如何基于Bootstrap-定制自己的样式" class="headerlink" title="如何基于Bootstrap 定制自己的样式"></a>如何基于Bootstrap 定制自己的样式</h3><ul><li>使用CSS同名类覆盖（操作简单但）</li><li>修改sass源码重新构建（需要了解Bootstrap 结构）</li><li>引用scss源文件 修改变量（按需使用，控制体积，推荐使用，干净，但需要了解结构）</li></ul><h2 id="CSS-工程化"><a href="#CSS-工程化" class="headerlink" title="CSS 工程化"></a>CSS 工程化</h2><p>关注几个事情：组织、优化、构建、维护</p><h3 id="PostCSS"><a href="#PostCSS" class="headerlink" title="PostCSS"></a>PostCSS</h3><ul><li>将 CSS 解析成 CSS，和预处理器没太多区别。</li><li>本身只有解析能力</li><li>各种神奇的特性全靠插件</li><li>目前至少有200多个插件</li></ul><p>常见：</p><ul><li>import 模块合并</li><li>autoprefixer 自动加前缀</li><li>cssnano 压缩代码</li><li>cssnext 使用CSS新特性</li><li>precss 变量、mixin、循环等</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/2020053009080083.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><h3 id="PostCSS插件的使用"><a href="#PostCSS插件的使用" class="headerlink" title="PostCSS插件的使用"></a>PostCSS插件的使用</h3><p>全局安装 <code>postcss-cli</code></p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">npm</span> <span class="selector-tag">install</span> <span class="selector-tag">postcss-cli</span> <span class="selector-tag">-g</span></span><br></pre></td></tr></table></figure><p>在 <code>postcss.config.js</code> 文件进行配置<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/2020053009210982.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><h3 id="cssnext"><a href="#cssnext" class="headerlink" title="cssnext"></a>cssnext</h3><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200530092327268.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><h3 id="precss"><a href="#precss" class="headerlink" title="precss"></a>precss</h3><ul><li>变量（使用和 sass 几乎一样）</li><li>条件（if）</li><li>循环</li><li>Mixin Extend</li><li>import</li><li>属性值引用</li></ul><h3 id="gulp-postcss"><a href="#gulp-postcss" class="headerlink" title="gulp-postcss"></a>gulp-postcss</h3><p>PostCSS 支持的构建工具</p><ul><li>CLI命令行工具</li><li>webpack postcss-loader</li><li>Gulp gulp-postcss</li><li>Grunt grunt-postcss</li><li>Rollup rollup-postcss</li><li>…</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200530093431237.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><h3 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h3><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200530094124374.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><ul><li>JS是整个应用的核心入口</li><li>一切资源均由JS管理依赖</li><li>一切资源均由webpack打包</li></ul><h3 id="webpack-和-CSS"><a href="#webpack-和-CSS" class="headerlink" title="webpack 和 CSS"></a>webpack 和 CSS</h3><ul><li>css-loader 将 CSS变为 JS</li><li>style-loader 将JS插入到head</li><li>ExtractTextPlugin 将 CSS 从 JS 中 提取出来</li><li>CSS modules 解决 CSS命名冲突的问题</li><li>less-loader sass-loader 各类预处理器</li><li>postcss-loader PostCSS处理</li></ul><h2 id="CSS-面试真题-6"><a href="#CSS-面试真题-6" class="headerlink" title="CSS 面试真题"></a>CSS 面试真题</h2><h3 id="如何解决CSS模块化问题"><a href="#如何解决CSS模块化问题" class="headerlink" title="如何解决CSS模块化问题"></a>如何解决CSS模块化问题</h3><ul><li>less sass 等CSS预处理器</li><li>PostCSS插件（postcss-import / precss等）</li><li>webpackl处理CSS（css-loader + style-loader）</li></ul><h3 id="PostCSS可以做什么？"><a href="#PostCSS可以做什么？" class="headerlink" title="PostCSS可以做什么？"></a>PostCSS可以做什么？</h3><ul><li>取决于插件做什么</li><li>autoprefixer cssnext precss等 兼容性处理</li><li>import 模块合并</li><li>css语法检查 兼容性检查</li><li>cssnano  压缩文件</li></ul><h3 id="CSS-modules是做什么的，如何使用"><a href="#CSS-modules是做什么的，如何使用" class="headerlink" title="CSS modules是做什么的，如何使用"></a>CSS modules是做什么的，如何使用</h3><ul><li>解决类名冲突的问题</li><li>使用PostCSS或者webpack等构建工具进行编译</li><li>在HTML模板中使用编译过程产生的类名</li></ul><h3 id="为什么使用JS来引用、加载CSS"><a href="#为什么使用JS来引用、加载CSS" class="headerlink" title="为什么使用JS来引用、加载CSS"></a>为什么使用JS来引用、加载CSS</h3><ul><li>JS作为入口，管理资源有天然优势</li><li>将组件的结构、样式、行为封装到一起，增强内聚</li><li>可以做更多处理（webpack）</li></ul><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>话说，我有女朋友吗？我有吗？原来我没有…<br> <img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200530102604497.jpg" alt=""><br>扯开女朋友话题，终于完成了这篇史诗级大作，时隔几天时间。更多笔记内容还请关注 <a href="https://github.com/Chocolate1999/Front-end-learning-to-organize-notes">小狮子前端笔记仓库</a> （不要白嫖，给个 star ✿✿ヽ(°▽°)ノ✿ 就是对我最大的支持啦~）</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">学如逆水行舟，不进则退</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「查漏补缺」深度剖析JavaScript ES5/AMD/CMD/COMMONJS/ES6模块化（加薪必备）</title>
      <link href="posts/20201008/"/>
      <url>posts/20201008/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前端模块化是一个有年代的知识，每次笔试面试遇到答的不是很好，现在整理一下相关知识，进行知识梳理，如若有帮助到您，请<strong>一键三连</strong>，当然，本文表述有问题的地方，欢迎读者指正，谢谢~</p><h2 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h2><p><code>CommonJS</code> 出现就是解决原本 <code>js</code> 文件引入出现的不足点，即  <strong>模块依赖</strong>  和 <strong>全局污染</strong> 问题。它并不是一个 <code>JS</code>语言啥的，而是对于模块化的一个规范。</p><ul><li><p>CommonJS 实际上就是用了 <code>require</code> 这个玩意，只要引用，就会创建一个<strong>模块的实例</strong>，即实例化（每当引入一个文件，就会将这个文件变为一个 <code>JS</code> 实例）</p></li><li><p>做法是通过 <code>require</code> 引入模块，通过 <code>module.exports</code> 导出，并且文件加载是<strong>同步</strong>完成的。</p></li><li><p>对服务端比较友好，内含<strong>缓存机制</strong>，也就是说只要 <code>require</code> 一个模块，那么这个模块就会被缓存，并且还会进行一次比较异同的操作，例如我修改了这个模块，那么就会<strong>将缓存的模块替换新的模块</strong>。</p></li><li><p>在 node 上运行，不依赖于客户端。</p></li></ul><p>而当我们引入一个模块后，其实会解析成一个立即执行函数，类似于原本 <code>ES5</code> 利用自执行函数封装一样，类似下面，因此，<strong>引入的模块并不是全局变量</strong>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">exports</span>, <span class="built_in">require</span>, <span class="built_in">module</span>, __filename,__dirname</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h2 id="AMD出现"><a href="#AMD出现" class="headerlink" title="AMD出现"></a>AMD出现</h2><p>你可能会说 <code>AMD YES！</code> 但次 AMD 非 AMD（正所谓此中有真意喵~）</p><p>从上文我们知道了 <code>CommonJS</code> 只能在 <code>nodejs</code> 服务端那边使用，在客户端没法运行，而 <code>CommonJS</code> 使用挺不错的，于是整出了这个 <code>AMD</code>，全称（Asynchronous Module Definition）异步模块定义，是通过 <strong>RequireJS</strong> 来实现的，区别于 <code>CommonJS</code>，它是<strong>异步</strong>的。</p><p>定义模块： <code>define(moduleName, [module], factory);</code></p><p>引入模块：<code>require([module], callback);</code></p><p>下面看这个例子：</p><p>定义一个模块 <code>moduleA</code></p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20201008201957432.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70#pic_center" alt=""><br>再来定义一个模块 <code>moduleB</code>，此时它依赖于模块A，按照如下方式进行依赖。<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20201008202046186.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70#pic_center" alt=""><br>然后再 <code>index.js</code> 文件中我们需要通过 <code>require.config</code> 来配置我们的模块路径，如若没有配置的话，就会报错找不到。<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20201008202202986.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70#pic_center" alt=""></p><p><strong>注意点！</strong> 上述依赖模块<strong>只有当全部加载完毕之后，才会执行后边的回调函数</strong>。这种方式就是我们比较疑惑的一个名词：<strong>前置依赖</strong>。</p><p>因此，它不用考虑模块的引入顺序，并且保证是规范化的输入输出，同时，它会动态的创建 <code>script</code> 标签，如下图所示，它使用了 <code>async</code>来进行异步加载。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20201008202841881.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70#pic_center" alt=""></p><h2 id="引出CMD"><a href="#引出CMD" class="headerlink" title="引出CMD"></a>引出CMD</h2><p>此刻，阿里也为模块化做了贡献，推出了 <code>CMD</code>，全称（Commin Module Definition）通用模块定义，同理，它也没办法在浏览器端运行，参考了 <code>AMD</code>通过 <code>RequireJS</code> 实现，<code>CMD</code>引入了 <strong>sea.js</strong>。</p><p>定义模块： <code>define(function (require, exports, module) &#123;&#125;);</code></p><p>引入模块：<code>sea.js([module路径], function(moduleA, moduleB, moduleC) &#123;&#125;)</code>;</p><p>下面看这个例子：</p><p>定义一个模块 <code>moduleA</code></p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20201008204227367.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70#pic_center" alt=""></p><p>再来定义一个模块 <code>moduleB</code>，此时它依赖于模块A，按照如下方式进行依赖。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20201008204319123.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70#pic_center" alt=""></p><p>然后再 <code>index.js</code> 文件中，我们需要首先通过数组确定模块路径，如下所示：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">seajs.use([<span class="string">&#x27;module_a.js&#x27;</span>, <span class="string">&#x27;module_b.js&#x27;</span>], <span class="function"><span class="keyword">function</span>(<span class="params">moduleA, moduleB</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(moduleA.a);</span><br><span class="line"><span class="built_in">console</span>.log(moduleB.b);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p> 下面总结一下 <code>CMD</code> 相关知识：</p><p>通过 <code>require</code> 加载， <code>define</code> 定义， <code>exports</code> 导出（使用 <code>return</code> 同理），<code>module</code>操作模块。</p><p>而在使用模块时，需要配置相关 <code>url</code>，依赖加载完毕之后，再执行回调函数，这里和 <code>AMD</code> 没啥区别。</p><p><strong>注意点！</strong> 但是下面就有本质上不同了，<code>CMD</code>  <strong>就近依赖</strong>、<strong>按需加载</strong>，增强灵活性。</p><h2 id="ES6模块化登场"><a href="#ES6模块化登场" class="headerlink" title="ES6模块化登场"></a>ES6模块化登场</h2><p>导入模块： <code>import module from &#39;模块路径&#39;</code>;</p><p>导出模块：<code>export module ;</code></p><p>下面看这个例子：</p><p>定义一个模块 <code>moduleA</code></p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20201008210152759.png#pic_center" alt=""></p><p>再来定义一个模块 <code>moduleB</code>，此时它依赖于模块A，按照如下方式进行依赖。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20201008210540724.png#pic_center" alt=""></p><p>然后在 <code>index.js</code> 文件中我们需要配置我们的模块路径，如若没有配置的话，就会报错找不到。<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20201008210446205.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70#pic_center" alt=""></p><p><code>ES6</code> 模块化 与 <code>CommonJS</code> 对比：</p><p>先做一个实验，假设</p><p>在 <code>export.js</code> 中我们导出一个变量 <code>a</code>，并且进行了自加操作：</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20201008211353888.png#pic_center" alt=""></p><p>在 <code>common.js</code> 文件中，我们写入如下代码：</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20201008211145599.png#pic_center" alt=""></p><p>在 <code>es6.js</code> 文件中，我们写入如下代码：</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20201008211236435.png#pic_center" alt=""></p><p>最终结果如下：<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20201008211454438.png#pic_center" alt=""></p><p>通过例子，我们来总结一下：</p><p>区别1：</p><ul><li>common.js 模块输出的是一个值的拷贝</li><li>ES6 模块输出的是一个值得引用</li></ul><p>区别2：</p><ul><li>common.js 运行在服务端，因此模块是在运行时加载，即程序执行时 <code>require</code> 才会加载。</li><li>ES6 模块在编译时加载</li></ul><h2 id="本文参考"><a href="#本文参考" class="headerlink" title="本文参考"></a>本文参考</h2><p><a href="https://www.bilibili.com/video/BV1K54y1S7zx">【前端面试必备】JavaScript模块化全面解析<br></a></p><blockquote><p>感谢小野老师的对JavaScript模块化的细致讲解，给老师打call，建议大家可以结合视频看一看，看完会恍然大悟的！</p></blockquote><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>文章产出不易，还望各位小伙伴们支持一波！</p><p>往期精选：</p><p><a href="https://github.com/Chocolate1999/Front-end-learning-to-organize-notes">小狮子前端の笔记仓库</a></p><p><a href="https://github.com/Chocolate1999/leetcode-javascript">leetcode-javascript：LeetCode 力扣的 JavaScript 解题仓库，前端刷题路线（思维导图）</a></p><p>小伙伴们可以在Issues中提交自己的解题代码，🤝 欢迎Contributing，可打卡刷题，Give a ⭐️ if this project helped you!</p><p><a href="https://yangchaoyi.vip/">访问超逸の博客</a>，方便小伙伴阅读玩耍~</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/2020090211491121.png#pic_center" alt=""></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">学如逆水行舟，不进则退</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「CSS深度指北」前端知识梳理之CSS篇（中秋国庆特别篇）</title>
      <link href="posts/20201001/"/>
      <url>posts/20201001/</url>
      
        <content type="html"><![CDATA[<p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20201001173118330.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70#pic_center" alt=""></p><h2 id="认识浏览器"><a href="#认识浏览器" class="headerlink" title="认识浏览器"></a>认识浏览器</h2><h3 id="组成部分"><a href="#组成部分" class="headerlink" title="组成部分"></a>组成部分</h3><p>可能一说组成部分，小伙伴们就直接懵了，开门见山地说，别怕，还有更懵的在后面呢！</p><p>组成分为两大部分： <code>shell</code> 和 <strong>内核</strong>（其中内核是核心部分，它代表着浏览器所使用的技术手段，而<code>shell</code>就是我们用户所看到的<strong>界面</strong>）</p><p>例举你知道的比较大的浏览器产商？</p><table><thead><tr><th>shell</th><th>内核</th></tr></thead><tbody><tr><td>Google Chrome</td><td>webkit（谷歌和苹果safari一起开发）/ blink（谷歌将技术独立出来）</td></tr><tr><td>safari</td><td>webkit</td></tr><tr><td>firefox</td><td>gecko</td></tr><tr><td>IE</td><td>trident</td></tr><tr><td>opera（目前属于360和昆仑万维）</td><td>presto</td></tr></tbody></table><p>===== 手动分界线 =====</p><ul><li>360</li><li>QQ</li><li>遨游</li><li>猎豹</li><li>全球</li><li>搜狗</li><li>…</li></ul><p><strong>分界线的意义</strong>：分界面下面部分只是在 <code>shell</code> 上做了手段，没有专属的内核。我们回答的话答分界线上部分即可。</p><h3 id="内核"><a href="#内核" class="headerlink" title="内核"></a>内核</h3><p>包含渲染（rendering）引擎 和 JS 引擎</p><p>渲染引擎如字面意思，就是渲染我们页面的，大致了解即可，本文在这里讲解一下 <code>JS</code> 引擎。 <code>JS</code> 引擎早期是不存在的，通过同步渲染引擎来负责<code>JS</code>的解析。而渲染引擎性能是有限的，所以JS解析代码能力就比较低，100行多代码可能就崩溃了。因此，引入了 <code>JS</code> 引擎，大大加大了对 <code>JS</code> 解析的优化，速度相当快。</p><p>比较有名的就是谷歌推出的 <code>V8</code> 引擎，针对 <code>JS</code> 解析做了非常多的优化。只能一句，谷歌，牛！</p><h2 id="认识CSS"><a href="#认识CSS" class="headerlink" title="认识CSS"></a>认识CSS</h2><p><code>cascading style sheet</code> （层叠样式表）</p><h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 内联样式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;width: 100px; height: 100px;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="comment">/* 内部样式 */</span></span></span><br><span class="line">  div&#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line"><span class="css">    <span class="selector-tag">background-color</span>: <span class="selector-id">#000</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 外部样式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;./index.css&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="权重优先级问题"><a href="#权重优先级问题" class="headerlink" title="权重优先级问题"></a>权重优先级问题</h3><p>查看如下代码，会显示什么颜色呢？</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>CSS样式基础<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 外部样式 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;./index.css&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="comment">/* 内部样式 */</span></span></span><br><span class="line">    div&#123;</span><br><span class="line">      background-color: blue;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;background-color: red;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>外部样式 <code>index.css</code> 文件代码如下：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案是 <code>红色</code> </p><p>权重：内联样式（用的较少，可以使用 <code>display: none</code> 缓存数据） &gt; 内部样式表（一般测试用） &gt; 外部样式表（主要使用方式）</p><h3 id="选择器的优先级"><a href="#选择器的优先级" class="headerlink" title="选择器的优先级"></a>选择器的优先级</h3><p>!important &gt; id &gt; class | 属性 &gt; 标签 &gt; *</p><h3 id="分组选择器"><a href="#分组选择器" class="headerlink" title="分组选择器"></a>分组选择器</h3><p>清除输入框的轮廓</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">input</span>,</span><br><span class="line"><span class="selector-tag">textarea</span>&#123;</span><br><span class="line">  <span class="attribute">outline</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="浏览器对父子选择器的匹配规则"><a href="#浏览器对父子选择器的匹配规则" class="headerlink" title="浏览器对父子选择器的匹配规则"></a>浏览器对父子选择器的匹配规则</h3><p>从下到上，从右到左</p><h3 id="button"><a href="#button" class="headerlink" title="button"></a>button</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">button</span>&#123;</span><br><span class="line">  border: none; // 去掉按钮的边框</span><br><span class="line">  <span class="selector-tag">color</span>: <span class="selector-tag">white</span>; // 更改按钮字体颜色</span><br><span class="line">  <span class="selector-tag">background-color</span>: <span class="selector-tag">red</span>; // 更改按钮颜色</span><br><span class="line">  <span class="selector-tag">font-size</span>: 12<span class="selector-tag">px</span>; // 更改字体大小</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单行文本截断和显示省略号的三大件"><a href="#单行文本截断和显示省略号的三大件" class="headerlink" title="单行文本截断和显示省略号的三大件"></a>单行文本截断和显示省略号的三大件</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">22px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#000</span>;</span><br><span class="line">  <span class="attribute">white-space</span>: nowrap; <span class="comment">/*不换行*/</span></span><br><span class="line">  <span class="attribute">overflow</span>: hidden; <span class="comment">/*超出部分隐藏*/</span></span><br><span class="line">  <span class="attribute">text-overflow</span>: ellipsis; <span class="comment">/*隐藏部分加省略号*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="visibility-hidden-和-display-none-区别"><a href="#visibility-hidden-和-display-none-区别" class="headerlink" title="visibility:hidden 和 display:none 区别"></a>visibility:hidden 和 display:none 区别</h3><p><code>visibility:hidden</code>  保留被隐藏的元素所占据的HTML文档空间</p><p><code>display:none</code> 不保留被隐藏的元素所占据的HTML文档空间</p><h3 id="行内块和行内元素文本对齐问题"><a href="#行内块和行内元素文本对齐问题" class="headerlink" title="行内块和行内元素文本对齐问题"></a>行内块和行内元素文本对齐问题</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>行内块和行内元素文本对齐问题<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.block</span>&#123;</span></span><br><span class="line">      display: inline-block;</span><br><span class="line">      width: 150px;</span><br><span class="line">      height: 100px;</span><br><span class="line"><span class="css">      <span class="selector-tag">border</span>: 1<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-id">#000</span>;</span></span><br><span class="line"><span class="css">      <span class="selector-tag">vertical-align</span>: <span class="selector-tag">middle</span>; <span class="comment">/*对齐*/</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;block&quot;</span>&gt;</span>123<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>123<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20201001094945574.png#pic_center" alt=""></p><h3 id="容器内多行文本居中的方法"><a href="#容器内多行文本居中的方法" class="headerlink" title="容器内多行文本居中的方法"></a>容器内多行文本居中的方法</h3><p>1、将容器的 display 设置为 table<br>2、将容器内的文本的 display 设置成 table-cell （表格单元格属性）<br>3、将容器内的文本的 vertical-aligin 设置成 middle</p><h3 id="行内块元素之间默认间距问题"><a href="#行内块元素之间默认间距问题" class="headerlink" title="行内块元素之间默认间距问题"></a>行内块元素之间默认间距问题</h3><p>在产生边距的行内块的父元素设置属性：font-size：0px;</p><p>在父元素上设置，word-spacing(词边距)的值设为合适的负值即可</p><h3 id="水平垂直居中：外盒子固定内边距，内盒子宽高100"><a href="#水平垂直居中：外盒子固定内边距，内盒子宽高100" class="headerlink" title="水平垂直居中：外盒子固定内边距，内盒子宽高100%"></a>水平垂直居中：外盒子固定内边距，内盒子宽高100%</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>水平垂直居中方式1<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.box</span> &#123;</span></span><br><span class="line">      width: 100px;</span><br><span class="line">      height: 100px;</span><br><span class="line">      padding: 30px;</span><br><span class="line"><span class="css">      <span class="selector-tag">border</span>: 1<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-id">#000</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.box</span> <span class="selector-class">.box1</span> &#123;</span></span><br><span class="line">      width: 100%;</span><br><span class="line">      height: 100%;</span><br><span class="line">      background-color: orange;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20201001103110237.png#pic_center" alt=""></p><h3 id="浏览器body默认margin"><a href="#浏览器body默认margin" class="headerlink" title="浏览器body默认margin"></a>浏览器body默认margin</h3><p>ie8 -&gt; 上下16px 左右8px<br>ie7 -&gt; 上下15px 左右11px</p><h2 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h2><h3 id="浮动流"><a href="#浮动流" class="headerlink" title="浮动流"></a>浮动流</h3><p>浮动流，块级元素无法识别浮动流元素的位置。而定位 <code>position</code> 会新建一个图层。</p><p>内联、内联块、浮动、溢出隐藏、纯文本都可以识别浮动元素的位置，除了块级元素。</p><p>float以后，元素就变成内联块级元素</p><h3 id="清除浮动方式1"><a href="#清除浮动方式1" class="headerlink" title="清除浮动方式1"></a>清除浮动方式1</h3><p>因为设置了浮动流了之后，块级元素没办法识别浮动流元素的位置，自然会出现高度塌陷的问题。可采用如下方式清除，通过一个<strong>块级元素</strong>，设置 <code>clear: both</code> 即可，但此方法不是特别好，额外新增了一个元素。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>清除浮动方式1<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.box</span> &#123;</span></span><br><span class="line">      width: 200px;</span><br><span class="line"><span class="css">      <span class="selector-tag">border</span>: 1<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-id">#000</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="selector-class">.box</span> <span class="selector-class">.inner-box</span>&#123;</span></span><br><span class="line">      float: left;</span><br><span class="line">      width: 100px;</span><br><span class="line">      height: 100px;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="selector-class">.box</span> <span class="selector-class">.inner-box</span><span class="selector-class">.box1</span>&#123;</span></span><br><span class="line">      background-color: green;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="selector-class">.box</span> <span class="selector-class">.inner-box</span><span class="selector-class">.box2</span>&#123;</span></span><br><span class="line">      background-color: orange;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="selector-class">.clearfix</span>&#123;</span></span><br><span class="line">      clear: both;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;inner-box box1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;inner-box box2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;clearfix&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/2020100114422624.png#pic_center" alt=""></p><h3 id="伪类"><a href="#伪类" class="headerlink" title="伪类"></a>伪类</h3><p>直接看下面例子，看看伪类是怎么使用的</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>伪类简单使用<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">p</span><span class="selector-pseudo">:before</span>&#123;</span></span><br><span class="line">      content: &quot;Chocolate&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="selector-tag">p</span><span class="selector-pseudo">:after</span>&#123;</span></span><br><span class="line">      content: &quot;写博客！&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>喜欢<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中， <code>content</code> 这个属性值<strong>必须加上！</strong></p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20201001144942942.png#pic_center" alt=""></p><h3 id="清除浮动方式2"><a href="#清除浮动方式2" class="headerlink" title="清除浮动方式2"></a>清除浮动方式2</h3><p>利用伪元素来清除浮动，通过添加一个块级并且设置 <code>clear:both</code>来清除。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;!<span class="selector-tag">DOCTYPE</span> <span class="selector-tag">html</span>&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;<span class="selector-tag">head</span>&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">  &lt;<span class="selector-tag">title</span>&gt;清除浮动方式2&lt;/<span class="selector-tag">title</span>&gt;</span><br><span class="line">  &lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">    <span class="selector-tag">ul</span><span class="selector-pseudo">::after</span>,</span><br><span class="line">    <span class="selector-tag">div</span><span class="selector-pseudo">::after</span>&#123;</span><br><span class="line">      <span class="attribute">content</span>: <span class="string">&quot;&quot;</span>;</span><br><span class="line">      <span class="attribute">display</span>: block;</span><br><span class="line">      <span class="attribute">clear</span>: both;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="selector-class">.box</span> &#123;</span><br><span class="line">      <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">      <span class="attribute">border</span>: <span class="number">10px</span> solid <span class="number">#000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 下面这种方式也可以，但没有上述直接设置div好 */</span></span><br><span class="line">    <span class="comment">/* .box::after&#123;</span></span><br><span class="line"><span class="comment">      content: &quot;&quot;;</span></span><br><span class="line"><span class="comment">      display: block;</span></span><br><span class="line"><span class="comment">      clear: both;</span></span><br><span class="line"><span class="comment">    &#125; */</span></span><br><span class="line"></span><br><span class="line">    <span class="selector-class">.box</span> <span class="selector-class">.inner-box</span>&#123;</span><br><span class="line">      <span class="attribute">float</span>: left;</span><br><span class="line">      <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">      <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="selector-class">.box</span> <span class="selector-class">.inner-box</span><span class="selector-class">.box1</span>&#123;</span><br><span class="line">      <span class="attribute">background-color</span>: green;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="selector-class">.box</span> <span class="selector-class">.inner-box</span><span class="selector-class">.box2</span>&#123;</span><br><span class="line">      <span class="attribute">background-color</span>: orange;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/<span class="selector-tag">style</span>&gt;</span><br><span class="line">&lt;/<span class="selector-tag">head</span>&gt;</span><br><span class="line">&lt;<span class="selector-tag">body</span>&gt;</span><br><span class="line">  &lt;div class=&quot;box&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;inner-box box1&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;inner-box box2&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">&lt;/<span class="selector-tag">body</span>&gt;</span><br><span class="line">&lt;/<span class="selector-tag">html</span>&gt;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20201001145806166.png#pic_center" alt=""></p><h3 id="清除浮动方式3"><a href="#清除浮动方式3" class="headerlink" title="清除浮动方式3"></a>清除浮动方式3</h3><p>下面才是清除浮动的最好方式，直接写一个类 <code>clearfix</code>，然后需要清除浮动的话，直接在父级元素上添加这个类就好了。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>清除浮动方式3<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.clearfix</span><span class="selector-pseudo">::after</span>&#123;</span></span><br><span class="line">      content: &quot;&quot;;</span><br><span class="line">      display: block;</span><br><span class="line">      clear: both;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="selector-class">.box</span> &#123;</span></span><br><span class="line">      width: 200px;</span><br><span class="line"><span class="css">      <span class="selector-tag">border</span>: 10<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-id">#000</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="selector-class">.box</span> <span class="selector-class">.inner-box</span>&#123;</span></span><br><span class="line">      float: left;</span><br><span class="line">      width: 100px;</span><br><span class="line">      height: 100px;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="selector-class">.box</span> <span class="selector-class">.inner-box</span><span class="selector-class">.box1</span>&#123;</span></span><br><span class="line">      background-color: green;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="selector-class">.box</span> <span class="selector-class">.inner-box</span><span class="selector-class">.box2</span>&#123;</span></span><br><span class="line">      background-color: orange;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box clearfix&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;inner-box box1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;inner-box box2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20201001145806166.png#pic_center" alt=""></p><h3 id="content-实现动态数据"><a href="#content-实现动态数据" class="headerlink" title="content 实现动态数据"></a>content 实现动态数据</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;!<span class="selector-tag">DOCTYPE</span> <span class="selector-tag">html</span>&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;<span class="selector-tag">head</span>&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">  &lt;<span class="selector-tag">title</span>&gt;<span class="selector-tag">content</span>动态数据获取&lt;/<span class="selector-tag">title</span>&gt;</span><br><span class="line">  &lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">    <span class="selector-tag">p</span><span class="selector-pseudo">::before</span>&#123;</span><br><span class="line">      <span class="attribute">content</span>: <span class="built_in">attr</span>(data-username);</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/<span class="selector-tag">style</span>&gt;</span><br><span class="line">&lt;/<span class="selector-tag">head</span>&gt;</span><br><span class="line">&lt;<span class="selector-tag">body</span>&gt;</span><br><span class="line">  &lt;p data-username=&quot;Chocolate&quot;&gt;,欢迎您的来访!&lt;/p&gt;</span><br><span class="line">&lt;/<span class="selector-tag">body</span>&gt;</span><br><span class="line">&lt;/<span class="selector-tag">html</span>&gt;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20201001151809174.png#pic_center" alt=""></p><h2 id="CSS3"><a href="#CSS3" class="headerlink" title="CSS3"></a>CSS3</h2><h3 id="盒子阴影"><a href="#盒子阴影" class="headerlink" title="盒子阴影"></a>盒子阴影</h3><p>box-shadow：水平位置（必） 垂直位置（必）模糊距离  阴影的尺寸（相当于在水平和垂直上的一个增量） 阴影颜色 阴影的种类</p><p>兼容性写法</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">-webkit-box-shadow</span>: 0 0 10<span class="selector-tag">px</span>;</span><br><span class="line"><span class="selector-tag">-moz-box-shadow</span>: 0 0 10<span class="selector-tag">px</span>;</span><br><span class="line"><span class="selector-tag">-o-box-shadow</span>: 0 0 10<span class="selector-tag">px</span>;</span><br></pre></td></tr></table></figure><h3 id="边框圆角"><a href="#边框圆角" class="headerlink" title="边框圆角"></a>边框圆角</h3><p>纯圆 50% 宽高一样</p><p>半圆角 height/2 + px</p><p>遇到图片突出覆盖问题，可以用 <code>overflow: hidden</code> 来解决。</p><h3 id="网站cover背景图缩放不改变比例"><a href="#网站cover背景图缩放不改变比例" class="headerlink" title="网站cover背景图缩放不改变比例"></a>网站cover背景图缩放不改变比例</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.banner</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">600px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: orange;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">url</span>(img/xxx.jpg);</span><br><span class="line">  <span class="attribute">background-repeat</span>: no-repeat;</span><br><span class="line">  <span class="attribute">background-size</span>: cover;</span><br><span class="line">  <span class="attribute">background-position</span>: center center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="背景图不随滚动条变化"><a href="#背景图不随滚动条变化" class="headerlink" title="背景图不随滚动条变化"></a>背景图不随滚动条变化</h3><p><code>background-attachment</code> 有两个属性值， <code>scrool</code>（默认值，会跟随滚动条而变化），<code>fixed</code>（不会随着滚动条变化）</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">html</span>&#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: orange;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">url</span>(img/xxx.jpg);</span><br><span class="line">  <span class="attribute">background-size</span>: <span class="number">100%</span> <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">background-attachment</span>: fixed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="logo公司常用写法模板"><a href="#logo公司常用写法模板" class="headerlink" title="logo公司常用写法模板"></a>logo公司常用写法模板</h3><p>解决因为网络问题导致css加载不出来时有一个补救措施</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>logo公司常用写法模板<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span></span><br><span class="line">    h1&#123;</span><br><span class="line">      margin: 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="selector-class">.logo</span>&#123;</span></span><br><span class="line">      width: 142px;</span><br><span class="line">      height: 58px;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="selector-class">.logo</span> <span class="selector-tag">h1</span> <span class="selector-class">.logo-hd</span>&#123;</span></span><br><span class="line">      display: block;</span><br><span class="line">      width: 142px;</span><br><span class="line">      height: 0;</span><br><span class="line">      padding-top: 58px;</span><br><span class="line"><span class="css">      <span class="selector-tag">background</span>: <span class="selector-tag">url</span>(<span class="selector-tag">img</span>/<span class="selector-tag">logo</span><span class="selector-class">.png</span>) <span class="selector-tag">no-repeat</span> 0 0/142<span class="selector-tag">px</span> 58<span class="selector-tag">px</span>;</span></span><br><span class="line">      overflow: hidden;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;logo&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;logo-hd&quot;</span>&gt;</span>淘宝网<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="BFC特点"><a href="#BFC特点" class="headerlink" title="BFC特点"></a>BFC特点</h3><ul><li>有点像完全独立出来的容器，不会对外面元素的布局产生影响。</li><li>属于普通流的范畴</li></ul><h3 id="如何让一个元素成为BFC"><a href="#如何让一个元素成为BFC" class="headerlink" title="如何让一个元素成为BFC"></a>如何让一个元素成为BFC</h3><ul><li>body本身就是BFC元素</li><li>被定义float: left / right</li><li>position: absolute / fixed</li><li>display: inline-block / table-cell / flex</li><li>overflow: auto / hidden / scroll</li></ul><h3 id="BFC解决了什么问题"><a href="#BFC解决了什么问题" class="headerlink" title="BFC解决了什么问题"></a>BFC解决了什么问题</h3><p>它解决了什么问题？</p><ul><li>margin合并问题  </li><li>高度塌陷问题</li><li>margin塌陷问题</li></ul><p>还是讲解一下 margin塌陷问题，如下代码，当我们在子级盒子里面设置 <code>margin-top</code> 发现会带着父级盒子一起下去了。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;!<span class="selector-tag">DOCTYPE</span> <span class="selector-tag">html</span>&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;<span class="selector-tag">head</span>&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">  &lt;<span class="selector-tag">title</span>&gt;<span class="selector-tag">BFC</span>：<span class="selector-tag">margin</span>塌陷问题&lt;/<span class="selector-tag">title</span>&gt;</span><br><span class="line">  &lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">    <span class="selector-class">.box1</span>&#123;</span><br><span class="line">      <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">      <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">      <span class="attribute">background-color</span>: <span class="number">#000</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="selector-class">.box2</span>&#123;</span><br><span class="line">      <span class="attribute">width</span>: <span class="number">50px</span>;</span><br><span class="line">      <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">      <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">      <span class="attribute">margin-top</span>: <span class="number">100px</span>;</span><br><span class="line">      <span class="attribute">background-color</span>: orange;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/<span class="selector-tag">style</span>&gt;</span><br><span class="line">&lt;/<span class="selector-tag">head</span>&gt;</span><br><span class="line">&lt;<span class="selector-tag">body</span>&gt;</span><br><span class="line">  &lt;div class=&quot;box1&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">&lt;/<span class="selector-tag">body</span>&gt;</span><br><span class="line">&lt;/<span class="selector-tag">html</span>&gt;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20201001170947333.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70#pic_center" alt=""><br>解决方式，就是利用BFC特性</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;!<span class="selector-tag">DOCTYPE</span> <span class="selector-tag">html</span>&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;<span class="selector-tag">head</span>&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">  &lt;<span class="selector-tag">title</span>&gt;<span class="selector-tag">BFC</span>：<span class="selector-tag">margin</span>塌陷问题&lt;/<span class="selector-tag">title</span>&gt;</span><br><span class="line">  &lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">    <span class="selector-class">.box1</span>&#123;</span><br><span class="line">      <span class="comment">/* 可选方式 */</span></span><br><span class="line">      <span class="comment">/* border: 1px solid transparent; */</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 解决方式，形成BFC */</span></span><br><span class="line">      <span class="comment">/* display: inline-block; */</span></span><br><span class="line">      <span class="comment">/* display: table-cell; */</span></span><br><span class="line">      <span class="comment">/* overflow: hidden; */</span></span><br><span class="line">      <span class="comment">/* float: left; */</span></span><br><span class="line">      <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">      <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">      <span class="attribute">background-color</span>: <span class="number">#000</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="selector-class">.box2</span>&#123;</span><br><span class="line">      <span class="attribute">width</span>: <span class="number">50px</span>;</span><br><span class="line">      <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">      <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">      <span class="attribute">margin-top</span>: <span class="number">100px</span>;</span><br><span class="line">      <span class="attribute">background-color</span>: orange;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/<span class="selector-tag">style</span>&gt;</span><br><span class="line">&lt;/<span class="selector-tag">head</span>&gt;</span><br><span class="line">&lt;<span class="selector-tag">body</span>&gt;</span><br><span class="line">  &lt;div class=&quot;box1&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">&lt;/<span class="selector-tag">body</span>&gt;</span><br><span class="line">&lt;/<span class="selector-tag">html</span>&gt;</span><br></pre></td></tr></table></figure><h3 id="CSS书写顺序"><a href="#CSS书写顺序" class="headerlink" title="CSS书写顺序"></a>CSS书写顺序</h3><ul><li>显示属性：display position float clear</li><li>自身属性：width height margin padding border background</li><li>文本属性：color font text-align  vertical-aligin white-space</li></ul><h2 id="本文参考"><a href="#本文参考" class="headerlink" title="本文参考"></a>本文参考</h2><p><a href="https://www.bilibili.com/video/BV15v411v7Y1">全网最细最全的『CSS基础+进阶+实战』深度指南</a></p><blockquote><p>感谢小野老师的对CSS的细致讲解，给老师打call，建议大家可以结合视频看一看，看完会恍然大悟的！</p></blockquote><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>文章产出不易，还望各位小伙伴们支持一波！</p><p>往期精选：</p><p><a href="https://github.com/Chocolate1999/Front-end-learning-to-organize-notes">小狮子前端の笔记仓库</a></p><p><a href="https://github.com/Chocolate1999/leetcode-javascript">leetcode-javascript：LeetCode 力扣的 JavaScript 解题仓库，前端刷题路线（思维导图）</a></p><p>小伙伴们可以在Issues中提交自己的解题代码，🤝 欢迎Contributing，可打卡刷题，Give a ⭐️ if this project helped you!</p><p><a href="https://yangchaoyi.vip/">访问超逸の博客</a>，方便小伙伴阅读玩耍~</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/2020090211491121.png#pic_center" alt=""></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">学如逆水行舟，不进则退</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「JavaScript灵魂之问」前端知识梳理之 JS 篇（中篇）</title>
      <link href="posts/2020917/"/>
      <url>posts/2020917/</url>
      
        <content type="html"><![CDATA[<h2 id="对象基础"><a href="#对象基础" class="headerlink" title="对象基础"></a>对象基础</h2><p>对象前置知识</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 对象基础知识 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> teacher = &#123;</span><br><span class="line">  name: <span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">  age: <span class="number">32</span>,</span><br><span class="line">  sex: <span class="string">&#x27;male&#x27;</span>,</span><br><span class="line">  height: <span class="number">176</span>,</span><br><span class="line">  weight: <span class="number">130</span>,</span><br><span class="line">  teach: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;I am teaching JS&#x27;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  smoke: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;I am smoking&#x27;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  eat: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;I am having a dinner&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 查找 */</span></span><br><span class="line"><span class="built_in">console</span>.log(teacher.name);</span><br><span class="line">teacher.teach();</span><br><span class="line">teacher.smoke();</span><br><span class="line">teacher.eat();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 增加 */</span></span><br><span class="line">teacher.address = <span class="string">&#x27;北京&#x27;</span></span><br><span class="line">teacher.drink = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;I am drinking beer&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(teacher.address);</span><br><span class="line">teacher.drink();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 修改 */</span></span><br><span class="line">teacher.teach = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;I am teaching Vue&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">teacher.teach();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 删除 */</span></span><br><span class="line"><span class="keyword">delete</span> teacher.address;</span><br><span class="line"><span class="keyword">delete</span> teacher.teach;</span><br><span class="line"><span class="built_in">console</span>.log(teacher);</span><br></pre></td></tr></table></figure><h2 id="构造函数基础"><a href="#构造函数基础" class="headerlink" title="构造函数基础"></a>构造函数基础</h2><p>从上文我们可以知道，创建对象的一种方式，通过 <code>&#123;&#125;</code> （即<strong>对象字面量</strong>）来创建。下面我们来讲讲采用构造函数方式创建。</p><p>第一种，通过系统自带的构造函数</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">obj.name = <span class="string">&#x27;张三&#x27;</span>;</span><br><span class="line">obj.sex = <span class="string">&#x27;男士&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj);</span><br></pre></td></tr></table></figure><p>这种方式通过系统自带的<strong>构造函数实例化</strong>出来的，其实是和对象字面量一样，没啥区别。</p><p>对象和构造函数不能混淆，对象是通过实例化构造函数而创建的。这里不知道小伙伴们理不理解，下文会探讨这个问题的。</p><p>第二种，自定义构造函数</p><p>对于自定义构造函数，我们一般采用<strong>大驼峰</strong>命名（单词首字母全大写），里面一个关键词 <code>this</code>，考一考，此时 <code>this</code> 指向谁？指向 <code>Teacher</code>吗？</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 自定义构造函数 采用大驼峰命名*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Teacher</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = <span class="string">&#x27;张三&#x27;</span>;</span><br><span class="line">  <span class="built_in">this</span>.sex = <span class="string">&#x27;男士&#x27;</span>;</span><br><span class="line">  <span class="built_in">this</span>.smoke = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;I am smoking&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>答案是 <code>this</code> 根本不存在，因为函数在 <code>GO</code>里面，里面内容根本不会看，如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">GO = &#123;</span><br><span class="line">Teacher: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此 <code>this</code>都没有生成，并且 <code>Teacher</code>是构造函数。而如果想要 <code>this</code>存在，就需要实例化，因为上文提到的，<code>this</code>它是指向的<strong>对象本身</strong>。因此，需要如下一行代码，进行实例化操作。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> teacher = <span class="keyword">new</span> Teacher();</span><br></pre></td></tr></table></figure></div></div><p>好的，那么我们现在对上述代码进行一丢丢修改，看下面代码会打印什么？</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Teacher</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = <span class="string">&#x27;张三&#x27;</span>;</span><br><span class="line">  <span class="built_in">this</span>.sex = <span class="string">&#x27;男士&#x27;</span>;</span><br><span class="line">  <span class="built_in">this</span>.smoke = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;I am smoking&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> teacher1 = <span class="keyword">new</span> Teacher();</span><br><span class="line"><span class="keyword">var</span> teacher2 = <span class="keyword">new</span> Teacher();</span><br><span class="line"></span><br><span class="line">teacher1.name = <span class="string">&#x27;李四&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(teacher1.name);</span><br><span class="line"><span class="built_in">console</span>.log(teacher2.name);</span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>答案是 <code>李四 张三</code>。因为通过构造函数 <code>new</code> 出来的两个对象根本不是一个东西，是两个不同的对象，因此更改某一个完全不影响另外一个对象。也就是说构造函数实例化的多个对象相互之间是不影响的。</p></div></div><p>下面给出一份封装构造函数的基础代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Teacher</span>(<span class="params">opt</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = opt.name;</span><br><span class="line">  <span class="built_in">this</span>.sex = opt.sex;</span><br><span class="line">  <span class="built_in">this</span>.weight = opt.weight;</span><br><span class="line">  <span class="built_in">this</span>.course = opt.course;</span><br><span class="line">  <span class="built_in">this</span>.smoke = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.weight--;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.weight);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">this</span>.eat = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.weight++;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.weight);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> t1 = <span class="keyword">new</span> Teacher(&#123;</span><br><span class="line">  name: <span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">  sex: <span class="string">&#x27;男士&#x27;</span>,</span><br><span class="line">  weight: <span class="number">130</span>,</span><br><span class="line">  course: <span class="string">&#x27;JS&#x27;</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> t2 = <span class="keyword">new</span> Teacher(&#123;</span><br><span class="line">  name: <span class="string">&#x27;李四&#x27;</span>,</span><br><span class="line">  sex: <span class="string">&#x27;女士&#x27;</span>,</span><br><span class="line">  weight: <span class="number">90</span>,</span><br><span class="line">  course: <span class="string">&#x27;Vue&#x27;</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(t1);</span><br><span class="line"><span class="built_in">console</span>.log(t2);</span><br></pre></td></tr></table></figure><h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><p>主要就是这三种：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Number</span> <span class="keyword">new</span> <span class="built_in">String</span> <span class="keyword">new</span> <span class="built_in">Boolean</span></span><br></pre></td></tr></table></figure><p>举个简单例子，小伙伴们应该就能明白了。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> aa = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&#x27;abc&#x27;</span>);</span><br><span class="line">aa.name = <span class="string">&#x27;aa&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(aa);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bb = aa + <span class="string">&#x27;bcd&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(bb);</span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>答案是 <code>abc [String: &#39;abc&#39;] abcbcd</code>，包装类参与运算的时候会转换成原始值参与运算。补充：<strong>原始值不会有属性和方法</strong>。</p></div></div><p>再来一道例题吧，下面输出会有结果吗？</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">123</span>;</span><br><span class="line">a.len = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a.len);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(b.length);</span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>答案是 <code>undefined 3</code>，这个时候就会有疑惑了，上文不是说原始值不会拥有属性和方法嘛，那 <code>b.length</code>是怎么肥事呢？这就涉及到<strong>包装类</strong>的问题了。</p><p>对于第一个输出，这里解释一下，首先原始值不会有属性和方法，而<code>js</code>在执行到 <code>a.len = 3</code>的时候，会进行一次包装，即 <code>new Number(3).len = 3;</code> 然而它仅仅只是赋值操作，也没有办法进行保存，赋值完后，执行 <code>delete</code>操作删除，最后当我们访问 <code>a.len</code> 的时候打印 <code>undefined</code>了。总体来说，相当于如下操作：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">&#x27;Chocolate&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj.name); <span class="comment">// Chocolate</span></span><br><span class="line"><span class="keyword">delete</span> obj.name;</span><br><span class="line"><span class="built_in">console</span>.log(obj.name); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>以上就是包装类的过程。</p><p>对于第二个输出，也来解释一下。有了上一题分析，我想你们也会想到包装类了，这里是字符串，我们不妨打印一下 <code>new String()</code> 会有怎样的结果：</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200916190436347.png#pic_center" alt=""></p><p>发现没有，包装类里面有一个 <code>length</code>属性，因此当我们 <code>js</code> 执行时，遇到 <code>b = &#39;abc&#39;</code>，也会进行一层包装，然后将长度存储到 <code>length</code>属性上，因此我们就能访问得到，而上一题我们没办法存储，最后也就被删除掉了。</p></div></div><p><strong>补充知识点</strong>：</p><p>数组的截断方法：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">arr.length = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// 1 2 3</span></span><br></pre></td></tr></table></figure><p>继续来做一道题，看看会输出什么：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;Chocolate&#x27;</span>;</span><br><span class="line">name += <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> type = <span class="keyword">typeof</span>(name);</span><br><span class="line"><span class="keyword">if</span>(type.length === <span class="number">6</span>)&#123;</span><br><span class="line">  type.text = <span class="string">&#x27;string&#x27;</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">console</span>.log(type.text);</span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>答案是 <code>undefined</code>，原理和上文代码一致。这里就不详细解释了，不太懂的小伙伴可以往上看看下面这个例子。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">123</span>;</span><br><span class="line">a.len = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a.len);</span><br></pre></td></tr></table></figure><p>那么，怎么输出 <code>string</code>呢？其实，我们可以自己包装一个就可以了。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;Chocolate&#x27;</span>;</span><br><span class="line">name += <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> type = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="keyword">typeof</span>(name));  <span class="comment">// 重点在这</span></span><br><span class="line"><span class="keyword">if</span>(type.length === <span class="number">6</span>)&#123;</span><br><span class="line">  type.text = <span class="string">&#x27;string&#x27;</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">console</span>.log(type.text); <span class="comment">// string</span></span><br></pre></td></tr></table></figure></div></div><p>接着，继续，来一道经典的笔试题，看看下面三个会输出什么？</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">a,b,c</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> d = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">this</span>.a = a;</span><br><span class="line">  <span class="built_in">this</span>.b = b;</span><br><span class="line">  <span class="built_in">this</span>.c = c;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    d++;</span><br><span class="line">    <span class="built_in">console</span>.log(d);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">this</span>.g = f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> test1 = <span class="keyword">new</span> test();</span><br><span class="line">test1.g(); <span class="comment">// </span></span><br><span class="line">test1.g(); <span class="comment">// </span></span><br><span class="line"><span class="keyword">var</span> test2 = <span class="keyword">new</span> test();</span><br><span class="line">test2.g(); <span class="comment">// </span></span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>答案：<code>2 3 2</code>。解释一下，其实在 <code>test</code>函数最后会有一个默认返回，即 <code>return this</code>。因此也就形成了一个闭包， <code>test</code>函数的 <code>AO</code>也被带出去了，这个和累加器原理一样。然后对于实例化的两个对象，它们互不影响，所以<code>d</code>都是从<code>1</code>作为初始值。</p></div></div><p>下面来一道综合题，回顾上篇的知识，下面三个函数哪些会打印 <code>1 2 3 4 5</code>呢？</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo1</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line">foo1(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo2</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo3</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;)(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>答案是 <code>foo1 foo3</code>。这里只解释一下<code>foo2</code>为啥不能打印，因为对于函数声明后面跟着括号 <code>()</code>，如果没有传参的话，就会报错，传参了，它会返回以逗号分割的最后一个元素。</p></div></div><p>继续，又是一个阿里的笔试原题，看看会输出什么？</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params">x,y,a</span>)</span>&#123;</span><br><span class="line">  a = <span class="number">10</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line">b(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>答案是 <code>10</code>，因为上篇就有介绍过，对于实参传形参，如果实参和形参有映射关系，那么我们就可以修改实参，否则没办法修改实参。</p></div></div><h2 id="原型基础"><a href="#原型基础" class="headerlink" title="原型基础"></a>原型基础</h2><p>原型 <code>prototype</code> 其实是 <code>function</code>对象的一个属性，但是打印出来结果它也是对象。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200916203357739.png#pic_center" alt=""><br>那我们直接看下面这个例子吧</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Foo.prototype.sex = <span class="string">&#x27;男士&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> Foo(<span class="string">&#x27;Chocolate&#x27;</span>,<span class="number">21</span>);</span><br><span class="line"><span class="built_in">console</span>.log(foo.name); <span class="comment">// Chocolate</span></span><br><span class="line"><span class="built_in">console</span>.log(foo.sex); <span class="comment">// 男士</span></span><br></pre></td></tr></table></figure><p>拓展：<code>prototype</code>是定义构造函数构造出的每个对象的公共祖先，所有被该构造函数构造出的对象都可以继承原型上的属性和方法。</p><p>原型的作用，如上述代码一样，将一些配置项写在构造函数里，对于一些写死的值或者方法，就可以直接挂载到原型上去，可以减少代码冗余。</p><p>知识点补充：</p><p>实例的 <code>__proto__</code>其实就是一个容器，就是为了在对象里面给 <code>prototype</code>设置一个键名。</p><p>来一道简单题吧，会输出什么？</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Car</span>(<span class="params"></span>) </span>&#123; &#125;;</span><br><span class="line">Car.prototype.name = <span class="string">&#x27;Math&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> car = <span class="keyword">new</span> Car();</span><br><span class="line">Car.prototype.name = <span class="string">&#x27;Benz&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(car.name);</span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>答案是 <code>Benz</code>，相当于进行了一次覆盖操作。</p></div></div><p>现在，我进行一点点修改，看看又会输出什么？</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Car.prototype.name = <span class="string">&#x27;Benz&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Car</span>(<span class="params"></span>) </span>&#123; &#125;;</span><br><span class="line"><span class="keyword">var</span> car = <span class="keyword">new</span> Car();</span><br><span class="line"></span><br><span class="line">Car.prototype = &#123;</span><br><span class="line">  name: <span class="string">&#x27;Math&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(car.name);</span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>答案是 <code>Benz</code>，实例化一个<code>car</code>对象，首先<code>car.name</code>先去找构造函数找对应 <code>name</code> 属性，没有找到，然后就去原型对象上去找，找到对应<code>name</code>值为 <code>Benz</code>，赋值。继续往下走，发现有对原型对象重定义的操作，但是此时实例对象早就通过原本构造函数 <code>new</code>出来了。（简单来说，就是再定义了一个 <code>prototype</code>，但是没有实例化）</p></div></div><p>可能不太好理解上述表达，我们对上述代码修改一丢丢，看看又会打印什么？</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Car.prototype.name = <span class="string">&#x27;Benz&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Car</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">Car.prototype = &#123;</span><br><span class="line">  name: <span class="string">&#x27;Math&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> car = <span class="keyword">new</span> Car();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(car.name);</span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>答案是 <code>Math</code>，因为你此时重新定义了构造函数的 <code>prototype</code>，并且进行了实例化。</p><p>可能你会想到这个例子，这里只是更改了属性，并不是<strong>重写</strong>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Car</span>(<span class="params"></span>) </span>&#123; &#125;;</span><br><span class="line">Car.prototype.name = <span class="string">&#x27;Math&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> car = <span class="keyword">new</span> Car();</span><br><span class="line">Car.prototype.name = <span class="string">&#x27;Benz&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(car.name);</span><br></pre></td></tr></table></figure></div></div><h2 id="原型链基础"><a href="#原型链基础" class="headerlink" title="原型链基础"></a>原型链基础</h2><p>下面我们就要开始讲解原型链相关了，直接看下面这个例子吧：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Professor.prototype.tSkill = <span class="string">&#x27;Java&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Professor</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> progessor = <span class="keyword">new</span> Professor();</span><br><span class="line"></span><br><span class="line">Teacher.prototype = progessor;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Teacher</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.mSkill = <span class="string">&#x27;js&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> teacher = <span class="keyword">new</span> Teacher();</span><br><span class="line"></span><br><span class="line">Student.prototype = teacher;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.pSkill = <span class="string">&#x27;html&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> student = <span class="keyword">new</span> Student();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(student);</span><br></pre></td></tr></table></figure><p>原型链就是像如下例子，沿着 <code>__protp__</code>这条线往上找相应的原型的属性值的链条，这就是原型链。<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200917133029232.png#pic_center" alt=""></p><p>补充，原型本身也有原型，但是原型链不可能一直链接，因此，会有一个顶端。<strong>原型链的顶端</strong>是 <code>Object.prototype</code>。因为<code>Object</code>也是有原型的。并且 <code>Object.prototype</code>保存了一个 <code>toString()</code>方法。</p><p>继续，我们对上述代码进行一点修改，然后我们修改<code>student</code>实例对象里面的属性值，看是否<code>teacher</code>实例对象也会发生变化？</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Professor.prototype.tSkill = <span class="string">&#x27;Java&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Professor</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> progessor = <span class="keyword">new</span> Professor();</span><br><span class="line"></span><br><span class="line">Teacher.prototype = progessor;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Teacher</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.mSkill = <span class="string">&#x27;js&#x27;</span>;</span><br><span class="line">  <span class="built_in">this</span>.success = &#123;</span><br><span class="line">    alibaba: <span class="string">&#x27;28&#x27;</span>,</span><br><span class="line">    tencent: <span class="string">&#x27;30&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> teacher = <span class="keyword">new</span> Teacher();</span><br><span class="line"></span><br><span class="line">Student.prototype = teacher;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.pSkill = <span class="string">&#x27;html&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> student = <span class="keyword">new</span> Student();</span><br><span class="line">student.success.baidu = <span class="string">&#x27;100&#x27;</span>;</span><br><span class="line">student.success.tencent = <span class="string">&#x27;50&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(teacher,student);</span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>结果：<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200917134826341.png#pic_center" alt=""></p></div></div><p>上述问题明白之后，我们再来看看下面这道题，看看又会有什么变化？</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Professor.prototype.tSkill = <span class="string">&#x27;Java&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Professor</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> progessor = <span class="keyword">new</span> Professor();</span><br><span class="line"></span><br><span class="line">Teacher.prototype = progessor;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Teacher</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.mSkill = <span class="string">&#x27;js&#x27;</span>;</span><br><span class="line">  <span class="built_in">this</span>.students = <span class="number">500</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> teacher = <span class="keyword">new</span> Teacher();</span><br><span class="line"></span><br><span class="line">Student.prototype = teacher;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.pSkill = <span class="string">&#x27;html&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> student = <span class="keyword">new</span> Student();</span><br><span class="line"><span class="built_in">console</span>.log(student.students);</span><br><span class="line">student.students++;</span><br><span class="line"><span class="built_in">console</span>.log(student, teacher);</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200917135155936.png#pic_center" alt=""><br>从结果我们发现，只有 <code>student</code>实例对象底下的 <code>students</code>变成了 <code>501</code>，而 <code>teacher</code> 实例对象下面的 <code>students</code>没有变化。因为对于原始值而言， <code>student</code>对象底下没有 <code>students</code>这个属性，于是就会创建一个，然后自加。上一题是拿到了引用地址，于是可以修改，这道题意思和如下代码类似：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">name: <span class="string">&#x27;Chocolate&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">obj.age = <span class="number">21</span>; <span class="comment">// obj没有age属性，于是创建一个。</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.age); </span><br></pre></td></tr></table></figure><p><strong>注意</strong>，一般不推荐按照如上两种方式修改原型对象上的属性值，后文会详细介绍继承的方式，这里只是抛砖引玉。</p><p>继续，看下一题，一道经典的笔试题：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Car</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.brand = <span class="string">&#x27;Benz&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">Car.prototype = &#123;</span><br><span class="line">  brand: <span class="string">&#x27;Mazda&#x27;</span>,</span><br><span class="line">  intro: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;我是&#x27;</span> + <span class="built_in">this</span>.brand + <span class="string">&#x27;车&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> car = <span class="keyword">new</span> Car();</span><br><span class="line">car.intro();</span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>答案是 <code>我是Benz车</code>，首先<code>new</code>出来一个实例对象，然后访问实例的 <code>intro()</code>方法，发现没找到，于是会沿着原型链往上找，发现存在，然后打印。关键是 <code>this.brand</code>，因为 <code>this</code>会指向这个实例，实例访问的话，会首先访问由对应构造函数实例出来的对象，发现存在，直接打印。</p></div></div><h2 id="Object-creat-基础"><a href="#Object-creat-基础" class="headerlink" title="Object.creat()基础"></a>Object.creat()基础</h2><p>之前了解到了 <code>Object</code>，现在我们探讨一下底下的一个方法 <code>create()</code>，它仍然可以创建对象，但是和普通创建对象又不太一样。下面来简单分析一下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Obeject.create(xxx); <span class="comment">// xxx处可以指定自定义原型或者填写null</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Obj</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Obj.prototype.num = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> obj1 = <span class="built_in">Object</span>.create(Obj.prototype);</span><br><span class="line"><span class="built_in">console</span>.log(obj1);</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200917152437239.png#pic_center" alt=""></p><p>打印出来，此时实例原型的<code>constructor</code>指向这个 <code>Obj()</code>。好的，那我们看看用 <code>new</code>出来的实例对象，有没有什么区别？</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Obj</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Obj.prototype.num = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> obj1 = <span class="built_in">Object</span>.create(Obj.prototype);</span><br><span class="line"><span class="keyword">var</span> obj2 = <span class="keyword">new</span> Obj();</span><br><span class="line"><span class="built_in">console</span>.log(obj1);</span><br><span class="line"><span class="built_in">console</span>.log(obj2);</span><br></pre></td></tr></table></figure><p>看看下面结果，发现其实没啥区别，因为都是根据<code>Obj</code>的原型创建出来的。<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/2020091715275519.png#pic_center" alt=""><br>继续，看看下面这种情况：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj1);</span><br></pre></td></tr></table></figure><p>通过<code>Object.create(null)</code>创建出来的对象，里面啥也没有，这里也就说明了一个点，虽然原型链的顶端是<code>Object.prototype</code>，但是这个<strong>特殊的空对象</strong>并没有原型，它不会继承于 <code>Object.prototype</code>，因此，不是所有的对象都继承于 <code>Object.prototype</code>。<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200917153448775.png#pic_center" alt=""><br><strong>注意</strong>，我们没办法自造 <code>__proto__</code>，创建了之后只是相当于属性值一样，实例对象是没有办法调用原型对象上的方法的。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">obj.num = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">  count: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">obj.__proto__ = obj1;</span><br><span class="line"><span class="built_in">console</span>.log(obj);</span><br><span class="line"><span class="built_in">console</span>.log(obj1);</span><br></pre></td></tr></table></figure><p>看下面这张图，有咩有发现什么不同，对于我们自造的 <code>__proto__</code>颜色更深有没有？<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200917154413755.png#pic_center" alt=""><br>现在探究一下自己造的 <code>__proto__</code>能不能访问到原型对象上的东西。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">obj.num = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">  count: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">obj.__proto__ = obj1;</span><br><span class="line"><span class="built_in">console</span>.log(obj.count);</span><br></pre></td></tr></table></figure><p>结果是 <code>undefined</code>，显然没有办法访问，也就证明我们没办法自造 <code>__proto__</code>。</p><p>好的，上文都是创建了一些对象，下文我们探讨一下特殊例子，比如<code>null</code>和 <code>undefined</code>。</p><p>上文有一个结论，我们发现除开空对象外都能继承<code>Object.prototype</code>，然后访问其中一个方法 <code>toString()</code>，那么<code>null</code>和 <code>undefined</code>可以吗？我们测试一下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="literal">null</span>.toString()); <span class="comment">// TypeError: Cannot read property &#x27;toString&#x27; of null</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">undefined</span>.toString()); <span class="comment">// TypeError: Cannot read property &#x27;toString&#x27; of undefined</span></span><br></pre></td></tr></table></figure><p>那么，为啥下面这个代码会输出 <code>1</code>呢？</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(num.toString()); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>在解释之前，我们再来回顾一下知识点：</p><p>原始值是没有属性的，为啥能调用 <code>toString()</code>方法，就是本文目录第三块讲解的<strong>包装类的概念</strong>了。</p><p>它的工作过程如下：</p><p>首先 <code>new Number(1)</code>，然后再调用<code>toString()</code>方法，因此之前<code>new</code>了一下成为了对象。为了更加准确，我们打印一下看看。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(num.toString());</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> num2 = <span class="keyword">new</span> <span class="built_in">Number</span>(num);</span><br><span class="line"><span class="built_in">console</span>.log(num2);</span><br></pre></td></tr></table></figure><p>发现<code>new</code>了之后，在 <code>__proto__</code>里面确实找到了 <code>toString()</code>方法。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200917155337583.png#pic_center" alt=""></p><p>回到开头，<code>null</code>和 <code>undefined</code>为啥不可以呢？就是因为上文提过<code>null</code>和 <code>undefined</code>没办法进行包装。始终为原始值，并且没有原型，也没办法继承。</p><p>下面我们探讨一下隐式转换性和继承相关问题，代码如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line"><span class="built_in">document</span>.write(num);</span><br><span class="line"><span class="built_in">document</span>.write(obj);</span><br><span class="line"><span class="built_in">document</span>.write(obj2);</span><br></pre></td></tr></table></figure><p>然后我们发现最后一个打印有了报错：<strong>不能转换为原始值</strong>，这是因为啊，<code>obj2</code>创建的空对象没有继承<code>Object.prototype</code>，因此也就没有对应 <code>toString()</code>方法。当然不能转换了。（<code>document.write()</code>方法转换为字符串）<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200917155907103.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70#pic_center" alt=""></p><h2 id="call-apply"><a href="#call-apply" class="headerlink" title="call / apply"></a>call / apply</h2><p>面试必备的知识点 <code>call / apply</code>，现在好好探究一下。</p><p>先来热热身，看如下样例：会输出什么？</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Car</span>(<span class="params">brand,color</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.brand = brand;</span><br><span class="line">  <span class="built_in">this</span>.color = color;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> newCar = &#123;&#125;;</span><br><span class="line">Car.call(newCar,<span class="string">&#x27;Benz&#x27;</span>,<span class="string">&#x27;red&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(newCar);</span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>答案是 <code>{ brand: &#39;Benz&#39;, color: &#39;red&#39; }</code>，发现没有，这里将 <code>this</code>指向改变了。</p><p>而 <code>apply</code>的使用如下，打印结果和上题一样，也是将 <code>this</code>指向改变了。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Car</span>(<span class="params">brand,color</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.brand = brand;</span><br><span class="line">  <span class="built_in">this</span>.color = color;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> newCar = &#123;&#125;;</span><br><span class="line">Car.apply(newCar,[<span class="string">&#x27;Benz&#x27;</span>,<span class="string">&#x27;red&#x27;</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(newCar);</span><br></pre></td></tr></table></figure></div></div><h2 id="链式调用基础"><a href="#链式调用基础" class="headerlink" title="链式调用基础"></a>链式调用基础</h2><p>给出如下代码，你如何进行修改，让最后一行代码都能执行呢？</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sched = &#123;</span><br><span class="line">  wakeup: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Running&#x27;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  work: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Wordking&#x27;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  end: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Ending&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">sched.wakeup().work().end();</span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>答案如下：</p><p>函数每次返回 <code>this</code>，这种做法类似于 <code>Jquery</code>里面的链式调用。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sched = &#123;</span><br><span class="line">  wakeup: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Running&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  work: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Wordking&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  end: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Ending&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">sched.wakeup().work().end();</span><br></pre></td></tr></table></figure></div></div><p>继续，看下面代码，补充一个知识点：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myLang = &#123;</span><br><span class="line">  No1: <span class="string">&#x27;HTML&#x27;</span>,</span><br><span class="line">  No2: <span class="string">&#x27;CSS&#x27;</span>,</span><br><span class="line">  No3: <span class="string">&#x27;JS&#x27;</span>,</span><br><span class="line">  myStudying: <span class="function"><span class="keyword">function</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>[<span class="string">&#x27;No&#x27;</span>+num]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">myLang.myStudying(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>答案是 <code>HTML</code>，显而易见，主要是说明如下知识点，在早起<code>JS</code>引擎就是这样访问对象属性的，通过 <code>obj[name]</code>中括号形式访问，现在继承了 <code>obj.name</code>的形式，但是最终解释时还是会转换成 <code>obj[name]</code>的形式。</p></div></div><h2 id="对象枚举"><a href="#对象枚举" class="headerlink" title="对象枚举"></a>对象枚举</h2><p>开门见山，我们直接来一道题，看看下面两种方式打印有区别吗？还是都可以打印？</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> car = &#123;</span><br><span class="line">  brand: <span class="string">&#x27;Benz&#x27;</span>,</span><br><span class="line">  color: <span class="string">&#x27;red&#x27;</span>,</span><br><span class="line">  displacement: <span class="string">&#x27;3.0&#x27;</span>,</span><br><span class="line">  lang: <span class="string">&#x27;5&#x27;</span>,</span><br><span class="line">  width: <span class="string">&#x27;2.5&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> car)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(car.key);</span><br><span class="line">  <span class="built_in">console</span>.log(car[key]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>答案是 <code>car.key</code>没有办法访问属性值，返回的都是 <code>undefined</code>，而<code>car[key]</code>可以。因为当我们访问 <code>cay.key</code>时，<code>JS</code>引擎会这样做：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">car.key -&gt; car[<span class="string">&#x27;key&#x27;</span>] -&gt; <span class="literal">undefined</span></span><br></pre></td></tr></table></figure></div></div><p>下面，我们来探究一下 <code>hasOwnProperty</code>这个方法。</p><p>在讲解方法之前，先来看看如下代码，会输出什么？</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Car</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.brand = <span class="string">&#x27;Benz&#x27;</span>;</span><br><span class="line">  <span class="built_in">this</span>.color = <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line">  <span class="built_in">this</span>.displacement = <span class="string">&#x27;3.0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Car.prototype = &#123;</span><br><span class="line">  lang: <span class="number">5</span>,</span><br><span class="line">  width: <span class="number">2.5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.prototype.name = <span class="string">&#x27;Object&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> car = <span class="keyword">new</span> Car();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> car)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key + <span class="string">&#x27;:&#x27;</span> + car[key]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>答案如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">brand:Benz</span><br><span class="line">color:red</span><br><span class="line">displacement:<span class="number">3.0</span></span><br><span class="line">lang:<span class="number">5</span></span><br><span class="line">width:<span class="number">2.5</span></span><br><span class="line">name:<span class="built_in">Object</span></span><br></pre></td></tr></table></figure><p>诶，我们发现了一个问题，当我们访问<code>car</code>实例对象的时候，原型链上所有的属性我们都访问出来了。那么我想要打印自己构造函数里面的属性值而不要原型链上的该怎么做呢？于是就印出来 <code>hasOwnProperty</code>。</p></div></div><p>现在修改一下代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Car</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.brand = <span class="string">&#x27;Benz&#x27;</span>;</span><br><span class="line">  <span class="built_in">this</span>.color = <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line">  <span class="built_in">this</span>.displacement = <span class="string">&#x27;3.0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Car.prototype = &#123;</span><br><span class="line">  lang: <span class="number">5</span>,</span><br><span class="line">  width: <span class="number">2.5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.prototype.name = <span class="string">&#x27;Object&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> car = <span class="keyword">new</span> Car();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> car) &#123;</span><br><span class="line">  <span class="keyword">if</span> (car.hasOwnProperty(key)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key + <span class="string">&#x27;:&#x27;</span> + car[key]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>此时打印结果如下，发现只打印自己构造函数里面的属性值，<strong>没有打印原型链上的</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">brand:Benz</span><br><span class="line">color:red</span><br><span class="line">displacement:<span class="number">3.0</span></span><br></pre></td></tr></table></figure></div></div><p>接下来，我们再来探究另外一个重要的东西，<code>instanceof</code>。</p><p>开门见山，还是以例题来热身：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Car</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> car = <span class="keyword">new</span> Car();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(car <span class="keyword">instanceof</span> Car);</span><br><span class="line"><span class="built_in">console</span>.log(car <span class="keyword">instanceof</span> <span class="built_in">Object</span>);</span><br><span class="line"><span class="built_in">console</span>.log([] <span class="keyword">instanceof</span> <span class="built_in">Array</span>);</span><br><span class="line"><span class="built_in">console</span>.log([] <span class="keyword">instanceof</span> <span class="built_in">Object</span>);</span><br><span class="line"><span class="built_in">console</span>.log(&#123;&#125; <span class="keyword">instanceof</span> <span class="built_in">Object</span>);</span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>答案是全为<code>true</code>，解释一下，<code>A instanceof B</code>，就是用来判断 <code>A</code>对象原型里面有没有 <code>B</code>的原型。也就是原型链上重合的都为 <code>true</code>。</p></div></div><h2 id="this指向"><a href="#this指向" class="headerlink" title="this指向"></a>this指向</h2><p>接下来，又是一个重点，我们探究一下 <code>this</code>指向问题。</p><p>开门见山，我们还是来一道简单题热热身，看看下面会有输出吗？会输出什么？</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">b</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.d = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">test(<span class="number">123</span>);</span><br><span class="line"><span class="built_in">console</span>.log(d);</span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>答案是 <code>3</code>，对于函数内部的<code>this</code>，如果没有进行实例化操作，<code>this</code>会指向 <code>window</code>。外部也可以访问。</p><p>总结归纳一下：</p><ul><li>全局 <code>this</code> 指向 <code>window</code></li><li>预编译函数 <code>this</code> 指向 <code>window</code></li><li><code>apply / call</code> 改变 <code>this</code> 指向</li><li>构造函数的 <code>this</code> 指向实例化的对象</li></ul></div></div><p>接下来，介绍一个平常容易忽视但确实用的比较少的知识：<code>callee / caller</code>的区别。</p><p>直接看下面例题，看会打印什么？</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">a,b,c</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.callee.length);</span><br><span class="line">&#125;</span><br><span class="line">test(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>答案： <code>3</code>，解释一下，<code>arguments.callee</code>会返回实参列表所对应的函数（即 <code>test</code>），然后执行 <code>test.length</code>（即形参的个数 <code>3</code>）。</p></div></div><p>那 <code>callee</code> 还有什么用呢，例如下述代码，在匿名自执行函里面，我们得不到对应函数名，而使用 <code>callee</code>可以用作递归，获取 <code>arguments</code>对应的函数来递归执行。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = (<span class="function"><span class="keyword">function</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(n&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> n + <span class="built_in">arguments</span>.callee(n-<span class="number">1</span>);</span><br><span class="line">&#125;)(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">console</span>.log(sum); <span class="comment">// 55</span></span><br></pre></td></tr></table></figure><p>下面讲解一下 <code>caller</code>，这个更少见，并且严格模式下还会报错，小伙伴们了解一下即可。</p><p>直接看下面例子，看会打印什么：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">test1();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  test2();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(test2.caller);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>答案是 <code>[Function: test1]</code>，解释一下， <code>test2.caller</code>结果就是谁执行了 <code>test2</code>，就会打印对应的那个函数。</p></div></div><h2 id="真题演练"><a href="#真题演练" class="headerlink" title="真题演练"></a>真题演练</h2><p>不知不觉，又总结了许多知识。下面我们好好练一练真题，巩固一下。</p><h3 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h3><p>首先，依旧是热热身，看看会输出什么？</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  bar.apply(<span class="literal">null</span>, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>答案如下：<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200917194307761.png#pic_center" alt=""><br>这里就相当于在 <code>foo</code> 函数里面执行了 <code>bar</code>，然后给它传了参数。<code>this</code>指向在<code>bar</code>函数里面没有使用，传<code>null</code>值也不影响。</p></div></div><h3 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h3><p><code>JS</code> 中 <code>typeof</code> 可能返回的值有哪些？</p><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>答案如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">number string <span class="literal">undefined</span> object <span class="function"><span class="keyword">function</span> <span class="title">boolean</span> </span></span><br></pre></td></tr></table></figure></div></div><h3 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h3><p>看看下面会输出什么？</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params">x,y,a</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">arguments</span>[<span class="number">2</span>] = <span class="number">10</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line">b(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>答案是 <code>10</code>，实参和形参映射关系，如果有映射，那么我们可以修改实参。</p></div></div><p>那么我们稍微修改一下上述代码，又会是怎样的结果呢？</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params">x,y,a</span>)</span>&#123;</span><br><span class="line">  a = <span class="number">10</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line">b(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>答案还是<code>10</code>，与上题思路一样，不作解释了。</p></div></div><p>继续，下面这道题之前有出过，再来温习一下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f = (</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">g</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> f);</span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>答案是 <code>function</code>，有没有和我一样以为是 <code>number</code>的小伙伴，还是不能太自信，粗心了。简单解释一下，对于括号表达式里面，以逗号分隔的话，会返回最后一个。</p></div></div><p>那么我把上述代码稍作修改一下，又会输出什么呢？</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f = (</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">g</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">)()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> f);</span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>答案显然是 <code>number</code>，因为执行了，不作过多解释了。</p></div></div><h3 id="第四题"><a href="#第四题" class="headerlink" title="第四题"></a>第四题</h3><p>下面打印<code>true</code>的是哪些？（序号以 <code>1</code>开头）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="literal">undefined</span> == <span class="literal">null</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">undefined</span> === <span class="literal">null</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="string">&#x27;100&#x27;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">&#x27;1a&#x27;</span>) == <span class="number">1</span>);</span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>答案是 <code>1 4</code>，这里只解释一下 <code>parseInt</code>，它只会去从左到右的数字，一遇到非数就截止了。</p></div></div><p>可能这几个隐式转换不算很难，下面再来几个，继续，加油！</p><p>这个又会输出什么呢？</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(&#123;&#125; == &#123;&#125;);</span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>答案是 <code>false</code>，因为引用值对应的是地址，地址不同，肯定不等。怎么让两个空对象相等呢，可以按照如下方式做：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> obj1 = obj;</span><br><span class="line"><span class="built_in">console</span>.log(obj == obj1); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></div></div><p>看一道输出题吧：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">  <span class="built_in">this</span>.a = <span class="string">&#x27;3&#x27;</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line">test();</span><br><span class="line"><span class="keyword">new</span> test();</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>答案是 <code>2 2 3</code>。 </p></div></div><p>提升一下，最后一题：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  a = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">  <span class="keyword">var</span> a;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line">test(); </span><br><span class="line"><span class="keyword">new</span> test(); </span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>答案如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">test(); <span class="comment">// 0 5 0</span></span><br><span class="line"><span class="keyword">new</span> test(); <span class="comment">// 0 undefined 0 </span></span><br></pre></td></tr></table></figure><p>简单解释一下，先给出 <code>AO</code> 和 <code>GO</code>吧。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Go = &#123;</span><br><span class="line">  a: <span class="literal">undefined</span> -&gt; <span class="number">5</span>,</span><br><span class="line">  test: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line">AO = &#123;</span><br><span class="line">  a: <span class="literal">undefined</span> -&gt; <span class="number">0</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里只解释为啥第二个中间打印 <code>undefined</code>，因为它 <code>new</code> 出来的实例，<code>this</code> 当然指向它，但是 <code>this</code> 上面没有 <code>a</code> 这个属性，所以打印 <code>undefined</code>。</p></div></div>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「JavaScript灵魂之问」前端知识梳理之 JS 篇（中秋特别篇）</title>
      <link href="posts/2020922/"/>
      <url>posts/2020922/</url>
      
        <content type="html"><![CDATA[<h2 id="JS-错误信息类型"><a href="#JS-错误信息类型" class="headerlink" title="JS 错误信息类型"></a>JS 错误信息类型</h2><h3 id="语法错误"><a href="#语法错误" class="headerlink" title="语法错误"></a>语法错误</h3><p>1、SyntaxError 语法错误</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 变量名不规范</span></span><br><span class="line"><span class="keyword">var</span> <span class="number">1</span> = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><code>SyntaxError: Unexpected number</code> 意外的数字</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> 1ab = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><code>SyntaxError: Invalid or unexpected token</code>  其中<code>token</code>指代标记的意思。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 关键字不可赋值</span></span><br><span class="line"><span class="keyword">new</span> = <span class="number">5</span>;</span><br></pre></td></tr></table></figure><p><code>SyntaxError: Unexpected token &#39;=&#39;</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基本语法错误</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">5</span>:</span><br></pre></td></tr></table></figure><p><code>SyntaxError: Unexpected token &#39;:&#39;</code></p><h3 id="引用错误"><a href="#引用错误" class="headerlink" title="引用错误"></a>引用错误</h3><p>2、ReferenceError 引用错误、</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 变量或函数未被声明</span></span><br><span class="line">test();</span><br></pre></td></tr></table></figure><p><code>ReferenceError: test is not defined</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a);</span><br></pre></td></tr></table></figure><p><code>ReferenceError: a is not defined</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 给无法被赋值的对象赋值的时候</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span> = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p><code>SyntaxError: Invalid left-hand side in assignment</code></p><h3 id="范围错误"><a href="#范围错误" class="headerlink" title="范围错误"></a>范围错误</h3><p>3、RangeError 范围错误</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组长度赋值为负数</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr.length = -<span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br></pre></td></tr></table></figure><p><code>RangeError: Invalid array length</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对象方法参数超出范围</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">66.66</span>);</span><br><span class="line"><span class="built_in">console</span>.log(num.toFixed(-<span class="number">1</span>));</span><br></pre></td></tr></table></figure><p><code>RangeError: toFixed() digits argument must be between 0 and 100</code></p><h3 id="类型错误"><a href="#类型错误" class="headerlink" title="类型错误"></a>类型错误</h3><p>4、TypeError 类型错误</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 调用不存在的方法</span></span><br><span class="line"><span class="number">123</span>();</span><br></pre></td></tr></table></figure><p><code>TypeError: 123 is not a function</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">obj.say();</span><br></pre></td></tr></table></figure><p><code>TypeError: obj.say is not a function</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实例化原始值</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="string">&#x27;string&#x27;</span>;</span><br></pre></td></tr></table></figure><p><code>TypeError: &quot;string&quot; is not a constructor</code></p><h3 id="URI-错误"><a href="#URI-错误" class="headerlink" title="URI 错误"></a>URI 错误</h3><p>5、URIError URI错误</p><p><code>URI</code>： uniform resource identifier （统一资源标识符）</p><p><code>URL</code>：uniform resource locator（统一资源定位符）</p><p><code>URN</code>：uniform resource name（统一资源名称）</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200919111617211.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70#pic_center" alt=""></p><h3 id="eval-函数执行错误"><a href="#eval-函数执行错误" class="headerlink" title="eval 函数执行错误"></a>eval 函数执行错误</h3><p>6、EvalError eval函数执行错误</p><p>这个就了解一下好了，在 <code>es3</code>就不建议使用了。它的性能不太好，也不好调试，同时可能会引起安全性问题<code>xss</code>攻击（例如 <code>eval</code> 和输入框 <code>input</code>值相绑定时容易引起 <code>xss</code> 安全性问题 ），另外，可读性也不太好（在字符串中执行）。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="string">&#x27;var a=1; console.log(a);&#x27;</span>);</span><br></pre></td></tr></table></figure><p>输出结果为 <code>1</code>。</p><p>它神奇的地方在于，它可以将 <code>json</code>数据转换成对象。<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200919141022375.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70#pic_center" alt=""></p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/2020091914103021.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70#pic_center" alt=""></p><h2 id="try-catch"><a href="#try-catch" class="headerlink" title="try / catch"></a>try / catch</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;正常执行1&#x27;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;正常执行2&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error.name + <span class="string">&#x27;:&#x27;</span> + error.message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">正常执行<span class="number">1</span></span><br><span class="line"><span class="built_in">ReferenceError</span>:a is not defined</span><br></pre></td></tr></table></figure><h2 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h2><p>从 <code>ES5</code>开始有了两种模式，一种是<strong>严格模式</strong>，一种是<strong>正常模式</strong>。<code>IE9及以下不支持严格模式</code>。</p><p><code>&#39;use strict&#39;;</code> 为什么要设置字符串，是因为字符串相当于表达式，在浏览器不会报错。并且书写的位置必须在最上面一行。</p><p>补充知识点：<code>with()</code>语法就是括号里面填入哪个对象，就会找到对应作用域，也就是作用域链会被改变（严格模式下不能使用）</p><p>另外，<code>arguments</code>下大部分属性严格模式不能使用，例如之前提到的 <code>callee / caller</code>，但是 <code>arguments</code>可以使用。</p><p>其次，严格模式下这种代码也会报错，说 <code>b</code>没有声明：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> a = b = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>那我们看看下面会输出什么，是 <code>1</code>嘛？</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">test.call(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>结果如下，会打印包装类 <code>Number</code>，因为 <code>this</code>会指向对象，所以会进行一次包装。而在严格模式下就会输出 <code>1</code>。<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200919143401520.png#pic_center" alt=""></p></div></div><p>继续，再看看这份代码在 <code>es5</code>严格模式下会输出什么？</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  a: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj.a);</span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>答案是 <code>2</code>，这个比较特殊，严格模式下不报错。</p></div></div><p>补充：在 <code>es5</code>严格模式下，<strong>函数的参数名不能重复</strong>。</p><p>继续，再看看这份代码在 <code>es5</code>严格模式下会输出什么？</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="built_in">eval</span>(<span class="string">&#x27;var a=1; console.log(a);&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>答案是 <code>1 报错</code>，因为严格模式下 <code>eval</code>有自己独立作用域，不会将 <code>var a</code> 放入全局使用了。</p></div></div><h2 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h2><p>垃圾回收机制就是负责管理代码执行过程中使用的内存。</p><p>原理：</p><p>第一步，找出不再使用的变量<br>第二步，释放其占用内存<br>第三部，固定的时间间隔运行</p><h2 id="重新探究-this-指向问题"><a href="#重新探究-this-指向问题" class="headerlink" title="重新探究 this 指向问题"></a>重新探究 this 指向问题</h2><h3 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h3><p>开门见山，我们来看看下面会打印什么？</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.a = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line">test();</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>答案是 <code>window 1 1</code>，不难发现，这个 <code>this</code>是指向 <code>window</code>的。</p></div></div><h3 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h3><p>继续，看看下面代码又会输出什么？</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line">test();</span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>答案是 <code>window 1</code>，和上题类似。</p></div></div><h3 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h3><p>继续，又会有怎样的输出呢？</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.a = a;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">window</span>.a);</span><br><span class="line">&#125;</span><br><span class="line">test(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>答案是 <code>1 1</code></p></div></div><h3 id="第四题"><a href="#第四题" class="headerlink" title="第四题"></a>第四题</h3><p>稍微改一下上面代码，又会输出什么呢？</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.a = a;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">window</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> test(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>答案是 <code>1 undefined</code>，因为 <code>window</code>底下并没有 <code>a</code>这个变量。</p></div></div><h3 id="第五题"><a href="#第五题" class="headerlink" title="第五题"></a>第五题</h3><p>接下来，我们再来看看这道题，会打印什么呢？</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.a = a;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">223</span>;</span><br><span class="line">test.prototype.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line">test.prototype.say();</span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>答案是 <code>undefiend</code>，是不是很惊讶？为什么呢？我明明都访问了原型上的<code>say</code>方法，而且全局都有 <code>a</code>变量，为啥呢？</p><p>我们不妨打印一下 <code>this</code>，看指向谁。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.a = a;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">223</span>;</span><br><span class="line">test.prototype.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">test.prototype.say();</span><br></pre></td></tr></table></figure><p>然后发现在原型上打印  <code>this</code>，发现指向的是那个函数，而函数如果没有返回值的话，默认会返回 <code>undefined</code>，当然<code>.a</code>也会打印 <code>undefined</code>。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200919153537445.png#pic_center" alt=""></p></div></div><h3 id="第六题"><a href="#第六题" class="headerlink" title="第六题"></a>第六题</h3><p>于是我们修改一下代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.a = a;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">223</span>;</span><br><span class="line">test.prototype.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line">test.prototype.say();</span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>答案是 <code>223</code>。</p></div></div><h3 id="第七题"><a href="#第七题" class="headerlink" title="第七题"></a>第七题</h3><p>因此在函数没有实例化的时候，原型上 <code>say</code>方法 <code>this</code>还是会指向那个函数。那么我们再次修改一下，看看下面代码会输出什么</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.a = a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">223</span>;</span><br><span class="line">test.prototype.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> t = <span class="keyword">new</span> test(<span class="number">1</span>);</span><br><span class="line">t.say();</span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>答案是 <code>1</code>，实例化了之后，原型上 <code>say</code>方法的 <code>this</code> 指向了实例对象。</p></div></div><h2 id="defineProperty"><a href="#defineProperty" class="headerlink" title="defineProperty"></a>defineProperty</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineProperty</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> _obj = &#123;&#125;;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(_obj,<span class="string">&#x27;a&#x27;</span>,&#123;</span><br><span class="line">    value: <span class="number">1</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> _obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = defineProperty();</span><br><span class="line"><span class="built_in">console</span>.log(obj);</span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>结果如下，它可以对一个对象赋予对应属性。并且<strong>该对象原本就是空的</strong>。<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200919170958163.png#pic_center" alt=""></p></div></div><h3 id="defineProperties"><a href="#defineProperties" class="headerlink" title="defineProperties"></a>defineProperties</h3><p>上述方式与我们直接通过 <code>.</code> 给对象赋值类似，那么怎么一下赋予多个属性呢，看如下代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineProperty</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> _obj = &#123;&#125;;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperties(_obj,&#123;</span><br><span class="line">    a: &#123;</span><br><span class="line">      value: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    b: &#123;</span><br><span class="line">      value: <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> _obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = defineProperty();</span><br><span class="line"><span class="built_in">console</span>.log(obj);</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/2020091917111749.png#pic_center" alt=""><br>有了前置知识后，我们继续修改一下上述代码，看看又会有怎样的变化：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineProperty</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> _obj = &#123;&#125;;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperties(_obj,&#123;</span><br><span class="line">    a: &#123;</span><br><span class="line">      value: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    b: &#123;</span><br><span class="line">      value: <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> _obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = defineProperty();</span><br><span class="line">obj.a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> k <span class="keyword">in</span> obj)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(k + <span class="string">&#x27;:&#x27;</span> + obj[k]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> obj.a;</span><br><span class="line"><span class="built_in">console</span>.log(obj);</span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>结果如下：<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/2020091917134747.png#pic_center" alt=""></p><p>我们发现得到的 <code>obj</code> 属性值不可改变，属性也不可以枚举，并且属性也不可以被删除。</p><p>因此，总结一下，通过 <code>Object.defineProperty</code> 配置的对象默认<strong>不可修改，不可枚举，不可删除</strong>。</p><p>对于默认值，我们当然可以进行修改，查看下面代码注释处：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineProperty</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> _obj = &#123;&#125;;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperties(_obj,&#123;</span><br><span class="line">    a: &#123;</span><br><span class="line">      value: <span class="number">1</span>,</span><br><span class="line">      writable: <span class="literal">true</span>, <span class="comment">// 配置是否可修改</span></span><br><span class="line">      enumerable: <span class="literal">true</span>, <span class="comment">// 配置是否可以枚举</span></span><br><span class="line">      configurable: <span class="literal">true</span> <span class="comment">// 配置是否可以删除</span></span><br><span class="line">    &#125;,</span><br><span class="line">    b: &#123;</span><br><span class="line">      value: <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> _obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = defineProperty();</span><br><span class="line">obj.a = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> k <span class="keyword">in</span> obj)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(k + <span class="string">&#x27;:&#x27;</span> + obj[k]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> obj.a;</span><br><span class="line"><span class="built_in">console</span>.log(obj);</span><br></pre></td></tr></table></figure><p>结果如下：<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200919171842523.png#pic_center" alt=""></p></div></div><h3 id="数据劫持引入"><a href="#数据劫持引入" class="headerlink" title="数据劫持引入"></a>数据劫持引入</h3><p>看这标题，是不是突然觉得高大上了，但实则不是，那我们看一下下面代码会输出什么吧：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineProperty</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> _obj = &#123;&#125;;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperties(_obj,&#123;</span><br><span class="line">    a: &#123;</span><br><span class="line">      <span class="function"><span class="title">get</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;the value of a is &#x27;</span> + a;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="function"><span class="title">set</span>(<span class="params">newVal</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;the set value is&#x27;</span> + newVal);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    b: &#123;</span><br><span class="line">      value: <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> _obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = defineProperty();</span><br><span class="line"><span class="built_in">console</span>.log(obj.a);</span><br><span class="line">obj.a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>结果如下：<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200919183610311.png#pic_center" alt=""><br>从上述结果我们可以总结归纳数据劫持的要点：</p><p>数据劫持，无非就是对待一个对象它的取值（<code>get</code>）和设置值（<code>set</code>）有一系列的<strong>配置和阻止</strong>的方法，这就是对一组数据属性的劫持。（即阻拦正常的输入输出）</p></div></div><h3 id="对数组进行操作"><a href="#对数组进行操作" class="headerlink" title="对数组进行操作"></a>对数组进行操作</h3><p>我想你们应该都知道，<code>defineProperty</code>没办法对数组进行劫持。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">DataArr</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> _val = <span class="literal">null</span>,</span><br><span class="line">      _arr = [];</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(<span class="built_in">this</span>,<span class="string">&#x27;val&#x27;</span>,&#123;</span><br><span class="line">    get:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> _val;</span><br><span class="line">    &#125;,</span><br><span class="line">    set:<span class="function"><span class="keyword">function</span>(<span class="params">newVal</span>)</span>&#123;</span><br><span class="line">      _val = newVal;</span><br><span class="line">      _arr.push(&#123;<span class="attr">val</span>: _val&#125;);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;A new value &#x27;</span> + _val + <span class="string">&#x27; hash been pushed to _arr&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="built_in">this</span>.getArr = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _arr;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> dataArr = <span class="keyword">new</span> DataArr();</span><br><span class="line">dataArr.val = <span class="number">123</span>;</span><br><span class="line">dataArr.val = <span class="number">234</span>;</span><br><span class="line"><span class="built_in">console</span>.log(dataArr.getArr());</span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>打印结果如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">A <span class="keyword">new</span> value <span class="number">123</span> hash been pushed to _arr</span><br><span class="line">A <span class="keyword">new</span> value <span class="number">234</span> hash been pushed to _arr</span><br><span class="line">[ &#123; <span class="attr">val</span>: <span class="number">123</span> &#125;, &#123; <span class="attr">val</span>: <span class="number">234</span> &#125; ]</span><br></pre></td></tr></table></figure></div></div><h2 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br></pre></td></tr></table></figure><p><code>defineProperty</code> 它可以对一个对象赋予对应属性。并且<strong>该对象原本就是空的</strong>。而 <code>proxy</code>代理是操作<strong>原本就有属性</strong>的对象。</p><p>主要功能：自定义对象属性的获取、赋值、枚举、函数调用等</p><h3 id="代理基础"><a href="#代理基础" class="headerlink" title="代理基础"></a>代理基础</h3><p>那么，我们看看如下代码吧：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> target = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params">target, prop</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;This is property value &#x27;</span> + target[prop]);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">set</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">proxy.a;</span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>答案是 <code>This is property value 1</code>。发现<code>new</code>了以后产生了一个新的代理对象，并且自定义了对象属性的获取。</p></div></div><p>继续，我们看看 <code>set</code> 方法又是怎样的呢？</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> target = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params">target, prop</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;This is property value &#x27;</span> + target[prop]);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">set</span>(<span class="params">target, prop, newVal</span>)</span> &#123;</span><br><span class="line">    target[prop] = newVal;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">proxy.a = <span class="number">3</span>;</span><br><span class="line">proxy.a;</span><br><span class="line"><span class="built_in">console</span>.log(target);</span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>打印结果为 <code>This is property value 3</code> 和 <code>{ a: 3, b: 2 }</code>，解释一下，尽管操作的代理对象，但是如果我们对代理对象进行了修改，原对象也会跟着改。</p></div></div><h3 id="操作函数"><a href="#操作函数" class="headerlink" title="操作函数"></a>操作函数</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;I am a function.&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn.a = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> newFn = <span class="keyword">new</span> <span class="built_in">Proxy</span>(fn, &#123;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params">fn, prop</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fn[prop] + <span class="string">&#x27;This is a Proxy return&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(newFn.a);</span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>打印结果为 <code>123This is a Proxy return</code>。</p></div></div><h3 id="操作数组"><a href="#操作数组" class="headerlink" title="操作数组"></a>操作数组</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [&#123; <span class="attr">name</span>: <span class="string">&#x27;Chocolate&#x27;</span>, <span class="attr">age</span>: <span class="number">21</span> &#125;, &#123; <span class="attr">name</span>: <span class="string">&#x27;jack&#x27;</span>, <span class="attr">age</span>: <span class="number">20</span> &#125;];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> persons = <span class="keyword">new</span> <span class="built_in">Proxy</span>(arr, &#123;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params">arr, prop</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> arr[prop];</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">set</span>(<span class="params">arr, prop, newVal</span>)</span> &#123;</span><br><span class="line">    arr[prop] = newVal;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(persons[<span class="number">1</span>]);</span><br><span class="line">persons[<span class="number">2</span>] = &#123; <span class="attr">name</span>: <span class="string">&#x27;leo&#x27;</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(persons, arr);</span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>打印结果如下：<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200921145046994.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70#pic_center" alt=""></p></div></div><h2 id="ES-14种操作对象的方法"><a href="#ES-14种操作对象的方法" class="headerlink" title="ES 14种操作对象的方法"></a>ES 14种操作对象的方法</h2><h3 id="获取原型"><a href="#获取原型" class="headerlink" title="获取原型"></a>获取原型</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">a</span>:<span class="number">1</span>,<span class="attr">b</span>:<span class="number">2</span>&#125;;</span><br><span class="line"><span class="comment">// 1.获取原型 [[GetPrototypeOf]]</span></span><br><span class="line"><span class="keyword">var</span> proto = <span class="built_in">Object</span>.getPrototypeOf(obj);</span><br><span class="line"><span class="built_in">console</span>.log(proto);</span><br><span class="line"><span class="built_in">console</span>.log(obj.__proto__);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype);</span><br></pre></td></tr></table></figure><p>打印结果如下：<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/2020092114575566.png#pic_center" alt=""></p><h3 id="设置原型"><a href="#设置原型" class="headerlink" title="设置原型"></a>设置原型</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="comment">// 2.设置原型 [[SetPrototypeOf]]</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(obj, &#123; <span class="attr">c</span>: <span class="number">3</span>, <span class="attr">d</span>: <span class="number">4</span> &#125;);</span><br><span class="line"><span class="comment">// 同样也可以采用如下两种方式，直接赋值</span></span><br><span class="line"><span class="comment">// obj.__proro__ = xxx;</span></span><br><span class="line"><span class="comment">// Object.prototype = xxx;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj);</span><br></pre></td></tr></table></figure><p>打印结果如下：<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200921145953692.png#pic_center" alt=""></p><h3 id="获取对象的可拓展性"><a href="#获取对象的可拓展性" class="headerlink" title="获取对象的可拓展性"></a>获取对象的可拓展性</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="comment">// 3.获取对象的可拓展性 [[IsExtensible]]</span></span><br><span class="line"><span class="keyword">var</span> extensible = <span class="built_in">Object</span>.isExtensible(obj);</span><br><span class="line"><span class="built_in">console</span>.log(extensible);</span><br><span class="line"><span class="comment">// 冻结对象</span></span><br><span class="line"><span class="built_in">Object</span>.freeze(obj);</span><br><span class="line"><span class="keyword">var</span> extensible2 = <span class="built_in">Object</span>.isExtensible(obj);</span><br><span class="line"><span class="built_in">console</span>.log(extensible2);</span><br></pre></td></tr></table></figure><p>打印结果为 <code>true false</code>。</p><p>诶，从中我们发现了一个新东西 <code>freeze</code>，作用就是<strong>冻结对象</strong>，与之相关的还有一个 <code>seal</code>，叫做<strong>封闭对象</strong>，（简称自闭…开个玩笑<code>^_^</code>），还是举一下例子，对比一下，先来介绍 <code>seal</code>封闭对象：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.seal(obj);</span><br><span class="line">obj.c = <span class="number">3</span>;  <span class="comment">// 不可修改</span></span><br><span class="line"><span class="built_in">console</span>.log(obj);</span><br><span class="line"><span class="keyword">delete</span> obj.a; <span class="comment">// 不可删除</span></span><br><span class="line"><span class="built_in">console</span>.log(obj);</span><br><span class="line">obj.b = <span class="number">3</span>; <span class="comment">// 可写</span></span><br><span class="line"><span class="built_in">console</span>.log(obj);</span><br></pre></td></tr></table></figure><p>打印结果如下，总结三点：<strong>不可修改、不可删除、可写</strong>。外加可读。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200921150813192.png#pic_center" alt=""></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.freeze(obj);</span><br><span class="line">obj.c = <span class="number">3</span>;  <span class="comment">// 不可修改</span></span><br><span class="line"><span class="built_in">console</span>.log(obj);</span><br><span class="line"><span class="keyword">delete</span> obj.a; <span class="comment">// 不可删除</span></span><br><span class="line"><span class="built_in">console</span>.log(obj);</span><br><span class="line">obj.b = <span class="number">3</span>; <span class="comment">// 不可写</span></span><br><span class="line"><span class="built_in">console</span>.log(obj);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(obj[key]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果如下，总结三点：<strong>不可修改、不可删除、不可写</strong>，仅可读。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200921151023131.png#pic_center" alt=""></p><h3 id="获取自有属性"><a href="#获取自有属性" class="headerlink" title="获取自有属性"></a>获取自有属性</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="comment">// 4.获取自有属性 [[getOwnProperty]]</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(obj, &#123; <span class="attr">c</span>: <span class="number">3</span>, <span class="attr">d</span>: <span class="number">4</span> &#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyNames(obj));</span><br></pre></td></tr></table></figure><p>答案是 <code>[ &#39;a&#39;, &#39;b&#39; ]</code>。</p><h3 id="禁止拓展对象"><a href="#禁止拓展对象" class="headerlink" title="禁止拓展对象"></a>禁止拓展对象</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="comment">// 5.禁止拓展对象 [[PreventExtensions]]</span></span><br><span class="line"><span class="built_in">Object</span>.preventExtensions(obj);</span><br><span class="line">obj.c = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj);</span><br><span class="line"><span class="keyword">delete</span> obj.a;</span><br><span class="line"><span class="built_in">console</span>.log(obj);</span><br></pre></td></tr></table></figure><p>答案是 <code>&#123; a: 1, b: 2 &#125;</code> 和  <code>&#123; b: 2 &#125;</code>，我们无法对 <code>obj</code> 对象进行拓展，但是可以进行删除操作。简单来说就是<strong>禁止增加属性，但可删除属性</strong>。</p><h3 id="拦截对象操作"><a href="#拦截对象操作" class="headerlink" title="拦截对象操作"></a>拦截对象操作</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// var obj = &#123; a: 1, b: 2 &#125;;</span></span><br><span class="line"><span class="comment">// 6.拦截对象操作 [[DefineOwnProperty]]</span></span><br><span class="line"><span class="comment">// Object.defineProperty()</span></span><br></pre></td></tr></table></figure><h3 id="判断是否是自身属性"><a href="#判断是否是自身属性" class="headerlink" title="判断是否是自身属性"></a>判断是否是自身属性</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="comment">// 7.判断是否是自身属性 [[HasProperty]]</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.hasOwnProperty(<span class="string">&#x27;a&#x27;</span>));</span><br></pre></td></tr></table></figure><p>答案是 <code>true</code>。</p><h3 id="获取对象属性"><a href="#获取对象属性" class="headerlink" title="获取对象属性"></a>获取对象属性</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="comment">// 8.获取对象属性 [[Get]]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;c&#x27;</span> <span class="keyword">in</span> obj);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;a&#x27;</span> <span class="keyword">in</span> obj);</span><br><span class="line"><span class="built_in">console</span>.log(obj.a);</span><br></pre></td></tr></table></figure><p>打印结果如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="设置对象属性"><a href="#设置对象属性" class="headerlink" title="设置对象属性"></a>设置对象属性</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="comment">// 9.设置对象属性 [[SET]]</span></span><br><span class="line">obj.a = <span class="number">3</span>;</span><br><span class="line">obj[<span class="string">&#x27;b&#x27;</span>] = <span class="number">4</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj);</span><br></pre></td></tr></table></figure><p>答案<code>&#123; a: 3, b: 4 &#125;</code>.</p><h3 id="删除对象属性"><a href="#删除对象属性" class="headerlink" title="删除对象属性"></a>删除对象属性</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="comment">// 10.删除对象属性 [[Delete]]</span></span><br><span class="line"><span class="keyword">delete</span> obj.a;</span><br><span class="line"><span class="built_in">console</span>.log(obj);</span><br></pre></td></tr></table></figure><p>答案是 <code>&#123; b: 2 &#125;</code>。</p><h3 id="枚举对象属性"><a href="#枚举对象属性" class="headerlink" title="枚举对象属性"></a>枚举对象属性</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="comment">// 11. 枚举 [[Enumerate]]</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> k <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(obj[k]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="获取键集合"><a href="#获取键集合" class="headerlink" title="获取键集合"></a>获取键集合</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="comment">// 12.获取键集合 [[OwnPropertyKeys]]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(obj));</span><br></pre></td></tr></table></figure><p>答案 <code>[ &#39;a&#39;, &#39;b&#39; ]</code></p><h3 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 13.调用函数</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line">test();</span><br><span class="line">obj.test = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line">obj.test();</span><br></pre></td></tr></table></figure><h3 id="new实例化对象"><a href="#new实例化对象" class="headerlink" title="new实例化对象"></a>new实例化对象</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 14.实例化对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span>(<span class="params"></span>) </span>&#123; &#125;;</span><br><span class="line"><span class="keyword">new</span> Test();</span><br></pre></td></tr></table></figure><h2 id="自己实现一个-Proxy"><a href="#自己实现一个-Proxy" class="headerlink" title="自己实现一个 Proxy"></a>自己实现一个 Proxy</h2><p>其实，有了前置知识，我们不难发现，<code>Proxy</code> 和 <code>Object.defineProperty</code> 实现效果是一样的，但其实两个原理上是有挺大差别的。</p><ul><li><code>defineProperty</code> 操作的是空对象，而 <code>proxy</code> 操作的是现有对象。</li><li><code>defineProperty</code> 原本目的是对一个对象赋予对应属性，而 <code>proxy</code>代理是操作<strong>原本就有属性</strong>的对象。其主要功能是自定义对象属性的获取、赋值、枚举、函数调用等</li></ul><p>那么，我们首先看看 <code>Proxy</code>是怎样使用的，看一下下面这个例子，然后我们再用 <code>defineProperty</code> 自己实现一个 <code>Proxy</code>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params">target, prop</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Get:&#x27;</span> + prop + <span class="string">&#x27;=&#x27;</span> + target[prop];</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">set</span>(<span class="params">target, prop, newVal</span>)</span> &#123;</span><br><span class="line">    target[prop] = newVal;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Set:&#x27;</span> + prop + <span class="string">&#x27;=&#x27;</span> + newVal);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(proxy.a);</span><br><span class="line">proxy.b = <span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>打印结果如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Get:a=<span class="number">1</span></span><br><span class="line"><span class="built_in">Set</span>:b=<span class="number">3</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyProxy</span>(<span class="params">target, handler</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 操作副本</span></span><br><span class="line">  <span class="keyword">let</span> _target = deepClone(target);</span><br><span class="line">  <span class="built_in">Object</span>.keys(_target).forEach(<span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(_target, key, &#123;</span><br><span class="line">      <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> handler.get &amp;&amp; handler.get(target, key);</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="function"><span class="title">set</span>(<span class="params">newVal</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> handler.set &amp;&amp; handler.set(target, key, newVal);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> _target;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实现深拷贝</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">org, tar</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> tar = tar || &#123;&#125;,</span><br><span class="line">    toStr = <span class="built_in">Object</span>.prototype.toString,</span><br><span class="line">    arrType = <span class="string">&#x27;Array&#x27;</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> org) &#123;</span><br><span class="line">    <span class="keyword">if</span> (org.hasOwnProperty(key)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> org[key] === <span class="string">&#x27;object&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> org[key] !== <span class="string">&#x27;null&#x27;</span>) &#123;</span><br><span class="line">        tar[key] = toStr.call(org[key]).slice(<span class="number">8</span>, -<span class="number">1</span>) === arrType ? [] : &#123;&#125;;</span><br><span class="line">        deepClone(org[key], tar[key]);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        tar[key] = org[key];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> tar;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> MyProxy(target, &#123;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params">target, prop</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Get:&#x27;</span> + prop + <span class="string">&#x27;=&#x27;</span> + target[prop];</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">set</span>(<span class="params">target, prop, newVal</span>)</span> &#123;</span><br><span class="line">    target[prop] = newVal;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Set:&#x27;</span> + prop + <span class="string">&#x27;=&#x27;</span> + newVal);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(proxy.a);</span><br><span class="line">proxy.b = <span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>打印结果如下，和上述源代码结果一样。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Get:a=<span class="number">1</span></span><br><span class="line"><span class="built_in">Set</span>:b=<span class="number">3</span></span><br></pre></td></tr></table></figure><p>这里再进行梳理一下，<code>MyProxy</code> 实现原理是首先，先拷贝一份原对象，因为原本的 <code>Proxy</code>就是返回了一个代理对象，而我们先<strong>深拷贝</strong>一份对象，然后遍历这个拷贝对象，依次让对象的属性通过 <code>Object.defineProperty</code> 来实现数据劫持的效果，里面用到了 <code>get</code> 和  <code>set</code> 方法，而<code>get</code>和 <code>set</code>时直接操作我们的原对象就是，这样当我们对代理对象（即我们一开始拷贝的对象）操作时，就会劫持我们的 <code>get</code> 和 <code>set</code>方法，这样就能直接操作原对象了。</p><p>最终效果就是我们自定义了对象属性的获取、赋值的方式，不直接操作原对象，而是操作这个代理对象即可。</p><h3 id="学习-Reflect"><a href="#学习-Reflect" class="headerlink" title="学习 Reflect"></a>学习 Reflect</h3><p><code>Reflect</code> 是 <code>ES6</code>中出版的一个内置对象，也叫作<strong>反射</strong>。由于我们很多对象的方法都是放在 <code>Object</code> 上的，但是我们有时候并不是一直操作 <code>Object</code>，还有可能是函数或者数组等。这种情况下，我们放入 <code>Object</code>里面就不太合理。因此，<code>ES6</code>推出了<code>Reflect</code>，它是一个方法集合的容器。</p><p>而原本我们 <code>get</code>函数里面就是一个<strong>取值</strong>的方法，而并不是一个<strong>函数式</strong>的来操作对象，而 <code>Reflect</code>里面就有 <code>get</code>方法来做，同时也有对应的 <code>set</code> 方法，这样就是用底层方法来做了，而不是用一个等式来做，并且它是有返回值的（Boolean类型），可以确保我们 <code>set</code>成功。下面，我们来看一下下面这个经典例子吧：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params">target, prop</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, prop);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">set</span>(<span class="params">target, prop, newVal</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> isOk = <span class="built_in">Reflect</span>.set(target, prop, newVal);</span><br><span class="line">    <span class="keyword">if</span>(isOk)&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;Set Successfully&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(proxy.a);</span><br><span class="line">proxy.b = <span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>打印结果如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="built_in">Set</span> Successfully</span><br></pre></td></tr></table></figure><p>接下来，就是对于 <code>Reflect</code>的整理归纳：</p><ul><li><code>Reflect</code>可以看做是一个新的方法容器，未来许多方法都会逐步放入 <code>Reflect</code>中，而 <code>Object</code>主要用来构造原型、构造对象的，并且 <code>Object</code>里面方法是杂多的。</li><li><code>Object</code> 返回值往往会抛出异常，例如像 <code>defineProperty</code>，<code>in</code> 这样，通常会抛出异常。而 <code>Reflect</code>方法一般都有返回值 <code>true / false</code>，操作性更加合理。</li><li><code>Reflect</code>里面操作对象的方法和 <code>handler</code> 几乎一致，除开<strong>枚举</strong>。</li><li><code>Reflect</code>属于 <code>ES6</code>中全局内置对象，在哪都可以访问，直接保存静态方法，例如 <code>get</code>、<code>set</code>、<code>has</code>，不需要进行实例化操作。例如平常使用的 <code>Math.random</code>，也是可以直接使用的。</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200922162617302.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70#pic_center" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「JavaScript灵魂之问」前端知识梳理之 JS 篇（下篇）</title>
      <link href="posts/2020919/"/>
      <url>posts/2020919/</url>
      
        <content type="html"><![CDATA[<h2 id="三元运算基础"><a href="#三元运算基础" class="headerlink" title="三元运算基础"></a>三元运算基础</h2><p>开门见山，三元运算，我想对于很多编程语言都有提到，下面就简单一个例子来讲解一下好了。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="number">89</span> &gt; <span class="number">9</span>? (<span class="string">&#x27;89&#x27;</span> &gt; <span class="string">&#x27;9&#x27;</span>? <span class="string">&#x27;通过了&#x27;</span>: <span class="string">&#x27;内层未通过&#x27;</span>) : <span class="string">&#x27;外层未通过&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str);</span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>答案是 <code>内层未通过</code>，注意 <code>&#39;89&#39; &gt; &#39;9&#39;</code>的比较，由于都是字符串，会从第一位以 <code>ASCII</code>码来进行比较。由于<code>89</code>第一位为<code>8</code>，于是小于 <code>9</code>，返回 <code>false</code>，走后面那个，最后打印了 <code>内层未通过</code>。</p></div></div><h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">  name: <span class="string">&#x27;Chocolate&#x27;</span>,</span><br><span class="line">  age: <span class="number">21</span>,</span><br><span class="line">  child: &#123;</span><br><span class="line">    car: [<span class="string">&#x27;Benz&#x27;</span>, <span class="string">&#x27;Mazda&#x27;</span>],</span><br><span class="line">    first: &#123;</span><br><span class="line">      name: <span class="string">&#x27;cc&#x27;</span>,</span><br><span class="line">      age: <span class="number">10</span></span><br><span class="line">    &#125;,</span><br><span class="line">    second: &#123;</span><br><span class="line">      name: <span class="string">&#x27;dd&#x27;</span>,</span><br><span class="line">      age: <span class="number">11</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person2 = clone(person1);</span><br><span class="line">person2.child.car.push(<span class="string">&#x27;BYD&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person1);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 浅拷贝 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">origin, target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> tar = target || &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> origin) &#123;</span><br><span class="line">    <span class="keyword">if</span> (origin.hasOwnProperty(key)) &#123;</span><br><span class="line">      tar[key] = origin[key];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> tar;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>答案如下：<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200918080401756.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70#pic_center" alt=""></p><p>从这个例子，我们发现，浅拷贝没办法拷贝引用地址，会污染原对象，深拷贝就不会出现这个问题。</p></div></div><h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><p>接下来，我们来探究一下深拷贝。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">  name: <span class="string">&#x27;Chocolate&#x27;</span>,</span><br><span class="line">  age: <span class="number">21</span>,</span><br><span class="line">  child: &#123;</span><br><span class="line">    car: [<span class="string">&#x27;Benz&#x27;</span>, <span class="string">&#x27;Mazda&#x27;</span>],</span><br><span class="line">    first: &#123;</span><br><span class="line">      name: <span class="string">&#x27;cc&#x27;</span>,</span><br><span class="line">      age: <span class="number">10</span></span><br><span class="line">    &#125;,</span><br><span class="line">    second: &#123;</span><br><span class="line">      name: <span class="string">&#x27;dd&#x27;</span>,</span><br><span class="line">      age: <span class="number">11</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person2 = deepClone(person1);</span><br><span class="line">person2.child.car.push(<span class="string">&#x27;BYD&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person1);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">origin, target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> tar = target || &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> origin) &#123;</span><br><span class="line">    <span class="keyword">if</span> (origin.hasOwnProperty(key)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> (origin[key]) == <span class="string">&#x27;object&#x27;</span> &amp;&amp; origin[key] !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.toString.call(origin[key]).slice(<span class="number">8</span>, -<span class="number">1</span>) == <span class="string">&#x27;Array&#x27;</span>) &#123;</span><br><span class="line">          tar[key] = [];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          tar[key] = &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        deepClone(origin[key], tar[key]);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        tar[key] = origin[key];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> tar;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>答案如下：</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200918081157273.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70#pic_center" alt=""><br>另外，还有一种关于 <code>JSON</code>的方法来克隆，但一般用的不是特别多，因为对于函数方面没办法进行拷贝。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person3 = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(person1));</span><br><span class="line"><span class="built_in">console</span>.log(person3);</span><br></pre></td></tr></table></figure></div></div><h2 id="真题演练"><a href="#真题演练" class="headerlink" title="真题演练"></a>真题演练</h2><h3 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(foo); </span><br><span class="line">  <span class="keyword">var</span> foo = <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(foo); </span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line">test();</span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>答案是 <code>undefined 2 error</code>，不解释了哈。</p></div></div><h3 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> test;</span><br><span class="line">  test();</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">a();</span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>答案 <code>1</code>，简单哈。</p></div></div><h3 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h3><p>前面两道题都是简单热个身，下面我们来一道阿里笔试题，应该对于 <code>this</code>指向最难的题了。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;222&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">  name: <span class="string">&#x27;111&#x27;</span>,</span><br><span class="line">  say: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> fun = a.say;</span><br><span class="line">fun(); <span class="comment">// </span></span><br><span class="line">a.say(); <span class="comment">// </span></span><br><span class="line"><span class="keyword">var</span> b = &#123;</span><br><span class="line">  name: <span class="string">&#x27;333&#x27;</span>,</span><br><span class="line">  say: <span class="function"><span class="keyword">function</span>(<span class="params">fun</span>)</span>&#123;</span><br><span class="line">    fun();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">b.say(a.say); <span class="comment">// </span></span><br><span class="line">b.say = a.say; </span><br><span class="line">b.say(); <span class="comment">//</span></span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>答案是 <code>222 111  222 333</code>，详细解释一下，对于第一句<code>var fun = a.say;</code>，也就相当于把匿名函数赋值给了 <code>fun</code>，详细如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fun = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，这里 <code>this</code>，就会指向 <code>window</code>，所以就是 <code>222</code>。</p><p>那么，第二个答案 <code>a.say();</code>必须得是 <code>111</code>，因为我们访问的是对象里面的方法，<code>this</code>当然指向这个对象。</p><p>接下来，对于第三个答案 <code>b.say(a.say);</code>，相当于在<code>GO</code>中执行该函数，这里其实和第一问类型，都是放在 <code>GO</code>里面执行，因此也是指向 <code>window</code>。</p><p>对于最后一个答案<code>b.say();</code>，和第二个答案类似，执行对象里面的方法，<code>this</code>当然指向这个对象。</p></div></div><h3 id="第四题"><a href="#第四题" class="headerlink" title="第四题"></a>第四题</h3><p>继续，再来一道关于 <code>this</code>指向问题的题目：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> marty = &#123;</span><br><span class="line">    name: <span class="string">&#x27;marty&#x27;</span>,</span><br><span class="line">    printName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> test1 = &#123;</span><br><span class="line">    name: <span class="string">&#x27;test1&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> test2 = &#123;</span><br><span class="line">    name: <span class="string">&#x27;test2&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> test3 = &#123;</span><br><span class="line">    name: <span class="string">&#x27;test3&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">  test3.printName = marty.printName;</span><br><span class="line">  marty.printName.call(test1); <span class="comment">// </span></span><br><span class="line">  marty.printName.apply(test2); <span class="comment">// </span></span><br><span class="line">  marty.printName(); <span class="comment">// </span></span><br><span class="line">  test3.printName(); <span class="comment">// </span></span><br><span class="line">&#125;</span><br><span class="line">test();</span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>答案是 <code>test1 test2  marty test3</code>，对于第一个和第二个答案，类似的，通过 <code>call / apply</code>改变了 <code>this</code> 指向问题，对于第三个答案，执行对象里面的方法，<code>this</code>当然指向这个对象。而对于第四个答案，也是执行对象里面的方法，<code>this</code>当然指向这个对象。</p></div></div><h3 id="第五题"><a href="#第五题" class="headerlink" title="第五题"></a>第五题</h3><p>下面这题是百度一道真题，但是感觉比较水，直接看看会打印什么吧：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> bar = &#123;</span><br><span class="line">  a: <span class="string">&#x27;1&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  bar.a = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">  <span class="built_in">Object</span>.prototype.b = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(bar.a);</span><br><span class="line">    <span class="built_in">console</span>.log(bar.b);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">test()(); <span class="comment">//</span></span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>答案是 <code>a b</code>，函数里面 <code>return</code>出去了一个函数，形成了一个闭包，会一直引用着 <code>test</code>的 <code>AO</code>，所以可以访问 <code>a</code>，而 <code>b</code>访问不到，会去原型链上一直找，最后找到了 <code>b</code>。</p></div></div><h3 id="经典题"><a href="#经典题" class="headerlink" title="经典题"></a>经典题</h3><p>下面来一道最经典的题，特别容易出错，<strong>注意！</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">Foo.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">Foo.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.getName(); <span class="comment">// </span></span><br><span class="line">getName(); <span class="comment">// </span></span><br><span class="line">Foo().getName(); <span class="comment">//  </span></span><br><span class="line">getName(); <span class="comment">// </span></span><br><span class="line"><span class="keyword">new</span> Foo.getName(); <span class="comment">// </span></span><br><span class="line"><span class="keyword">new</span> Foo().getName(); <span class="comment">// </span></span><br><span class="line"><span class="keyword">new</span> <span class="keyword">new</span> Foo().getName(); <span class="comment">//  </span></span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>答案是 <code>2 4 1 1 2 3 3</code>。详细解释一下：</p><p>第一问，执行<code>Foo.getName();</code>我们执行的是这段代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Foo.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为，这里访问的对象的属性，把函数充当了一个特殊对象，我们直接访问它的属性，然后打印 <code>2</code>。</p><p>第二问，执行 <code>getName();</code>在全局<code>GO</code>里面，是这样的情况，存在<strong>函数提升</strong>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">GO: &#123;</span><br><span class="line">getName: <span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log(<span class="number">5</span>);&#125; -&gt; <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="number">4</span>);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三问，执行 <code>Foo().getName();</code>时，里面有一个变量 <code>getName</code>，没有申明，放到外面，就会给到全局，此时</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">GO: &#123;</span><br><span class="line">getName: <span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log(<span class="number">5</span>);&#125; -&gt; <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="number">4</span>);&#125; -&gt; <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="number">1</span>);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>于是访问 <code>getName</code>又进行了覆盖，打印 <code>1</code>。</p><p>第四问，执行 <code>getName();</code> <code>GO</code>和上一问一样，打印 <code>1</code>。</p><p>第五问，执行 <code>new Foo.getName();</code>这里要牵扯到优先级问题了，<code>.</code> 运算符的优先级要比 <code>new</code>要高。因此，先执行<code>Foo.getName();</code>（即先执行下面这段代码）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Foo.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先打印 <code>2</code>，然后<code>new</code>没有什么意义，等于没写。</p><p>第六问，执行<code>new Foo().getName();</code>这里又要牵扯到优先级问题了，<code>()</code>运算符的优先级要比 <code>.</code>高。而在执行<code>()</code>时会带着 <code>new</code>一起执行。然后返回 <code>this</code>，此时我们执行的是 <code>this.getName</code>，发现此时没有 <code>this.getName</code>，然后就会去原型链上找，能找到如下代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Foo.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>于是最终结果打印 <code>3</code>。</p><p>第七问，执行 <code>new new Foo().getName();</code>，也是与优先级有关，首先，<code>()</code>运算符的优先级要比 <code>.</code>高，先得到 <code>new this.getName();</code> 然后<code>.</code> 运算符的优先级要比 <code>new</code>要高，和第六问一样了，访问原型链上的方法，得到 <code>3</code>，最后<code>new</code>没有什么意义，等于没写。</p></div></div><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>先来一些前置知识，后续我们会把数组相关知识好好整理一番。</p><h3 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 创建数组 */</span></span><br><span class="line"><span class="keyword">var</span> arr1 = []; <span class="comment">// 通过字面量创建</span></span><br><span class="line"><span class="keyword">var</span> arr2 = <span class="keyword">new</span> <span class="built_in">Array</span>(); <span class="comment">// 通过系统内置的Array构造函数</span></span><br></pre></td></tr></table></figure><p>所有的数组都继承于 <code>Array.prototype</code>。</p><p>看看下面这个，会输出什么呢？</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [, ,];</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br></pre></td></tr></table></figure><p>答案是 <code>[ &lt;2 empty items&gt; ]</code>，诶，我明明有三个空的，为啥是两个 <code>empty</code>呢？此时，我们打印一下长度看看，发现还是 <code>2</code>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(arr.length); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>好了，不布置坑了，直接看下面这例子吧：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [, <span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,];</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [ &lt;1 empty item&gt;, 1, 3, 5, 7 ]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.length); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><p>从结果看出来，发现数组内置会有一个截取，最后一个空，它不会算。（注意，只是最后为空的元素不会算）这就叫做<strong>稀疏数组</strong></p><p>那么，我们可以直接造<code>100</code>个为空的数组吗？而不是一个个赋值为空，当然可以，用构造函数即可：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">100</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [ &lt;100 empty items&gt; ]</span></span><br></pre></td></tr></table></figure><h3 id="在原数组上修改"><a href="#在原数组上修改" class="headerlink" title="在原数组上修改"></a>在原数组上修改</h3><h3 id="push-unshift"><a href="#push-unshift" class="headerlink" title="push / unshift"></a>push / unshift</h3><p>看看会输出什么？</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.push(<span class="number">5</span>));</span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>答案是 <code>5</code>，诶，你会不会一位会打印数组，当然不是哈， <code>push / unshift</code>返回值是执行方法以后<strong>数组的长度</strong>。</p></div></div><p>举个例子：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.push(<span class="number">5</span>));</span><br><span class="line"><span class="built_in">console</span>.log(arr.unshift(<span class="number">0</span>));</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>答案如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line">[ <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> ]</span><br></pre></td></tr></table></figure></div></div><h3 id="重写-push-方法"><a href="#重写-push-方法" class="headerlink" title="重写 push 方法"></a>重写 push 方法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.myPush = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="built_in">arguments</span>.length;i++)&#123;</span><br><span class="line">    <span class="built_in">this</span>[<span class="built_in">this</span>.length] = <span class="built_in">arguments</span>[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.myPush(<span class="number">5</span>)); <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [ 1, 2, 3, 4, 5 ]</span></span><br></pre></td></tr></table></figure><h3 id="pop-shift"><a href="#pop-shift" class="headerlink" title="pop / shift"></a>pop / shift</h3><p>它们没有参数，返回值为弹出去的 <code>value</code>值</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"><span class="keyword">var</span> tmp = arr.pop();</span><br><span class="line"><span class="built_in">console</span>.log(tmp); <span class="comment">// 4</span></span><br><span class="line"><span class="keyword">var</span> tmp2 = arr.shift();</span><br><span class="line"><span class="built_in">console</span>.log(tmp2); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h3 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a>reverse</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">arr.reverse();</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [ 3, 2, 1 ]</span></span><br></pre></td></tr></table></figure><h3 id="splice"><a href="#splice" class="headerlink" title="splice"></a>splice</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// arr.splice(开始项的下标，剪切长度，剪切以后最后一位开始添加数据)</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line">arr.splice(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [&#x27;a&#x27;]</span></span><br><span class="line">arr.splice(<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [ &#x27;a&#x27;, 2, 3 ]</span></span><br></pre></td></tr></table></figure><h3 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [-<span class="number">1</span>,-<span class="number">5</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">2</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.sort()); <span class="comment">// [ -1, -5, 0, 2, 8 ]</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;z&#x27;</span>,<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;i&#x27;</span>,<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.sort()); <span class="comment">// [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;h&#x27;, &#x27;i&#x27;, &#x27;z&#x27; ]</span></span><br></pre></td></tr></table></figure><p>好的，在你以为按照升序排列后，我们再来看看下面又会打印什么？</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">27</span>,<span class="number">49</span>,<span class="number">5</span>,<span class="number">7</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.sort());</span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>答案是 <code>[ 27, 49, 5, 7 ]</code>，发现奇怪的事情，居然不排序了？？？现在来好好解释一下，原来数组是按照 <code>ASCII</code>码来排序的。</p></div></div><p>那么，为了自定义排序， <code>sort</code>里面可以传一个回调函数进来。看看下面例子吧：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">  sort 按照ascii码来进行排序</span></span><br><span class="line"><span class="comment">  1、参数a,b</span></span><br><span class="line"><span class="comment">  2、返回值：负值，a 就排在前面</span></span><br><span class="line"><span class="comment">            正值，b 就排在前面</span></span><br><span class="line"><span class="comment">            0， 保持不动</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">27</span>, <span class="number">49</span>, <span class="number">5</span>, <span class="number">7</span>];</span><br><span class="line">arr.sort(<span class="function">(<span class="params">a,b</span>)=&gt;</span>a-b);</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [ 5, 7, 27, 49 ]</span></span><br><span class="line">arr.sort(<span class="function">(<span class="params">a,b</span>)=&gt;</span>b-a);</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [ 49, 27, 7, 5 ]</span></span><br></pre></td></tr></table></figure><p>可以以<strong>冒泡</strong>排序为例，当 <code>a-b</code>返回值为正数的时候，就将 <code>a</code>冒泡上去，然后就是从小到大排序啦。</p><p>总结归纳：</p><p>修改原数组的方法：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">push/unshift pop/shift reverse splice sort</span><br></pre></td></tr></table></figure><h3 id="新建数组（不对原数组产生影响）"><a href="#新建数组（不对原数组产生影响）" class="headerlink" title="新建数组（不对原数组产生影响）"></a>新建数组（不对原数组产生影响）</h3><h3 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> arr3 = arr1.concat(arr2);</span><br><span class="line"><span class="built_in">console</span>.log(arr3); <span class="comment">// [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27; ]</span></span><br></pre></td></tr></table></figure><h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> arr1 = arr.toString();</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [ 1, 2, 3 ]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr1); <span class="comment">// 1,2,3</span></span><br></pre></td></tr></table></figure><h3 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h3><p>数组切割，有两个可选参数，第一个参数为 <code>start</code>，第二个参数为 <code>end</code>，区间为 <code>[ start, end)</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> arr1 = arr.slice(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr1); <span class="comment">// [ &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27; ]</span></span><br></pre></td></tr></table></figure><h3 id="join"><a href="#join" class="headerlink" title="join"></a>join</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> str1 = arr.join();</span><br><span class="line"><span class="keyword">var</span> str2 = arr.toString();</span><br><span class="line"><span class="keyword">var</span> str3 = arr.join(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(str1); <span class="comment">// a,b,c,d</span></span><br><span class="line"><span class="built_in">console</span>.log(str2); <span class="comment">// a,b,c,d</span></span><br><span class="line"><span class="built_in">console</span>.log(str3); <span class="comment">// abcd</span></span><br></pre></td></tr></table></figure><h3 id="split"><a href="#split" class="headerlink" title="split"></a>split</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> str1 = arr.join(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(str1); <span class="comment">// a-b-c-d</span></span><br><span class="line"><span class="keyword">var</span> arr1 = str1.split(<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(arr1); <span class="comment">// [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27; ]</span></span><br><span class="line"><span class="keyword">var</span> arr2 = str1.split(<span class="string">&#x27;-&#x27;</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">console</span>.log(arr2); <span class="comment">// [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27; ]</span></span><br></pre></td></tr></table></figure><h2 id="类数组"><a href="#类数组" class="headerlink" title="类数组"></a>类数组</h2><p>开门见山，看看下面代码会打印什么？</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line">test(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>结果如下，发现会是一个数组形式，但里面有很多东西，但是没有数组方法，因为它并没有继承 <code>Array.prototype</code>。<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200919075711450.png#pic_center" alt=""></p></div></div><p>接下来，我们再来看看下面这个例子：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line">test(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="string">&#x27;0&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="string">&#x27;1&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="string">&#x27;2&#x27;</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="string">&#x27;length&#x27;</span>: <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj);</span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>结果如下，发现一个是系统自带的，一个是由我们来生成的，是不一样的！<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200919080911782.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70#pic_center" alt=""></p></div></div><p>另外，我们发现<code>obj</code>也不是数组的形式，那么我们怎么变成数组的形式呢？看看如下操作吧：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="string">&#x27;0&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="string">&#x27;1&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="string">&#x27;2&#x27;</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="string">&#x27;length&#x27;</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="string">&#x27;splice&#x27;</span>: <span class="built_in">Array</span>.prototype.splice</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj);</span><br></pre></td></tr></table></figure><p>在我们继承数组的 <code>splice</code>的方法后，居然真变成了数组的形式，那么我们可以使用 <code>push</code>方法吗？<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200919081149582.png#pic_center" alt=""><br>试一试：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="string">&#x27;0&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="string">&#x27;1&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="string">&#x27;2&#x27;</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="string">&#x27;length&#x27;</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="string">&#x27;splice&#x27;</span>: <span class="built_in">Array</span>.prototype.splice,</span><br><span class="line">  <span class="string">&#x27;push&#x27;</span>: <span class="built_in">Array</span>.prototype.push</span><br><span class="line">&#125;</span><br><span class="line">obj.push(<span class="number">7</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj);</span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>结果如下，继承数组的<code>push</code>方法后，真的可以！<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200919081304784.png#pic_center" alt=""></p></div></div><p>既然刚刚是直接对象来继承数组的方法，那么可以直接挂载到 <code>Object</code>上吗？看如下例子：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="string">&#x27;0&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="string">&#x27;1&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="string">&#x27;2&#x27;</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="string">&#x27;length&#x27;</span>: <span class="number">3</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.prototype.push = <span class="built_in">Array</span>.prototype.push;</span><br><span class="line"><span class="built_in">Object</span>.prototype.splice = <span class="built_in">Array</span>.prototype.splice;</span><br><span class="line">obj.push(<span class="number">7</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj);</span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>答案是可以的，因为大部分对象都继承于<code>Object</code>嘛。<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200919081513734.png#pic_center" alt=""></p></div></div><h3 id="真题演练-1"><a href="#真题演练-1" class="headerlink" title="真题演练"></a>真题演练</h3><p>看看下面代码会输出什么，一道经典的笔试题：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="string">&#x27;2&#x27;</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="string">&#x27;3&#x27;</span>: <span class="number">4</span>,</span><br><span class="line">  <span class="string">&#x27;length&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="string">&#x27;splice&#x27;</span>: <span class="built_in">Array</span>.prototype.splice,</span><br><span class="line">  <span class="string">&#x27;push&#x27;</span>: <span class="built_in">Array</span>.prototype.push</span><br><span class="line">&#125;</span><br><span class="line">obj.push(<span class="number">1</span>);</span><br><span class="line">obj.push(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj);</span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>答案如下，来解释一下<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200919082033627.png#pic_center" alt=""><br>其实内部是这样做的：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.push = <span class="function"><span class="keyword">function</span>(<span class="params">elem</span>)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>[<span class="built_in">this</span>.length] = elem;</span><br><span class="line"><span class="built_in">this</span>.length++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>于是我们执行的时候会这样执行，每次找数组长度处进行赋值。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">obj[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">obj[<span class="number">3</span>] = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>最后，我们的 <code>length</code> 加到 <code>4</code>，而前面两个<strong>补空</strong>。</p></div></div><p>下面我们再来看看一个例题吧，加深巩固。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  <span class="string">&#x27;0&#x27;</span>: <span class="string">&#x27;张小一&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;1&#x27;</span>: <span class="string">&#x27;张小二&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;2&#x27;</span>: <span class="string">&#x27;张小三&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;age&#x27;</span>: <span class="number">32</span>,</span><br><span class="line">  <span class="string">&#x27;height&#x27;</span>: <span class="number">140</span>,</span><br><span class="line">  <span class="string">&#x27;weight&#x27;</span>: <span class="number">180</span>,</span><br><span class="line">  <span class="string">&#x27;length&#x27;</span>: <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.prototype.push = <span class="built_in">Array</span>.prototype.push;</span><br><span class="line"><span class="built_in">Object</span>.prototype.splice = <span class="built_in">Array</span>.prototype.splice;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person[<span class="number">1</span>]); <span class="comment">// 张小二</span></span><br><span class="line"><span class="built_in">console</span>.log(person.weight);<span class="comment">// 180</span></span><br></pre></td></tr></table></figure><h3 id="类数组转换成数组"><a href="#类数组转换成数组" class="headerlink" title="类数组转换成数组"></a>类数组转换成数组</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)); <span class="comment">// [ 1, 2, 3 ]</span></span><br><span class="line">&#125;</span><br><span class="line">test(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>结果如下：<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200919091148809.png#pic_center" alt=""></p></div></div><p>有了转换数组操作后，我们又可以来封装一下 <code>unshift</code>方法了。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>]</span><br><span class="line"><span class="built_in">Array</span>.prototype.myUnshift = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> argArr = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">  <span class="keyword">let</span> newArr = argArr.concat(<span class="built_in">this</span>);</span><br><span class="line">  <span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> newArr = arr.myUnshift(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(newArr);</span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>答案是 <code>[ &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39; ]</code></p></div></div><h3 id="数组按照元素的字节数排序"><a href="#数组按照元素的字节数排序" class="headerlink" title="数组按照元素的字节数排序"></a>数组按照元素的字节数排序</h3><p><code>unicode</code> 中 <code>0-255</code>为 <code>1</code>个字节，<code>256 - ~</code>为 <code>2</code> 个字节。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 数组按照元素的字节数排序 */</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;Chocolate&#x27;</span>,<span class="string">&#x27;我爱你&#x27;</span>,<span class="string">&#x27;OK&#x27;</span>,<span class="string">&#x27;杰伦&#x27;</span>];</span><br><span class="line">arr.sort(<span class="function">(<span class="params">a,b</span>)=&gt;</span>getBytes(a)-getBytes(b));</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [ &#x27;OK&#x27;, &#x27;杰伦&#x27;, &#x27;我爱你&#x27;, &#x27;Chocolate&#x27; ]</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getBytes</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> bytes = str.length;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (str.charCodeAt(i) &gt; <span class="number">255</span>) &#123;</span><br><span class="line">      bytes++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> bytes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="封装-typeof"><a href="#封装-typeof" class="headerlink" title="封装 typeof"></a>封装 typeof</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 封装 typeof */</span></span><br><span class="line"><span class="comment">// 返回值 number string boolean object function </span></span><br><span class="line"><span class="comment">// undefined </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myTypeof</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> type = <span class="keyword">typeof</span>(val);</span><br><span class="line">  <span class="keyword">let</span> toStr = <span class="built_in">Object</span>.prototype.toString;</span><br><span class="line">  <span class="keyword">if</span>(val === <span class="literal">null</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;null&#x27;</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(type === <span class="string">&#x27;object&#x27;</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> res = toStr.call(val);</span><br><span class="line">    res = res.slice(<span class="number">8</span>,-<span class="number">1</span>);</span><br><span class="line">    res = res[<span class="number">0</span>].toLowerCase() + res.substr(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> type;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(myTypeof(<span class="number">1</span>)); <span class="comment">// number</span></span><br><span class="line"><span class="built_in">console</span>.log(myTypeof(&#123;<span class="attr">name</span>: <span class="string">&#x27;chocolate&#x27;</span>&#125;)); <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(myTypeof([])); <span class="comment">// array</span></span><br><span class="line"><span class="built_in">console</span>.log(myTypeof(<span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">1</span>))); <span class="comment">// number</span></span><br><span class="line"><span class="built_in">console</span>.log(myTypeof(<span class="keyword">new</span> <span class="built_in">String</span>(<span class="number">1</span>))); <span class="comment">// string</span></span><br><span class="line"><span class="built_in">console</span>.log(myTypeof(<span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="number">1</span>))); <span class="comment">// boolean</span></span><br><span class="line"><span class="built_in">console</span>.log(myTypeof(<span class="literal">null</span>)); <span class="comment">// null</span></span><br><span class="line"><span class="built_in">console</span>.log(myTypeof(<span class="literal">undefined</span>)); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(myTypeof(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;)); <span class="comment">// function</span></span><br></pre></td></tr></table></figure><h3 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 数组去重 */</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.prototype.unique = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> tmp = &#123;&#125;;</span><br><span class="line">  <span class="keyword">let</span> newArr = [];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="built_in">this</span>.length;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!tmp.hasOwnProperty(<span class="built_in">this</span>[i]))&#123;</span><br><span class="line">      tmp[<span class="built_in">this</span>[i]] = <span class="built_in">this</span>[i];</span><br><span class="line">      newArr.push(<span class="built_in">this</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(arr.unique()); <span class="comment">// [ 0, 1, 2, 3, &#x27;a&#x27;, &#x27;b&#x27; ]</span></span><br></pre></td></tr></table></figure><h2 id="闭包回顾"><a href="#闭包回顾" class="headerlink" title="闭包回顾"></a>闭包回顾</h2><h3 id="第一题-1"><a href="#第一题-1" class="headerlink" title="第一题"></a>第一题</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> d = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">this</span>.a = a;</span><br><span class="line">  <span class="built_in">this</span>.b = b;</span><br><span class="line">  <span class="built_in">this</span>.c = c;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">e</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    d++;</span><br><span class="line">    <span class="built_in">console</span>.log(d);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">this</span>.f = e;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> test1 = <span class="keyword">new</span> Test();</span><br><span class="line">test1.f();</span><br><span class="line">test1.f();</span><br><span class="line"><span class="keyword">var</span> test2 = <span class="keyword">new</span> Test();</span><br><span class="line">test2.f();</span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>答案是 <code>1 2 1</code>，解释最后一个为什么还是 <code>1</code>，因为后面又实例化了一个新的对象，和之前的对象地址当然不是一个地方了，<code>d</code>的初始值都是 <code>0</code>。</p></div></div><h3 id="第二题-1"><a href="#第二题-1" class="headerlink" title="第二题"></a>第二题</h3><p>看看下面代码会输出什么？</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">typeof</span>(<span class="built_in">arguments</span>));</span><br><span class="line">&#125;</span><br><span class="line">test(); <span class="comment">// </span></span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>答案是 <code>object</code>，因为 <code>arguments</code>是类数组（类似于数组的对象，即用对象模拟的数组）</p></div></div><h3 id="第三题-1"><a href="#第三题-1" class="headerlink" title="第三题"></a>第三题</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> test = <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(a)); <span class="comment">//</span></span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>答案是 <code>undefined</code>，函数表达式是忽略函数名的，等于 <code>a</code> 根本没有。相当于 <code>a</code> 没有申明，如果直接打印会直接报错，但是 <code>typeof</code>的话会打印 <code>undefined</code>。</p></div></div>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「JavaScript灵魂之问」前端知识梳理之 JS 篇（上篇）</title>
      <link href="posts/2020916/"/>
      <url>posts/2020916/</url>
      
        <content type="html"><![CDATA[<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="typeof-知多少"><a href="#typeof-知多少" class="headerlink" title="typeof 知多少"></a>typeof 知多少</h3><p>前置知识：</p><p><code>typeof</code> 判断数据类型会输出如下这些：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">number string boolean object <span class="literal">undefined</span> <span class="function"><span class="keyword">function</span></span></span><br></pre></td></tr></table></figure><p>需要注意的：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(<span class="literal">null</span>)) <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(<span class="literal">undefined</span>)) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>开门见山，下面输出会是什么？</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(<span class="number">1</span> -<span class="string">&#x27;1&#x27;</span>))</span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p><code>number</code>，你有没有中招呢？</p></div></div><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(<span class="string">&#x27;1&#x27;</span> -<span class="string">&#x27;1&#x27;</span>))</span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>还是<code>number</code>，诶？怎么肥事？为啥不是 <code>string</code> 呢？</p></div></div><p>上面两个题，答的怎么样呢？后续讲解显示/隐式类型转换时会给大家解答，接着继续 GO！</p><p>下面代码会是怎样的结果？</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a)</span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>可能你会说输出 <code>undefined</code>，但你又入坑了…答案是会<strong>报错</strong>。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/2020091322404744.png#pic_center" alt=""></p></div></div><p>好的，接下来继续，我再来变一下，下面又会输出什么？还是会报错吗？</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(a))</span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>答案是 <code>undefined</code> ，又中招了？ 这里 <code>a</code> 没声明，判断类型当然是 <code>undefined</code>呐！</p></div></div><p>go on ! 那么下面这个代码我先提示一下，有坑，接上一题，我们得到了 <code>undefined</code>，下面这题我们又套了一层 <code>typeof</code> ，按照开头提到的注意点，会是 <code>undefined</code>吗？</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(<span class="keyword">typeof</span>(a)))</span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>答案是 <code>string</code>，在下一题进行解释。</p></div></div><p>下一题，这个应该是输出？</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(<span class="keyword">typeof</span>(<span class="number">123</span>)))</span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>答案还是 <code>string</code>（这里要解释了，不然就要哭了┭┮﹏┭┮），原因是 <code>typeof</code> 判断数据类型时，会返回字符串形式的类型，例如上上题的<code>typeof(typeof(a))</code>，里面会返回一个 <code>&#39;undefined&#39;</code>这样的结果，而 <code>typeof(typeof(123))</code> 里面会返回一个<code>&#39;number&#39;</code>。因此我们再次 <code>typeof</code> 时，就会返回 <code>string</code> 类型。（恍然大悟，给自己鼓个掌~）</p></div></div><h3 id="显示、隐式类型转换"><a href="#显示、隐式类型转换" class="headerlink" title="显示、隐式类型转换"></a>显示、隐式类型转换</h3><h4 id="显示转换"><a href="#显示转换" class="headerlink" title="显示转换"></a>显示转换</h4><p>搞简单点，先来看看显示转换吧：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">&#x27;123&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(<span class="built_in">Number</span>(a)) + <span class="string">&#x27;-&#x27;</span> + <span class="built_in">Number</span>(a))</span><br></pre></td></tr></table></figure><p>显然会输出数字 <code>123</code></p><p>我们把 <code>a</code> 改成 字符串 <code>&#39;true&#39;</code>，又会输出什么呢？</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">&#x27;true&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(<span class="built_in">Number</span>(a)) + <span class="string">&#x27;-&#x27;</span> + <span class="built_in">Number</span>(a))</span><br></pre></td></tr></table></figure><p>此时会输出 <code>NaN</code>，如果把 a 改成 <code>true</code>，就会输出数字 <code>1</code>（即改成下述代码）。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="literal">true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(<span class="built_in">Number</span>(a)) + <span class="string">&#x27;-&#x27;</span> + <span class="built_in">Number</span>(a))</span><br></pre></td></tr></table></figure><p>继续，来点特殊一点的东西：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="literal">null</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(<span class="built_in">Number</span>(a)) + <span class="string">&#x27;-&#x27;</span> + <span class="built_in">Number</span>(a))</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="literal">undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(<span class="built_in">Number</span>(a)) + <span class="string">&#x27;-&#x27;</span> + <span class="built_in">Number</span>(a))</span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>对于 <code>null</code>，结果会输出数字 <code>0</code><br>对于 <code>undefined</code>，结果会输出 <code>NaN</code></p></div></div><p>下面给出一些其他例子，小伙伴们可以好好消化一下。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;a&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(<span class="built_in">Number</span>(a)) + <span class="string">&#x27;-&#x27;</span> + <span class="built_in">Number</span>(a)) <span class="comment">// number-NaN</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;1a&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(<span class="built_in">Number</span>(a)) + <span class="string">&#x27;-&#x27;</span> + <span class="built_in">Number</span>(a))<span class="comment">// number-NaN</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">3.14</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(<span class="built_in">Number</span>(a)) + <span class="string">&#x27;-&#x27;</span> + <span class="built_in">Number</span>(a))<span class="comment">// number-3.14</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(<span class="literal">NaN</span>)) <span class="comment">// number</span></span><br></pre></td></tr></table></figure><p>接下来，我们一起来探讨一下 <code>parseInt</code>：</p><p>还是先来个简单的热热身，我们知道 <code>parseInt</code>会将数字转换成整形，例如：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">&#x27;123&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(<span class="built_in">parseInt</span>(a)) + <span class="string">&#x27;-&#x27;</span> + <span class="built_in">parseInt</span>(a)) <span class="comment">//number-123</span></span><br></pre></td></tr></table></figure><p>那么，对于下面这个情况呢？</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="literal">true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(<span class="built_in">parseInt</span>(a)) + <span class="string">&#x27;-&#x27;</span> + <span class="built_in">parseInt</span>(a))</span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>答案是 <code>number-NaN</code>，因为 <code>parseInt</code>不会对非数字进行取整操作。</p><p>对于 <code>true</code>、<code>false</code>、<code>undefined</code>、<code>null</code>、<code>NaN</code> 都会输出 <code>NaN</code>。如果是小数，不会四舍五入，而是直接舍弃小数点后的位数。</p></div></div><p><strong>parseInt()更多用法：</strong></p><p><code>parseInt()</code> 函数可解析一个字符串，并返回一个整数。</p><table><thead><tr><th align="center">参数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">string</td><td align="center">必需。要被解析的字符串。</td></tr><tr><td align="center">radix</td><td align="center">可选。表示要解析的数字的基数。该值介于 2 ~ 36 之间。如果省略该参数或其值为 0，则数字将以 10 为基础来解析。如果它以 “0x” 或 “0X” 开头，将以 16 为基数。如果该参数小于 2 或者大于 36，则 parseInt() 将返回 NaN。</td></tr></tbody></table><p>直接看下面例子，应该就能明白了</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">&quot;10&quot;</span>);<span class="comment">//返回 10</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&quot;19&quot;</span>,<span class="number">10</span>);<span class="comment">//返回 19 (10+9)</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&quot;11&quot;</span>,<span class="number">2</span>);<span class="comment">//返回 3 (2+1)</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&quot;17&quot;</span>,<span class="number">8</span>);<span class="comment">//返回 15 (8+7)</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&quot;1f&quot;</span>,<span class="number">16</span>);<span class="comment">//返回 31 (16+15)</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&quot;010&quot;</span>);<span class="comment">//未定：返回 10 或 8</span></span><br></pre></td></tr></table></figure><p>最后，再来两个输出，结束我们的 <code>parseInt</code> 的介绍</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">&#x27;abc123&#x27;</span>)) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">&#x27;123abc456&#x27;</span>)) <span class="comment">// 123</span></span><br></pre></td></tr></table></figure><p><strong>parseFloat()用法（保留小数位数）：</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseFloat</span>(<span class="string">&#x27;3.1415926&#x27;</span>).toFixed(<span class="number">2</span>)) <span class="comment">// 3.14</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseFloat</span>(<span class="string">&#x27;3.1415926&#x27;</span>).toFixed(<span class="number">4</span>)) <span class="comment">// 3.1416</span></span><br></pre></td></tr></table></figure><hr/><p>上述我们进行了字符串到整数的转换，下面我们介绍整数到字符串的转换：</p><p>由于还算比较简单，这里我就直接上代码了。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="number">123</span> + <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">let</span> str1 = <span class="number">123</span></span><br><span class="line">str1 = str1.toString()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(str)) <span class="comment">//string</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(str1)) <span class="comment">// string</span></span><br></pre></td></tr></table></figure><p>比较特殊的是，下面会报错，因为 <code>null</code> 和 <code>undefined</code> 会报错。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="literal">null</span></span><br><span class="line"><span class="keyword">let</span> str1 = <span class="literal">undefined</span></span><br><span class="line">str = str.toString()</span><br><span class="line">str1 = str1.toString()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(str)) <span class="comment">// error</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(str1)) <span class="comment">// error</span></span><br></pre></td></tr></table></figure><p>另外， <code>toString()</code>也能传一个基数，可以进行进制转换。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">10</span></span><br><span class="line"><span class="built_in">console</span>.log(num.toString(<span class="number">2</span>)) <span class="comment">// 1010</span></span><br></pre></td></tr></table></figure><hr/><p>接下来，我们探讨一下 <code>Boolean</code>，直接看下面几个输出就好了，记住下面几个 <code>false</code>就行，其它就为 <code>true</code> 了。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="number">1</span>)) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="literal">null</span>)) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="literal">undefined</span>)) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="literal">NaN</span>)) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="string">&quot;&quot;</span>)) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="number">0</span>)) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h4 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h4><p>开门见山，还是先看一道题，注意隐式转换标题！</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">&#x27;123&#x27;</span></span><br><span class="line">a++</span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>答案是 <code>124</code>，因为看到 <code>a++</code> 操作，会有一个 <code>Number(a)</code> 的操作，然后数字自加，得到 <code>124</code>。</p></div></div><p>再来看一道吧：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">&#x27;a&#x27;</span> + <span class="number">1</span></span><br><span class="line"><span class="built_in">console</span>.log(a) </span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>答案是 <code>a1</code>，这应该好理解，此时将 <code>1</code> 进行 <code>String(1)</code> 的操作，然后进行字符串拼接。</p></div></div><p>接下来，再给几个样例，小伙伴们看一看就好了。<code>(*^▽^*)</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">&#x27;3&#x27;</span> &gt; <span class="number">2</span></span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// true</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">1</span> == <span class="string">&#x27;1&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>下面来一道经典题，会输出什么？</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span> === <span class="string">&#x27;1&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>答案是 <code>false</code>，因为 <code>===</code>是全等于，不会进行隐式转换，而上面 <code>==</code> 是会进行隐式转换的。</p></div></div><p>继续，会输出什么？</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="literal">NaN</span> == <span class="literal">NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>答案是 <code>false</code>，因为和谁都不相等，连自己也不相等。</p></div></div><p>继续，会输出什么？难倒你为止！</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">4</span> &gt; <span class="number">3</span> &gt; <span class="number">2</span> </span><br><span class="line"><span class="keyword">let</span> b = <span class="number">2</span> &gt; <span class="number">1</span> == <span class="number">1</span>  </span><br><span class="line"><span class="built_in">console</span>.log(a,b)</span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>答案是 <code>false</code> 和 <code>true</code> ，因为 <code>4 &gt; 3</code> 会返回 <code>true</code> ，然后再隐式转换为 <code>1</code>，下面类似。</p></div></div><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="literal">undefined</span> &gt; <span class="number">0</span> </span><br><span class="line"><span class="keyword">let</span> b = <span class="literal">undefined</span> == <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> c = <span class="literal">undefined</span> &lt; <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> d = <span class="literal">undefined</span> == <span class="literal">undefined</span></span><br><span class="line"><span class="keyword">let</span> e = <span class="literal">undefined</span> == <span class="literal">null</span></span><br><span class="line"><span class="keyword">let</span> f = <span class="literal">null</span> &gt; <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> g = <span class="literal">null</span> == <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> h = <span class="literal">null</span> &lt; <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a,b,c,d,e,f,g,h)</span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>答案是 <code>false false false true true false false false</code>，因为 <code>null</code> 和 <code>undefined</code> 只和它们比才相等。</p></div></div><p><strong>补充：</strong></p><p>显示转换那里，我们介绍了字符串转整数的几种方式，还例举了很多题目，现在再补充一个：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">&#x27;123&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(+ a) + <span class="string">&#x27;-&#x27;</span> + +a) <span class="comment">// number-123</span></span><br></pre></td></tr></table></figure><p>有了前面转换知识了，那就看看下面会输出什么吧</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="literal">NaN</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="string">&#x27;123&#x27;</span></span><br><span class="line"><span class="keyword">let</span> c = <span class="string">&#x27;a&#x27;</span></span><br><span class="line"><span class="keyword">let</span> d = <span class="literal">null</span></span><br><span class="line"><span class="keyword">let</span> e = <span class="literal">undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(a))</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(b))</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(c))</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(d))</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(e))</span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>答案</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure></div></div><p>最后的最后，我们回到开头让你想不明白的问题，现在再来做一下吧</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(<span class="number">1</span> -<span class="string">&#x27;1&#x27;</span>))</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(<span class="string">&#x27;1&#x27;</span> - <span class="string">&#x27;1&#x27;</span>))</span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>答案都是 <code>number</code>，不解释了哈</p></div></div><hr/><h2 id="函数基础"><a href="#函数基础" class="headerlink" title="函数基础"></a>函数基础</h2><h3 id="函数种类、字面量"><a href="#函数种类、字面量" class="headerlink" title="函数种类、字面量"></a>函数种类、字面量</h3><p>开门见山，下面代码会输出什么，不知道小伙伴平常有咩有想过这类问题</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> test = <span class="function"><span class="keyword">function</span> <span class="title">test1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line">test()</span><br><span class="line">test1()</span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>答案是 <code>1</code> 和 <code>报错</code>，报错信息如下：</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200914140339661.png#pic_center" alt=""><br>这是为什么呢？实际上，我们申明了一个变量 <code>test</code>，把这个函数 <code>test1</code>赋给它的时候，就已经把这个变量赋予了<strong>函数</strong>的功能，调用 <code>test()</code>方法当然能够正常运行，输出 <code>1</code>。而对于表达式赋值，会自动忽略后面的函数名称，也就是说写与不写并不影响 <code>test()</code>方法的执行。不信，看看下面代码会输出什么？</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> test = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line">test() <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>那这样，是不是说 <code>test1</code>完全没作用了，那写着干嘛，还多几个字符。<strong>当然不是！</strong>，<code>test1</code>在函数体内部是可见的，而在外部却不可见，通过这样，我们就可以实现<strong>递归操作</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> test = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而对于上述代码，后面函数体没有名字，我们称之为 <strong>匿名函数</strong>，是不是有点印象了，原来就是这东西，哟西~</p><p>而通过这种方式赋值的表达式，我们称之为 <strong>匿名函数表达式</strong>，也称为 <strong>函数字面量</strong>，这些专有名词一出来，瞬间觉得有点逼格了有没有！</p><p>字面量这种东西，简单来说就是数据，例如下述，有<code>数字字面量，字符串字面量，数组字面量</code>等等。简单理解就是，对于赋值的过程，右边的数据就是字面量。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="string">&#x27;111&#x27;</span></span><br><span class="line"><span class="keyword">var</span> c = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure></div></div><h3 id="形参实参映射"><a href="#形参实参映射" class="headerlink" title="形参实参映射"></a>形参实参映射</h3><p>补充：如何获取形参和实参对应的长度？</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span> (<span class="params">a,b</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(test.length)  <span class="comment">// 形参的长度 2</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.length) <span class="comment">// 实参的长度 3</span></span><br><span class="line">&#125;</span><br><span class="line">test(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>我想小伙伴们应该清楚实参和形参是什么玩意，但是我们可以更改实参的值吗？例如下述代码，会输出什么呢？</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  a =<span class="number">3</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line">test(<span class="number">1</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>答案是 <code>3</code>，我们可以修改实参的值。</p></div></div><p>刚刚那题只是简单热个身，继续下一题吧，我们可以改变 <code>b</code> 的值吗？（提示：注意我并没有传对应实参哦~）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  b = <span class="number">3</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">test(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>答案是 <code>undefined</code>，因此对于上一题表述，要修改一下：对于实参传递过来确定的值，我们是可以进行修改的，而如果实参并没有传递值过来，我们是不能进行修改的。这就是<strong>形参和实参的映射关系</strong>。</p><p>简单解释一下<strong>形参和实参的映射关系</strong>，其实<strong>实参</strong>和<strong>形参</strong>不能说是一类的，看上述代码，我们可以通过 <code>arguments</code> 来获取我们的实参，可以看做是一个数组里面的某一项值，而数组是存放<strong>堆内存</strong>的，而对应我们形参其实是存放在<strong>栈内存</strong>的，它们之间会有一个映射关系，并且是一对一对应的，上述我们实参没有对<code>b</code>进行赋值，尽管修改了形参，但改变不了我们的 <code>arguments[1]</code> 就是这个道理。（没有建立一对一映射关系）。</p></div></div><h2 id="让人费解的-GO-和-AO"><a href="#让人费解的-GO-和-AO" class="headerlink" title="让人费解的 GO 和 AO"></a>让人费解的 GO 和 AO</h2><h3 id="作用域引入"><a href="#作用域引入" class="headerlink" title="作用域引入"></a>作用域引入</h3><p>再来一道引申题，为后续内容做铺垫。下面 <code>a b c</code> 分别会输出什么？</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test1</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a)  <span class="comment">// </span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">test2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> c = <span class="number">3</span></span><br><span class="line">    <span class="built_in">console</span>.log(b); <span class="comment">// </span></span><br><span class="line">  &#125;</span><br><span class="line">  test2();</span><br><span class="line">  <span class="built_in">console</span>.log(c); <span class="comment">// </span></span><br><span class="line">&#125;</span><br><span class="line">test1();</span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>答案是 <code>1 2 报错</code>，这就牵扯到 <code>scope</code> 问题了，简单理解就是函数内部能访问外面的变量，而函数外面却不能访问内部的变量，也就是<strong>闭包</strong>问题。（这个后文会提到）</p></div></div><h3 id="函数默认参数"><a href="#函数默认参数" class="headerlink" title="函数默认参数"></a>函数默认参数</h3><p>如果实参没有赋值，那么形参怎样设置默认参数呢？说到默认参数，我想你应该会想到如下代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">a = <span class="number">1</span>, b = <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a)</span><br><span class="line">  <span class="built_in">console</span>.log(b)</span><br><span class="line">&#125;</span><br><span class="line">test() <span class="comment">// 1 1</span></span><br></pre></td></tr></table></figure><p>好的，上述问题算是开胃小菜，我们继续，我如果给 <code>a</code> 设定默认值，而 <code>b</code> 通过实参传递过来呢？可以实现吗？之前没有传参的话，不是默认打印 <code>undefined</code>吗，那我现在给 <code>a</code> 传递一个 <code>undefined</code>，是不是就会定为默认值。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">a = <span class="number">1</span>, b</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a)</span><br><span class="line">  <span class="built_in">console</span>.log(b)</span><br><span class="line">&#125;</span><br><span class="line">test(<span class="literal">undefined</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>答案是可以的，上述代码输出结果为 <code>1 2</code>。简单解释一下，在之前我们将了形参实参是有一个映射关系，对于堆内存 <code>arguments</code> 里面，如果给了 <code>undefined</code>，那么就会去栈内存形参里面找，如果不为 <code>undefined</code>，则会设置形参的默认值。（其实这是 <code>es6</code> 的语法了）</p><p>那么，可以用<code>es5</code>的方式实现一下吗？（当然可以，见代码）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  a = <span class="built_in">arguments</span>[<span class="number">0</span>] || <span class="number">1</span></span><br><span class="line">  b = <span class="built_in">arguments</span>[<span class="number">1</span>] || <span class="number">1</span></span><br><span class="line">  <span class="built_in">console</span>.log(a)</span><br><span class="line">  <span class="built_in">console</span>.log(b)</span><br><span class="line">&#125;</span><br><span class="line">test(<span class="literal">undefined</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure></div></div><h3 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h3><p>预编译总结一下就是如下几点：</p><ul><li>检查通篇的语法错误</li><li>解释一行，执行一行</li></ul><p>下面这两段代码，熟悉的同学一下就明白了，<strong>面试常考</strong>的经典题！</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">test()</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>这就扯到了函数声明提升和变量提升相关的问题了。这里总结整理一下：</p><p><strong>函数声明会进行整体的提升，而变量只有声明进行了提升，赋值不会提升</strong></p><p>关于变量那块，举例下面代码，其实是有两个步骤：第一，进行变量声明 <code>var a;</code> 第二，进行赋值操作，<code>a = 1;</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>好了，这里我就认为你已经理解了提升相关的知识了，我们来看一道题吧：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>答案是<code>[Function: a]</code> （即函数 <code>a</code>），这里可能一下也想不明白，我们先来讲一下知识，再来解决这个问题吧。</p><p>讲解暗示全局变量 <code>imply golbal variable</code></p><p>下面代码会输出 <code>1</code>，比较简单，就直接说答案了。实际上这里就暗示全局变量了，因为全局有一个 <code>window</code>对象 ，下面代码也可以这样表示 <code>window.a = 1</code>，所有权归 <code>window</code>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br></pre></td></tr></table></figure><p>这又让我想到了下述代码，<code>b</code> 能打印出来吗？还是会报错？</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = b = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">test();</span><br><span class="line"><span class="built_in">console</span>.log(b)</span><br></pre></td></tr></table></figure><p>答案是 <code>1</code>，能打印出来 <code>b</code>，这种写法就是经典的<strong>变量泄露</strong>问题。而 <code>a</code>没办法打印，因为它是<code>test</code>函数的局部变量，相当于闭包内的变量，外层没办法访问闭包内的变量。</p></div></div><p>继续，这次加大一点难度。下面代码又分别输出什么呢？</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">  <span class="keyword">var</span> b = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">  <span class="built_in">console</span>.log(b)</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">d</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">test(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>放答案之前，先总结一下知识点，函数在执行之前，会生成一个 <code>AO</code>（<code>activation object</code>，也称为<strong>活动对象</strong>或者<strong>函数上下文</strong>）这个<code>AO</code>会按照如下形式创建：</p><ul><li>第一步：寻找函数里的形参和变量声明</li><li>第二步：将实参的参数值赋值给形参</li><li>第三步：寻找函数声明，然后赋值函数体</li><li>第四步：执行</li></ul><p>下述代码是预编译（即函数执行之前<code>AO</code>对象的结果）：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">AO = &#123;</span><br><span class="line"> a: <span class="literal">undefined</span> -&gt; <span class="number">2</span> -&gt; <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) (<span class="params"></span>)</span></span><br><span class="line"><span class="function"> <span class="title">b</span>: <span class="title">undefined</span></span></span><br><span class="line"><span class="function"> <span class="title">d</span>: <span class="function"><span class="keyword">function</span> <span class="title">d</span>(<span class="params"></span>) </span>&#123;&#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p>下述代码是执行函数之后<code>AO</code>对象的结果：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">AO = &#123;</span><br><span class="line"> a: <span class="literal">undefined</span> -&gt; <span class="number">2</span> -&gt; <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) (<span class="params"></span>) -&gt; 1</span></span><br><span class="line"><span class="function"> <span class="title">b</span>: <span class="title">undefined</span> -&gt; <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span></span><br><span class="line"><span class="function"> <span class="title">d</span>: <span class="function"><span class="keyword">function</span> <span class="title">d</span>(<span class="params"></span>) </span>&#123;&#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p>直接看着上述执行完后的<code>AO</code>，对于第一个输出，由与在赋值 <code>a</code> 为 <code>1</code> 之前，所以我们直接打印 <code>Function: a</code>，对于第二个输出，对 <code>a</code> 变量进行了赋值为 <code>1</code> 的操作，所以取 <code>AO</code> 对象中的最后一个 <code>1</code>，打印 1，对于第三个输出，没有其它赋值操作了，直接输出 1 ，对于 <code>b</code>，输出 <code>Function: b</code>，这个不需要太多解释。</p><p>最后，给出例题的答案：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="built_in">Function</span>: a]</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">[<span class="built_in">Function</span>: b]</span><br></pre></td></tr></table></figure></div></div><p>下面来一道例题，巩固一下，小伙伴们可以自己拿过去做一遍。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">a,b</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br><span class="line">  c = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> c;</span><br><span class="line">  a = <span class="number">5</span>;</span><br><span class="line">  b = <span class="number">6</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(b); <span class="comment">// 6</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">d</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">  <span class="built_in">console</span>.log(b) <span class="comment">// 6</span></span><br><span class="line">&#125;</span><br><span class="line">test(<span class="number">1</span>)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">AO = &#123;</span></span><br><span class="line"><span class="comment">  a: undefined -&gt; 1 -&gt; 5</span></span><br><span class="line"><span class="comment">  b: undefined -&gt; function b()&#123;&#125; -&gt; 6</span></span><br><span class="line"><span class="comment">  c: undefined -&gt; 0</span></span><br><span class="line"><span class="comment">  d: function d()&#123;&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><hr/><p>接下来，换类型了哈，下面会输出什么呢？</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>答案是 <code>1</code>，不用过多解释。</p><p>举上述例子是为了引出下文，因为这已经不是函数内部的问题了，是<strong>全局</strong>的问题了。<code>JS</code>执行之前，会产生一个叫做 <code>GO</code> 的东西，也称为 <code>global object</code>（全局上下文），也会按照如下步骤进行创建：</p><ul><li>第一步：寻找变量声明</li><li>第二步：寻找函数声明</li><li>第三部：执行</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">GO = &#123;</span><br><span class="line">a: <span class="literal">undefined</span> -&gt; <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;&#125; -&gt; <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，答案为 <code>1</code>。实际 <code>GO</code>，就是 <code>window</code>，<code>window</code>存储过程就是这样的！</p></div></div><p>好的，继续下一题，又会输出什么？</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a,b)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> b = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>答案是 <code>[Function: a] undefined</code>，这个答案也许和你想的完全相反，有没有？按照 <code>GO</code>来解决这道题吧！</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">GO = &#123;</span><br><span class="line">a: <span class="literal">undefined</span> -&gt; <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">b: <span class="literal">undefined</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是因为在 <code>console.log(a,b)</code>在 <code>var b = function() {}</code>之前，此时还没有对 <code>b</code> 变量进行赋值，而 <code>a</code>通过函数声明整体提升，会输出 <code>funtion a() {}</code>，如果上述代码改成如下代码 <code>b</code>变量就会有对应值啦。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a,b)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure></div></div><hr/><p>回到我们开头的一道题，现在解决它应该没问题了，会输出什么呢？</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>由于并没有执行函数，我们不用 <code>AO</code>，改用 <code>GO</code>，这道题其实和上一道题差不多，因为我们 <code>console.log(a)</code> 在赋值操作之前，因此我们不会有 <code>1</code>的结果，所以我们会打印 <code>function a()&#123;&#125;</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">GO = &#123;</span><br><span class="line">  a: <span class="literal">undefined</span> -&gt; <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加大难度，看这一题，结合上述所说 <code>AO</code> 和 <code>GO</code> 来做，试一试！</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(b);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">a(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>答案：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="built_in">Function</span>: a]</span><br><span class="line">[<span class="built_in">Function</span>: a]</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure><p>我觉得能把这道题完整做出来， <code>AO</code> 和 <code>GO</code> 基本没啥问题了，现在来解释一波：</p><p>直接上 <code>GO</code>、<code>AO</code>，后续不再过多解释了，如果还有不明白的小伙伴，建议往上再复习一遍，相信可以独立解决这道题的 <code>(*^▽^*)</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">GO = &#123;</span><br><span class="line">  b: <span class="literal">undefined</span> -&gt; <span class="number">3</span></span><br><span class="line">  a: <span class="literal">undefined</span> -&gt; <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">AO = &#123;</span><br><span class="line">  a: <span class="literal">undefined</span> -&gt; <span class="number">1</span> -&gt; <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;&#125; -&gt; <span class="number">2</span></span><br><span class="line">  b: <span class="literal">undefined</span> -&gt; <span class="number">5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><p>不知道上一道题做的咋样，这道题我们找一点自信，看看会输出什么？</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a); </span><br><span class="line">  a = <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a); </span><br><span class="line">  <span class="keyword">var</span> a =<span class="number">3</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line">test();</span><br><span class="line"><span class="keyword">var</span> a;</span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>答案是 <code>undefined  2  3</code>，还是老规矩，直接上 <code>GO</code> 和 <code>AO</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">GO = &#123;</span><br><span class="line">  a: <span class="literal">undefined</span> -&gt; <span class="number">1</span></span><br><span class="line">  test: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">AO = &#123;</span><br><span class="line">  a: <span class="literal">undefined</span> -&gt; <span class="number">2</span> -&gt; <span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，可能就有小部分长的比较帅的小伙伴就要问了，为啥我第一个 <code>a</code> 不是打印 <code>1</code>呢，<code>GO</code> 里面不是可以取嘛？ 确实，但是你漏掉了前提， <code>AO</code>里面此时存在变量 <code>a</code>，就不会去<code>GO</code>里面找了，<strong>这里容易掉坑，必须注意！</strong></p></div></div><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(b); </span><br><span class="line">  <span class="keyword">if</span>(a)&#123;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  c = <span class="number">3</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(c); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line">test();</span><br><span class="line">a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a); </span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>答案： <code>undefined 3 1</code>，直接上 <code>GO</code> 和 <code>AO</code>，解释一个地方，为啥 <code>b</code> 要放在 <code>AO</code> 里面，因为 <code>js</code>在预编译时，不会管你什么条件执不执行，只看你是否进行了申明，简单来说，只要在函数内声明了，那么我们就放入 <code>AO</code>里面，否则放在全局的<code>GO</code>里面。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">GO = &#123;</span><br><span class="line">  a: <span class="literal">undefined</span> -&gt; <span class="number">1</span></span><br><span class="line">  test: <span class="function"><span class="title">fucntion</span>(<span class="params"></span>)</span>&#123;...&#125;</span><br><span class="line">  c: <span class="literal">undefined</span> -&gt; <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line">AO = &#123;</span><br><span class="line">  b: <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><p>最后，我们来几道题找点自信，结束这让人费解的 <code>GO</code> 和 <code>AO</code>吧，答案里我就只给 <code>GO</code> 和 <code>AO</code>啦，还不会方法的，建议多看上文内容，我就不作解释了。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">  a = <span class="number">1</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(test());</span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>答案： <code>[Function: a]</code> </p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">GO = &#123;</span><br><span class="line">  test: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line">AO = &#123;</span><br><span class="line">  a: <span class="literal">undefined</span> -&gt; <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;&#125; -&gt; <span class="number">1</span> -&gt; <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><p>继续，下一题：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  a = <span class="number">1</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(test())</span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>答案： <code>2</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">GO = &#123;</span><br><span class="line">  test: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line">AO = &#123;</span><br><span class="line">  a: <span class="literal">undefined</span> -&gt; <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;&#125; -&gt; <span class="number">1</span> -&gt; <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><p>加大难度，注意头发…</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">e</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">  <span class="built_in">arguments</span>[<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(e); </span><br><span class="line">  <span class="keyword">if</span>(a)&#123;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> c;</span><br><span class="line">  a = <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">var</span> a;</span><br><span class="line">  <span class="built_in">console</span>.log(b); </span><br><span class="line">  f = <span class="number">5</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(c); </span><br><span class="line">  <span class="built_in">console</span>.log(a); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line">test(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="built_in">console</span>.log(f);</span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>答案是 <code>2 undefined undefined  4 1 5</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">GO = &#123;</span><br><span class="line">  a: <span class="literal">undefined</span> -&gt; <span class="number">1</span></span><br><span class="line">  test: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;...&#125;</span><br><span class="line">  f: <span class="literal">undefined</span> -&gt; <span class="number">5</span></span><br><span class="line">&#125;</span><br><span class="line">AO = &#123;</span><br><span class="line">  e: <span class="literal">undefined</span> -&gt; <span class="number">1</span> -&gt; <span class="function"><span class="keyword">function</span> <span class="title">e</span>(<span class="params"></span>)</span>&#123;&#125; -&gt; <span class="number">2</span></span><br><span class="line">  b: <span class="literal">undefined</span> </span><br><span class="line">  a: <span class="literal">undefined</span> -&gt; <span class="number">4</span></span><br><span class="line">  c: <span class="literal">undefined</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><hr/><p>下面来一点加餐，我想小伙伴们一定是不满足于上述 <strong>“简单”</strong> 的输出题的，下面来几道经典笔试题：</p><p>第一题，下面会输出什么？</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="literal">false</span> + <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>答案是 <code>1</code>，存在隐式类型转换。</p></div></div><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="literal">false</span> == <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(b)</span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>答案是 <code>false</code>，存在隐式类型转换。</p></div></div><p>可能前两道题比较简单，看看下面这份代码吧：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span>(a) &amp;&amp; (-<span class="literal">true</span>) + (+<span class="literal">undefined</span>) + <span class="string">&#x27;&#x27;</span>)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>答案是 <code>1</code>，也是存在隐式类型转换，并且结合了上文的知识，一道非常不错的题。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(-<span class="literal">true</span>) <span class="comment">// -1</span></span><br><span class="line"><span class="built_in">console</span>.log(+<span class="literal">undefined</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span>(a) &amp;&amp; (-<span class="literal">true</span>) + (+<span class="literal">undefined</span>) + <span class="string">&#x27;&#x27;</span>)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(-<span class="string">&#x27;123&#x27;</span>)) <span class="comment">// number</span></span><br><span class="line"><span class="built_in">console</span>.log((-<span class="literal">true</span>) + (+<span class="literal">undefined</span>) + <span class="string">&#x27;&#x27;</span>) <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure></div></div><p>上面那道题解决了的话，下面这道题就是小试牛刀了，看看会输出什么？</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="number">1</span>+<span class="number">5</span>*<span class="string">&#x27;3&#x27;</span> === <span class="number">16</span>)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>答案是 <code>1</code>，虽然 <code>===</code> 不能进行隐式转换，但是没说左边或右边单独不能进行隐式转换呐。</p></div></div><p>继续，</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(!!<span class="string">&#x27; &#x27;</span> + !!<span class="string">&#x27;&#x27;</span> - !!<span class="literal">false</span> || <span class="string">&#x27;未通过&#x27;</span>);</span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>答案：<code>1</code>，因为左边 <code>1+0-0</code> 得到 <code>0</code>，所以不会走右边。</p></div></div><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.a || (<span class="built_in">window</span>.a = <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.a)</span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>答案：<code>1</code>，因为这里有 <code>()</code>括号，优先级最高，首先会对 <code>window.a</code> 赋值 <code>1</code>，然后判断左边 <code>window.a</code>为真，直接走下面输出函数。 而如果说先走左边<code>window.a</code> 判断为 <code>false</code>，然后走右边进行赋值为 <code>1</code>，最后打印 <code>1</code>，这样回答的话就错啦，<strong>没有考虑括号优先级</strong>。</p></div></div><h2 id="作用域、作用域链"><a href="#作用域、作用域链" class="headerlink" title="作用域、作用域链"></a>作用域、作用域链</h2><p>有了上文 <code>AO</code> 和 <code>GO</code> 的知识，作用域和作用域链就好理解了。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">a,b</span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(test.name) <span class="comment">// test</span></span><br><span class="line"><span class="built_in">console</span>.log(test.length) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>从上述代码我们可以知道，函数也是一种对象类型，它也有一些属性，比如 <code>test.name</code>，<code>test.length</code>，<code>test.prototype</code>。而对象，有些属性是我们无法访问的，这些属性是<code>JS</code>引擎`内部固有的隐式属性。可以理解为内部的私有属性。引出  [ [scope] ] ，总结整理如下：</p><ul><li>函数创建时，生成的一个 <code>JS</code>内部的隐式属性</li><li>函数存储作用域链的容器，作用域链存放的就是 <code>AO</code>（函数的执行期上下文）、<code>GO</code>（全局的执行期上下文），函数执行完成以后，<code>AO</code>是要销毁的，也就是说 <code>AO</code> 是一个<strong>即时</strong>的存储容器。</li></ul><p><a href="https://www.bilibili.com/video/BV1x441167iH?p=6">推荐观看视频：小野老师讲解作用域、作用域链</a></p><p>总结一下关系：</p><p>函数在被定义的时候，已经存在作用域了，已经形成作用域链了，已经创建了 <code>GO</code>，而当函数在执行的时候，才会生成自己的 <code>AO</code>。</p><h2 id="闭包基础"><a href="#闭包基础" class="headerlink" title="闭包基础"></a>闭包基础</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">test2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> test2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> c = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">var</span> test3 = test1();</span><br><span class="line">test3();</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200915151044651.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70#pic_center" alt=""></p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200915151130291.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70#pic_center" alt=""></p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200915151229453.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70#pic_center" alt=""><br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200915151524730.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70#pic_center" alt=""><br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200915151851765.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70#pic_center" alt=""><br>总结如下：</p><p>当内部函数被返回到外部并保存时，一定会产生闭包。闭包会产生原来的作用域链不释放，过度的闭包可能会导致内存泄露或者加载过慢。</p><p>接着，我们来一道简单题，热个身吧，下面会输出什么，注意，这里我通过数组的方式，抛出了两个函数。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> n = <span class="number">100</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    n++;</span><br><span class="line">    <span class="built_in">console</span>.log(n);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reduce</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    n--;</span><br><span class="line">    <span class="built_in">console</span>.log(n);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> [add,reduce];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = test();</span><br><span class="line">arr[<span class="number">0</span>]();</span><br><span class="line">arr[<span class="number">1</span>]();</span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>答案是 <code>101 100</code>，因为 <code>test</code>函数在执行的时候， <code>add</code> 和 <code>reduce</code> 函数已经被定义，此时作用域环境就是 <code>test</code>函数的 <code>AO</code>，而这个 <code>AO</code>里面就会创建一个 <code>n:100</code>，和对应函数，如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">test函数执行时：</span><br><span class="line">AO = &#123;</span><br><span class="line">n: <span class="literal">undefined</span> -&gt;<span class="number">100</span></span><br><span class="line">add : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;...&#125;</span><br><span class="line">reduce: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们抛出 <code>add</code> 和 <code>reduce</code> 函数时，此时 <code>AO</code>并不会销毁。只是把线剪断了，因为 <code>add</code> 和 <code>reduce</code> 作用域链还连着的。都会一起返回出去，然后给到外部全局变量使用，当我们操作 <code>add</code>函数时，就能访问原本 <code>test</code>函数创建的 <code>AO</code>，将 <code>n++</code>得到 <code>101</code>，然后操作 <code>reduce</code> 函数将此时 <code>n=101</code>进行 <code>--</code>操作得到 <code>100</code>，就是我们的最终答案了。</p></div></div><hr/><p>下面举一个比较好玩的例子，面包售卖进货管理系统。和上述代码思想一致，都是利用了闭包的思想。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 面包售卖进货管理</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">breadMgr</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> breadNum = num || <span class="number">10</span>;</span><br><span class="line">  <span class="comment">// 进货面包，每次进10个</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">supply</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    breadNum += <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(breadNum);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 售卖面包，每次卖一个</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">sale</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    breadNum--;</span><br><span class="line">    <span class="built_in">console</span>.log(breadNum);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> [supply,sale];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> breadMgr = breadMgr(<span class="number">50</span>);</span><br><span class="line">breadMgr[<span class="number">0</span>]();</span><br><span class="line">breadMgr[<span class="number">1</span>]();</span><br><span class="line">breadMgr[<span class="number">1</span>]();</span><br><span class="line">breadMgr[<span class="number">1</span>]();</span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>答案是 <code>60 59 58 57</code>，就不多解释了，和上一题代码几乎一致。</p></div></div><p>同样，我们也可以通过对象的形式，一起抛出去，见下面例子：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sunSched</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> sunSched = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="keyword">var</span> operation = &#123;</span><br><span class="line">    setSched: <span class="function"><span class="keyword">function</span>(<span class="params">thing</span>)</span>&#123;</span><br><span class="line">      sunSched = thing;</span><br><span class="line">    &#125;,</span><br><span class="line">    showSched: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;My Schedule on sunday is &quot;</span> + sunSched);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> operation;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> sunSched = sunSched();</span><br><span class="line">sunSched.setSched(<span class="string">&#x27;studying&#x27;</span>);</span><br><span class="line">sunSched.showSched(); <span class="comment">// My Schedule on sunday is studying</span></span><br></pre></td></tr></table></figure><h2 id="立即执行函数"><a href="#立即执行函数" class="headerlink" title="立即执行函数"></a>立即执行函数</h2><p>观察如下代码，我们发现函数都是放在 <code>GO</code> 里的，它不会自动释放，也就是说放在 <code>GO</code>里的函数我们可以直接调用，不用重新定义新的函数，想调用随时调用。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">test2(); <span class="comment">// 2</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test3</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  test1(); <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line">test3();</span><br></pre></td></tr></table></figure><p>在上述我们讨论了闭包，这一块我们来探讨立即执行函数，简单来说就是自动执行，执行完后立即释放。</p><p><code>IIFE - immediately - invoked - function - expression</code></p><p>立即执行函数有一个功能性的说法就是<strong>初始化函数</strong>。</p><p>下面，我们简单看一个立即执行函数的例子吧，重点学习语法，下面规范也是 <code>W3C</code>建议：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a+b);</span><br><span class="line">&#125;(<span class="number">1</span>,<span class="number">2</span>))</span><br></pre></td></tr></table></figure><p>下面写法也是可以的，但不是 <code>W3C</code>建议的写法。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">或者</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a+b);</span><br><span class="line">&#125;)(<span class="number">1</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>有的时候，我们想要拿到函数返回值，那么立即执行函数每次执行完都会立即释放，直接 <code>return</code>我们是拿不到的，该如何是好？</p><p>原来，立即执行函数也是有返回值的，我们可以将 <code>return</code> 的结果直接返回给一个变量存起来，如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> res = (<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;(<span class="number">1</span>,<span class="number">2</span>))</span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>总结一下：<code>()</code>包括的内容相当于<strong>表达式</strong>。</p><p>比较下面结果，思考一下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> test1 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a+b);</span><br><span class="line">&#125;(<span class="number">1</span>,<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test3</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure><p>得到的结果：<strong>一定是表达式才能被执行符号执行</strong>。</p><p>证明立即自执行函数执行完后立即释放：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> test = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(test); <span class="comment">// [Function: test]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> test1 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;()</span><br><span class="line"><span class="built_in">console</span>.log(test1);</span><br></pre></td></tr></table></figure><p>打印 <code>1 undefined</code> ，因为立即自执行函数执行完后，立即销毁，所以 <code>test1</code> 接收不到函数体。</p><p>补充：函数声明变成表达式的方法： + - ! &amp;&amp; ||</p><p>举个例子：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">+ <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>下面来一道经典面试题，将数组每一位都存放一个匿名函数，最后遍历执行时会打印什么？</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> arr = [];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">    arr[i] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> myArr = test();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">  myArr[i]();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>答案是 <code>10个10</code> ，其实是在 <code>test</code> 函数里面返回了 <code>10</code> 个匿名函数，而这 <code>10</code>个函数还没有执行，和上文闭包基础讲的例题一样，形成了一个闭包。原本 <code>test</code> 的 <code>AO</code> 中是有变量 <code>i</code>的，经过for循环，使得变量 <code>i</code> 变为 10了，而<code>test</code>的 <code>AO</code>只是剪掉了，而那十个匿名函数的作用域链还连着的。所以后面我们一个个执行的时候，拿到的还是 <code>test</code>里面的 <code>AO</code>的 <code>i</code>值。</p><p>那么，对于上述代码，如果想要打印<code>0-9</code>，要怎么做呢？ 根据当前标题，就可知道可以使用立即执行函数。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">test();</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> arr = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span> (<span class="params">j</span>) </span>&#123;</span><br><span class="line">      arr[j] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(j);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;(i))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> myArr = test();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  myArr[i]();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><p>接下来，再来一道面试题，看看会返回什么？</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fn = (</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">test1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">test2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">)();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(fn));</span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>答案是返回 <code>string</code> ，因为括号里的逗号运算，会返回最后一个，如下，会返回 <code>2</code>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log((<span class="number">1</span>,<span class="number">2</span>)); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>因此括号里面放两个函数，以逗号分隔，就会立即执行 <code>test2</code>，然后 <code>typeof</code> 之后，就会返回 <code>string</code>了。</p></div></div><p>继续，我们再来一道面试题：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123;&#125;)&#123;</span><br><span class="line">  a += <span class="keyword">typeof</span>(b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>答案是  <code>10undefined</code> ，解释一下，首先 <code>if</code> 判断是要执行的，然后 <code>(function b(){})</code>这个，是不是就是一个表达式了，然后忽略名称， <code>function(){}</code>，到下面的时候函数 <code>b</code>已经不存在了都。</p></div></div>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>某跳动面试官：请你设计一下ES6中 class 实现私有属性</title>
      <link href="posts/20201010/"/>
      <url>posts/20201010/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在上一篇 <a href="https://juejin.im/post/6881597417637511181">某跳动面试官：说说微信扫码登录背后的实现原理？</a> 文章发出之后，没想到有挺多点赞的，掘金社区前端小伙伴真是多啊，以后还是多多在掘金社区活跃起来吧，简单说一下我会整理的专栏系列：</p><p>之前，一直在 <code>CSDN</code> 平台发布博客，<a href="https://chocolate.blog.csdn.net/">超逸の学习技术博客</a>，发现前端活跃度不是很高，而在掘金社区我看到一系列优秀的文章，点赞数达到上千，访问量好几十万的也有，并且文章质量是真的高，能学习很多知识。</p><p>在这里，我会对一个问题进行研究，带着好奇心去看待问题，尽量用简洁易懂的话语呈现给大家，能把别人教会，对于自己而言也是蛮有成就感和收获的。</p><hr/><p>在此，分享一下上学期IT项目管理老师教课提到的人们能够记住的东西有如下规律：</p><ul><li>听到的内容的 5%</li><li>读过的内容的10%</li><li>见过的内容的 30%</li><li>讨论过的内容的 50%</li><li>亲自做的内容的 75%</li><li>教给别人所做过的事情的 90%</li></ul><p>如若有帮助到您，请<strong>一键三连</strong>，当然，本文表述有问题的地方，欢迎读者指正，也是一个学习的过程，谢谢~</p><h2 id="回归正文"><a href="#回归正文" class="headerlink" title="回归正文"></a>回归正文</h2><p>赶紧回到正题，这个问题也是和上一篇博客一样，也是在今年8月份的时候被问到过，当时知道class这个东西，在社区里面看过一些class继承相关知识，但是没有真正动手敲过代码，犹记得当时对话场景是这样的：</p><p>面试官：你应该了解过ES6吧？（这个当然），那好，那你知道ES6中有一个class，你可以设计实现它的私有属性吗？</p><p>我：emmm（此时我想了想，好像可以用闭包来做），我可以采用闭包的思想来做嘛？</p><p>面试官：当然可以（show me the code）</p><p>于是乎，我就写下了这一份代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">classA</span></span>&#123;</span><br><span class="line"><span class="comment">// xxx省略</span></span><br><span class="line"><span class="keyword">let</span> fun = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(++a);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// xxx省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中省略了一点点代码，但总体和上述代码差不多，现在回想过来，当时真是太可笑了，难怪面试官喊停来了一句，语法都不对。同时，当时写的时候也是焦头烂额的，因为这个语法代码也不是很熟，但今天我带着好奇心来解决这个问题。</p><h2 id="为什么会出现-class"><a href="#为什么会出现-class" class="headerlink" title="为什么会出现 class"></a>为什么会出现 class</h2><p>其实，学过 <code>java</code> 的小伙伴一定对 <code>class</code> 熟悉不过了，本人大二大三期间也是各种 <code>java</code> 代码写来写去。那为什么 <code>JS</code> 里面还要引入 <code>class</code> 呢？</p><p>在 es6 之前，虽然 JS 和 Java 同样都是 OOP （面向对象）语言，但是在 JS 中，只有对象而没有类的概念。</p><p>es6 中 class 的出现拉近了 JS 和传统 OOP 语言的距离。但是，它仅仅是一个<strong>语法糖</strong>罢了，不能实现传统 OOP 语言一样的功能。在其中，比较大的一个痛点就是私有属性问题。</p><h3 id="何为私有属性？"><a href="#何为私有属性？" class="headerlink" title="何为私有属性？"></a>何为私有属性？</h3><p>私有属性是面向对象编程（OOP）中非常常见的一个特性，一般满足以下的特点：</p><ul><li>能被class内部的不同方法访问，但不能在类外部被访问；</li><li>子类不能继承父类的私有属性。</li></ul><p>在 Java 中，可以使用 <code>private</code> 实现私有变量，但是可惜的是， JS 中并没有该功能。</p><h2 id="私有属性提案"><a href="#私有属性提案" class="headerlink" title="私有属性提案"></a>私有属性提案</h2><p>2015年6月，ES6发布成为标准，为了纪念这个历史性时刻，这个标准又被称为ES2015，至此，JavaScript中的 class 从备胎中转正。但是没有解决私有属性这个问题，产生了一个提案——在属性名之前加上 <code>#</code> ，用于表示私有属性。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  #a;  <span class="comment">// 定义私有属性</span></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">a, b</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.#a = a;</span><br><span class="line">    <span class="built_in">this</span>.b = b</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上述代码私有属性的声明，需要先经过Babel等编译器编译后才能正常使用。</p></blockquote><p>至于为什么不用 <code>private</code> 关键字呢？参考大佬说的就是有一大原因是向 Python 靠拢，毕竟从 es6 以来， JS 一直向着 Python 发展。</p><h2 id="如何设计实现私有属性呢？"><a href="#如何设计实现私有属性呢？" class="headerlink" title="如何设计实现私有属性呢？"></a>如何设计实现私有属性呢？</h2><p>上文我们介绍了class 出现原因，以及它没有解决私有属性这个问题，那么我们作为 <code>JSer</code> 们，如何自己设计一下呢？带着好奇心来探讨一下吧：</p><h3 id="约定命名"><a href="#约定命名" class="headerlink" title="约定命名"></a>约定命名</h3><p>目前使用最广的方式：<strong>约定命名</strong>，既然还没有解决，我们不是可以自己定义一下嘛，对于特殊命名的就把它当做私有属性使用不就可以了吗？大家都遵循这个规范，不就解决这个问题了吗？</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 约定命名 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassA</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">x</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>._x = x;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">getX</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> classa = <span class="keyword">new</span> ClassA(<span class="number">1</span>);</span><br><span class="line"><span class="comment">/* 此时可以访问我们自定义私有属性命名的_x */</span></span><br><span class="line"><span class="built_in">console</span>.log(classa._x); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(classa.getX()); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>显然，上述方法简单方便，大家按照规范来就可以了，也比较好阅读他人代码。</p><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包的一个好处就是可以保护内部属性，也是我开头想要实现的一种方式，做法就是将属性定义在 <code>constructor</code> 作用域内，如下代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 闭包 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassB</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">x</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> _x = x;</span><br><span class="line">    <span class="built_in">this</span>.getX = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> _x;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> classb = <span class="keyword">new</span> ClassB(<span class="number">1</span>);</span><br><span class="line"><span class="comment">/* 此时不可以访问我们自定义私有属性命名的_x */</span></span><br><span class="line"><span class="built_in">console</span>.log(classb._x); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(classb.getX()); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>显然，如果私有属性越来越多，那么看起来就很臃肿，对后续维护造成了一定的麻烦，对于他人阅读也是不太友好。同时呢，引用私有变量的方法又不能定义在原型链上。</p><h3 id="进阶版闭包"><a href="#进阶版闭包" class="headerlink" title="进阶版闭包"></a>进阶版闭包</h3><p>可以通过  <code>IIFE</code> （立即执行函数表达式） 建立一个闭包，在其中建立一个变量以及 class ，通过 class 引用变量实现私有变量。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 进阶版闭包 */</span></span><br><span class="line"><span class="keyword">const</span> classC = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> _x;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">ClassC</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">x</span>)</span> &#123;</span><br><span class="line">      _x = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">getX</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> _x;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ClassC;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> classc = <span class="keyword">new</span> classC(<span class="number">3</span>);</span><br><span class="line"><span class="comment">/* 此时不可以访问我们自定义私有属性命名的_x */</span></span><br><span class="line"><span class="built_in">console</span>.log(classc._x); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(classc.getX()); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>这种方式就有点 <strong>模块化</strong> 的思想了，关于模块化的知识，推荐之前的这篇文章：</p><p><a href="https://juejin.im/post/6881241853258104839">「查漏补缺」深度剖析JavaScript ES5/AMD/CMD/COMMONJS/ES6模块化（加薪必备）| 掘金技术征文-双节特别篇</a></p><hr/><h3 id="闭包的做法产生的问题？"><a href="#闭包的做法产生的问题？" class="headerlink" title="闭包的做法产生的问题？"></a>闭包的做法产生的问题？</h3><p>上述，我们用了闭包和进阶版闭包来解决私有属性这个问题，但是这是有问题的，我们以进阶版闭包为例：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 进阶版闭包带来的问题 */</span></span><br><span class="line"><span class="keyword">const</span> classC = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> _x;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">ClassC</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">x</span>)</span> &#123;</span><br><span class="line">      _x = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">getX</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> _x;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ClassC;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> classc1 = <span class="keyword">new</span> classC(<span class="number">3</span>);</span><br><span class="line"><span class="comment">/* 此时不可以访问我们自定义私有属性命名的_x */</span></span><br><span class="line"><span class="built_in">console</span>.log(classc1._x); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(classc1.getX()); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 问题引出：此时新创建一个实例 */</span></span><br><span class="line"><span class="keyword">let</span> classc2 = <span class="keyword">new</span> classC(<span class="number">4</span>);</span><br><span class="line"><span class="comment">/* 出现了问题：实例之间会共享变量 */</span></span><br><span class="line"><span class="built_in">console</span>.log(classc1.getX()); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><p>从上述代码可以发现，用闭包创建私有变量是不行的，实例之间会共享变量，就好像几个人都实例化了，但是操作地还是同一个属性，这显然是不可取的。</p><h3 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h3><p>利用 <code>Symbol</code> 变量可以作为对象 <code>key</code> 的特点，我们可以模拟实现更真实的私有属性。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Symbol */</span></span><br><span class="line"><span class="keyword">const</span> classD = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> _x = <span class="built_in">Symbol</span>(<span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">ClassD</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">x</span>)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>[_x] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">getX</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>[_x];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ClassD;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> classd = <span class="keyword">new</span> classD(<span class="number">4</span>);</span><br><span class="line"><span class="comment">/* 此时不可以访问我们自定义私有属性命名的_x */</span></span><br><span class="line"><span class="built_in">console</span>.log(classd._x); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(classd.getX()); <span class="comment">// 4</span></span><br><span class="line">classd[_x] = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(classd[_x]); <span class="comment">// ReferenceError: _x is not defined</span></span><br></pre></td></tr></table></figure><p>关于上述代码，我参考了大佬文章底下评论区的回答：</p><blockquote><p>Sysmol要配合 import/export 模板语法。比如A.js里面你定义了class A和Symbol（就用你的写法），对外只暴露class A。然后在别的js文件引入class A实例化，拿不到Symbol的值，而且无法通过’.’去访问变量名（Symbol唯一，不暴露外界拿不到）。这样才是私有。</p></blockquote><p>通过模板化的角度，我们对外暴露 <code>ClassD</code>，<code>Symbol</code> 唯一，不会暴露，外界拿不到，但是这个也不是毫无破绽，看如下代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(classd[<span class="built_in">Object</span>.getOwnPropertySymbols(classd)[<span class="number">0</span>]]); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><p>原来，ES6 的 <code>Object.getOwnPropertySymbols</code> 可以获取symbol属性，今天又学到了新东西 <code>(*^▽^*)</code></p><p>为了解决上述问题，我们又要引出一个新的东西：<strong>WeakMap</strong> </p><h3 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* WeakMap  */</span></span><br><span class="line"><span class="keyword">const</span> classE = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> _x = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">ClassE</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">x</span>)</span> &#123;</span><br><span class="line">      _x.set(<span class="built_in">this</span>, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">getX</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> _x.get(<span class="built_in">this</span>);;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ClassE;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> classe = <span class="keyword">new</span> classE(<span class="number">5</span>);</span><br><span class="line"><span class="comment">/* 此时不可以访问我们自定义私有属性命名的_x */</span></span><br><span class="line"><span class="built_in">console</span>.log(classe._x); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(classe.getX()); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><p>这种方式就很好解决了私有属性的问题，至于 <code>WeakMap 和 Map</code> 相关知识，我打算在下一篇文章继续探讨，这个知识目前也不算是特别了解，大概了解不能遍历、弱引用这些，可以关注后续的文章。</p><h3 id="关于-WeakMap-补充更新"><a href="#关于-WeakMap-补充更新" class="headerlink" title="关于 WeakMap 补充更新"></a>关于 WeakMap 补充更新</h3><hr/><p>10月12日补充更新</p><p>在评论区@HsuYang 小伙伴的提出的问题：如果是要支持多个私有变量的话，这儿用Map有没有啥问题呢？</p><p>于是我就尝试了一下多个私有变量，先看如下代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* WeakMap  */</span></span><br><span class="line"><span class="keyword">const</span> classE = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> _x = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">ClassE</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">x, y</span>)</span> &#123;</span><br><span class="line">      _x.set(<span class="built_in">this</span>, x);</span><br><span class="line">      _x.set(<span class="built_in">this</span>, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">getX</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> _x.get(<span class="built_in">this</span>);;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ClassE;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> classe = <span class="keyword">new</span> classE(<span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line"><span class="comment">/* 此时不可以访问我们自定义私有属性命名的_x */</span></span><br><span class="line"><span class="built_in">console</span>.log(classe.getX()); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><p>诶，发现问题了没有，我们最后输出的只有 <code>_y</code> 这个私有属性，原来出现了<strong>覆盖问题</strong>，那么该如何解决这个问题呢？</p><hr/><p>既然私有属性要和实例进行关联，那么是不是可以创建一个包含所有私有属性对应的对象来维护呢？这样所有私有属性就都存储在其中了，也就解决多个私有变量问题啦，同时，这种技术也有好处，就是在遍历属性时或者在执行 <code>JSON.stringify</code> 时不会展示出实例的私有属性。</p><p>但它依赖于一个放在类外面的可以访问和操作的 <code>WeakMap</code> 变量。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="comment">// 创建一个在每个实例中存储私有变量的对象</span></span><br><span class="line"><span class="keyword">const</span> internal = <span class="function">(<span class="params">obj</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!map.has(obj)) &#123;</span><br><span class="line">    map.set(obj, &#123;&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> map.get(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassE</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name, age</span>)</span> &#123;</span><br><span class="line">    internal(<span class="built_in">this</span>).name = name;</span><br><span class="line">    internal(<span class="built_in">this</span>).age = age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">userInfo</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;姓名：&#x27;</span> + internal(<span class="built_in">this</span>).name + <span class="string">&#x27;,年龄：&#x27;</span> + internal(<span class="built_in">this</span>).age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> classe1 = <span class="keyword">new</span> ClassE(<span class="string">&#x27;Chocolate&#x27;</span>, <span class="number">18</span>);</span><br><span class="line"><span class="keyword">const</span> classe2 = <span class="keyword">new</span> ClassE(<span class="string">&#x27;Lionkk&#x27;</span>, <span class="number">19</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(classe1.userInfo); <span class="comment">// 姓名：Chocolate,年龄：18</span></span><br><span class="line"><span class="built_in">console</span>.log(classe2.userInfo); <span class="comment">// 姓名：Lionkk,年龄：19</span></span><br><span class="line"><span class="comment">/* 无法访问私有属性 */</span></span><br><span class="line"><span class="built_in">console</span>.log(classe1.name); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(classe2.age); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><h3 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h3><p>在评论区@蜀 黍 小伙伴提出可以用 <strong>代理设置拦截</strong> 这种方式来做，现在来补充一下。</p><p>Proxy 是 JavaScript 中一项美妙的新功能，它将允许你有效地将对象包装在名为 Proxy 的对象中，并拦截与该对象的所有交互。我们将使用 Proxy 并遵照上面的 <strong>命名约定</strong> 来创建私有变量，但可以让这些私有变量在类外部访问受限。</p><p>Proxy 可以拦截许多不同类型的交互，但我们要关注的是 <code>get</code> 和 <code>set</code> ，Proxy 允许我们分别拦截对一个属性的读取和写入操作。创建 Proxy 时，你将提供两个参数，第一个是打算包裹的<strong>实例</strong>，第二个是您定义的希望拦截不同方法的 <strong>“处理器” 对象</strong>。</p><p>我们的处理器将会看起来像是这样：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  get: <span class="function"><span class="keyword">function</span>(<span class="params">target, key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key[<span class="number">0</span>] === <span class="string">&#x27;_&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Attempt to access private property&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target[key];</span><br><span class="line">  &#125;,</span><br><span class="line">  set: <span class="function"><span class="keyword">function</span>(<span class="params">target, key, value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key[<span class="number">0</span>] === <span class="string">&#x27;_&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Attempt to access private property&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    target[key] = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在每种情况下，我们都会检查被访问的属性的名称是否以下划线开头，如果是的话我们就抛出一个错误从而阻止对它的访问。</p><p>通过以上方法保留使用 <code>instanceof</code> 的能力（闭包那一块就出现了这个问题），但是此时又有一个新的问题：</p><p>当我们尝试执行 <code>JSON.stringify</code> 时会出现问题，因为它试图对私有属性进行格式化。为了解决这个问题，我们需要重写 <code>toJSON</code> 函数来仅<strong>返回“公共的”属性</strong>。我们可以通过更新我们的 <code>get</code> 处理器来处理 <code>toJSON</code> 的特定情况：</p><blockquote><p>注：这将覆盖任何自定义的 toJSON 函数。</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> get: <span class="function"><span class="keyword">function</span>(<span class="params">target, key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (key[<span class="number">0</span>] === <span class="string">&#x27;_&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Attempt to access private property&#x27;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key === <span class="string">&#x27;toJSON&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> target) &#123;</span><br><span class="line">      <span class="keyword">if</span> (key[<span class="number">0</span>] !== <span class="string">&#x27;_&#x27;</span>) &#123;           <span class="comment">// 只复制公共属性</span></span><br><span class="line">        obj[key] = target[key];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> obj;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> target[key];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么我们就可以整合一下代码了：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name, age</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>._name = name;</span><br><span class="line">    <span class="built_in">this</span>._age = age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">userInfo</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;姓名：&#x27;</span> + <span class="built_in">this</span>._name + <span class="string">&#x27;,年龄：&#x27;</span> + <span class="built_in">this</span>._age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  get: <span class="function"><span class="keyword">function</span> (<span class="params">target, key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key[<span class="number">0</span>] === <span class="string">&#x27;_&#x27;</span>) &#123; <span class="comment">// 访问私有属性，返回一个 error</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Attempt to access private property&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key === <span class="string">&#x27;toJSON&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> target) &#123; <span class="comment">// 只返回公共属性</span></span><br><span class="line">        <span class="keyword">if</span> (key[<span class="number">0</span>] !== <span class="string">&#x27;_&#x27;</span>) &#123;</span><br><span class="line">          obj[key] = target[key];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="function">() =&gt;</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target[key]; <span class="comment">// 访问公共属性，默认返回</span></span><br><span class="line">  &#125;,</span><br><span class="line">  set: <span class="function"><span class="keyword">function</span> (<span class="params">target, key, value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key[<span class="number">0</span>] === <span class="string">&#x27;_&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Attempt to access private property&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    target[key] = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> stu = <span class="keyword">new</span> <span class="built_in">Proxy</span>(<span class="keyword">new</span> Student(<span class="string">&#x27;Chocolate&#x27;</span>, <span class="number">21</span>), handler);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(stu.userInfo);           <span class="comment">// 姓名：Chocolate,年龄：21</span></span><br><span class="line"><span class="built_in">console</span>.log(stu <span class="keyword">instanceof</span> Student); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(stu));  <span class="comment">// &quot;&#123;&#125;&quot;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> stu) &#123;           </span><br><span class="line">  <span class="built_in">console</span>.log(key);  <span class="comment">// _name  _age</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们现在已经封闭了我们的私有属性，而预计的功能仍然存在，唯一的警告是我们的私有属性仍然可被遍历。<code>for(const key in stu)</code> 会列出 <code>_name</code> 和 <code>_age</code> 。</p><hr/><p>为了解决上述私有属性遍历问题，我又想到了可以操作对象属性对应的属性描述符，然后配置 <code>enumerable</code>，正好 <code>Proxy</code> 可以处理这个问题，它可以拦截对 <code>getOwnPropertyDescriptor</code> 的调用并操作我们的私有属性的输出，代码如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">getOwnPropertyDescriptor</span>(<span class="params">target, key</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> desc = <span class="built_in">Object</span>.getOwnPropertyDescriptor(target, key);</span><br><span class="line">  <span class="keyword">if</span> (key[<span class="number">0</span>] === <span class="string">&#x27;_&#x27;</span>) &#123;</span><br><span class="line">    desc.enumerable = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> desc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>详细内容可参考：</p><p><a href="https://cloud.tencent.com/developer/section/1191908">Object.getOwnPropertyDescriptor 参考文档</a></p><p>终于，我们迎来了最终完整版本，祝贺 <code>(*^▽^*)</code>，整合代码如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name, age</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>._name = name;</span><br><span class="line">    <span class="built_in">this</span>._age = age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">userInfo</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;姓名：&#x27;</span> + <span class="built_in">this</span>._name + <span class="string">&#x27;,年龄：&#x27;</span> + <span class="built_in">this</span>._age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  get: <span class="function"><span class="keyword">function</span> (<span class="params">target, key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key[<span class="number">0</span>] === <span class="string">&#x27;_&#x27;</span>) &#123; <span class="comment">// 访问私有属性，返回一个 error</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Attempt to access private property&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key === <span class="string">&#x27;toJSON&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> target) &#123; <span class="comment">// 只返回公共属性</span></span><br><span class="line">        <span class="keyword">if</span> (key[<span class="number">0</span>] !== <span class="string">&#x27;_&#x27;</span>) &#123;</span><br><span class="line">          obj[key] = target[key];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="function">() =&gt;</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target[key]; <span class="comment">// 访问公共属性，默认返回</span></span><br><span class="line">  &#125;,</span><br><span class="line">  set: <span class="function"><span class="keyword">function</span> (<span class="params">target, key, value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key[<span class="number">0</span>] === <span class="string">&#x27;_&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Attempt to access private property&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    target[key] = value;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 解决私有属性能遍历问题，通过访问属性对应的属性描述符，然后设置 enumerable 为 false</span></span><br><span class="line">  <span class="function"><span class="title">getOwnPropertyDescriptor</span>(<span class="params">target, key</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> desc = <span class="built_in">Object</span>.getOwnPropertyDescriptor(target, key);</span><br><span class="line">    <span class="keyword">if</span> (key[<span class="number">0</span>] === <span class="string">&#x27;_&#x27;</span>) &#123;</span><br><span class="line">      desc.enumerable = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> stu = <span class="keyword">new</span> <span class="built_in">Proxy</span>(<span class="keyword">new</span> Student(<span class="string">&#x27;Chocolate&#x27;</span>, <span class="number">21</span>), handler);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(stu.userInfo);           <span class="comment">// 姓名：Chocolate,年龄：21</span></span><br><span class="line"><span class="built_in">console</span>.log(stu <span class="keyword">instanceof</span> Student); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(stu));  <span class="comment">// &quot;&#123;&#125;&quot;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> stu) &#123;           <span class="comment">// No output 不能遍历私有属性</span></span><br><span class="line">  <span class="built_in">console</span>.log(key);</span><br><span class="line">&#125;</span><br><span class="line">stu._name = <span class="string">&#x27;Lionkk&#x27;</span>;                  <span class="comment">// Error: Attempt to access private property</span></span><br></pre></td></tr></table></figure><h3 id="新式做法"><a href="#新式做法" class="headerlink" title="新式做法"></a>新式做法</h3><p>就发展趋势来看， TS 已经成为前端必备的技能之一，<code>TypeScript</code> 的 private 很好解决了私有属性这个问题，后续学习了 <code>ts</code> 之后再补充吧。</p><h3 id="附：TypeScript-中的处理方式"><a href="#附：TypeScript-中的处理方式" class="headerlink" title="附：TypeScript 中的处理方式"></a>附：TypeScript 中的处理方式</h3><p>TypeScript 是 JavaScript 的一个超集，它会编译为原生 JavaScript 用在生产环境。允许指定私有的、公共的或受保护的属性是 TypeScript 的特性之一。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">  private name;</span><br><span class="line">  private age;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name, age</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">userInfo</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;姓名：&#x27;</span> + <span class="built_in">this</span>.name + <span class="string">&#x27;,年龄：&#x27;</span> + <span class="built_in">this</span>.age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> stu = <span class="keyword">new</span> Student(<span class="string">&#x27;Chocolate&#x27;</span>, <span class="number">21</span>);</span><br><span class="line"><span class="built_in">console</span>.log(stu.userInfo);           <span class="comment">// 姓名：Chocolate,年龄：21</span></span><br></pre></td></tr></table></figure><p>使用 TypeScript 需要注意的重要一点是，它只有在 <strong>编译</strong> 时才获知这些类型，而私有、公共修饰符在编译时才有效果。如果你尝试访问 <code>stu.name</code>，你会发现，居然是可以的。只不过 TypeScript 会在编译时给你报出一个错误，但不会停止它的编译。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 编译时错误：属性 ‘name’ 是私有的，只能在 ‘Student ’ 类中访问。</span></span><br><span class="line"><span class="built_in">console</span>.log(stu.name); <span class="comment">// &#x27;Chocolate&#x27;</span></span><br></pre></td></tr></table></figure><p>TypeScript 不会自作聪明，不会做任何的事情来尝试阻止代码在运行时访问私有属性。我只把它列在这里，也是让大家意识到它并不能直接解决问题。</p><p>另外，TypeScript  的 class 私有变量最终编译也是通过 <code>WeakMap</code> 来实现的，来自评论区小伙伴们的解答~</p><hr/><p>到此，本文就结束了，后续的文章也会加快更近，带着好奇心去学习，去思考~</p><p>如若小伙伴有更加不错的方式，欢迎交流，当然，本文或许存在疑点，欢迎大家指正，也是一个学习的过程，谢谢~</p><p>特此感谢评论区的小伙伴们，对于 <strong>设计一下ES6中 class 实现私有属性</strong> 这个问题我又有了更深入的理解，感谢 <code>Thanks♪(･ω･)ﾉ</code></p><h2 id="本文参考"><a href="#本文参考" class="headerlink" title="本文参考"></a>本文参考</h2><p><a href="https://juejin.im/post/6844903748997742605">浅谈 class 私有变量</a></p><p><a href="https://juejin.im/post/6844903880174600205">ES6 Class中实现私有属性的几种方法</a></p><p><a href="https://libin1991.github.io/2019/07/10/ES6%E6%A8%A1%E6%8B%9F%E7%A7%81%E6%9C%89%E5%B1%9E%E6%80%A7-%E5%89%8D%E7%AB%AF100%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98/">ES6模拟私有属性+前端100道面试题</a></p><blockquote><p>感谢以上大佬的文章，尊重劳动成果，特此提出原文链接。</p></blockquote><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>文章产出不易，还望各位小伙伴们支持一波！</p><p>往期精选：</p><p><a href="https://github.com/Chocolate1999/Front-end-learning-to-organize-notes">小狮子前端の笔记仓库</a></p><p><a href="https://github.com/Chocolate1999/leetcode-javascript">leetcode-javascript：LeetCode 力扣的 JavaScript 解题仓库，前端刷题路线（思维导图）</a></p><p>小伙伴们可以在Issues中提交自己的解题代码，🤝 欢迎Contributing，可打卡刷题，Give a ⭐️ if this project helped you!</p><p><a href="https://yangchaoyi.vip/">访问超逸の博客</a>，方便小伙伴阅读玩耍~</p><p><img src= "/img/loading.gif" data-lazy-src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/61b9395a3ddb4aeab844c9deda01afe4~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">学如逆水行舟，不进则退</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「星辰大海」你可能需要知道的 promise 知识的总结（内附思维导图）</title>
      <link href="posts/20211214/"/>
      <url>posts/20211214/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>接上一期 <a href="https://juejin.cn/post/6902942813097459720">「高频面试题」女友：消息队列 和 事件循环系统终于弄明白了！（内附思维导图）</a> 文章出炉后，微信好友也多了不少，还挺好的~</p><p>最近又重新整理一下 <code>Promise</code> 相关知识，一方面和上一期文章有个接应，另一方面，方便自己日后复盘回顾。</p><blockquote><p>本篇文章参考视频学习而来，都是自己一个字一个字敲出来的，也加了自己的理解，视频就在参考处，建议大家先看视频，后续回顾的话通过本文几个例题就好了。✿✿ヽ(°▽°)ノ✿</p></blockquote><p>学完本篇文章，你将会明白如下几大模块知识：</p><ul><li>迭代器</li><li>生成器</li><li>promise</li><li>async、await</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/83909feafe5343048a76c9d062eeb114~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><blockquote><p>（手机端可能看不清）获取高清PDF，请在微信公众号【小狮子前端】回复【promise知识】</p></blockquote><h2 id="迭代器是什么"><a href="#迭代器是什么" class="headerlink" title="迭代器是什么"></a>迭代器是什么</h2><h3 id="提出问题"><a href="#提出问题" class="headerlink" title="提出问题"></a>提出问题</h3><p>在了解迭代器之前，我们先来提出一个问题：</p><blockquote><p>遍历和迭代有什么区别？</p></blockquote><p>如下代码，对于数组、字符串、对象等我们可以按照如下方式进行遍历。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;123&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="comment">// 遍历数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 遍历字符串</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(str[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 遍历数组</span></span><br><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 遍历对象</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key, obj[key]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log([...arguments]);</span><br><span class="line">&#125;</span><br><span class="line">test(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>但对于这些数据类型的不同，我们可能需要不同的遍历方式，比如对象我们需要通过 <code>for...in</code>，函数也不一样，那么我们想着是否对于不同数据类型可以用同一种遍历方式呢？</p><p>没错，当然可以，这就是<strong>迭代</strong>，到此你应该明白了上文提出的问题：遍历和迭代有什么区别？</p><blockquote><p>迭代就是从目标源依次按逐个抽取的方式来提取数据，其中目标源满足：1、有序的 2、连续的  而遍历就没有这些要求，对于不同数据类型会有不同遍历方式。</p></blockquote><h3 id="迭代引入"><a href="#迭代引入" class="headerlink" title="迭代引入"></a>迭代引入</h3><p>而对于数据类型呢，在这里先提前告知大家，有哪些可以直接迭代出来的：</p><blockquote><p>Array、Map、Set、String、TypeArray、arguments、NodeList</p></blockquote><p>上述都是可以通过 <code>for..of</code> 来迭代出来。可能此时你会有疑问了，对象不可以么？（那我们不妨来试试）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;123&#x27;</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;</span><br><span class="line"><span class="built_in">console</span>.log(arr)</span><br><span class="line"><span class="built_in">console</span>.log(str)</span><br><span class="line"><span class="built_in">console</span>.log(obj)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> arr)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> str)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> obj)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过打印之后，我们发现当我们遍历 <code>obj</code> 对象的时候会抛出错误：<code>Uncaught TypeError: obj is not iterable</code></p><p>通过打印，我们发现，如果一个数据类型能迭代的话，会在原型上存在 <code>Symbol(Symbol.iterator)</code>方法，我们不妨来试着用一用这个方法，如下代码所示：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;123&#x27;</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> iter = arr[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"><span class="built_in">console</span>.log(iter.next()); <span class="comment">//  &#123;value: 1, done: false&#125;</span></span><br></pre></td></tr></table></figure><p>此时会打印 <code>&#123;value: 1, done: false&#125;</code>，发现 <code>done</code> 为 <code>false</code>，这意味着还没有完成迭代，即可以继续迭代。对于这个数组而言，有4个元素，那我们可以通过迭代5次来完成对数组的迭代，如下代码所示：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">let</span> iter = arr[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"><span class="built_in">console</span>.log(iter.next()); <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iter.next()); <span class="comment">// &#123;value: 2, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iter.next()); <span class="comment">// &#123;value: 3, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iter.next()); <span class="comment">// &#123;value: 4, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iter.next()); <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>总结：调用<code>Symbol(Symbol.iterator)</code>方法将会返回一个 <code>迭代器对象</code>，而这个迭代器对象具备 <code>next()</code> 方法，通过这个方法来实现逐步调用，同时每次调用的时候会返回一个对象，包括 <code>value</code> 和 <code>done</code> 两个属性，当<code>value</code>为 <code>undefined</code>，<code>done</code> 为 <code>true</code> 时迭代完成。</p></blockquote><h3 id="自己动手实现-Symbol-iterator"><a href="#自己动手实现-Symbol-iterator" class="headerlink" title="自己动手实现 Symbol.iterator"></a>自己动手实现 Symbol.iterator</h3><p>实现代码如下，我们依然可以获得与上文一样的结果。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeIterator</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> index=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span>&#123;</span><br><span class="line">    <span class="function"><span class="title">next</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(index&lt;arr.length)&#123;</span><br><span class="line">        <span class="keyword">return</span>&#123;</span><br><span class="line">          value: arr[index++], <span class="attr">done</span>: <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> iter = makeIterator(arr);</span><br><span class="line"><span class="built_in">console</span>.log(iter.next()); <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iter.next()); <span class="comment">// &#123;value: 2, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iter.next()); <span class="comment">// &#123;value: 3, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iter.next()); <span class="comment">// &#123;value: 4, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iter.next()); <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure><h3 id="实现对象的自定义迭代器对象"><a href="#实现对象的自定义迭代器对象" class="headerlink" title="实现对象的自定义迭代器对象"></a>实现对象的自定义迭代器对象</h3><blockquote><p>上文我们知道了对象是没办法进行迭代的，因为它的原型上没有 <code>Symbol(Symbol.iterator)</code> 方法，那么有了上文自己动手实现 <code>Symbol.iterator</code> 前置知识后，我们现在来实现对象的自定义迭代器对象。</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; </span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="number">2</span>,</span><br><span class="line">  c: <span class="number">3</span>,</span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]()&#123;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">&#x27;a&#x27;</span>,<span class="number">1</span>],[<span class="string">&#x27;b&#x27;</span>,<span class="number">2</span>],[<span class="string">&#x27;c&#x27;</span>,<span class="number">3</span>]]);</span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line">      <span class="function"><span class="title">next</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 获取键值对</span></span><br><span class="line">        <span class="keyword">let</span> mapEntries = [...map.entries()];</span><br><span class="line">        <span class="keyword">if</span>(index &lt; map.size)&#123;</span><br><span class="line">          <span class="keyword">return</span>&#123;</span><br><span class="line">            value: mapEntries[index++], <span class="attr">done</span>: <span class="literal">false</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span>&#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> iter = obj[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"><span class="built_in">console</span>.log(iter.next()); <span class="comment">// &#123;value: (2) [&quot;a&quot;, 1], done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iter.next()); <span class="comment">// &#123;value: (2) [&quot;b&quot;, 2], done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iter.next()); <span class="comment">// &#123;value: (2) [&quot;c&quot;, 3], done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iter.next()); <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure><p>从上文我们知道，我们可以通过 <code>for...of</code> 的方式来迭代，因此，对于上述代码我们可以换一种方式，如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> obj)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果也是能迭代打印对象数据，那么也就是说 <code>for...of</code> 就是调用 <code>[Symbol.iterator]()</code> 方法来实现迭代，它能一次性迭代出对象中所有属性和属性值。</p><h2 id="生成器的使用"><a href="#生成器的使用" class="headerlink" title="生成器的使用"></a>生成器的使用</h2><h3 id="生成器初识"><a href="#生成器初识" class="headerlink" title="生成器初识"></a>生成器初识</h3><blockquote><p>上文我们介绍了迭代器是什么，发现对象没办法使用迭代，然后我们自己动手实现了对对象的自定义迭代器，然后也发现了说 <code>for...of</code> 就是调用 <code>[Symbol.iterator]()</code> 方法来实现迭代，它能一次性迭代出对象中所有属性和属性值。</p></blockquote><p>接下来，我们来讲解生成器了。首先，生成器它能像迭代一样返回一个迭代器对象，然后调用 <code>next</code> 方法进行抽取，下面结合一个例子就能明白了：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> iter = test();</span><br><span class="line"><span class="built_in">console</span>.log(iter.next()); <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iter.next()); <span class="comment">// &#123;value: 2, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iter.next()); <span class="comment">// &#123;value: 3, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iter.next()); <span class="comment">// &#123;value: 4, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iter.next()); <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure><p>同样，我们也可以通过 <code>for...of</code> 方式实现，这里就不再演示了。</p><h3 id="探讨生成器"><a href="#探讨生成器" class="headerlink" title="探讨生成器"></a>探讨生成器</h3><p>我们不妨来看一下下面这段代码，看看会有怎样的结果：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> iter = test();</span><br></pre></td></tr></table></figure><p>结果显示是 <code>没有打印结果</code>，你是否以为会执行了 <code>test</code> 函数之后会默认输出 <code>0</code> 呢，答案<strong>不是</strong>，这很奇怪！ 那么我们不妨执行一下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(iter.next()); </span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// &#123;value: 1, done: false&#125;</span></span><br></pre></td></tr></table></figure><p>从结果上来看，当我们调用一下 <code>next</code> 方法之后，打印 <code>0</code> 的那行代码被执行了，而没有调用的时候就没执行。</p><p>那么总结一下，<code>yeild</code> 实际上能够中断函数，这里就有 <code>return</code> 的味道了，不妨看看下面几个例子：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> iter = test();</span><br><span class="line"><span class="built_in">console</span>.log(iter); <span class="comment">// 打印迭代器对象</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> iter = test();</span><br><span class="line"><span class="built_in">console</span>.log(iter.next());</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// &#123;value: 1, done: true&#125;</span></span><br></pre></td></tr></table></figure><p>这里因为在抽取的时候没有遇到 <code>yield</code> 因此全部抽取完，然后 <code>done</code> 设置为 <code>true</code>，此时代表迭代完成。因此，生成器函数一般不会 <code>return</code> 一个值。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> iter = test();</span><br><span class="line"><span class="built_in">console</span>.log(iter.next());</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// &#123;value: 1, done: false&#125;</span></span><br></pre></td></tr></table></figure><h3 id="探究生成器传参"><a href="#探究生成器传参" class="headerlink" title="探究生成器传参"></a>探究生成器传参</h3><p>上文我们介绍了生成器抽取相关问题，也提及了一般不会使用 <code>return</code> 返回一个值，下面我们来探究一下生成器传参是怎样的情况，例如如下代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> value1 = <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(value1);</span><br><span class="line">  <span class="keyword">let</span> value2 = <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(value2);</span><br><span class="line">  <span class="keyword">let</span> value3 = <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(value3);</span><br><span class="line">  <span class="keyword">let</span> value4 = <span class="keyword">yield</span> <span class="number">4</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(value4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> iter = test();</span><br><span class="line"><span class="built_in">console</span>.log(iter.next(<span class="string">&#x27;one&#x27;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(iter.next(<span class="string">&#x27;two&#x27;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(iter.next(<span class="string">&#x27;three&#x27;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(iter.next(<span class="string">&#x27;four&#x27;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(iter.next());</span><br></pre></td></tr></table></figure><p>打印结果如下：</p><p><img src= "/img/loading.gif" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/415528566a65462eb005558d8a179286~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><blockquote><p>从上述打印结果来看，我们发现，第一个 <code>yield</code> 的返回值是在调用第二个 <code>next</code> 方法时的<code>传参</code>。</p></blockquote><p>然而上述传参其实不太符合我们想象中的逻辑，可以有解决办法嘛？</p><blockquote><p>当然有办法，因此之后推出了 <code>async/await</code>。</p></blockquote><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p>关于 <code>Promise</code> 讲解的话，网上也是一大堆，但本篇还是以简单便捷的方式给大家呈现 <code>promise</code> 知识点，因此，可能需要你起初对 <code>promise</code> 有一定了解，本文不会从零去讲 <code>promise</code>，比如它的来源，为什么要使用 <code>promise</code> 这些问题，本文不会过多涉及，更多内容小狮子们可以参考文末提供的学习视频，通过系统学习过后，如若后续还想继续复盘的话，就可以参考本文，而无需再看一遍视频了，我想读者应该明白我这些话的意思了哈，下面我们正式进入 <code>promise</code> 章节。</p><h3 id="Promise的特性"><a href="#Promise的特性" class="headerlink" title="Promise的特性"></a>Promise的特性</h3><p>1、promise 状态不受外界影响</p><p>2、promise 的固化（一旦 promise 状态发生变化后就不能再更改）</p><p>下面来看一个例子，看看会输出什么，这也就是 <code>promise</code> 的执行方式，通过 <strong>微任务</strong> 的方式来执行 <code>promise</code> 注册的回调函数，不管是成功还是失败。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;promise&#x27;</span>);</span><br><span class="line">  resolve(<span class="string">&#x27;resolve&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;timeout&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;Chocolate&#x27;</span>);</span><br></pre></td></tr></table></figure><p>打印结果如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">promise</span><br><span class="line">Chocolate</span><br><span class="line">resolve</span><br><span class="line">timeout</span><br></pre></td></tr></table></figure><p>这道题主要还是与事件循环相关，小狮子们可以阅读我的上一篇文章，看完我想你对事件循环的理解会更加深入一些：</p><p><a href="https://juejin.cn/post/6902942813097459720">「高频面试题」女友：消息队列 和 事件循环系统终于弄明白了！（内附思维导图）</a></p><h3 id="thenable-对象"><a href="#thenable-对象" class="headerlink" title="thenable 对象"></a>thenable 对象</h3><p>直接看下面例子，你觉得会输出什么呢？</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="function"><span class="title">then</span>(<span class="params">resolve, reject</span>)</span> &#123;</span><br><span class="line">    resolve(<span class="number">11</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.resolve(obj);</span><br><span class="line"></span><br><span class="line">p1.then(<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>答案是输出 <code>11</code>，解释一波，当绑定一个对象参数为 <code>thenable</code> 的时候，那么会默认调用对象的 <code>then</code> 方法，之后<code>then</code> 方法里面 <code>resolve</code> 传递的值，就会成为之后 <code>then</code> 回调传入的值，即上述代码中的 <code>data</code>。</p><blockquote><p>（如果<code>then</code> 方法是 <code>resolve</code> 则为成为状态，如果是 <code>reject</code> 则成为失败状态）</p></blockquote><p>上一句话怎么理解呢，我们不妨修改一下上文代码，如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="function"><span class="title">then</span>(<span class="params">resolve, reject</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// resolve(11);</span></span><br><span class="line">    reject(<span class="number">10</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.resolve(obj);</span><br><span class="line"></span><br><span class="line">p1.then(<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;err&#x27;</span> + err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>输出结果是 <code>err10</code>，也就是说当我们<code>Promise</code> 执行 <code>reslove</code> 方法时，传入参数为对象并且包含 <code>then</code> 方法，那么就会改变当前 <code>promise</code> 的状态。</p><p>但是，我们再试试改变一下上述代表，将 <code>Promise</code>执行 <code>reject</code> 方法，会有什么变化呢？</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="function"><span class="title">then</span>(<span class="params">resolve, reject</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// resolve(11);</span></span><br><span class="line">    reject(<span class="number">10</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.reject(obj);</span><br><span class="line"></span><br><span class="line">p1.then(<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>打印结果是 <code>&#123; then: [Function: then] &#125;</code>，发现并没有执行 <code>thenable</code> 对象，因为此时 <code>Promise</code> 执行的是 <code>reject</code>。</p><blockquote><p>总结：当 <code>Promise</code> 是 <code>reslove</code> 状态时，我们可以通过传入对象并且对象包含 <code>then</code> 方法，那么可以通过这个 <code>then</code> 方法来改变 <code>promise</code> 状态，并且进行传参。</p></blockquote><p>在此，穿插一道 <code>promise</code> 相关题目，看看输出结果是什么？</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;promise1&#x27;</span>);</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout2&#x27;</span>);</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout1&#x27;</span>);</span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise2&#x27;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">promise1</span><br><span class="line">setTimeout1</span><br><span class="line">promise2</span><br><span class="line">setTimeout2</span><br></pre></td></tr></table></figure><blockquote><p>这里要注意的是首先执行上面微任务，是整个微任务底下的代码加入微任务队列，因此第一个定时器宏任务会在微任务执行的时候才会加入延迟队列（或者叫做 <code>Web APIs</code>）而第二个定时器宏任务在预编译代码的时候就在微任务之后加入了延迟队列，而它们都是设置的延时 <code>0</code> 秒，那么在下一次事件循环的时候显然第二个定时器会优先拿出来调用。</p></blockquote><h3 id="promise-的链式调用"><a href="#promise-的链式调用" class="headerlink" title="promise 的链式调用"></a>promise 的链式调用</h3><p>对于链式调用这一块，我想小狮子们应该或多或少的听说过，或许你听说过返回普通值，或者返回 <code>promise</code> 对象啥的，但应该对于这个链式调用理解的还是很模糊，接下来我们在这一章节一起来探讨一下：</p><p>首先，还是由浅入深，看一下简单例子：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="number">1</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p1.then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res));</span><br></pre></td></tr></table></figure><p>显然改变了 <code>promise</code> 状态为 <code>resolve</code> 成功态，会输出 <code>1</code>。</p><p>上面代码应该很容易就看出来了，下面我们对上文代码进行新增，尝试进行链式调用，如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="number">1</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p1.then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res + <span class="number">1</span>))</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res + <span class="number">2</span>));</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="literal">NaN</span></span><br><span class="line"><span class="literal">NaN</span></span><br></pre></td></tr></table></figure><p>这里来解释一下，首先我们想一想，为什么能进行链式调用呢？第一个 <code>then</code> 是因为 <code>promise</code> 状态变为了成功态，就可以执行回调，那么第二个 <code>then</code> 为什么能执行呢？带着这个问题，我们不妨打印一下第一个 <code>then</code> 的返回结果：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(p1.then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))) <span class="comment">// Promise &#123; &lt;pending&gt; &#125;</span></span><br></pre></td></tr></table></figure><p>发现，执行 <code>then</code> 回调之后返回的也是 <code>promise</code>，那么为什么能进行链式调用也就解释的清了。如果我们接着执行 <code>then</code> 方法，那么 <code>p1.then</code> 会包装返回 <code>Promise.resolve(undefined)</code>，因为 <code>console.log</code> 函数默认返回值就是 <code>undefined</code>，因此第二个 <code>then</code> 回调打印的其实就是 <code>undefined+1</code>，显然结果就是 <code>NaN</code>。</p><p>对于第三个 <code>then</code> 回调，得到的是第二个 <code>then</code>包装返回的<code>Promise.resolve(undefined)</code>，而 <code>console.log</code> 函数默认返回值就是 <code>undefined</code>，因此第三个 <code>then</code> 回调打印的其实就是 <code>undefined+2</code>，显然结果就是 <code>NaN</code>。</p><p>我们继续修改一下代码，看看返回 <code>promise</code> 对象这种情况，如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="number">1</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p1.then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  reject(<span class="number">2</span>);</span><br><span class="line">&#125;))</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">  &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;error:&#x27;</span> + err);</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p>打印结果如下，这里就不解释了，可以参考上文讲述哈~</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">error:<span class="number">2</span></span><br></pre></td></tr></table></figure><p>接着，我们看看如下代码，直接看它们区别，这对于你理解链式调用会有一定帮助。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">10</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p1.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(res); <span class="keyword">return</span> res + <span class="number">1</span> &#125;); <span class="comment">// 10</span></span><br><span class="line">p1.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(res); <span class="keyword">return</span> res + <span class="number">1</span> &#125;); <span class="comment">// 10</span></span><br><span class="line">p1.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(res); <span class="keyword">return</span> res + <span class="number">1</span> &#125;); <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line">p1.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(res); <span class="keyword">return</span> res + <span class="number">1</span> &#125;) <span class="comment">// 10</span></span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(res); <span class="keyword">return</span> res + <span class="number">1</span> &#125;) <span class="comment">// 11</span></span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(res); <span class="keyword">return</span> res + <span class="number">1</span> &#125;); <span class="comment">// 12</span></span><br></pre></td></tr></table></figure><p>对于第一种情况，它都是看的 <code>p1</code>的状态，为 <code>resolve</code>，那么执行结果都一样。</p><p>对于第二种情况它会有三个 <code>promise</code> 状态，并且是链式调用的，那么下一个回调需要上一个回调的返回值。</p><h3 id="promise-的固化-多层嵌套"><a href="#promise-的固化-多层嵌套" class="headerlink" title="promise 的固化 | 多层嵌套"></a>promise 的固化 | 多层嵌套</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="number">1</span>);</span><br><span class="line">  reject(<span class="number">2</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p1.then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br><span class="line">  .then()</span><br><span class="line">  .then()</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(err));</span><br></pre></td></tr></table></figure><p>打印结果如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="literal">undefined</span></span><br></pre></td></tr></table></figure><p>解释一波，对于中间那两行 <code>.then()</code>，可能有的小狮子们会疑惑这到底是有啥用，我的回答是<strong>确实没用</strong>，会默认忽略掉！</p><p>而 <code>promise</code> 固化即<strong>一旦状态发生变化后就不能再更改</strong>。</p><h3 id="promise-状态依赖"><a href="#promise-状态依赖" class="headerlink" title="promise 状态依赖"></a>promise 状态依赖</h3><p>直接看下面这段代码，看看会输出什么？</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    reject(<span class="string">&#x27;400&#x27;</span>);</span><br><span class="line">  &#125;, <span class="number">3000</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    resolve(p1);</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p2.then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;error:&#x27;</span>+err));</span><br></pre></td></tr></table></figure><p>输出结果为<code>3s</code>之后打印 <code>error:400</code>，或许你会疑惑，我 <code>p2</code>明明是<code>resolve</code>状态，为什么会走到<code>catch</code>那里捕获错误呢，这里要解释一下了：</p><blockquote><p>当 <code>promise</code> 状态存在依赖时，它的状态与自身无关了，由依赖来决定，对于上述代码，就是 p2 的状态由依赖 p1 来决定，而p1是 <code>reject</code>，所以会走 <code>catch</code>。</p></blockquote><h3 id="Promise-all-Promise-race"><a href="#Promise-all-Promise-race" class="headerlink" title="Promise.all | Promise.race"></a>Promise.all | Promise.race</h3><blockquote><p>有了上文 <code>promise</code> 的介绍，这两个方法就比较简单了，下文就直接给出例子啦~</p></blockquote><p> <strong>Promise.all 使用</strong></p><p>传递一个异步请求数组，只有当请求状态全都是成功态，才能调用成功回调函数，同时，它会受 <code>reject</code> 的影响，只要有 <code>reject</code>，那么就不会调用 <code>then</code> 的回调。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">10</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">20</span>);</span><br><span class="line">  &#125;, <span class="number">2000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">30</span>);</span><br><span class="line">  &#125;, <span class="number">3000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p4 = <span class="built_in">Promise</span>.all([p1, p2, p3]);</span><br><span class="line"></span><br><span class="line">p4.then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res));</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[ <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span> ]</span><br></pre></td></tr></table></figure><p> <strong>Promise.race使用</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">10</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    reject(<span class="number">20</span>);</span><br><span class="line">  &#125;, <span class="number">2000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">30</span>);</span><br><span class="line">  &#125;, <span class="number">3000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p4 = <span class="built_in">Promise</span>.race([p1, p2, p3]);</span><br><span class="line"></span><br><span class="line">p4.then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res));</span><br></pre></td></tr></table></figure><p>输出结果是 <code>10</code>，<code>Promise.race</code> 传参也是一个 <code>promise</code> 相关的数组，但是它不会受 <code>reject</code> 的影响，谁跑的最快就返回谁。</p><h2 id="async-await"><a href="#async-await" class="headerlink" title="async | await"></a>async | await</h2><blockquote><p>如果要细说的话，那么本文篇幅就会很多了，但本文文末会提供参考文献，或者大家留下关于 async、await 写的不错的文章链接。</p></blockquote><p>async await和generator的写法很像，就是将 Generator 函数的星号（*）替换成 async，将 yield 替换成await</p><p>但async 函数对 Generator 函数做了改进：</p><p>1、内置执行器：Generator函数的执行必须靠执行器，所以才有了 co 函数库，而 async 函数自带执行器.也就是说，async 函数的执行，与普通函数一模一样。</p><p>2、更好的语义：async 和 await，比起星号和 yield，语义更清楚了。async 表示函数里有异步操作，await 表示紧跟在后面的表达式需要等待结果。</p><p>3、更广的适用性： co 函数库约定，yield 命令后面只能是 Thunk 函数或 Promise 对象，而 async 函数的 await 命令后面，可以跟 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）</p><blockquote><p>async 函数是非常新的语法功能，新到都不属于 ES6，而是属于 ES7。目前，它仍处于提案阶段，但是转码器 Babel 和 regenerator 都已经支持，转码后就能使用。</p></blockquote><h2 id="Promise-自测面试题（由易到难-满分100分）"><a href="#Promise-自测面试题（由易到难-满分100分）" class="headerlink" title="Promise 自测面试题（由易到难 | 满分100分）"></a>Promise 自测面试题（由易到难 | 满分100分）</h2><h3 id="第一题（5分）"><a href="#第一题（5分）" class="headerlink" title="第一题（5分）"></a>第一题（5分）</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve()</span><br><span class="line">  .then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;error!!!&#x27;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;then:&#x27;</span> + res);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;catch:&#x27;</span> + err);</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><details><summary><b>查看答案</b></summary><p><p>输出结果如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">then:<span class="built_in">Error</span>: error!!!</span><br></pre></td></tr></table></figure><p>第一题热身题，应该不成问题，还是解释一下： <code>Promise</code>是 <code>resolve</code>成功状态，那么就会执行第一个<code>then</code> 回调，返回值是 <code>Error</code>对象，那么就会封装一个 <code>Promise.resolve(参数为Error对象)</code>，然后又执行第二个 <code>then</code> 回调，那么打印结果如上所示。</p></p></details><h3 id="第二题（5分）"><a href="#第二题（5分）" class="headerlink" title="第二题（5分）"></a>第二题（5分）</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">&#x27;success1&#x27;</span>);</span><br><span class="line">  reject(<span class="string">&#x27;error&#x27;</span>);</span><br><span class="line">  resolve(<span class="string">&#x27;success2&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise</span><br><span class="line">  .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;then:&#x27;</span> + res);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;catch:&#x27;</span> + err);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><details><summary><b>查看答案</b></summary><p><p>输出结果如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">then:success1</span><br></pre></td></tr></table></figure><p>本题主要考察 <code>promise</code> 的固化，一旦状态改变就不会再改变了！</p></p></details><h3 id="第三题（10分）"><a href="#第三题（10分）" class="headerlink" title="第三题（10分）"></a>第三题（10分）</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">  resolve();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">4</span>);</span><br></pre></td></tr></table></figure><details><summary><b>查看答案</b></summary><p><p>输出结果如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p>本题与事件循环相关，<code>Promise</code> 构造函数内部的<strong>执行器函数内部</strong>属于同步代码，<code>.then</code> 注册的回调函数属于<strong>微任务</strong>，那么会先输出同步代码 <code>1</code>，遇到 <code>resolve()</code> 并不会阻止后面同步代码的执行，因为并没有 <code>return</code> 语句。然后将微任务加入微任务队列，之后打印同步代码 <code>2</code>，之后继续先打印同步代码 <code>4</code>，最后取出微任务队列中的任务元素，打印 <code>3</code>，因此打印结果为 <code>1 2 4 3</code>。</p></p></details><h3 id="第四题（10分）"><a href="#第四题（10分）" class="headerlink" title="第四题（10分）"></a>第四题（10分）</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  reject(<span class="number">42</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p1.catch((<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">  <span class="keyword">return</span> value + <span class="number">1</span>;</span><br><span class="line">&#125;)).then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><details><summary><b>查看答案</b></summary><p><p>输出结果如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">42</span></span><br><span class="line"><span class="number">43</span></span><br></pre></td></tr></table></figure><p>解释： <code>p1</code> 是返回的 <code>reject</code> 状态的 <code>promise</code>，那么就会走 <code>catch</code>，首先就会打印 <code>42</code>，然后遇到 <code>return</code>语句，返回的是普通值，那么就会封装成 <code>Promise.resolve(43)</code>，那么就会执行后面的 <code>then</code> 回调，打印 <code>43</code>。</p></p></details><h3 id="第五题（10分）"><a href="#第五题（10分）" class="headerlink" title="第五题（10分）"></a>第五题（10分）</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="number">42</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;TypeError!!!&#x27;</span>));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p1.then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">  <span class="keyword">return</span> p2;</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><details><summary><b>查看答案</b></summary><p><p>输出结果如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">42</span></span><br><span class="line"><span class="built_in">Error</span>: <span class="built_in">TypeError</span>!!!</span><br></pre></td></tr></table></figure><p>解释一下，打印 <code>42</code>我想应该不用解释了，我们注意 <code>p1</code> 执行 <code>.then</code> 回调时返回的是 <code>p2</code>，而 p2 是失败的 <code>promise</code>状态，那么就不会像上一题一样进行 <code>promise.resolve()</code>的封装了，直接返回失败的状态，那么就只会执行 <code>then</code> 回调的第二个 <code>err</code> 那条路了。</p></p></details><h3 id="第六题（10分）"><a href="#第六题（10分）" class="headerlink" title="第六题（10分）"></a>第六题（10分）</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;timer1&#x27;</span>);</span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise1&#x27;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;promise2&#x27;</span>);</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;timer2&#x27;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><details><summary><b>查看答案</b></summary><p><p>输出结果如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">promise2</span><br><span class="line">timer1</span><br><span class="line">promise1</span><br><span class="line">timer2</span><br></pre></td></tr></table></figure><p>这题也是考察事件循环相关，首先遇到 <code>setTimeout</code>，加入宏任务队列，然后遇到 <code>Promise.resolve().then</code>微任务，加入微任务队列，此时主线程没有同步代码可执行，先拿出微任务队列中的人物执行，先执行同步代码 <code>promise2</code>，然后遇到 <code>setTimeout</code>，加入宏任务队列。此时微任务执行完毕，取出宏任务队列中的任务，依次执行即可，打印输出结果。</p></p></details><h3 id="第七题（10分）"><a href="#第七题（10分）" class="headerlink" title="第七题（10分）"></a>第七题（10分）</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve()</span><br><span class="line">  .then(<span class="function">() =&gt;</span> &#123; <span class="comment">// 外层第一个then</span></span><br><span class="line">    <span class="built_in">Promise</span>.resolve().then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">    &#125;).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">() =&gt;</span> &#123; <span class="comment">// 外层第二个then</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><details><summary><b>查看答案</b></summary><p><p>输出结果如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p>这道题很容易做错，你可能会想着打印出 <code>1 2 3</code>，但是最外层的两个 <code>then</code> 属于同一级别关系，因此会先加入外层第一个 <code>then</code> ，然后再加入外层第二个 <code>then</code>。此时主线程没有同步代码，于是取微任务队列中的任务，先执行输出 <code>1</code>，然后又添加了一个输出 2 的微任务，然后取出微任务队列头部的任务，输出 <code>3</code>，最后取出最后一个任务，输出 <code>2</code>。</p></p></details><h3 id="第八题（10分）"><a href="#第八题（10分）" class="headerlink" title="第八题（10分）"></a>第八题（10分）</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> async2();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;async1 end&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;async2 end&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">async1();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><details><summary><b>查看答案</b></summary><p><p>输出结果如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">async2 end</span><br><span class="line"><span class="number">10</span></span><br><span class="line">async1 end</span><br></pre></td></tr></table></figure><p>这题考察了 <code>async/await</code>，在执行 <code>async1</code> 函数时，遇到 <code>await async2();</code> 这段代码，而 <code>async2</code>函数是个同步函数，直接输出 <code>async2 end</code>，然后因为是 <code>await</code>，返回的是 <code>promise</code>对象，返回值是 <code>async2()</code>执行的结果，即默认的 <code>undefined</code>，之后的代码属于微任务，加入微任务队列，此时再走同步代码，输出 <code>10</code>，之后，主线程已经执行完毕，然后去找微任务队列，取出之前加入的微任务，输出 <code>async1 end</code>。</p></p></details><p>下面，我们还可以对上述代码进行一个变形，如下代码所示：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> async2();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;async1 end&#x27;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;async2 end&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;error!!!&#x27;</span>));</span><br><span class="line">&#125;</span><br><span class="line">async1();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><details><summary><b>查看答案</b></summary><p><p>输出结果如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">async2 end</span><br><span class="line"><span class="number">10</span></span><br><span class="line">async1 end</span><br><span class="line"><span class="built_in">Error</span>: error!!!</span><br></pre></td></tr></table></figure><p>这里要注意的就是对于 <code>await</code> 返回 <code>reject</code> 状态，必须要用 <code>try / catch</code> 进行捕获错误，不然就会报错！</p></p></details><h3 id="第九题（15分）"><a href="#第九题（15分）" class="headerlink" title="第九题（15分）"></a>第九题（15分）</h3><blockquote><p>下面这道题是特别特别经典的一道题了！</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;async1 start&#x27;</span>);</span><br><span class="line">    <span class="keyword">await</span> async2();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;async1 end&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;async2&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script start&#x27;</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line">async1();</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise1&#x27;</span>);</span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise2&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script end&#x27;</span>);</span><br></pre></td></tr></table></figure><details><summary><b>查看答案</b></summary><p><blockquote><p>总体思路就是：先执行宏任务（当前代码块也算是宏任务），然后执行当前宏任务产生的微任务，然后接着执行宏任务</p></blockquote><ul><li>从上往下执行代码，先执行同步代码，输出 <code>script start</code></li><li>遇到 <code>setTimeout</code> ，现把 <code>setTimeout</code> 的代码放到宏任务队列中</li><li>执行 <code>async1()</code>，输出 <code>async1 start</code>, 然后执行 <code>async2()</code>, 输出 <code>async2</code>，把 <code>async2()</code> 后面的代码 <code>console.log(&#39;async1 end&#39;)</code>放到微任务队列中</li><li>接着往下执行，输出 <code>promise1</code>，把 .then() 放到微任务队列中；<strong>注意 Promise 本身是同步的立即执行函数，.then是异步执行函数</strong></li><li>接着往下执行， 输出 <code>script end</code>。同步代码（同时也是宏任务）执行完成，接下来开始执行刚才放到微任务中的代码</li><li>依次执行微任务中的代码，依次输出 <code>async1 end</code>、 <code>promise2</code>, 微任务中的代码执行完成后，开始执行宏任务中的代码，输出 <code>setTimeout</code></li></ul><p>最后结果如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">script start</span><br><span class="line">async1 start</span><br><span class="line">async2</span><br><span class="line">promise1</span><br><span class="line">script end</span><br><span class="line">async1 end</span><br><span class="line">promise2</span><br><span class="line"><span class="built_in">setTimeout</span></span><br></pre></td></tr></table></figure></p></details><h3 id="第十题（15分）"><a href="#第十题（15分）" class="headerlink" title="第十题（15分）"></a>第十题（15分）</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;promise1&#x27;</span>);</span><br><span class="line">  resolve();</span><br><span class="line">&#125;).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;promise2&#x27;</span>);</span><br><span class="line">&#125;).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;promise3&#x27;</span>);</span><br><span class="line">&#125;).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;promise4&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">a = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="keyword">async</span> (resolve, reject) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">  <span class="keyword">await</span> b;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;after1&#x27;</span>);</span><br><span class="line">  <span class="keyword">await</span> a;</span><br><span class="line">  resolve(<span class="literal">true</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;after2&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;end&#x27;</span>);</span><br></pre></td></tr></table></figure><details><summary><b>查看答案</b></summary><p><p>输出结果如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">promise1</span><br><span class="line"><span class="literal">undefined</span></span><br><span class="line">end</span><br><span class="line">promise2</span><br><span class="line">promise3</span><br><span class="line">promise4</span><br><span class="line"><span class="built_in">Promise</span> &#123; &lt;pending&gt; &#125;</span><br><span class="line">after1</span><br></pre></td></tr></table></figure><p>这道题是一道综合性比较强的题，但是如果理解了前面9道题，这道题应该问题也不是很大的，现在来解释一波：</p><p>首先， <code>new Promise</code>里面是同步代码，会优先打印 <code>promise1</code>。然后注册了三个 <code>then</code> 的回调，加入微任务队列。</p><p>之后来到下一个  <code>new Promise</code>，此时的 <code>a</code> 还没有接收到任务返回值，那么就是默认值 <code>undefined</code>。</p><p>然后遇到 <code>await b</code>，然而 b 是一个promise 的实例， 已经在之前通过 new Promise 执行了，是三个微任务，之后先去找找看还有没有同步代码，于是找到了输出 <code>end</code>。</p><p>此时主线程同步代码已经执行完毕，去找微任务，依次打印 <code>promise2 promise3 promise4</code>。</p><p>而 <code>await b</code> 也是返回 <code>promise</code> 对象，即封装好的 <code>Promise.resolve(undefined)</code>。然而没有进行返回和接受。</p><p>之后执行输出 <code>a</code>的那行代码，此时主线程同步代码已经执行完了，那么 <code>a</code> 也会返回一个 <code>Promise</code>，但是状态没有发生变化，因此打印的是 <code>Promise &#123; &lt;pending&gt; &#125;</code>。</p><p>然后执行输出 <code>after1</code>。</p><p>然后遇到 <code>await a</code>，而此时 <code>a</code>还是 <code>pending</code>，因此后面回调代码不会执行，这也是这道题的小坑，很容易跳进去！</p></p></details><blockquote><p>到此，自测面试题就结束了，满分100分，你得到多少分了呢？来评论区留下你的分数吧，你也可以提出疑问，让大伙一起解决~</p></blockquote><h2 id="本文参考"><a href="#本文参考" class="headerlink" title="本文参考"></a>本文参考</h2><ul><li><a href="https://www.bilibili.com/video/BV1mp4y1z7KB">【全网首发更新完】迭代器 | 生成器 | promise | async | await</a></li><li><a href="https://juejin.cn/post/6844903586481209358">Async +Await</a></li><li><a href="https://juejin.cn/post/6844903582299324424">Generator用法详解+co</a></li></ul><blockquote><p>建议大家伙先观看小夏老师的视频再来阅读本文~</p></blockquote><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>文章产出不易，还望各位小伙伴们支持一波！</p><p>往期精选：</p><p><a href="https://github.com/Chocolate1999/Front-end-learning-to-organize-notes">小狮子前端の笔记仓库</a></p><p><a href="https://github.com/Chocolate1999/leetcode-javascript">leetcode-javascript：LeetCode 力扣的 JavaScript 解题仓库，前端刷题路线（思维导图）</a></p><p>小伙伴们可以在Issues中提交自己的解题代码，🤝 欢迎Contributing，可打卡刷题，Give a ⭐️ if this project helped you!</p><p><a href="https://yangchaoyi.vip/">访问超逸の博客</a>，方便小伙伴阅读玩耍~</p><p><img src= "/img/loading.gif" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3f8dd8f6d93e498ba33a76819052be06~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">学如逆水行舟，不进则退</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 写给女友 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 总结 </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「前端四问」一位师弟的提问，小狮子回答</title>
      <link href="posts/20201219/"/>
      <url>posts/20201219/</url>
      
        <content type="html"><![CDATA[<section id="nice" data-tool="mdnice编辑器" data-website="https://www.mdnice.com" style="font-size: 16px; color: black; padding: 0 10px; word-spacing: 0px; word-break: break-word; word-wrap: break-word; text-align: left; line-height: 1.25; font-family: Optima-Regular, Optima, PingFangTC-Light, PingFangSC-light, PingFangTC-light; letter-spacing: 2px; background-image: linear-gradient(90deg, rgba(50, 0, 0, 0.05) 3%, rgba(0, 0, 0, 0) 3%), linear-gradient(360deg, rgba(50, 0, 0, 0.05) 3%, rgba(0, 0, 0, 0) 3%); background-size: 20px 20px; background-position: center center;"><h2 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; text-align: left; margin: 20px 10px 0px 0px;"><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 18px; font-weight: bold; display: inline-block; padding-left: 10px; border-left: 5px solid #916dd5;">前言</span><span class="suffix"></span></h2><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;">最近朋友的师弟找到了我，早早地就准备了询问问题，我震惊了，没想到哇，我还小有名气，话不多说，直接开门见山地看问题吧：</p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;">1.&nbsp;算法题应该刷到什么程度？除了剑指offer，其它类似Leetcode还需要刷哪些题，是刷一些像HOT100类型的，还是不同标签的题象征性的刷点</p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;">2.&nbsp;其它像react这种框架，还有flutter、element这种目前框架中没用到的技术是不是不急着学？</p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;">3.&nbsp;还有webpack、node这种应该学习到什么程度，目前webpack只是照着视频模拟了一下，不过这种东西很容易忘记，node还没怎么接触过</p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;">4.&nbsp;网络协议之前看过面试时会问到输入url之后会发生什么，这块东西是不是直接看面经然后总结知识点会比较好？</p><h2 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; text-align: left; margin: 20px 10px 0px 0px;"><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 18px; font-weight: bold; display: inline-block; padding-left: 10px; border-left: 5px solid #916dd5;">阅读须知</span><span class="suffix"></span></h2><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;">对于这四个问题，我想应该是大多数人都会考虑的，在这里，我仅发表我自己的观点与想法，如若与你的不同，请 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #916dd5; font-weight: bolder; background: none;">海纳百川有容乃大</code>。当然，你也可以在留言板提出你自己的观点（公众号没有留言板，但我会在文末提供给你留言板，欢迎来留言~）</p><blockquote class="multiquote-1" data-tool="mdnice编辑器" style="border: none; display: block; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; border-left: 3px solid rgba(0, 0, 0, 0.4); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; border-left-color: #d89cf6; background: #f4eeff;"><p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px; margin: 0px; color: black; line-height: 26px;">我仅代表我个人建议，你觉得你的观点是对的，那就是对的，我不会有任何意见。</p></blockquote><h3 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; color: black; font-size: 16px; font-weight: bold; text-align: center;"><span class="prefix" style="display: none;"></span><span class="content" style="border-bottom: 2px solid #d89cf6;">问题一</span><span class="suffix" style="display: none;"></span></h3><blockquote class="multiquote-1" data-tool="mdnice编辑器" style="border: none; display: block; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; border-left: 3px solid rgba(0, 0, 0, 0.4); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; border-left-color: #d89cf6; background: #f4eeff;"><p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px; margin: 0px; color: black; line-height: 26px;">算法题应该刷到什么程度？除了剑指offer，其它类似Leetcode还需要刷哪些题，是刷一些像HOT100类型的，还是不同标签的题象征性的刷点</p></blockquote><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;">对于第一个问题，算法刷到什么程度。我觉得前端相比于后端来说，算法这一块都还好，刷题的话，如果是之前没有接触过或者零基础，应该要花费一个月左右的时间准备，至于刷哪些题的话，最好是分专题来刷题，比如说这周就刷数据结构-栈，下周刷递归与回溯专题，再下周刷链表。我自己也是分专题刷的，在github上面整理一个做题路线：https://github.com/Chocolate1999/leetcode-javascript  大概80道题，主要是学习思维，当然，刷完剑指offer也是不错的选择。其次，我觉得前端算法面试来说的话考察也不是很难，我遇到的和我看的一些面经，很多就是考察一下排序算法，递归例如走楼梯，回溯的话也还是比较简单，代码量的话一般就10-20行左右。前端算法面试的话，我就觉得字节跳动会考察算法比较多，然而也不是很难，手写代码确实会常见，问的比较多的是JS原理实现，比如深拷贝，防抖与节流理解，数组操作，业务上问题，这些手写很能体现前端的能力。综上，前端算法不是很难，但也重要，这对于理解前端框架一些源码很有帮助，如果没有接触过，还是需要好好准备，有一定基础的话，找一些top题做做差不多了，面试的时候就算没能A掉，说清楚思路也不会很惨。</p><figure data-tool="mdnice编辑器" style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex; flex-direction: column; justify-content: center; align-items: center;"><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/img_convert/77299a6a0651c7942af18b564e9edc04.png" alt style="max-width: 100%; border-radius: 6px; display: block; margin: 20px auto; object-fit: contain; box-shadow: 2px 4px 7px #999;"></figure><h3 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; color: black; font-size: 16px; font-weight: bold; text-align: center;"><span class="prefix" style="display: none;"></span><span class="content" style="border-bottom: 2px solid #d89cf6;">问题二</span><span class="suffix" style="display: none;"></span></h3><blockquote class="multiquote-1" data-tool="mdnice编辑器" style="border: none; display: block; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; border-left: 3px solid rgba(0, 0, 0, 0.4); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; border-left-color: #d89cf6; background: #f4eeff;"><p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px; margin: 0px; color: black; line-height: 26px;">其它像react这种框架，还有flutter、element这种目前框架中没用到的技术是不是不急着学？</p></blockquote><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;">对于第二个问题，前端框架确实也很多，这个也要看自己想学的技术栈和意向公司的招聘信息，比如想去的公司，例如字节跳动，腾讯这些，我觉得学会react在面试中会有更大优势。其次，我觉得这些框架只是一个我们前端工程师使用的工具而已，不管是现在主流的vue还是react框架，说不定未来又有新的框架出来。真正体现前端人能力的还是js能力，js基本功扎实，我觉得这些框架学起来都挺快的，所以不必都学，例如大家可能都在学习vue，那么与一般人的能力差距就在于有没有读过源码，能清晰地分析讲解其中源码实现，这对于面试是一个加分项，也可以作为自己的杀手锏，其实vue源码看了一些了，会发现学习react也不是很难，没有大家所说的react就很难学，这些都只是一个工具而已。综上，如果目前在学的是vue的话，那就往底层学一点，如果已经在学react，也可以去了解一些源码，例如react-fiber，然后讲清楚redux工作流等等。</p><h3 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; color: black; font-size: 16px; font-weight: bold; text-align: center;"><span class="prefix" style="display: none;"></span><span class="content" style="border-bottom: 2px solid #d89cf6;">问题三</span><span class="suffix" style="display: none;"></span></h3><blockquote class="multiquote-1" data-tool="mdnice编辑器" style="border: none; display: block; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; border-left: 3px solid rgba(0, 0, 0, 0.4); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; border-left-color: #d89cf6; background: #f4eeff;"><p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px; margin: 0px; color: black; line-height: 26px;">还有webpack、node这种应该学习到什么程度，目前webpack只是照着视频模拟了一下，不过这种东西很容易忘记，node还没怎么接触过</p></blockquote><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;">对于第三个问题，对于webpack和node来说的话，个人觉得面试考察频率不算太多吧，除非简历上明确写了会问，这些都与业务，工程化偏向多一点了，校招来说的话不会太多涉及，不过也要看一下意向公司的招聘信息，webpack这东西如果有时间可以深入理解一下，如果准备时间不够了，大概了解一下它是一个打包工具，然后看看一些面经应该足够。而node的话，现在后端也可以用js来写了，nodejs也有几个框架，比如经典express，同一个团队开发的Koa，还有阿里的egg.js，这些在自己js基本功扎实情况下学习起来也很容易，面试的话考察也较少，也看点运气咯。如果公司对这个考察比较多的话，那一般前端团队技术比较牛吧，前后端都能写！基本上就是react+ts技术栈了。</p><h3 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; color: black; font-size: 16px; font-weight: bold; text-align: center;"><span class="prefix" style="display: none;"></span><span class="content" style="border-bottom: 2px solid #d89cf6;">问题四</span><span class="suffix" style="display: none;"></span></h3><blockquote class="multiquote-1" data-tool="mdnice编辑器" style="border: none; display: block; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; border-left: 3px solid rgba(0, 0, 0, 0.4); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; border-left-color: #d89cf6; background: #f4eeff;"><p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px; margin: 0px; color: black; line-height: 26px;">网络协议之前看过面试时会问到输入url之后会发生什么，这块东西是不是直接看面经然后总结知识点会比较好？</p></blockquote><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;">对于第四个问题，关于网络方面的话，我觉得前后端都是重点吧，至于输入url之后发生什么，这个其实是属于浏览器工作原理方面了，网络原理方面是这方面的前置基础，关于这方面，我也正在写我自己的前端学习路线，https://yangchaoyi.vip/posts/2021520/（这份技术路线，我会一直持续更新到2021年春招，打算在最近两周内完成一个大概，后续会持续更改）其次，网络协议和浏览器这一块问题也算比较固定，其次前端还有网络安全，比如xss，csrf等。还有比较常见的跨域问题。</p></section>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【源码篇：总结与思考】虚拟节点与DOM Diff算法源码实现</title>
      <link href="posts/2020927/"/>
      <url>posts/2020927/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文源码收录于 <a href="https://github.com/Chocolate1999/DOM-Diff">DOM-Diff</a> 仓库，文章内容按照一位老师视频学习而来（详情见文本末尾哈），每一个字都是自己手动敲出来的，算是给自己的一个梳理和总结，下面，我们一起来学习一下 <code>dom diff</code> 吧。</p><h2 id="DOM-Diff"><a href="#DOM-Diff" class="headerlink" title="DOM Diff"></a>DOM Diff</h2><p><code>dom diff</code> 其实就是对比两个虚拟节点，然后对比它们的差异。然后再对应真实 <code>dom</code> 上进行一个打补丁操作。我们的目的就是找到其中的差异，然后用最小的代价来操作 <code>dom</code>。因为操作 <code>dom</code> 相对而言比较耗性能。</p><p>而对于虚拟节点呢，我们可以简单理解为<strong>普通对象</strong>。就是将真实节点用对象的方式模拟出来，通过比较两个新老虚拟节点，得到彼此的差异，形成一个补丁，最后再与真实的 <code>dom</code> 进行匹配，将这些补丁打到真实 <code>dom</code> 上去，最终，我们还是操作了原来的真实 <code>dom</code>，但是我们是用了差异化结果的 <strong>最小的代价</strong>  来操作的。</p><h3 id="平级对比"><a href="#平级对比" class="headerlink" title="平级对比"></a>平级对比</h3><p>上文我们讲解了虚拟节点可以简单理解为普通对象，那么我们来用图示来看一看，得到其中的一个特点：<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200926232712906.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70#pic_center" alt=""><br>左边就是旧的虚拟节点，而右边是新的虚拟节点。我们来看看有什么变化：</p><ul><li>第一层， <code>ul</code> 底下的 <code>class</code> 由 <code>list</code> 变为了 <code>wrap</code></li><li>第二层，第三个孩子 <code>li</code> 变为了 <code>div</code></li><li>第三层，有文本节点发生了变化，并且删除了一个节点</li><li>第四层，删除了一个节点</li></ul><p>从上述表述来看，可以知道 <code>dom diff</code> 算法是有一定规则的，即它只会平级的进行对比，是对应的，不存在跨级对比的问题。</p><p><strong>特点一</strong>：平级对比</p><h3 id="存在索引值"><a href="#存在索引值" class="headerlink" title="存在索引值"></a>存在索引值</h3><p>我们再来看看下面这种情况，比如左边旧虚拟 dom 和右边新的虚拟 dom ，会不会按照下面这种方式进行对比呢？</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200926233851748.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70#pic_center" alt=""><br>仍然不会，因为不是一一对应关系，即不属于平级关系。</p><p>那么，如果我们将新的虚拟dom上面节点删除掉呢，这种情况下会进行比对吗？<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200926234234333.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70#pic_center" alt=""><br>答案是不一定，因为在 <code>dom diff</code>算法中，对于虚拟节点是有对应的索引值的，如果满足<strong>平级</strong>关系后，此时索引值不相同，还是不会进行比对，只有<strong>索引值相同</strong>的才会进行比对，这个在下文会进一步探讨。</p><p><strong>特点二</strong>：存在索引值</p><h3 id="交换平级虚拟节点，无需重新渲染"><a href="#交换平级虚拟节点，无需重新渲染" class="headerlink" title="交换平级虚拟节点，无需重新渲染"></a>交换平级虚拟节点，无需重新渲染</h3><p>对于下图中，如果对于新旧虚拟dom中，我们的变化只是交换了一个虚拟节点，此时就不需要重新渲染了，直接替换就好了。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200926234534852.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70#pic_center" alt=""><br><strong>特点三</strong>：交换平级虚拟节点，无需重新渲染</p><h3 id="深度遍历"><a href="#深度遍历" class="headerlink" title="深度遍历"></a>深度遍历</h3><p>从下图索引值遍历循序课件，<code>dom</code> 的遍历时按照深度进行遍历的。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200926234744443.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70#pic_center" alt=""><br><strong>特点四</strong>：深度遍历</p><h2 id="建立项目"><a href="#建立项目" class="headerlink" title="建立项目"></a>建立项目</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>创建一个文件夹，我这里命名 <code>vDOM</code>，然后以 <code>vscode</code>打开，打开一个终端，执行下面代码，生成一个 <code>package.json</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm init - y</span><br></pre></td></tr></table></figure><p>然后安装 <code>webpack</code> 相关插件：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install webpack webpack-cli webpack-dev-server html-webpack-plugin</span><br></pre></td></tr></table></figure><p>安装完后，我们在项目文件夹内新建一个名为 <code>webpack.config.js</code> 的文件，进行相关配置：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>), <span class="comment">// 处理html</span></span><br><span class="line">  &#123; resolve &#125; = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">&#x27;./src/js/index.js&#x27;</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: resolve(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">    filename: <span class="string">&#x27;bundle.js&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  devtool: <span class="string">&#x27;source-map&#x27;</span>,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: resolve(__dirname, <span class="string">&#x27;src/index.html&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    contentBase: <span class="string">&#x27;./&#x27;</span>,</span><br><span class="line">    open: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置相关命令"><a href="#配置相关命令" class="headerlink" title="配置相关命令"></a>配置相关命令</h3><p>然后，我们回来 <code>package.json</code> 文件中来，更改我们的 <code>scripts</code>命令。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;vDOM&quot;</span>,</span><br><span class="line">  <span class="string">&quot;version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line">  <span class="string">&quot;description&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="string">&quot;main&quot;</span>: <span class="string">&quot;index.js&quot;</span>,</span><br><span class="line">  <span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;dev&quot;</span>: <span class="string">&quot;webpack-dev-server&quot;</span>,</span><br><span class="line">    <span class="string">&quot;build&quot;</span>: <span class="string">&quot;webpack&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;keywords&quot;</span>: [],</span><br><span class="line">  <span class="string">&quot;author&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="string">&quot;license&quot;</span>: <span class="string">&quot;ISC&quot;</span>,</span><br><span class="line">  <span class="string">&quot;dependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;html-webpack-plugin&quot;</span>: <span class="string">&quot;^4.5.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;webpack&quot;</span>: <span class="string">&quot;^4.44.2&quot;</span>,</span><br><span class="line">    <span class="string">&quot;webpack-cli&quot;</span>: <span class="string">&quot;^3.3.12&quot;</span>,</span><br><span class="line">    <span class="string">&quot;webpack-dev-server&quot;</span>: <span class="string">&quot;^3.11.0&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h3><p>配置完成后，我们就可以创建相关文件了，如下图所示：</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/2020092708412665.png#pic_center" alt=""><br>其中 <code>index.html</code> 文件内容可以初始化如下代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;en&quot;</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">  &lt;meta name=<span class="string">&quot;viewport&quot;</span> content=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br><span class="line">  &lt;title&gt;vDOM&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div id=<span class="string">&quot;app&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><code>index.js</code>文件初始化为如下代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>最后，执行 <code>npm run dev</code>，如果控制台打印了 1 ，代表 <code>webpack</code> 配置成功。</p><h3 id="创建虚拟-dom"><a href="#创建虚拟-dom" class="headerlink" title="创建虚拟 dom"></a>创建虚拟 dom</h3><p>配置成功后，就可先在 <code>js/index.js</code> 文件准备好我们的虚拟 dom 了，如下代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> vDom = createElement(<span class="string">&#x27;ul&#x27;</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;list&#x27;</span>, <span class="attr">style</span>: <span class="string">&#x27;width: 300px;height: 300px;background-color: orange&#x27;</span> &#125;, [</span><br><span class="line">  createElement(<span class="string">&#x27;li&#x27;</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;item&#x27;</span>, <span class="string">&#x27;data-index&#x27;</span>: <span class="number">0</span> &#125;, [</span><br><span class="line">    createElement(<span class="string">&#x27;p&#x27;</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;text&#x27;</span> &#125;, [<span class="string">&#x27;第1个列表项&#x27;</span>])</span><br><span class="line">  ]),</span><br><span class="line">  createElement(<span class="string">&#x27;li&#x27;</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;item&#x27;</span>, <span class="string">&#x27;data-index&#x27;</span>: <span class="number">1</span> &#125;, [</span><br><span class="line">    createElement(<span class="string">&#x27;p&#x27;</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;text&#x27;</span> &#125;, [</span><br><span class="line">      createElement(<span class="string">&#x27;span&#x27;</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;title&#x27;</span> &#125;, [<span class="string">&#x27;第2个列表项&#x27;</span>])</span><br><span class="line">    ])</span><br><span class="line">  ]),</span><br><span class="line">  createElement(<span class="string">&#x27;li&#x27;</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;item&#x27;</span>, <span class="string">&#x27;data-index&#x27;</span>: <span class="number">2</span> &#125;, [<span class="string">&#x27;第3个列表项&#x27;</span>])</span><br><span class="line">]);</span><br></pre></td></tr></table></figure><h3 id="生成-dom-对象"><a href="#生成-dom-对象" class="headerlink" title="生成 dom 对象"></a>生成 dom 对象</h3><p>创建完成后，会发现 <code>createElement</code>未定义，接下来我们来定义一下，在 <code>js</code> 文件夹底下，创建一个名为 <code>virtualDom.js</code> 的文件，相关内容代码如下：</p><p>定义 <code>createElement</code>，其中当然是要将我们的虚拟dom转换为dom对象，因此我们定义了一个类（见后文），然后将这个方法导出去。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Element <span class="keyword">from</span> <span class="string">&#x27;./Element&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createElement</span>(<span class="params">type, props, children</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Element(type, props, children);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">  createElement</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时，我们创建一个 <code>Element.js</code> 文件，用来将我们的虚拟dom转换为dom对象。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Element</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">type, props, children</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.type = type;</span><br><span class="line">    <span class="built_in">this</span>.props = props;</span><br><span class="line">    <span class="built_in">this</span>.children = children;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Element;</span><br></pre></td></tr></table></figure><p>定义好了方法之后，我们在最开始的 <code>index.js</code>文件里面进行引入操作</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createElement &#125; <span class="keyword">from</span> <span class="string">&#x27;./virtualDom&#x27;</span></span><br></pre></td></tr></table></figure><p>在尾部，我们可以打印一下 <code>vDom</code>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(vDom);</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200927090042901.png#pic_center" alt=""></p><h3 id="生成真实-dom-结构"><a href="#生成真实-dom-结构" class="headerlink" title="生成真实 dom 结构"></a>生成真实 dom 结构</h3><p>有了 <code>dom</code> 对象后，我们还需要解析成为真实的 <code>dom</code>，才会显示我们对应的页面，而这里需要一个 <code>render</code> 函数</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> rDom = render(vDom);</span><br></pre></td></tr></table></figure><p>在 <code>render</code>函数中，我们需要创建一个真实节点，然后将其属性加上去，而我们的属性 <code>key</code>值可能是 value，也可能是 style ，还有其它一些属性 key 值，因此我们不能直接通过 <code>node.setAttribute</code> 给节点设置属性值，需要分情况考虑。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将虚拟dom转换为真实dom</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">vDom</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; type, props, children &#125; = vDom;</span><br><span class="line">  <span class="comment">// 创建真实节点</span></span><br><span class="line">  <span class="keyword">const</span> el = <span class="built_in">document</span>.createElement(type);</span><br><span class="line">  <span class="comment">// 遍历属性</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> props) &#123;</span><br><span class="line">    <span class="comment">// 设置属性 分 input textarea </span></span><br><span class="line">    setAttrs(el, key, props[key]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(el);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，我们需要自定义设置节点属性值的方法，对于 value 、style等进行一个区分。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 给节点设置属性</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setAttrs</span>(<span class="params">node, prop, value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (prop) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;value&#x27;</span>:</span><br><span class="line">      <span class="keyword">if</span> (node.tagName === <span class="string">&#x27;INPUT&#x27;</span> || node.tagName === <span class="string">&#x27;TEXTAREA&#x27;</span>) &#123;</span><br><span class="line">        node.value = value;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node.setAttribute(prop, value);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;style&#x27;</span>:</span><br><span class="line">      node.style.cssText = value;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      node.setAttribute(prop, value);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，打印得到如下结果，发现 <code>ul</code>上的属性值都挂载上去了。<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200927093040424.png#pic_center" alt=""></p><h3 id="render-孩子节点"><a href="#render-孩子节点" class="headerlink" title="render 孩子节点"></a>render 孩子节点</h3><p>上文，我们只是对于祖先节点的设置属性操作，而对于孩子节点没有进行处理。对于孩子节点呢，我们也需要考虑一下，如果它还是属于 <code>Element</code>对象，那么我们就需要进行递归操作，而对于文本节点，直接创建一个新的节点即可，具体实现代码如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将虚拟dom转换为真实dom</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">vDom</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; type, props, children &#125; = vDom;</span><br><span class="line">  <span class="comment">// 创建真实节点</span></span><br><span class="line">  <span class="keyword">const</span> el = <span class="built_in">document</span>.createElement(type);</span><br><span class="line">  <span class="comment">// 遍历属性</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> props) &#123;</span><br><span class="line">    <span class="comment">// 设置属性 分 input textarea </span></span><br><span class="line">    setAttrs(el, key, props[key]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 处理孩子节点</span></span><br><span class="line">  children.map(<span class="function">(<span class="params">c</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 如果是元素节点</span></span><br><span class="line">    <span class="keyword">if</span> (c <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">      <span class="comment">// 递归操作</span></span><br><span class="line">      c = render(c);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 对于文本节点，直接创建一个新的节点</span></span><br><span class="line">      c = <span class="built_in">document</span>.createTextNode(c);</span><br><span class="line">    &#125;</span><br><span class="line">    el.appendChild(c);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> el;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终，我们得到了我们的真实 <code>dom</code>  结构啦，✿✿ヽ(°▽°)ノ✿</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200927093510983.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70#pic_center" alt=""></p><h3 id="renderDOM"><a href="#renderDOM" class="headerlink" title="renderDOM"></a>renderDOM</h3><p>有了真实dom后，我们还需要将这个真实dom渲染到页面去，方法如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 渲染真实dom</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">renderDOM</span>(<span class="params">rDom, rootEl</span>) </span>&#123;</span><br><span class="line">  rootEl.appendChild(rDom);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在我们的<code>index.js</code>文件中执行该方法：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> rDom = render(vDom);</span><br><span class="line"><span class="comment">// 执行渲染</span></span><br><span class="line">renderDOM(</span><br><span class="line">  rDom,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;app&#x27;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>最终，我们成功渲染我们的真实dom，得到如下结果✿✿ヽ(°▽°)ノ✿<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200927151400857.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70#pic_center" alt=""></p><h2 id="虚拟节点差异比较"><a href="#虚拟节点差异比较" class="headerlink" title="虚拟节点差异比较"></a>虚拟节点差异比较</h2><p>在上文，我们得到了真实dom结构并且进行了渲染，下文我们将进行两个虚拟dom之间的差异分析，然后形成一个补丁。</p><h3 id="两个虚拟dom"><a href="#两个虚拟dom" class="headerlink" title="两个虚拟dom"></a>两个虚拟dom</h3><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/2020092715180359.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70#pic_center" alt=""><br>上文两个 <code>vDom</code> 对应下面代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> vDom = createElement(<span class="string">&#x27;ul&#x27;</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;list&#x27;</span>, <span class="attr">style</span>: <span class="string">&#x27;width: 300px;height: 300px;background-color: orange&#x27;</span> &#125;, [</span><br><span class="line">  createElement(<span class="string">&#x27;li&#x27;</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;item&#x27;</span>, <span class="string">&#x27;data-index&#x27;</span>: <span class="number">0</span> &#125;, [</span><br><span class="line">    createElement(<span class="string">&#x27;p&#x27;</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;text&#x27;</span> &#125;, [<span class="string">&#x27;第1个列表项&#x27;</span>])</span><br><span class="line">  ]),</span><br><span class="line">  createElement(<span class="string">&#x27;li&#x27;</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;item&#x27;</span>, <span class="string">&#x27;data-index&#x27;</span>: <span class="number">1</span> &#125;, [</span><br><span class="line">    createElement(<span class="string">&#x27;p&#x27;</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;text&#x27;</span> &#125;, [</span><br><span class="line">      createElement(<span class="string">&#x27;span&#x27;</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;title&#x27;</span> &#125;, [<span class="string">&#x27;第2个列表项&#x27;</span>])</span><br><span class="line">    ])</span><br><span class="line">  ]),</span><br><span class="line">  createElement(<span class="string">&#x27;li&#x27;</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;item&#x27;</span>, <span class="string">&#x27;data-index&#x27;</span>: <span class="number">2</span> &#125;, [<span class="string">&#x27;第3个列表项&#x27;</span>])</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> vDom2 = createElement(<span class="string">&#x27;ul&#x27;</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;list-wrap&#x27;</span>, <span class="attr">style</span>: <span class="string">&#x27;width: 300px;height: 300px;background-color: orange&#x27;</span> &#125;, [</span><br><span class="line">  createElement(<span class="string">&#x27;li&#x27;</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;item&#x27;</span>, <span class="string">&#x27;data-index&#x27;</span>: <span class="number">0</span> &#125;, [</span><br><span class="line">    createElement(<span class="string">&#x27;p&#x27;</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;title&#x27;</span> &#125;, [<span class="string">&#x27;特殊列表项&#x27;</span>])</span><br><span class="line">  ]),</span><br><span class="line">  createElement(<span class="string">&#x27;li&#x27;</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;item&#x27;</span>, <span class="string">&#x27;data-index&#x27;</span>: <span class="number">1</span> &#125;, [</span><br><span class="line">    createElement(<span class="string">&#x27;p&#x27;</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;text&#x27;</span> &#125;, [])</span><br><span class="line">  ]),</span><br><span class="line">  createElement(<span class="string">&#x27;div&#x27;</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;item&#x27;</span>, <span class="string">&#x27;data-index&#x27;</span>: <span class="number">2</span> &#125;, [<span class="string">&#x27;第3个列表项&#x27;</span>])</span><br><span class="line">]);</span><br></pre></td></tr></table></figure><h3 id="patches"><a href="#patches" class="headerlink" title="patches"></a>patches</h3><p>补丁，其实也是一个对象。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200927152157893.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70#pic_center" alt=""></p><h3 id="domDiff"><a href="#domDiff" class="headerlink" title="domDiff"></a>domDiff</h3><p>在 <code>js</code> 文件夹底下，我们创建一个 <code>domDiff</code>文件，用来实现虚拟dom差异比较的方法。</p><p>在此之前，我们可以提前设置好对应的属性值，创建一个 <code>patchTypes.js</code>  文件，如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ATTR = <span class="string">&#x27;ATTR&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> TEXT = <span class="string">&#x27;TEXT&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> REPLACE = <span class="string">&#x27;REPLACE&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> REMOVE = <span class="string">&#x27;REMOVE&#x27;</span>;</span><br></pre></td></tr></table></figure><p>在 <code>domDiff</code> 文件中，我们需要做如下操作：</p><ul><li>进行深度遍历，比较新旧虚拟dom的差异</li><li>深度遍历时比较的是每一个虚拟节点，对于新节点如果它不存在，那么就是删除操作，打上删除的补丁</li><li>如果新旧节点都是文本节点并且值不相同，打上替换的补丁</li><li>而对于都是元素节点，并且节点类型相同的情况，我们就需要比较它们的属性值是否相同。同时，对于元素节点，它们都有自己的孩子节点，因此，我们需要对孩子节点进行递归 vnodeWalk 操作，此时需要定义一个全局节点的索引值，用来对应每一个虚拟节点的补丁索引</li><li>其它情况，就是进行了替换操作，直接打上替换的补丁</li></ul><p>比较元素节点的属性值时，又会有几种情况考虑：</p><ul><li>先遍历旧的属性集合，如果新旧属性值不一样，那么就是修改了属性，打上修改的属性补丁</li><li>在遍历新的属性集合，如果旧属性值没有，那么就是新增了属性，打上增加的属性补丁</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  ATTR,</span><br><span class="line">  TEXT,</span><br><span class="line">  REPLACE,</span><br><span class="line">  REMOVE</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&#x27;./patchTypes&#x27;</span>;</span><br><span class="line"><span class="comment">// 定义全局补丁对象</span></span><br><span class="line"><span class="keyword">let</span> patches = &#123;&#125;;</span><br><span class="line"><span class="comment">// 定义全局索引值</span></span><br><span class="line"><span class="keyword">let</span> vnIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">domDiff</span>(<span class="params">oldVDom, newVDom</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 深度遍历</span></span><br><span class="line">  vnodeWalk(oldVDom, newVDom, index);</span><br><span class="line">  <span class="keyword">return</span> patches;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 深度遍历</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">vnodeWalk</span>(<span class="params">oldNode, newNode, index</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 对每一个节点创建一个小补丁</span></span><br><span class="line">  <span class="keyword">let</span> vnPatch = [];</span><br><span class="line">  <span class="comment">// 如果在新节点不存在了，就是存在删除操作</span></span><br><span class="line">  <span class="keyword">if</span> (!newNode) &#123;</span><br><span class="line">    vnPatch.push(&#123;</span><br><span class="line">      type: REMOVE,</span><br><span class="line">      index</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> oldNode === <span class="string">&#x27;string&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> newNode === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果都是文本节点并且值不相同，需要进行替换操作</span></span><br><span class="line">    <span class="keyword">if</span> (oldNode !== newNode) &#123;</span><br><span class="line">      vnPatch.push(&#123;</span><br><span class="line">        type: TEXT,</span><br><span class="line">        text: newNode</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldNode.type === newNode.type) &#123;</span><br><span class="line">    <span class="comment">// 如果两个都是元素节点，并且它们的类型相同，此时我们需要对它们的属性进行差异比较</span></span><br><span class="line">    <span class="keyword">const</span> attrPatch = attrsWalk(oldNode.props, newNode.props);</span><br><span class="line">    <span class="comment">// 如果属性差异有的话，我们才会放入我们的补丁集合当中</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Object</span>.keys(attrPatch).length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      vnPatch.push(&#123;</span><br><span class="line">        type: ATTR,</span><br><span class="line">        attrs: attrPatch</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历它们的孩子</span></span><br><span class="line">    childrenWalk(oldNode.children, newNode.children);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">// 其它情况，执行了替换操作，打上替换补丁即可</span></span><br><span class="line">    vnPatch.push(&#123;</span><br><span class="line">      type: REPLACE,</span><br><span class="line">      newNode</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 判断是否有补丁</span></span><br><span class="line">  <span class="keyword">if</span>(vnPatch.length)&#123;</span><br><span class="line">    patches[index] = vnPatch;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打属性的补丁</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">attrsWalk</span>(<span class="params">oldAttrs, newAttrs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> attrPatch = &#123;&#125;;</span><br><span class="line">  <span class="comment">// 遍历旧的属性值，看是否修改了属性值</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> oldAttrs) &#123;</span><br><span class="line">    <span class="comment">// 如果对于相同的key，值不相同，则需要保存新节点的属性值，形成一个小补丁</span></span><br><span class="line">    <span class="keyword">if</span> (oldAttrs[key] !== newAttrs[key]) &#123;</span><br><span class="line">      attrPatch[key] = newAttrs[key];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 遍历新的属性值，看是否存在新增了属性值</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> newAttrs) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!oldAttrs.hasOwnProperty(key)) &#123;</span><br><span class="line">      attrPatch[key] = newAttrs[key];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> attrPatch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历孩子</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">childrenWalk</span>(<span class="params">oldChildren, newChildren</span>) </span>&#123;</span><br><span class="line">  oldChildren.map(<span class="function">(<span class="params">c, idx</span>) =&gt;</span> &#123;</span><br><span class="line">    vnodeWalk(c, newChildren[idx], ++vnIndex);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> domDiff;</span><br></pre></td></tr></table></figure><p>此时，我们打印出来了比对差异之后的补丁 ✿✿ヽ(°▽°)ノ✿</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200927155818144.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70#pic_center" alt=""></p><h3 id="给真实-dom-打补丁"><a href="#给真实-dom-打补丁" class="headerlink" title="给真实 dom 打补丁"></a>给真实 dom 打补丁</h3><p>上文我们得到了虚拟dom之间的差异补丁，下面我们将做打补丁操作。</p><p>首先，还是在 <code>js</code> 文件夹下创建一个 <code>doPatch.js</code> 文件，里面编写打补丁方法。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 保存补丁包，形成全局变量</span></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  ATTR,</span><br><span class="line">  TEXT,</span><br><span class="line">  REPLACE,</span><br><span class="line">  REMOVE</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&#x27;./patchTypes&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; setAttrs, render &#125; <span class="keyword">from</span> <span class="string">&#x27;./virtualDom&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Element <span class="keyword">from</span> <span class="string">&#x27;./Element&#x27;</span></span><br><span class="line"><span class="keyword">let</span> finalPatches = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> rnIndex = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doPatch</span>(<span class="params">rDom, patches</span>) </span>&#123;</span><br><span class="line">  finalPatches = patches;</span><br><span class="line">  <span class="comment">// 遍历真实dom</span></span><br><span class="line">  rNodeWalk(rDom);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 真实dom遍历</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rNodeWalk</span>(<span class="params">rNode</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> rnPatch = finalPatches[rnIndex++];</span><br><span class="line">  <span class="keyword">const</span> childNodes = rNode.childNodes;</span><br><span class="line">  <span class="comment">// 递归孩子节点</span></span><br><span class="line">  [...childNodes].map(<span class="function">(<span class="params">c</span>) =&gt;</span> &#123;</span><br><span class="line">    rNodeWalk(c);</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 如果当前索引下存在补丁，才会有后续操作</span></span><br><span class="line">  <span class="keyword">if</span> (rnPatch) &#123;</span><br><span class="line">    patchAction(rNode, rnPatch);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打补丁</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patchAction</span>(<span class="params">rNode, rnPatch</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 遍历当前索引节点下的所有补丁</span></span><br><span class="line">  rnPatch.map(<span class="function">(<span class="params">p</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (p.type) &#123;</span><br><span class="line">      <span class="keyword">case</span> ATTR:</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> p.attrs) &#123;</span><br><span class="line">          <span class="comment">// 取属性值</span></span><br><span class="line">          <span class="keyword">const</span> val = p.attrs[key];</span><br><span class="line">          <span class="comment">// 属性值存在，我们就对其进行设置</span></span><br><span class="line">          <span class="keyword">if</span> (val) &#123;</span><br><span class="line">            setAttrs(rNode, key, val);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 属性值不存在，直接删除对应key值即可</span></span><br><span class="line">            rNode.removeAttribute(key);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> TEXT:</span><br><span class="line">        rNode.textContent = p.text;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> REPLACE:</span><br><span class="line">        <span class="comment">// 替换操作的话，我们需要判断如果还是虚拟dom的话需要走一遍render函数，形成真实dom，否则就直接新创建一个文本节点</span></span><br><span class="line">        <span class="keyword">const</span> newNode = (p.newNode <span class="keyword">instanceof</span> Element) ? render(p.newNode) : <span class="built_in">document</span>.createTextNode(p.newNode);</span><br><span class="line">        <span class="comment">// 替换操作，先找到父节点然后替换子节点即可</span></span><br><span class="line">        rNode.parentNode.replaceChild(newNode, rNode);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> REMOVE:</span><br><span class="line">        <span class="comment">// 删除操作，先找到父节点然后直接删除对应自己即可</span></span><br><span class="line">        rNode.parentNode.removeChild(rNode);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> doPatch;</span><br></pre></td></tr></table></figure><p>此时，我们打印出来了最后打上补丁的dom结构  ✿✿ヽ(°▽°)ノ✿</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/2020092716582879.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70#pic_center" alt=""></p><p>最终，我们的页面变成了这样：</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200927165907168.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70#pic_center" alt=""></p><h2 id="总结与个人思考"><a href="#总结与个人思考" class="headerlink" title="总结与个人思考"></a>总结与个人思考</h2><p>根据本文的理解，下面我将总结一下如果面试的话，该如何讲清楚这个 diff 算法。经典三部曲：是什么，为什么，怎么做？</p><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>首先，谈及 <code>diff</code> 算法，其实就是对比两个虚拟节点，然后对比它们的差异。然后再对应真实 <code>dom</code> 上进行一个打补丁操作。我们的目的就是找到其中的差异，然后用最小的代价来操作 <code>dom</code>。因为操作 <code>dom</code> 相对而言比较耗性能。</p><h3 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h3><p>那么为什么用 <code>diff</code>算法呢？直接操作真实 <code>dom</code> 难道不香吗？而且你使用 <code>diff</code> 算法后只是得到了差异化，最后还是要操作真实 dom 的，好像没太多区别？</p><p>当然有区别了，从 <strong>是什么</strong> 我们了解了直接操作 <code>dom</code> 的话比较耗费性能，想想 <code>JQuery</code> 时代，操作一个表格，如果对表格中某一项进行修改，那么整个表格 dom 节点都要重新刷一下，这显然很费性能。</p><p>虚拟节点呢，我们可以简单理解为<strong>普通对象</strong>。就是将真实节点用对象的方式模拟出来，通过比较两个新老虚拟节点，得到彼此的差异，形成一个补丁，最后再与真实的 <code>dom</code> 进行匹配，将这些补丁打到真实 <code>dom</code> 上去，最终，我们还是操作了原来的真实 <code>dom</code>，但是我们是用了差异化结果的 <strong>最小的代价</strong>  来操作的。</p><h3 id="怎么做"><a href="#怎么做" class="headerlink" title="怎么做"></a>怎么做</h3><p>这里我就按照本文的思路来说一说实现过程了：</p><p>首先，我们需要将虚拟节点给创建出来，虚拟节点可以理解为 <strong>普通对象</strong>，然后将虚拟dom转换为真实的dom节点，通过 <code>renderDOM</code>方法渲染到页面上，呈现出我们看到的页面。之后，通过 <code>domDiff</code> 方法，比对两个虚拟 dom ，得到补丁 <code>patches</code>，最后，我们通过 <code>doPatch</code> 方法操作真实 dom 执行打补丁操作。</p><p>对于<strong>虚拟 dom 转换为真实 dom</strong> 过程中，有需要注意的点：</p><p>首先，遍历每一个虚拟节点，对其创建一个真实的节点，此时节点上面还没有任何属性添加，我们需要遍历虚拟节点的属性，而对于属性，会有几种情况需要考虑，对于像<strong>输入框</strong>和<strong>文本框</strong>，我们是通过 <code>node.value</code> 这样来进行赋值操作，而对于<strong>样式属性</strong>的话，我们是通过 <code>node.style.cssText</code>来设置样式，其它情况我们是通过 <code>node.setAttribute</code> 直接操作。因此，我们需要分情况来讨论，所以在上述代码中，我们单独写了一个 <code>setAttr</code> 方法来给真实节点设置属性。</p><p>属性操作完了，还是不够，我们不是有三个属性吗？ <code>type</code> 、 <code>props</code>、<code>children</code>，对了还有我们的孩子节点，对于孩子节点，我们需要判断是不是<strong>普通文本节点</strong>，如果是的话，直接通过  <code>document.createTextNode</code> 来创建一个文本节点就好了，而对于虚拟节点的话，我们需要执行<strong>递归</strong>操作。最后，将孩子节点通过 <code>appendChild</code>方法添加到当前<strong>真实根节点</strong>上。</p><hr/><p>对于 <strong>dom diff</strong>， 一个核心部分就是 <code>vnodeWalk</code>，用来进行节点的深度遍历。</p><p>在 <code>domDiff</code> 文件中，我们需要做如下操作：</p><ul><li>进行深度遍历，比较新旧虚拟dom的差异</li><li>深度遍历时比较的是每一个虚拟节点，对于新节点如果它不存在，那么就是删除操作，打上删除的补丁</li><li>如果新旧节点都是文本节点并且值不相同，打上替换的补丁</li><li>而对于都是元素节点，并且节点类型相同的情况，我们就需要比较它们的属性值是否相同。同时，对于元素节点，它们都有自己的孩子节点，因此，我们需要对孩子节点进行递归 vnodeWalk 操作，此时需要定义一个全局节点的索引值，用来对应每一个虚拟节点的补丁索引</li><li>其它情况，就是进行了替换操作，直接打上替换的补丁</li></ul><p>比较元素节点的属性值时，又会有几种情况考虑：</p><ul><li>先遍历旧的属性集合，如果新旧属性值不一样，那么就是修改了属性，打上修改的属性补丁</li><li>在遍历新的属性集合，如果旧属性值没有，那么就是新增了属性，打上增加的属性补丁</li></ul><h2 id="本文参考"><a href="#本文参考" class="headerlink" title="本文参考"></a>本文参考</h2><p><a href="https://www.bilibili.com/video/BV1zk4y1y7sD">【全网首发:完结】虚拟节点与DOM Diff算法源码实现【面试必备】</a></p><blockquote><p>感谢小野老师的对算法的细致讲解，给老师打call，建议大家可以结合视频看一看，看完会恍然大悟的！</p></blockquote><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>文章产出不易，还望各位小伙伴们支持一波！</p><p>往期精选：</p><p><a href="https://github.com/Chocolate1999/Front-end-learning-to-organize-notes">小狮子前端の笔记仓库</a></p><p><a href="https://github.com/Chocolate1999/leetcode-javascript">leetcode-javascript：LeetCode 力扣的 JavaScript 解题仓库，前端刷题路线（思维导图）</a></p><p>小伙伴们可以在Issues中提交自己的解题代码，🤝 欢迎Contributing，可打卡刷题，Give a ⭐️ if this project helped you!</p><p><a href="https://yangchaoyi.vip/">访问超逸の博客</a>，方便小伙伴阅读玩耍~</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/2020090211491121.png#pic_center" alt=""></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">学如逆水行舟，不进则退</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 源码篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（1.8w字，建议收藏）Vue源码解析—动手实现简化版MVVM</title>
      <link href="posts/2020718/"/>
      <url>posts/2020718/</url>
      
        <content type="html"><![CDATA[<h2 id="Vue源码解析—动手实现简化版MVVM"><a href="#Vue源码解析—动手实现简化版MVVM" class="headerlink" title="Vue源码解析—动手实现简化版MVVM"></a>Vue源码解析—动手实现简化版MVVM</h2><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p> 相信只要去面试 <code>Vue</code>，都会被用到 <code>vue</code>的双向数据绑定，你如果只说个 <code>mvvm</code>就是视图模型模型视图，只要数据改变视图也会同步更新，那可能达不到面试官想要的那个层次。甚至可以说这一点就让面试官觉得你知识了解的还不够，只是粗略地明白双向绑定这个概念。</p><p>本博客旨在通过一个简化版的代码来对 <code>mvvm</code> 理解更加深刻，如若存在问题，欢迎评论提出，谢谢您！</p><p>最后，希望你给一个点赞或 <code>star</code> :star:，谢谢您的支持！</p><p><a href="https://github.com/Chocolate1999/Vue-MVVM">实现源码传送门</a></p><p>同时，也会收录在<strong>小狮子前端笔记</strong>仓库里 ✿✿ヽ(°▽°)ノ✿</p><p><a href="https://github.com/Chocolate1999/Front-end-learning-to-organize-notes">小狮子前端の学习整理笔记   Front-end-learning-to-organize-notes</a></p><p><strong>实现效果：</strong><br><img src= "/img/loading.gif" data-lazy-src="https://user-gold-cdn.xitu.io/2020/7/18/1735ffad3c1fbcd9?w=353&h=359&f=gif&s=51667" alt=""></p><h2 id="几种实现双向绑定的做法"><a href="#几种实现双向绑定的做法" class="headerlink" title="几种实现双向绑定的做法"></a>几种实现双向绑定的做法</h2><p>目前几种主流的 <code>mvc(vm)</code>框架都实现了单向数据绑定，即用数据操作视图，数据更新，视图同步更新。而双向数据绑定无非就是在单向绑定的基础上给可输入元素（如 <code>input</code>、<code>textarea</code>等）添加了 <code>change(input)</code>事件，来动态修改  <code>model</code> 和 <code>view</code>，这样就能用视图来操作数据了，即视图更新，数据同步更新。</p><p>实现数据绑定的做法大致有如下几种：</p><blockquote><p>发布者-订阅者模式（backbone.js）<br>脏值检查（angular.js）将旧值和新值进行比对，如果有变化的话，就会更新视图，最简单的方式就是通过 <code>setInterval()</code>定时轮询检测数据变动。<br>数据劫持（vue.js）</p></blockquote><p><strong>发布者-订阅者模式</strong>：一般通过 <code>sub</code>，<code>pub</code> 的方式实现数据和视图的绑定监听，更新数据方式通常做法是 <code>vm.set(&#39;property&#39;, value)</code></p><p>但上述方式对比现在来说满足不了我们需要了，我们更希望通过 <code>vm.property = value</code> 这种方式更新数据，同时自动更新视图，于是有了下面两种方式：</p><p><strong>脏值检测</strong>： <code>angular.js</code> 是通过脏值检测的方式比对数据是否变更，来决定是否更新视图，最简单的方式就是通过 <code>setInterval()</code>定时轮询检测数据变动。当然，它只在指定的事件触发时才进入脏值检测，大致如下：</p><ul><li><code>DOM</code>事件，譬如用户输入文本，点击按钮等。(<code>ng-click</code>)</li><li><code>XHR</code>响应事件（<code>$http</code>）</li><li>浏览器 <code>Location</code> 变更事件（<code>$location</code>）</li><li><code>Timer</code> 事件（<code>$timeout</code>, <code>$interval</code>）</li></ul><p><strong>数据劫持</strong>： <code>vue.js</code> 则是采用数据劫持结合发布者-订阅者模式的方式，通过 <code>object.defineProperty()</code> 来劫持各个属性的 <code>setter</code>、<code>getter</code>，在数据变动时发布消息给订阅者，触发相应的监听回调。 </p><h2 id="实现-mvvm-的双向绑定"><a href="#实现-mvvm-的双向绑定" class="headerlink" title="实现 mvvm 的双向绑定"></a>实现 <code>mvvm</code> 的双向绑定</h2><p>要实现 <code>mvvm</code> 的双向绑定，就必须要实现以下几点： </p><ul><li>实现一个指令解析器 <code>Compile</code>，对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数 </li><li>实现一个数据监听器<code>Observer</code>，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者 </li><li>实现一个<code>Watcher</code>，作为连接<code>Observer</code>和<code>Compile</code>的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图 </li><li><code>mvvm</code>入口函数，整合以上三者</li></ul><p>整合流程图如下图所示：<br><img src= "/img/loading.gif" data-lazy-src="https://user-gold-cdn.xitu.io/2020/7/18/1735ffad46ecf108?w=730&h=390&f=png&s=49521" alt=""></p><h2 id="实现指令解析器-Compile"><a href="#实现指令解析器-Compile" class="headerlink" title="实现指令解析器 Compile"></a>实现指令解析器 Compile</h2><p><code>compile</code> 主要做的事情是<strong>解析模板指令</strong>，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图，如下图所示：<br><img src= "/img/loading.gif" data-lazy-src="https://user-gold-cdn.xitu.io/2020/7/18/1735ffad3cd1a2f0?w=625&h=259&f=png&s=30493" alt=""></p><p>因为遍历解析的过程有多次操作 <code>dom</code> 节点，为提高性能和效率，会先将 <code>vue</code> 实例根节点的 <code>el</code> 转换成文档碎片<code>fragment</code>进行解析编译操作，解析完成，再将<code>fragment</code>添加回原来的真实<code>dom</code>节点中。</p><p><code>html</code> 页面引入我们重新写的 <code>myVue.js</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;./myVue.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="创建-myVue-类"><a href="#创建-myVue-类" class="headerlink" title="创建 myVue 类"></a>创建 <code>myVue</code> 类</h3><p>创建一个 <code>myVue</code> 类，构造函数如下所示，将页面的挂载 <code>el</code>、数据 <code>data</code>、操作集 <code>options</code> 进行保存。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myVue</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">options</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.$el = options.el</span><br><span class="line">    <span class="built_in">this</span>.$data = options.data</span><br><span class="line">    <span class="built_in">this</span>.$options = options</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">this</span>.$el)&#123;</span><br><span class="line">      <span class="comment">// 1.实现数据观察者（省略...）</span></span><br><span class="line">      <span class="comment">// 2.实现指令解析器</span></span><br><span class="line">      <span class="keyword">new</span> Compile(<span class="built_in">this</span>.$el,<span class="built_in">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// console.log(this)</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现-Compile-类"><a href="#实现-Compile-类" class="headerlink" title="实现 Compile 类"></a>实现 <code>Compile</code> 类</h3><p>具体实现步骤：</p><ul><li>判断当前挂载是否为元素节点，不是的话就得寻找 <code>query</code></li><li>获取文档碎片对象，放入内存中来操作我们的 <code>dom</code>节点，目的是减少页面的回流和重绘</li><li>最后，将编译后的模板添加到根元素</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Compile</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">el,vm</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 判断是否为元素节点，如果不是就query</span></span><br><span class="line">    <span class="built_in">this</span>.el = <span class="built_in">this</span>.isElementNode(el) ? el : <span class="built_in">document</span>.querySelector(el)</span><br><span class="line">    <span class="built_in">this</span>.vm = vm</span><br><span class="line">    <span class="comment">// 1、获取文档碎片对象，放入内存中，会减少页面的回流和重绘</span></span><br><span class="line">    <span class="keyword">const</span> fragment = <span class="built_in">this</span>.node2Fragment(<span class="built_in">this</span>.el)</span><br><span class="line">    <span class="comment">// 2、编译模板</span></span><br><span class="line">    <span class="built_in">this</span>.compile(fragment)</span><br><span class="line">    <span class="comment">// 3、追加子元素到根元素</span></span><br><span class="line">    <span class="built_in">this</span>.el.appendChild(fragment)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>判断是否为元素节点，直接判断nodeType是否为1即可</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">isElementNode</span>(<span class="params">node</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> node.nodeType  === <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 <code>document.createDocumentFragment()</code> 创建文档碎片对象，通过 <code>el.firstChild</code> 是否还存在来判断，然后将 <code>dom</code> 节点添加到文档碎片对象中，最后 <code>return</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">node2Fragment</span>(<span class="params">el</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 创建文档碎片对象</span></span><br><span class="line">  <span class="keyword">const</span> fragment = <span class="built_in">document</span>.createDocumentFragment()</span><br><span class="line">  <span class="keyword">let</span> firstChild</span><br><span class="line">  <span class="keyword">while</span>(firstChild =  el.firstChild)&#123;</span><br><span class="line">    fragment.appendChild(firstChild)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fragment</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编译模板"><a href="#编译模板" class="headerlink" title="编译模板"></a>编译模板</h3><p>解析模板时，会获取得到所有的子节点，此时分两种情况，即<code>元素</code>节点和<code>文本</code>节点。如果当前节点还存在子节点，则需要通过递归操作来遍历其子节点。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">compile</span>(<span class="params">fragment</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 1、获取所有子节点</span></span><br><span class="line">  <span class="keyword">const</span> childNodes = fragment.childNodes;</span><br><span class="line">  [...childNodes].forEach(<span class="function"><span class="params">child</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// console.log(child)</span></span><br><span class="line">    <span class="comment">// 如果是元素节点，则编译元素节点</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">this</span>.isElementNode(child))&#123;</span><br><span class="line">       <span class="comment">// console.log(&#x27;元素节点&#x27;,child) </span></span><br><span class="line">      <span class="built_in">this</span>.compileElement(child)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="comment">// 其它为文本节点，编译文本节点</span></span><br><span class="line">      <span class="comment">// console.log(&#x27;文本节点&#x27;,child)</span></span><br><span class="line">      <span class="built_in">this</span>.compileText(child)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(child.childNodes &amp;&amp; child.childNodes.length)&#123;</span><br><span class="line">      <span class="built_in">this</span>.compile(child)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编译元素节点（遇见设计模式）"><a href="#编译元素节点（遇见设计模式）" class="headerlink" title="编译元素节点（遇见设计模式）"></a>编译元素节点（遇见设计模式）</h3><p>节点 <code>node</code> 上有一个 <code>attributes</code> 属性，来获取当前节点的所有属性，通过是否以 <code>v-</code> 开头来判断当前属性名称是否为一个指令。如果是一个指令的话，还需进行分类编译，用数据来驱动视图。更新数据完毕后，再通过 <code>removeAttribute</code> 事件来删除指令上标签的属性。</p><p>如果是非指令的话，例如事件 <code>@click=&quot;sayHi&quot;</code>，仅需通过指令 <code>v-on</code> 来实现即可。</p><p>对于不同的指令，我们最好进行一下封装，这里就巧妙运用了 <strong>策略模式</strong> 。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">compileElement</span>(<span class="params">node</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> attributes = node.attributes;</span><br><span class="line">    [...attributes].forEach(<span class="function"><span class="params">attr</span>=&gt;</span>&#123;</span><br><span class="line">      <span class="comment">// console.log(attr)</span></span><br><span class="line">      <span class="keyword">const</span> &#123;name,value&#125; = attr;</span><br><span class="line">      <span class="comment">// console.log(name,value)</span></span><br><span class="line">      <span class="comment">// 判断当前name值是否为一个指令，通过是否以 &#x27;v-&#x27; 开头来判断</span></span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">this</span>.isDirective(name))&#123;</span><br><span class="line">        <span class="comment">// console.log(name.split(&#x27;-&#x27;))</span></span><br><span class="line">        <span class="keyword">const</span> [,directive] = name.split(<span class="string">&#x27;-&#x27;</span>) <span class="comment">// text html model on:click</span></span><br><span class="line">        <span class="comment">// console.log(directive)</span></span><br><span class="line">        <span class="keyword">const</span> [dirName,eventName] = directive.split(<span class="string">&#x27;:&#x27;</span>) <span class="comment">// text html model on</span></span><br><span class="line">        <span class="comment">// 更新数据 数据驱动视图</span></span><br><span class="line">        complieUtil[dirName](node,value,<span class="built_in">this</span>.vm,eventName)</span><br><span class="line">        <span class="comment">// 删除指令上标签上的属性</span></span><br><span class="line">        node.removeAttribute(<span class="string">&#x27;v-&#x27;</span> + directive)</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">this</span>.isEventName(name))&#123; <span class="comment">// @click=&quot;sayHi&quot;</span></span><br><span class="line">        <span class="keyword">let</span> [,eventName] = name.split(<span class="string">&#x27;@&#x27;</span>)</span><br><span class="line">        complieUtil[<span class="string">&#x27;on&#x27;</span>](node,value,<span class="built_in">this</span>.vm,eventName)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>判断当前 <code>attrName</code> 是否为一个指令，仅需判断是否以 <code>v-</code> 开头</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">isDirective</span>(<span class="params">attrName</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> attrName.startsWith(<span class="string">&#x27;v-&#x27;</span>)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>判断当前 <code>attrName</code> 是否为一个事件，就看是否以<code>&#39;@&#39;</code>开头的事件绑定</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">isEventName</span>(<span class="params">attrName</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> attrName.startsWith(<span class="string">&#x27;@&#x27;</span>)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>指令处理集合</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> complieUtil = &#123;</span><br><span class="line">  <span class="function"><span class="title">getVal</span>(<span class="params">expr,vm</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> expr.split(<span class="string">&#x27;.&#x27;</span>).reduce(<span class="function">(<span class="params">data,currentVal</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="comment">// console.log(currentVal)</span></span><br><span class="line">      <span class="keyword">return</span> data[currentVal]</span><br><span class="line">    &#125;,vm.$data)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">text</span>(<span class="params">node,expr,vm</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> value;</span><br><span class="line">    <span class="comment">// 元素节点</span></span><br><span class="line">    <span class="keyword">if</span>(expr.indexOf(<span class="string">&#x27;&#123;&#123;&#x27;</span>) !== -<span class="number">1</span>)&#123;</span><br><span class="line">      value = expr.replace(<span class="regexp">/\&#123;\&#123;(.+?)\&#125;\&#125;/g</span>, <span class="function">(<span class="params">...args</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.getVal(args[<span class="number">1</span>],vm);</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123; <span class="comment">// 文本节点</span></span><br><span class="line">      value = <span class="built_in">this</span>.getVal(expr,vm)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.updater.textUpdater(node,value)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">html</span>(<span class="params">node,expr,vm</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> value = <span class="built_in">this</span>.getVal(expr,vm)</span><br><span class="line">    <span class="built_in">this</span>.updater.htmlUpdater(node,value)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">model</span>(<span class="params">node,expr,vm</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> value = <span class="built_in">this</span>.getVal(expr,vm)</span><br><span class="line">    <span class="built_in">this</span>.updater.modelUpdater(node,value)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">on</span>(<span class="params">node,expr,vm,eventName</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> fn = vm.$options.methods &amp;&amp; vm.$options.methods[expr] </span><br><span class="line">    <span class="comment">// 1、让fn通过bind函数指向原来的vm 2、默认冒泡</span></span><br><span class="line">    node.addEventListener(eventName,fn.bind(vm),<span class="literal">false</span>) </span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">bind</span>(<span class="params">node,expr,vm,attrName</span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 更新的函数</span></span><br><span class="line">  updater:&#123;</span><br><span class="line">    <span class="function"><span class="title">textUpdater</span>(<span class="params">node,value</span>)</span>&#123;</span><br><span class="line">      node.textContent = value</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">htmlUpdater</span>(<span class="params">node,value</span>)</span>&#123;</span><br><span class="line">      node.innerHTML = value</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">modelUpdater</span>(<span class="params">node,value</span>)</span>&#123;</span><br><span class="line">      node.value = value</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现数据监听器-Observer"><a href="#实现数据监听器-Observer" class="headerlink" title="实现数据监听器 Observer"></a>实现数据监听器 Observer</h2><p>利用 <code>Obeject.defineProperty()</code> 来监听属性变动，那么将需要 <code>observe</code> 的数据对象进行递归遍历，包括子属性对象的属性，都加上 <code>setter</code> 和 <code>getter</code> 。这样的话，给这个对象的某个值赋值，就会触发 <code>setter</code> ，那么就能监听到了数据变化。具体代码如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.observe(data)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">observe</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(data &amp;&amp; <span class="keyword">typeof</span> data === <span class="string">&#x27;object&#x27;</span>)&#123;</span><br><span class="line">      <span class="comment">// console.log(Object.keys(data))</span></span><br><span class="line">      <span class="comment">// 进行数据劫持</span></span><br><span class="line">      <span class="built_in">Object</span>.keys(data).forEach(<span class="function"><span class="params">key</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.defineReactive(data,key,data[key])</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">defineReactive</span>(<span class="params">obj,key,value</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 递归遍历</span></span><br><span class="line">    <span class="built_in">this</span>.observe(value)</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(obj,key,&#123;</span><br><span class="line">      enumerable: <span class="literal">true</span>,</span><br><span class="line">      configurable: <span class="literal">false</span>,</span><br><span class="line">      <span class="function"><span class="title">get</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 订阅数据变化时，往Dep中添加观察者，进行依赖收集</span></span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 通过箭头函数改变this指向到class Observer</span></span><br><span class="line">      set:<span class="function">(<span class="params">newVal</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.observe(newVal)</span><br><span class="line">        <span class="keyword">if</span>(newVal !== value)&#123;</span><br><span class="line">          value = newVal</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>data</code> 示例如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">  person:&#123;</span><br><span class="line">    name: <span class="string">&#x27;Chocolate&#x27;</span>,</span><br><span class="line">    age: <span class="number">20</span>,</span><br><span class="line">    hobby: <span class="string">&#x27;写代码&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  msg: <span class="string">&#x27;超逸の技术博客&#x27;</span>,</span><br><span class="line">  htmlStr: <span class="string">&#x27;&lt;h3&gt;欢迎一起学习~&lt;/h3&gt;&#x27;</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h2 id="实现-watcher-去更新视图"><a href="#实现-watcher-去更新视图" class="headerlink" title="实现 watcher 去更新视图"></a>实现 watcher 去更新视图</h2><p><img src= "/img/loading.gif" data-lazy-src="https://user-gold-cdn.xitu.io/2020/7/18/1735ffad46ecf108?w=730&h=390&f=png&s=49521" alt=""><br><code>Watcher</code>  订阅者作为 <code>Observer</code> 和 <code>Compile</code> 之间通信的桥梁，主要做的事情是:</p><ul><li>在自身实例化时往属性订阅器( <code>dep</code> )里面添加自己 </li><li>自身必须有一个 <code>update()</code>方法 </li><li>待属性变动<code>dep.notify()</code>通知时，能调用自身的 <code>update()</code> 方法，并触发 <code>Compile</code> 中绑定的回调。</li></ul><h3 id="Watcher-订阅者"><a href="#Watcher-订阅者" class="headerlink" title="Watcher  订阅者"></a><code>Watcher</code>  订阅者</h3><p>实例化 <code>Watcher</code> 的时候，调用 <code>getOldVal()</code> 方法，来获取旧值。通过 <code>Dep.target = watcherInstance（this）</code> 标记订阅者是当前 <code>watcher</code>实例（即指向自己）。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">vm,expr,cb</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.vm = vm</span><br><span class="line">    <span class="built_in">this</span>.expr = expr</span><br><span class="line">    <span class="built_in">this</span>.cb = cb</span><br><span class="line">    <span class="comment">// 先将旧值进行保存</span></span><br><span class="line">    <span class="built_in">this</span>.oldVal = <span class="built_in">this</span>.getOldVal()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">getOldVal</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 将当前订阅者指向自己</span></span><br><span class="line">    Dep.target = <span class="built_in">this</span></span><br><span class="line">    <span class="comment">// 获取旧值</span></span><br><span class="line">    <span class="keyword">const</span> oldVal = complieUtil.getVal(<span class="built_in">this</span>.expr,<span class="built_in">this</span>.vm)</span><br><span class="line">    <span class="comment">// 添加完毕，重置</span></span><br><span class="line">    Dep.target = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">return</span> oldVal</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 比较新值与旧值，如果有变化就更新视图</span></span><br><span class="line">  <span class="function"><span class="title">update</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> newVal = complieUtil.getVal(<span class="built_in">this</span>.expr,<span class="built_in">this</span>.vm)</span><br><span class="line">    <span class="comment">// 如果新旧值不相等，则将新值callback</span></span><br><span class="line">    <span class="keyword">if</span>(newVal !== <span class="built_in">this</span>.oldVal)&#123;</span><br><span class="line">      <span class="built_in">this</span>.cb(newVal)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>强行触发属性定义的 <code>get</code> 方法，<code>get</code> 方法执行的时候，就会在属性的订阅器 <code>dep</code> 添加当前<code>watcher</code> 实例，从而在属性值有变化的时候，<code>watcherInstance（this）</code> 就能收到更新通知。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 上文省略...</span></span><br><span class="line"><span class="function"><span class="title">defineReactive</span>(<span class="params">obj,key,value</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 递归遍历</span></span><br><span class="line">    <span class="built_in">this</span>.observe(value)</span><br><span class="line">    <span class="keyword">const</span> dep = <span class="keyword">new</span> Dep()</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(obj,key,&#123;</span><br><span class="line">      enumerable: <span class="literal">true</span>,</span><br><span class="line">      configurable: <span class="literal">false</span>,</span><br><span class="line">      <span class="function"><span class="title">get</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 订阅数据属性时，往Dep中添加观察者，进行依赖收集</span></span><br><span class="line">        Dep.target &amp;&amp; dep.addSub(Dep.target)</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 通过箭头函数改变this指向到class Observer</span></span><br><span class="line">      set:<span class="function">(<span class="params">newVal</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.observe(newVal)</span><br><span class="line">        <span class="keyword">if</span>(newVal !== value)&#123;</span><br><span class="line">          value = newVal</span><br><span class="line">          <span class="comment">// 如果新旧值不同，则告诉Dep通知变化</span></span><br><span class="line">          dep.notify()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="订阅器-dep"><a href="#订阅器-dep" class="headerlink" title="订阅器 dep"></a>订阅器 <code>dep</code></h3><p>主要做两件事情：</p><ul><li>收集订阅者</li><li>通知订阅者更新</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.subs = []</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 收集观察者</span></span><br><span class="line">  <span class="function"><span class="title">addSub</span>(<span class="params">watcher</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.subs.push(watcher)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 通知观察者去更新</span></span><br><span class="line">  <span class="function"><span class="title">notify</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;观察者&#x27;</span>,<span class="built_in">this</span>.subs);</span><br><span class="line">    <span class="built_in">this</span>.subs.forEach(<span class="function"><span class="params">watcher</span> =&gt;</span> watcher.update())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="修改我们原本的-Compile-js-文件"><a href="#修改我们原本的-Compile-js-文件" class="headerlink" title="修改我们原本的 Compile.js 文件"></a>修改我们原本的 <code>Compile.js</code> 文件</h3><p>做完上述事情后，此时，当我们修改某个数据时，数据已经发生了变化，但是视图没有更新。那我们在什么时候来添加绑定 <code>watcher</code> 呢？请继续看下图</p><p><img src= "/img/loading.gif" data-lazy-src="https://user-gold-cdn.xitu.io/2020/7/18/1735ffad8380710d?w=776&h=423&f=png&s=224895" alt=""></p><p>也就是说，当我们订阅数据变化时，来绑定更新函数，从而让 <code>watcher</code> 去更新视图。此时我们修改我们原本的 <code>Compile.js</code> 文件如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 指令处理集合</span></span><br><span class="line"><span class="keyword">const</span> complieUtil = &#123;</span><br><span class="line">  <span class="function"><span class="title">getVal</span>(<span class="params">expr,vm</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> expr.split(<span class="string">&#x27;.&#x27;</span>).reduce(<span class="function">(<span class="params">data,currentVal</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="comment">// console.log(currentVal)</span></span><br><span class="line">      <span class="keyword">return</span> data[currentVal]</span><br><span class="line">    &#125;,vm.$data)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 获取新值 对&#123;&#123;a&#125;&#125;--&#123;&#123;b&#125;&#125; 这种格式进行处理</span></span><br><span class="line">  <span class="function"><span class="title">getContentVal</span>(<span class="params">expr,vm</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> expr.replace(<span class="regexp">/\&#123;\&#123;(.+?)\&#125;\&#125;/g</span>, <span class="function">(<span class="params">...args</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="comment">// console.log(args[1]);</span></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.getVal(args[<span class="number">1</span>],vm);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">text</span>(<span class="params">node,expr,vm</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> value;</span><br><span class="line">    <span class="keyword">if</span>(expr.indexOf(<span class="string">&#x27;&#123;&#123;&#x27;</span>) !== -<span class="number">1</span>)&#123;</span><br><span class="line">      value = expr.replace(<span class="regexp">/\&#123;\&#123;(.+?)\&#125;\&#125;/g</span>, <span class="function">(<span class="params">...args</span>)=&gt;</span>&#123;</span><br><span class="line">         <span class="comment">// 绑定watcher从而更新视图</span></span><br><span class="line">        <span class="keyword">new</span> Watcher(vm,args[<span class="number">1</span>],<span class="function">()=&gt;</span>&#123;</span><br><span class="line">          <span class="built_in">this</span>.updater.textUpdater(node,<span class="built_in">this</span>.getContentVal(expr,vm))</span><br><span class="line">          <span class="comment">// console.log(expr);</span></span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.getVal(args[<span class="number">1</span>],vm);</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123; <span class="comment">// 也可能是v-text=&#x27;obj.name&#x27; v-text=&#x27;msg&#x27;</span></span><br><span class="line">      value = <span class="built_in">this</span>.getVal(expr,vm)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.updater.textUpdater(node,value)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">html</span>(<span class="params">node,expr,vm</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> value = <span class="built_in">this</span>.getVal(expr,vm)</span><br><span class="line">    <span class="keyword">new</span> Watcher(vm,expr,<span class="function">(<span class="params">newVal</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.updater.htmlUpdater(node,newVal)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">this</span>.updater.htmlUpdater(node,value)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">model</span>(<span class="params">node,expr,vm</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> value = <span class="built_in">this</span>.getVal(expr,vm)</span><br><span class="line">    <span class="comment">// 订阅数据变化时 绑定更新函数 更新视图的变化</span></span><br><span class="line">    <span class="comment">// 数据==&gt;视图</span></span><br><span class="line">    <span class="keyword">new</span> Watcher(vm,expr,<span class="function">(<span class="params">newVal</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.updater.modelUpdater(node,newVal)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">this</span>.updater.modelUpdater(node,value)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">on</span>(<span class="params">node,expr,vm,eventName</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> fn = vm.$options.methods &amp;&amp; vm.$options.methods[expr] </span><br><span class="line">    <span class="comment">// 1、让fn通过bind函数指向原来的vm 2、默认冒泡</span></span><br><span class="line">    node.addEventListener(eventName,fn.bind(vm),<span class="literal">false</span>) </span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">bind</span>(<span class="params">node,expr,vm,attrName</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> attrVal = <span class="built_in">this</span>.getVal(expr,vm)</span><br><span class="line">    <span class="built_in">this</span>.updater.attrUpdater(node,attrName,attrVal)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 更新的函数</span></span><br><span class="line">  updater:&#123;</span><br><span class="line">    <span class="function"><span class="title">textUpdater</span>(<span class="params">node,value</span>)</span>&#123;</span><br><span class="line">      node.textContent = value</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">htmlUpdater</span>(<span class="params">node,value</span>)</span>&#123;</span><br><span class="line">      node.innerHTML = value</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">modelUpdater</span>(<span class="params">node,value</span>)</span>&#123;</span><br><span class="line">      node.value = value</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">attrUpdater</span>(<span class="params">node, attrName, attrVal</span>)</span>&#123;</span><br><span class="line">      node.setAttribute(attrName,attrVal)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Compile</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">el,vm</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 判断是否为元素节点，如果不是就query</span></span><br><span class="line">    <span class="built_in">this</span>.el = <span class="built_in">this</span>.isElementNode(el) ? el : <span class="built_in">document</span>.querySelector(el)</span><br><span class="line">    <span class="built_in">this</span>.vm = vm</span><br><span class="line">    <span class="comment">// 1、获取文档碎片对象，放入内存中，会减少页面的回流和重绘</span></span><br><span class="line">    <span class="keyword">const</span> fragment = <span class="built_in">this</span>.node2Fragment(<span class="built_in">this</span>.el)</span><br><span class="line">    <span class="comment">// 2、编译模板</span></span><br><span class="line">    <span class="built_in">this</span>.compile(fragment)</span><br><span class="line">    <span class="comment">// 3、追加子元素到根元素</span></span><br><span class="line">    <span class="built_in">this</span>.el.appendChild(fragment)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 判断是否为元素节点，直接判断nodeType是否为1即可</span></span><br><span class="line">  <span class="function"><span class="title">isElementNode</span>(<span class="params">node</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> node.nodeType  === <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">node2Fragment</span>(<span class="params">el</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 创建文档碎片对象</span></span><br><span class="line">    <span class="keyword">const</span> fragment = <span class="built_in">document</span>.createDocumentFragment()</span><br><span class="line">    <span class="keyword">let</span> firstChild</span><br><span class="line">    <span class="keyword">while</span>(firstChild =  el.firstChild)&#123;</span><br><span class="line">      fragment.appendChild(firstChild)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fragment</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">compile</span>(<span class="params">fragment</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 1、获取所有子节点</span></span><br><span class="line">    <span class="keyword">const</span> childNodes = fragment.childNodes;</span><br><span class="line">    [...childNodes].forEach(<span class="function"><span class="params">child</span>=&gt;</span>&#123;</span><br><span class="line">      <span class="comment">// console.log(child)</span></span><br><span class="line">      <span class="comment">// 如果是元素节点，则编译元素节点</span></span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">this</span>.isElementNode(child))&#123;</span><br><span class="line">        <span class="comment">// console.log(&#x27;元素节点&#x27;,child) </span></span><br><span class="line">        <span class="built_in">this</span>.compileElement(child)</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 其它为文本节点，编译文本节点</span></span><br><span class="line">        <span class="comment">// console.log(&#x27;文本节点&#x27;,child)</span></span><br><span class="line">        <span class="built_in">this</span>.compileText(child)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(child.childNodes &amp;&amp; child.childNodes.length)&#123;</span><br><span class="line">        <span class="built_in">this</span>.compile(child)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 编译元素节点</span></span><br><span class="line">  <span class="function"><span class="title">compileElement</span>(<span class="params">node</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> attributes = node.attributes;</span><br><span class="line">    [...attributes].forEach(<span class="function"><span class="params">attr</span>=&gt;</span>&#123;</span><br><span class="line">      <span class="comment">// console.log(attr)</span></span><br><span class="line">      <span class="keyword">const</span> &#123;name,value&#125; = attr;</span><br><span class="line">      <span class="comment">// console.log(name,value)</span></span><br><span class="line">      <span class="comment">// 判断当前name值是否为一个指令，通过是否以 &#x27;v-&#x27; 开头来判断</span></span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">this</span>.isDirective(name))&#123;</span><br><span class="line">        <span class="comment">// console.log(name.split(&#x27;-&#x27;))</span></span><br><span class="line">        <span class="keyword">const</span> [,directive] = name.split(<span class="string">&#x27;-&#x27;</span>) <span class="comment">// text html model on:click</span></span><br><span class="line">        <span class="comment">// console.log(directive)</span></span><br><span class="line">        <span class="keyword">const</span> [dirName,eventName] = directive.split(<span class="string">&#x27;:&#x27;</span>) <span class="comment">// text html model on</span></span><br><span class="line">        <span class="comment">// 更新数据 数据驱动视图</span></span><br><span class="line">        complieUtil[dirName](node,value,<span class="built_in">this</span>.vm,eventName)</span><br><span class="line">        <span class="comment">// 删除指令上标签上的属性</span></span><br><span class="line">        node.removeAttribute(<span class="string">&#x27;v-&#x27;</span> + directive)</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">this</span>.isEventName(name))&#123; <span class="comment">// @click=&quot;sayHi&quot;</span></span><br><span class="line">        <span class="keyword">let</span> [,eventName] = name.split(<span class="string">&#x27;@&#x27;</span>)</span><br><span class="line">        complieUtil[<span class="string">&#x27;on&#x27;</span>](node,value,<span class="built_in">this</span>.vm,eventName)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 编译文本节点</span></span><br><span class="line">  <span class="function"><span class="title">compileText</span>(<span class="params">node</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// &#123;&#123;&#125;&#125; v-text</span></span><br><span class="line">    <span class="comment">// console.log(node.textContent)</span></span><br><span class="line">    <span class="keyword">const</span> content = node.textContent</span><br><span class="line">    <span class="keyword">if</span>(<span class="regexp">/\&#123;\&#123;(.+?)\&#125;\&#125;/</span>.test(content))&#123;</span><br><span class="line">      <span class="comment">// console.log(content)</span></span><br><span class="line">      complieUtil[<span class="string">&#x27;text&#x27;</span>](node,content,<span class="built_in">this</span>.vm)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">isDirective</span>(<span class="params">attrName</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> attrName.startsWith(<span class="string">&#x27;v-&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 判断当前attrName是否为一个事件，以&#x27;@&#x27;开头的事件绑定</span></span><br><span class="line">  <span class="function"><span class="title">isEventName</span>(<span class="params">attrName</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> attrName.startsWith(<span class="string">&#x27;@&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr/><p>此时，我们就能通过数据变化来驱动视图了，例如更改我们的年龄 <code>age</code> 从原来的 <code>20</code> 设置为 <code>22</code>，如下图所示，发现数据更改， <code>watcher</code> 去更新了视图。</p><p><img src= "/img/loading.gif" data-lazy-src="https://user-gold-cdn.xitu.io/2020/7/18/1735ffad865fc84f?w=1007&h=355&f=png&s=41559" alt=""></p><h2 id="知识再梳理"><a href="#知识再梳理" class="headerlink" title="知识再梳理"></a>知识再梳理</h2><p>有了之前的代码与流程图结合，我想对于<code>Vue</code>源码分析应该更加了解了，那么我们再次来梳理一下我们学习的知识点。依旧是结合下面流程图：<br><img src= "/img/loading.gif" data-lazy-src="https://user-gold-cdn.xitu.io/2020/7/18/1735ffad46ecf108?w=730&h=390&f=png&s=49521" alt=""><br>最开始，我们实现了 <code>Compile</code> 来<strong>解析指令</strong>，找到 <code>&#123;&#123;xxx&#125;&#125;</code>、指令、事件、绑定等等，然后再<strong>初始化视图</strong>。但此时还有一件事情没做，就是当数据发生变化的时候，在更新数据之前，我们还要<strong>订阅数据变化，绑定更新函数</strong>，此时就需要加入订阅者<code>Watcher</code>了。当订阅者观察到数据变化时，就会触发<code>Updater</code>来更新视图。</p><p>当然，创建 <code>Watcher</code>的前提时要进行<strong>数据劫持来监听所有属性</strong>，所以创建了 <code>Observer.js</code> 文件。在 <code>get</code>方法中，需要给 <code>Dep</code> <strong>通知变化</strong>，此时就需要将 <code>Dep</code> 的依赖收集关联起来，并且添加订阅者 <code>Watcher</code>（这个 <code>Watcher</code> 在 <code>Complie</code> 订阅数据变化，绑定更新函数时就已经创建了的）。此时 <code>Dep</code> 订阅器里就有很多个 <code>Watcher</code> 了，有多少个属性就对应有多少个 <code>Watcher</code>。</p><hr/><p>那么，我们举一个简单例子来走一下上述流程图：</p><p>假设原本 <code>data</code> 数据中有一个 <code>a:1</code>，此时我们进行更新为 <code>a:10</code>，由于早已经对我们的数据进行了数据劫持并且监听了所有属性，此时就会触发 <code>set</code> 方法，在 <code>set</code>方法里就会通知 <code>Dep</code> 订阅器发生了变化，然后就会通知相关 <code>Watcher</code> 触发 <code>update</code> 函数来更新视图。而这些订阅者 <code>Watcher</code> 在 <code>Complie</code> 订阅数据变化，绑定更新函数时就已经创建了。</p><h2 id="视图-gt-数据"><a href="#视图-gt-数据" class="headerlink" title="视图-&gt;数据"></a>视图-&gt;数据</h2><p>上述，我们基本完成了数据驱动视图，现在我们来完成一下通过视图的变化来更新数据，真正实现双向数据绑定的效果。</p><p>在我们 <code>complieUtil</code> 指令处理集合中的 <code>model</code> 模块，给我们当前节点绑定一个 <code>input</code> 事件即可。我们可以通过  <code>e.target.value</code> 来获取当前 <code>input</code> 输入框的值。然后比对一下旧值和新值是否相同，如果不同的话，就得需要更新，调用 <code>setVal</code> 方法（具体见下文代码）。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">model</span>(<span class="params">node,expr,vm</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> value = <span class="built_in">this</span>.getVal(expr,vm)</span><br><span class="line">    <span class="comment">// 订阅数据变化时 绑定更新函数 更新视图的变化</span></span><br><span class="line">    <span class="comment">// 数据==&gt;视图</span></span><br><span class="line">    <span class="keyword">new</span> Watcher(vm,expr,<span class="function">(<span class="params">newVal</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.updater.modelUpdater(node,newVal)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 视图==》数据</span></span><br><span class="line">    node.addEventListener(<span class="string">&#x27;input&#x27;</span>,<span class="function">(<span class="params">e</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">var</span> newValue = e.target.value</span><br><span class="line">      <span class="keyword">if</span>(value == newValue) <span class="keyword">return</span></span><br><span class="line">      <span class="comment">// 设置值</span></span><br><span class="line">      <span class="built_in">this</span>.setVal(expr,vm,newValue)</span><br><span class="line">      value = newValue</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">this</span>.updater.modelUpdater(node,value)</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><p><code>setVal</code> 和 <code>getVal</code> 两者没有多大区别，只是 <code>set</code> 时多了一个 <code>inputVal</code>。它们都是找到最底层 <code>key</code> 值，然后更新 <code>value</code> 值。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">getVal</span>(<span class="params">expr,vm</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> expr.split(<span class="string">&#x27;.&#x27;</span>).reduce(<span class="function">(<span class="params">data,currentVal</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// console.log(currentVal)</span></span><br><span class="line">    <span class="keyword">return</span> data[currentVal]</span><br><span class="line">  &#125;,vm.$data)</span><br><span class="line">&#125;,</span><br><span class="line"><span class="function"><span class="title">setVal</span>(<span class="params">expr,vm,inputVal</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> expr.split(<span class="string">&#x27;.&#x27;</span>).reduce(<span class="function">(<span class="params">data,currentVal</span>)=&gt;</span>&#123;</span><br><span class="line">     data[currentVal] = inputVal</span><br><span class="line">  &#125;,vm.$data)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>更新 <code>bug</code>：在上文，对于 <code>v-text</code>指令处，我们遗漏了绑定 <code>Watcher</code> 步骤，现在进行补充。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">text</span>(<span class="params">node,expr,vm</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> value;</span><br><span class="line">    <span class="keyword">if</span>(expr.indexOf(<span class="string">&#x27;&#123;&#123;&#x27;</span>) !== -<span class="number">1</span>)&#123;</span><br><span class="line">      value = expr.replace(<span class="regexp">/\&#123;\&#123;(.+?)\&#125;\&#125;/g</span>, <span class="function">(<span class="params">...args</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">// 绑定watcher从而更新视图</span></span><br><span class="line">        <span class="keyword">new</span> Watcher(vm,args[<span class="number">1</span>],<span class="function">()=&gt;</span>&#123;</span><br><span class="line">          <span class="built_in">this</span>.updater.textUpdater(node,<span class="built_in">this</span>.getContentVal(expr,vm))</span><br><span class="line">          <span class="comment">// console.log(expr);</span></span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.getVal(args[<span class="number">1</span>],vm);</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123; <span class="comment">// 也可能是v-text=&#x27;obj.name&#x27; v-text=&#x27;msg&#x27;</span></span><br><span class="line">      value = <span class="built_in">this</span>.getVal(expr,vm)</span><br><span class="line">      <span class="comment">// 绑定watcher从而更新视图</span></span><br><span class="line">      <span class="keyword">new</span> Watcher(vm,expr,<span class="function">(<span class="params">newVal</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.updater.textUpdater(node,newVal)</span><br><span class="line">        <span class="comment">// console.log(expr);</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.updater.textUpdater(node,value)</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><p>最终，当我们更改 <code>input</code> 输入框中的值时，发现其他节点也跟着修改，这代表我们的数据进行了修改，相关订阅者触发了 <code>update</code> 方法，双向绑定功能实现！<br><img src= "/img/loading.gif" data-lazy-src="https://user-gold-cdn.xitu.io/2020/7/18/1735ffad86f9de34?w=1069&h=345&f=png&s=54894" alt=""></p><h2 id="实现-proxy"><a href="#实现-proxy" class="headerlink" title="实现 proxy"></a>实现 proxy</h2><p>我们在使用 <code>vue</code> 的时候,通常可以直接 <code>vm.msg</code> 来获取数据,这是因为 <code>vue</code> 源码内部做了一层代理.也就是说把数据获取操作 <code>vm</code> 上的取值操作 都代理到 <code>vm.$data</code> 上。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myVue</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">options</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.$el = options.el</span><br><span class="line">    <span class="built_in">this</span>.$data = options.data</span><br><span class="line">    <span class="built_in">this</span>.$options = options</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">this</span>.$el)&#123;</span><br><span class="line">      <span class="comment">// 1.实现数据观察者</span></span><br><span class="line">      <span class="keyword">new</span> Observer(<span class="built_in">this</span>.$data)</span><br><span class="line">      <span class="comment">// 2.实现指令解析器</span></span><br><span class="line">      <span class="keyword">new</span> Compile(<span class="built_in">this</span>.$el,<span class="built_in">this</span>)</span><br><span class="line">      <span class="comment">// 3.实现proxy代理</span></span><br><span class="line">      <span class="built_in">this</span>.proxyData(<span class="built_in">this</span>.$data)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// console.log(this)</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">proxyData</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> key <span class="keyword">in</span> data)&#123;</span><br><span class="line">      <span class="built_in">Object</span>.defineProperty(<span class="built_in">this</span>,key,&#123;</span><br><span class="line">        <span class="function"><span class="title">get</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">          <span class="keyword">return</span> data[key]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="title">set</span>(<span class="params">newVal</span>)</span>&#123;</span><br><span class="line">          data[key] = newVal</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们简单测试一下，例如我们给 <code>button</code> 绑定一个 <code>sayHi()</code> 事件，通过设置 <code>proxy</code> 做了一层代理后，我们不需要像后面那样通过 <code>this.$data.person.name</code>来更改我们的数据，而直接可以通过 <code>this.person.name</code> 来获取我们的数据。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">   <span class="function"><span class="title">sayHi</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">     <span class="built_in">this</span>.person.name = <span class="string">&#x27;超逸&#x27;</span></span><br><span class="line">     <span class="comment">//this.$data.person.name = &#x27;Chaoyi&#x27;</span></span><br><span class="line">     <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="大厂面试题"><a href="#大厂面试题" class="headerlink" title="大厂面试题"></a>大厂面试题</h2><p>请阐述一下你对 <code>MVVM</code> 响应式的理解</p><p><img src= "/img/loading.gif" data-lazy-src="https://user-gold-cdn.xitu.io/2020/7/18/1735ffad46ecf108?w=730&h=390&f=png&s=49521" alt=""></p><p><code>vue.js</code> 则是采用数据劫持结合发布者-订阅者模式的方式，通过 <code>Object.defineProperty()</code>来劫持各个属性的<code>getter</code>，<code>setter</code>，在数据变动时发布消息给订阅者，触发相应的监听回调。</p><p><code>MVVM</code>作为数据绑定的入口，整合<code>Observer</code>、<code>Compile</code> 和 <code>Watcher</code> 三者，通过<code>Observer</code>来监听自己的<code>model</code>数据变化，通过<code>Compile</code>来解析编译模板指令，最终利用<code>Watcher</code>搭起<code>Observer</code>和<code>Compile</code>之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(<code>input</code>) -&gt; 数据<code>model</code>变更的双向绑定效果。</p><p>最开始，我们实现了 <code>Compile</code> 来<strong>解析指令</strong>，找到 <code>&#123;&#123;xxx&#125;&#125;</code>、指令、事件、绑定等等，然后再<strong>初始化视图</strong>。但此时还有一件事情没做，就是当数据发生变化的时候，在更新数据之前，我们还要<strong>订阅数据变化，绑定更新函数</strong>，此时就需要加入订阅者<code>Watcher</code>了。当订阅者观察到数据变化时，就会触发<code>Updater</code>来更新视图。</p><p>当然，创建 <code>Watcher</code>的前提时要进行<strong>数据劫持来监听所有属性</strong>，所以创建了 <code>Observer.js</code> 文件。在 <code>get</code>方法中，需要给 <code>Dep</code> <strong>通知变化</strong>，此时就需要将 <code>Dep</code> 的依赖收集关联起来，并且添加订阅者 <code>Watcher</code>（这个 <code>Watcher</code> 在 <code>Complie</code> 订阅数据变化，绑定更新函数时就已经创建了的）。此时 <code>Dep</code> 订阅器里就有很多个 <code>Watcher</code> 了，有多少个属性就对应有多少个 <code>Watcher</code>。</p><hr/><p>那么，我们举一个简单例子来走一下上述流程图：</p><p>假设原本 <code>data</code> 数据中有一个 <code>a:1</code>，此时我们进行更新为 <code>a:10</code>，由于早已经对我们的数据进行了数据劫持并且监听了所有属性，此时就会触发 <code>set</code> 方法，在 <code>set</code>方法里就会通知 <code>Dep</code> 订阅器发生了变化，然后就会通知相关 <code>Watcher</code> 触发 <code>update</code> 函数来更新视图。而这些订阅者 <code>Watcher</code> 在 <code>Complie</code> 订阅数据变化，绑定更新函数时就已经创建了。</p><h2 id="总结与答疑"><a href="#总结与答疑" class="headerlink" title="总结与答疑"></a>总结与答疑</h2><p>总算是把这篇长文写完了，字数也是达到将近 1w8。通过学习 <code>Vue MVVM源码</code>，对于 <code>Vue</code> 双向数据绑定这一块理解也更加深刻了。当然，本文书写的代码还算是比较简单，也参考了大佬的博客与代码，同时，也存在不足并且小部分功能没有实现，相较于源码来说还是有很多可优化和可重构的地方，那么也欢迎小伙伴们来 <code>PR</code>。一起来动手实现 <code>mvvm</code> 。</p><blockquote><p>本篇博客参考文献<br><a href="https://juejin.im/post/5edefb32518825431373704c#heading-12">笑马哥：Vue的MVVM实现原理</a><br><a href="https://github.com/DMQ/mvvm">github：mvvm</a><br><a href="https://www.bilibili.com/video/BV1qJ411W7YR?p=7">视频学习：Vue源码解析</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「查漏补缺」Vue2.0 源码重写『数据劫持』【面试必备】</title>
      <link href="posts/20201011/"/>
      <url>posts/20201011/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>学习源码的目标是学习其中的设计思路，在工作业务中就可利用这些思路编写我们的项目。对于数据劫持这一块，是比较重要而且有价值学习的，今天，带着好奇心来探讨学习一下，首先，我们得明白数据劫持目的是什么，它到底做了啥？</p><p><strong>数据劫持的目的是什么？</strong></p><p>我们不希望原生的对对象或者数组的操作，仅仅是一个单纯的操作，我们希望在对对象赋值或者对数组 <code>push</code> 等方法时，我们可以增加一写操作进去，比如说让视图做数据的绑定，即数据改变的时候也让视图也跟着变化，如果仅仅一个单纯的操作，那么就 <code>state</code> 发生了变化，视图并没有随之变化。因此，我们需要在数据变化的时候拦截一下，在保证数据变化的同时，对我们的视图进行操作，也就是说在操作数据的过程当中，我们希望能够做更多的事情。</p><hr/><p>如若有帮助到您，请<strong>一键三连</strong>，当然，本文表述有问题的地方，欢迎读者指正，也是一个学习的过程，谢谢~</p><h2 id="阅读须知"><a href="#阅读须知" class="headerlink" title="阅读须知"></a>阅读须知</h2><p>在环境搭建和实现相关代码之前，先提供本次代码的目录结构，不然后续一些文件名以及文件路径可能会有小伙伴有疑惑。</p><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">--vueDemo  ---项目文件夹</span><br><span class="line"></span><br><span class="line">---public  ---主页面</span><br><span class="line">----index.html</span><br><span class="line"></span><br><span class="line">---src  ---项目主入口</span><br><span class="line">----index.js</span><br><span class="line"></span><br><span class="line">---vue ---数据劫持源码实现</span><br><span class="line">----array.js </span><br><span class="line">----config.js</span><br><span class="line">----index.js</span><br><span class="line">----init.js</span><br><span class="line">----observe.js</span><br><span class="line">----observer.js</span><br><span class="line">----observerArr.js</span><br><span class="line">----proxy.js</span><br><span class="line">----reactive.js</span><br><span class="line"></span><br><span class="line">---package.json</span><br><span class="line">---webpack.config.js ---配置webpack</span><br></pre></td></tr></table></figure><h3 id="本篇实现源码"><a href="#本篇实现源码" class="headerlink" title="本篇实现源码"></a>本篇实现源码</h3><p>提供本次实现源代码，Give a ⭐️ if this project helped you!</p><p><a href="https://github.com/Chocolate1999/Front-end-learning-to-organize-notes/tree/master/Vue%E5%8F%8A%E6%BA%90%E7%A0%81/Vue2.0%E6%BA%90%E7%A0%81%E9%87%8D%E5%86%99%E3%80%8E%E6%95%B0%E6%8D%AE%E5%8A%AB%E6%8C%81%E3%80%8F/vueDemo">Vue2.0源码重写『数据劫持』</a></p><h3 id="须知"><a href="#须知" class="headerlink" title="须知"></a>须知</h3><p>本篇代码均本人一字一句敲的，代码中有着比较详细的注释，学习了两遍终于理解了其中实现原理，关于环境搭建那一块，对于 <code>webpack</code> 比较熟悉的小伙伴可以直接跳过，直接到 <code>Vue使用</code> 这一章节开始阅读。同时，本篇还提及到了两个设计模式：<strong>观察者模式</strong> 和 <strong>装饰者模式</strong>，是不是有点期待了呢？</p><p>后续的文章也会加快更近，带着好奇心去学习，去思考~</p><p>对于有疑惑点可以提出来，一起讨论~</p><h2 id="初始化及环境搭建"><a href="#初始化及环境搭建" class="headerlink" title="初始化及环境搭建"></a>初始化及环境搭建</h2><p>创建一个 <code>vueDemo</code>文件夹，初始化 <code>npm</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm init -y</span><br></pre></td></tr></table></figure><h3 id="webpack安装"><a href="#webpack安装" class="headerlink" title="webpack安装"></a>webpack安装</h3><p>初始化我们需要 <code>webpack</code> 环境，执行下面代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install webpack webpack-cli webpack-dev-server</span><br></pre></td></tr></table></figure><h3 id="入口文件"><a href="#入口文件" class="headerlink" title="入口文件"></a>入口文件</h3><p>然后，在项目根目录下创建 <code>webpack.config.js</code> 文件，配置一下入口文件，如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// 配置入口</span></span><br><span class="line">  entry: <span class="string">&#x27;./src/index.js&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在根目录下我们创建对应入口文件 <code>src</code> 文件夹。</p><h3 id="public"><a href="#public" class="headerlink" title="public"></a>public</h3><p>其次，我们需要 <code>html</code> 文件，与 <code>src</code> 同级，我们新创建一个 <code>public</code> 文件夹，在其中创建 <code>index.html</code>文件。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;en&quot;</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">  &lt;meta name=<span class="string">&quot;viewport&quot;</span> content=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br><span class="line">  &lt;title&gt;Vue2<span class="number">.0</span>源码重写『数据劫持』【面试必备】&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div id=<span class="string">&quot;app&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h3 id="配置输出"><a href="#配置输出" class="headerlink" title="配置输出"></a>配置输出</h3><p>配置好了入口文件，接下来就是配置输出了：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// 配置入口</span></span><br><span class="line">  entry: <span class="string">&#x27;./src/index.js&#x27;</span>,</span><br><span class="line">  <span class="comment">// 配置输出</span></span><br><span class="line">  output: &#123;</span><br><span class="line">    <span class="comment">// 文件名称</span></span><br><span class="line">    filename: <span class="string">&#x27;bundle.js&#x27;</span>,</span><br><span class="line">    <span class="comment">// 配置路径</span></span><br><span class="line">    path: path.resolve(__dirname, <span class="string">&#x27;dist&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置html-webpack-plugin"><a href="#配置html-webpack-plugin" class="headerlink" title="配置html-webpack-plugin"></a>配置html-webpack-plugin</h3><p>处理 <code>html</code> 文件，我们需要一个 <code>plugin</code>，执行下面代码进行安装。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install html-webpack-plugin</span><br></pre></td></tr></table></figure><p>在实例化 <code>HtmlWebpackPlugin</code> 时，会接受一个参数，其中一个就是配置模板 <code>template</code>，</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: path.resolve(__dirname, <span class="string">&#x27;public/index.html&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure><h3 id="定义-source-map"><a href="#定义-source-map" class="headerlink" title="定义 source-map"></a>定义 source-map</h3><p>打包时我们可能会出现问题，有的时候比较难发现，而通过定义 <code>source-map</code> 后，我们就能将错误定义到源码上来。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 配置 source-map ，打包出错定位到源码上</span></span><br><span class="line">devtool: <span class="string">&#x27;source-map&#x27;</span>,</span><br></pre></td></tr></table></figure><h3 id="引入vue"><a href="#引入vue" class="headerlink" title="引入vue"></a>引入vue</h3><p>在根目录下创建一个名为 <code>vue</code> 文件</p><p>在 <code>src</code>文件中，我们引入 <code>Vue</code>，此时有一个问题，假设我就想通过方式一引入可以吗？</p><p>方式一：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;/vue&#x27;</span>;</span><br></pre></td></tr></table></figure><p>方式二：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;../vue&#x27;</span>;</span><br></pre></td></tr></table></figure><p>按照目前配置好的代码是不可行的，只能通过方式二来引入，因为默认会去 <code>node_modules</code> 中去找。那么我们来配置一下就好了：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">    modules: [path.resolve(__dirname, <span class="string">&#x27;&#x27;</span>), path.resolve(__dirname, <span class="string">&#x27;node_modules&#x27;</span>)]</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><h3 id="package-json-设置命令"><a href="#package-json-设置命令" class="headerlink" title="package.json 设置命令"></a>package.json 设置命令</h3><p>上文配置好了 <code>webpack</code> 后，我们就需要在 <code>package.json</code> 文件中设置打包相关命令了：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;dev&quot;</span>: <span class="string">&quot;webpack-dev-server&quot;</span>,</span><br><span class="line">    <span class="string">&quot;build&quot;</span>: <span class="string">&quot;webpack&quot;</span></span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><h3 id="webpack-config-js-文件代码"><a href="#webpack-config-js-文件代码" class="headerlink" title="webpack.config.js 文件代码"></a>webpack.config.js 文件代码</h3><p>下面给出本文配置 <code>webpack</code> 源码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>),</span><br><span class="line">      HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// 配置入口</span></span><br><span class="line">  entry: <span class="string">&#x27;./src/index.js&#x27;</span>,</span><br><span class="line">  <span class="comment">// 配置输出</span></span><br><span class="line">  output: &#123;</span><br><span class="line">    <span class="comment">// 文件名称</span></span><br><span class="line">    filename: <span class="string">&#x27;bundle.js&#x27;</span>,</span><br><span class="line">    <span class="comment">// 配置路径</span></span><br><span class="line">    path: path.resolve(__dirname, <span class="string">&#x27;dist&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 配置 source-map ，打包出错定位到源码上</span></span><br><span class="line">  devtool: <span class="string">&#x27;source-map&#x27;</span>,</span><br><span class="line">  resolve: &#123;</span><br><span class="line">    modules: [path.resolve(__dirname, <span class="string">&#x27;&#x27;</span>), path.resolve(__dirname, <span class="string">&#x27;node_modules&#x27;</span>)]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: path.resolve(__dirname, <span class="string">&#x27;public/index.html&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Vue使用"><a href="#Vue使用" class="headerlink" title="Vue使用"></a>Vue使用</h2><h3 id="options-API"><a href="#options-API" class="headerlink" title="options API"></a>options API</h3><p>我们在使用 <code>Vue</code> 的时候，会进行实例化操作，如下代码，在使用 <code>Vue</code> 函数的时候，传入了一个对象，而这个对象其实就叫做 <code>options</code>，因此，<code>Vue 2.0</code> 又叫做 <code>options API</code> 就是这个道理。传入的对象都是一些选项，比如 data、methods、computed、生命周期函数等等，需要的时候按照规范传入即可。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="comment">// options</span></span><br><span class="line"><span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      title: <span class="string">&#x27;学生列表&#x27;</span>,</span><br><span class="line">      classNum: <span class="number">1</span>,</span><br><span class="line">      total: <span class="number">2</span>,</span><br><span class="line">      teachers: [<span class="string">&#x27;张三&#x27;</span>, <span class="string">&#x27;李四&#x27;</span>],</span><br><span class="line">      students: [</span><br><span class="line">        &#123;</span><br><span class="line">          id: <span class="number">1</span>,</span><br><span class="line">          name: <span class="string">&#x27;小红&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          id: <span class="number">2</span>,</span><br><span class="line">          name: <span class="string">&#x27;小明&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Vue函数-初始化"><a href="#Vue函数-初始化" class="headerlink" title="Vue函数 / 初始化"></a>Vue函数 / 初始化</h3><p>在上文我们知道 <code>Vue</code> 是个函数，那么我们用 <code>es5</code>语法来写的话，就要写对应构造函数了。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Vue</span>(<span class="params">options</span>)</span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Vue;</span><br></pre></td></tr></table></figure><p>在 <code>Vue 2.0</code> 中做的事情主要是给 <code>Vue</code> 函数的原型上添加方法。这就涉及到原型、原型链、原型对象、创建对象方法等相关知识了，可以查漏补缺~</p><p>Vue 会有一个初始化函数，在初始化的时候完成对数据的劫持，如下代码所示：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Vue</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>._init(options);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">Vue.prototype._init = <span class="function"><span class="keyword">function</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 保存实例</span></span><br><span class="line">  <span class="keyword">var</span> vm = <span class="built_in">this</span>;</span><br><span class="line">  vm.$options = options; <span class="comment">// 将 options 挂载到实例上</span></span><br><span class="line"></span><br><span class="line">  initState(vm); <span class="comment">// 初始化状态</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Vue;</span><br></pre></td></tr></table></figure><h3 id="initState-初始化状态"><a href="#initState-初始化状态" class="headerlink" title="initState / 初始化状态"></a>initState / 初始化状态</h3><p>上文代码我们在函数原型上定义了初始化方法，将 options 挂载到实例上，现在我们需要<strong>初始化状态</strong>，此时，创建一个名为 <code>init.js</code> 的文件，来编写 <code>initState</code>函数，同理，在 <code>Vue 2.0</code> 源码中，你还可以看到 <code>initMixin</code> 函数，这些都是放在 <code>init.js</code> 文件，由于本文探讨数据劫持，因此就只整理关于 <code>initState</code> 函数：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initState</span>(<span class="params">vm</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> options = vm.$options;</span><br><span class="line">  <span class="comment">// 判断 data 是否存在</span></span><br><span class="line">  <span class="keyword">if</span> (options.data) &#123;</span><br><span class="line">    initData(vm); <span class="comment">// 初始化数据</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initData</span>(<span class="params">vm</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> data = vm.$options.data;</span><br><span class="line">  <span class="comment">// 将 data 挂载到 vm 的 _data 上</span></span><br><span class="line">  vm._data = data = <span class="keyword">typeof</span> data === <span class="string">&#x27;function&#x27;</span> ? data.call(vm) : data || &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">  initState</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="initData"><a href="#initData" class="headerlink" title="initData"></a>initData</h3><p>初始化状态时，首先要判断这个 <code>data</code> 是否存在，存在的话才会进行初始化数据的操作，在上述代码中，我们对数据进行了处理，将 <code>data</code> 挂载到 <code>vm</code> 的 <code>_data</code> 上，可能比较疑惑的就是下面这一行代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">vm._data = data = <span class="keyword">typeof</span> data === <span class="string">&#x27;function&#x27;</span> ? data.call(vm) : data || &#123;&#125;;</span><br></pre></td></tr></table></figure><p>现在来分析一下，对于传过来的<code>data</code>，我们想象，是不是实例化 <code>Vue</code> 的时候传过来的？可能会有如下两种传参方式：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一种方式：</span></span><br><span class="line"><span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="comment">// xxx</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 第二种方式：</span></span><br><span class="line"><span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="comment">// xxx</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>对于第一种传过来的就是一个 <code>data</code> 函数，我们如果不执行的话，是不会得到我们想要的数据的，而对于第二种直接传对象的方式，有可能啥也没有，因此需要一个默认值 <code>&#123;&#125;</code>，所以就会有上文那一行代码。</p><h3 id="数据是如何访问的？"><a href="#数据是如何访问的？" class="headerlink" title="数据是如何访问的？"></a>数据是如何访问的？</h3><p>好了，上述问题解决完了之后，我们又来了一个新的问题：<strong>数据是如何访问的？</strong></p><p>我们不妨打印一下 <code>titile</code>：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(vm._data.title); <span class="comment">// 学生列表</span></span><br></pre></td></tr></table></figure><p>然而这种方式不是我们想要的，在 <code>vue 2.0</code> 中，我们可以通过 <code>vm.title</code>来访问，或者在 <code>methods</code>中直接通过 <code>this.title</code> 来访问。</p><h3 id="proxy-代理数据"><a href="#proxy-代理数据" class="headerlink" title="proxy 代理数据"></a>proxy 代理数据</h3><p>为了解决上述问题，此时就需要我们设置一下代理了，创建一个名为 <code>proxy.js</code>文件（并非用 <code>ES6 proxy</code>），在里面我们定义我们的代理函数：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">proxyData</span>(<span class="params">vm, target, key</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(vm, key, &#123;</span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="comment">// 相当于将vm._data.title 转变成 vm.title</span></span><br><span class="line">      <span class="keyword">return</span> vm[target][key];</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">set</span>(<span class="params">newVal</span>)</span> &#123;</span><br><span class="line">      <span class="comment">// set 同理</span></span><br><span class="line">      vm[target][key] = newVal;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> proxyData;</span><br></pre></td></tr></table></figure><p>此时，返回到 <code>init.js</code> 文件，导入我们写好的代理函数 <code>proxyData</code>，对我们挂载的数据进行代理操作，如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> proxyData <span class="keyword">from</span> <span class="string">&#x27;./proxy&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initState</span>(<span class="params">vm</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> options = vm.$options;</span><br><span class="line">  <span class="comment">// 判断 data 是否存在</span></span><br><span class="line">  <span class="keyword">if</span> (options.data) &#123;</span><br><span class="line">    initData(vm); <span class="comment">// 初始化数据</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initData</span>(<span class="params">vm</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> data = vm.$options.data;</span><br><span class="line">  <span class="comment">// 将 data 挂载到 vm 的 _data 上</span></span><br><span class="line">  vm._data = data = <span class="keyword">typeof</span> data === <span class="string">&#x27;function&#x27;</span> ? data.call(vm) : data || &#123;&#125;;</span><br><span class="line">  <span class="comment">/* 进行代理 */</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> data) &#123;</span><br><span class="line">    proxyData(vm, <span class="string">&#x27;_data&#x27;</span>, key);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">  initState</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，返回 <code>src/index.js</code> 文件，我们就直接可以用 <code>vm.title</code> 来获取对应数据了。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(vm.title); <span class="comment">// 学生列表</span></span><br></pre></td></tr></table></figure><h2 id="观察数据"><a href="#观察数据" class="headerlink" title="观察数据"></a>观察数据</h2><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>在上一章节，我们完成了数据状态初始化，并且代理了数据，现在就需要观察了，这里涉及到 <strong>观察者模式</strong> ，就是对 <code>data</code> 进行观察，并且还需要对 <code>data</code> 内部也需要观察。对于内部是对象情况，我们就需要进行数据劫持，而如果是数组的话，还需要对相关方法进行拦截，这里就先提及一下，在后文我们来详细探讨一下，带着好奇心学习这个<code>观察者模式</code>。</p><p>在 <code>init.js</code> 文件中，对数据进行观察</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 观察 data</span></span><br><span class="line">observe(vm._data);</span><br></pre></td></tr></table></figure><p>创建一个名为 <code>observe.js</code> 的文件来专门写观察函数 <code>observe</code>：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Observer <span class="keyword">from</span> <span class="string">&#x27;./observer&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observe</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 观察对象，如果不是对象形式，直接返回即可</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> data !== <span class="string">&#x27;object&#x27;</span> || data === <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// 添加观察者</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Observer(data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> observe;</span><br></pre></td></tr></table></figure><h3 id="添加观察者"><a href="#添加观察者" class="headerlink" title="添加观察者"></a>添加观察者</h3><p>我们观察的是对象，对于非对象形式，我们直接返回即可，然后需要给对象添加观察者，因此我们还需要创建一个名为 <code>Observer.js</code> 的文件，设置<strong>观察者</strong>，此时就有一个问题了，对于对象和数组我们处理方式是不一样的，对象可以用 <code>defineProperty</code>，而数组需要自己去写相应方法，因此，我们需要进行判断：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Observer</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 处理数组</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(data)) &#123;</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.walk(data);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原型上方法 walk</span></span><br><span class="line">Observer.prototype.walk = <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 响应式需求，我们需要重新定义对象</span></span><br><span class="line">  <span class="comment">// 获取对象中的 key 数组</span></span><br><span class="line">  <span class="keyword">var</span> keys = <span class="built_in">Object</span>.keys(data);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> key = keys[i],</span><br><span class="line">      val = data[key];</span><br><span class="line">    <span class="comment">// 处理响应式</span></span><br><span class="line">    defineReactiveData(data, key, val);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Observer;</span><br></pre></td></tr></table></figure><h3 id="先处理对象"><a href="#先处理对象" class="headerlink" title="先处理对象"></a>先处理对象</h3><p>对于上述代码，我们优先处理对象，而对于数组的话，我们在后文继续探讨分析。</p><p>对于对象的话，由于响应式需求，我们就需要重新定义对象，拿到对象的 <code>key-val</code>，然后通过<code>defineReactiveData</code> 方法来处理响应式，因此我们又需要建立一个名为 <code>reactive.js</code> 的文件：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> observe <span class="keyword">from</span> <span class="string">&#x27;./observe&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactiveData</span>(<span class="params">data, key, val</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 有可能当前val还是一个对象，因此继续观察当前 val</span></span><br><span class="line">  observe(val);</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(data, key, &#123;</span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;响应式数据-获取&#x27;</span>, val);</span><br><span class="line">      <span class="keyword">return</span> val;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">set</span>(<span class="params">newVal</span>)</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;响应式数据-设置&#x27;</span>, newVal);</span><br><span class="line">      <span class="keyword">if</span> (newVal === val) <span class="keyword">return</span>;</span><br><span class="line">      <span class="comment">// 可能更新的这个newVal 还是一个对象或者数组，我们需要再观察一下</span></span><br><span class="line">      observe(newVal); </span><br><span class="line">      val = newVal;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> defineReactiveData;</span><br></pre></td></tr></table></figure><hr/><p><strong>注意点！</strong> 上述代码中，我们首先对 <code>val</code> 进行了一个递归操作，然后对 <code>set</code> 设置的 <code>newVal</code> 也进行了观察，这是为什么呢？</p><p>因为当我们观察对象的时候，有可能这个对象里面还有一个对象，因此我们就需要进行递归操作。我们不妨在 <code>data</code> 增加一个数据如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">info:&#123;</span><br><span class="line">  club:&#123;</span><br><span class="line">    name: <span class="string">&#x27;篮球&#x27;</span>,</span><br><span class="line">    num: <span class="number">30</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>然后在 <code>src/index.js</code> 文件中，我们打印一下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(vm.info);</span><br></pre></td></tr></table></figure><p>查看下图，通过添加观察者，我们的对象数据通过 <code>defineProperty</code> 方法都有了 <code>get</code> 和 <code>set</code> 方法，相当于外包了一层。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20201011101434388.png#pic_center" alt=""></p><blockquote><p>对象里面也有对应 get 和 set</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20201011110459986.png#pic_center" alt=""></p><h3 id="后处理数组"><a href="#后处理数组" class="headerlink" title="后处理数组"></a>后处理数组</h3><p>上一章节，我们处理完了对象，现在我们来好好探讨一下处理数组的方式，对源码有一定了解的小伙伴肯定知道 <code>Object.defineProperty</code> 并不是用来劫持数组的，原本是来劫持对象的，那么我们需要拦截数组的 7 个改变原数组的方法，并且对于修改原数组的方法，我们也不希望它通过原型上的方法直接进行更改。</p><p>其次，对于 <code>push、unshifit、splice</code> 这些方法，它们会新增一项进去，而对于新增的这一项我们又需要观察它是不是数组，是不是对象，或者是原始值，这显然麻烦了起来，而用原本 <code>Array</code> 原型上方法我们没办法满足这些需求，因此我们需要重写原型上的方法。</p><p>创建一个名为 <code>array.js</code> 文件，用来专门处理数组，在此之前，我们先创建一个名为 <code>config.js</code> 文件，用来存放我们需要操作数组方法。</p><p>以下就是可以改变原数组的 7 个方法（关于改变原数组这一块面试也是常考点，正好复习了一下）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ARR_METHODS = [</span><br><span class="line">  <span class="string">&#x27;push&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;pop&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;shift&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;unshift&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;splice&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;sort&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;reverse&#x27;</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">  ARR_METHODS</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h3><p>上文我们探讨了数组无法劫持的原因，下面我们就引出新的设计模式——<strong>装饰者模式</strong>，来重写数组原型方法，具体如下述代码，先取出数组原型，拷贝一份，避免影响到了原来的原型链。</p><p>然后通过遍历方法，我们重写一下对应方法，先调用原来的方法，来获得我们更新的数据，然后对于 <code>push、unshifit、splice</code> 这3个方法，会有新增数组项的操作，我们将这新增项保存到 <code>newArr</code> 中，然后观察这个新增项，看它是不是对象还是数组还是原始值。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ARR_METHODS &#125; <span class="keyword">from</span> <span class="string">&#x27;./config&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> originArrMethods = <span class="built_in">Array</span>.prototype,  <span class="comment">// 取出数组原型</span></span><br><span class="line">  arrMethods = <span class="built_in">Object</span>.create(originArrMethods); <span class="comment">// 拷贝一份，原因：避免影响到了原来的原型链</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 装饰者模式，重写原型方法</span></span><br><span class="line">ARR_METHODS.map(<span class="function"><span class="keyword">function</span> (<span class="params">m</span>) </span>&#123;</span><br><span class="line">  arrMethods[m] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 把arguments 类数组转化成数组</span></span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="comment">// 先调用原来的方法</span></span><br><span class="line">    <span class="keyword">var</span> rt = originArrMethods[m].apply(<span class="built_in">this</span>, args);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> newArr; <span class="comment">// 用来存储新增的那一项</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (m) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;push&#x27;</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;unshift&#x27;</span>:</span><br><span class="line">        newArr = args;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;splice&#x27;</span>:</span><br><span class="line">        newArr = args.slice(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果有新增项，那么需要观察这个新增项</span></span><br><span class="line">    newArr &amp;&amp; ObserverArr(newArr);</span><br><span class="line">    <span class="keyword">return</span> rt; <span class="comment">// 返回调用原来方法得到的结果</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>对于观察新增项，我们再新增一个名为 <code>observerArr.js</code> 的文件，如下代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> observe <span class="keyword">from</span> <span class="string">&#x27;./observe&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observerArr</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    observe(arr[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> observerArr;</span><br></pre></td></tr></table></figure><p>然后调用原本写好的 <code>observe</code> 方法进行观察即可，至于添加观察者那一块，我们上文不是还有空着的代码块嘛，下面我们来进行补充。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> defineReactiveData <span class="keyword">from</span> <span class="string">&#x27;./reactive&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> observerArr <span class="keyword">from</span> <span class="string">&#x27;./observerArr&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; arrMethods &#125; <span class="keyword">from</span> <span class="string">&#x27;./array&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Observer</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 处理数组</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(data)) &#123;</span><br><span class="line">    data.__proto__ = arrMethods; <span class="comment">// 将重写数组的prototype替换到data上的prototype</span></span><br><span class="line">    observerArr(data); <span class="comment">// 可能数组里面还有数组，我们还需要再次观察一下</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.walk(data);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原型上方法 walk</span></span><br><span class="line">Observer.prototype.walk = <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 响应式需求，我们需要重新定义对象</span></span><br><span class="line">  <span class="comment">// 获取对象中的 key 数组</span></span><br><span class="line">  <span class="keyword">var</span> keys = <span class="built_in">Object</span>.keys(data);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> key = keys[i],</span><br><span class="line">      val = data[key];</span><br><span class="line">    <span class="comment">// 处理响应式</span></span><br><span class="line">    defineReactiveData(data, key, val);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Observer;</span><br></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>基本上重写代码就完工了，我们来测试一下代码，看是否实现了对数据的劫持操作</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(vm.title); <span class="comment">// 学生列表</span></span><br><span class="line"><span class="built_in">console</span>.log(vm.info);</span><br><span class="line"><span class="built_in">console</span>.log(vm);</span><br><span class="line"><span class="built_in">console</span>.log(vm.teachers[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(vm.info.club.num = <span class="number">40</span>);</span><br><span class="line"><span class="built_in">console</span>.log(vm.students.splice(<span class="number">1</span>, <span class="number">1</span>, &#123;</span><br><span class="line">  id: <span class="number">3</span>,</span><br><span class="line">  name: <span class="string">&#x27;小白&#x27;</span></span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><p>打印结果如下：</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20201011112408197.png#pic_center" alt=""></p><hr/><p>本文到此也就结束了，原本以为特别难理解的数据劫持今天通过这一篇梳理也是明白了许多，里面还涉及到了设计模式以及有价值的设计思路。后续我会继续学习 <strong>Vue3.0 源码重写『数据劫持』</strong> ，文章也会加快更新，下篇再见啦~</p><h2 id="本文参考"><a href="#本文参考" class="headerlink" title="本文参考"></a>本文参考</h2><p><a href="https://www.bilibili.com/video/BV1mf4y1Q7mg?p=1">【全网首发:完结】Vue2.0源码重写『数据劫持』【面试必备】<br></a></p><blockquote><p>感谢小野老师的对Vue2.0源码重写『数据劫持』的细致讲解，给老师打call，建议大家可以结合视频看一看，看完会恍然大悟的！</p></blockquote><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>文章产出不易，还望各位小伙伴们支持一波！</p><p>往期精选：</p><p><a href="https://github.com/Chocolate1999/Front-end-learning-to-organize-notes">小狮子前端の笔记仓库</a></p><p><a href="https://github.com/Chocolate1999/leetcode-javascript">leetcode-javascript：LeetCode 力扣的 JavaScript 解题仓库，前端刷题路线（思维导图）</a></p><p>小伙伴们可以在Issues中提交自己的解题代码，🤝 欢迎Contributing，可打卡刷题，Give a ⭐️ if this project helped you!</p><p><a href="https://yangchaoyi.vip/">访问超逸の博客</a>，方便小伙伴阅读玩耍~</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/2020090211491121.png#pic_center" alt=""></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">学如逆水行舟，不进则退</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue 技术栈 手写响应式原理 到 探索设计模式</title>
      <link href="posts/37332/"/>
      <url>posts/37332/</url>
      
        <content type="html"><![CDATA[<h2 id="写在开头"><a href="#写在开头" class="headerlink" title="写在开头"></a>写在开头</h2><p>学习完了ES 6基础，<a href="https://blog.csdn.net/weixin_42429718/article/details/104696830">推荐阅读：ECMAScript 6 全套学习目录 整理 完结</a></p><p>现在开始逐步深入Vue 技术栈，想了想，技术栈专栏的主要内容包括：</p><p>1、Vue源码分析<br>2、手把手教 保姆级 撸代码<br>3、无惧面试，学以致用，继承创新<br>4、谈谈前端发展与学习心得<br>5、手写源码技术栈，附上详细注释<br>6、从源码中学习设计模式，一举两得<br>7、编程思想的提升及代码质量的提高<br>8、通过分析源码学习架构，看看优秀的框架<br>9、项目实战开发<br>10、面试准备，完善个人简历</p><hr/><p>暂时想到的就这么多，把这列举的10点做好了，我觉得也OK了，欢迎一起学习，觉得不错的话，可以关注博主，专栏会不断更新，可以关注一下，<a href="https://blog.csdn.net/weixin_42429718/category_9761758.html">传送门~</a></p><h2 id="学习目录"><a href="#学习目录" class="headerlink" title="学习目录"></a>学习目录</h2><p>为了方便自己查阅与最后整合，还是打算整个目录，关于Vue技术栈前面的几篇优秀的文章：</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="Vue-2的响应式原理"><a href="#Vue-2的响应式原理" class="headerlink" title="Vue 2的响应式原理"></a>Vue 2的响应式原理</h3><hr/><p>提到Vue2的响应式原理，或许你就会想到<code>Object.defineProperty()</code>，但Object.defineProperty()严格来说的话，并不是来做响应式的。</p><h4 id="什么是defineProperty"><a href="#什么是defineProperty" class="headerlink" title="什么是defineProperty( )"></a>什么是defineProperty( )</h4><p><a href="https://blog.csdn.net/weixin_42429718/article/details/104472989">推荐阅读：Vue 中 数据劫持 Object.defineProperty()</a></p><ul><li>defineProperty其实是定义对象的属性，或者你可以认为是对象的属性标签<blockquote><div>defineProperty其实并不是核心的为一个对象做数据双向绑定，而是去给对象做属性标签，只不过属性里的get和set实现了响应式</div></blockquote></li></ul><table><thead><tr><th>属性名</th><th>默认值</th></tr></thead><tbody><tr><td>value</td><td>undefined</td></tr><tr><td>get</td><td>undefined</td></tr><tr><td>set</td><td>undefined</td></tr><tr><td>writalbe</td><td>true</td></tr><tr><td>enumerable</td><td>true</td></tr><tr><td>configurable</td><td>true</td></tr></tbody></table><p>下面我们来详细了解一下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj=&#123;</span><br><span class="line">    a:<span class="number">1</span>,</span><br><span class="line">    b:<span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//参数说明：1.对象 2.对象的某个属性 3.对于属性的配置</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj,<span class="string">&#x27;a&#x27;</span>,&#123;</span><br><span class="line">writable:<span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(obj,<span class="string">&#x27;a&#x27;</span>));</span><br></pre></td></tr></table></figure><p>打开浏览器，按F12，将以上代码粘贴过去，查看控制台内容：</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200307130404152.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""><br>上述，打印的就是我们obj对象中a属性的一系列标签，权限方面可以看到默认的话为true</p><p>那么，我们刚刚设置了 writalbe为false，即设置了a属性不可写，进行简单测试一下：<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200307130555143.png" alt=""><br>发现我们无法对a属性进行value的修改，因为将writalbe设置了为false</p><p>当然，我们可以设置其他权限标签，例如：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj=&#123;</span><br><span class="line">    a:<span class="number">1</span>,</span><br><span class="line">    b:<span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//参数说明：1.对象 2.对象的某个属性 3.对于属性的配置</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj,<span class="string">&#x27;a&#x27;</span>,&#123;</span><br><span class="line">writable:<span class="literal">false</span>,</span><br><span class="line">enumerable:<span class="literal">false</span>,</span><br><span class="line">configurable:<span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(obj,<span class="string">&#x27;a&#x27;</span>));</span><br></pre></td></tr></table></figure><p>因此，承接上文所述，defineProperty并不是来做响应式的，而是给对象中某个属性设置权限操作，是否可写，是否可以for in，是否可delete</p><hr/><h4 id="get和set的使用"><a href="#get和set的使用" class="headerlink" title="get和set的使用"></a>get和set的使用</h4><p>Vue中实现双向绑定，其实就是与get和set有很大关系</p><p>举个栗子，请看如下代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj=&#123;</span><br><span class="line">    a:<span class="number">1</span>,</span><br><span class="line">    b:<span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//参数说明：1.对象 2.对象的某个属性 3.对于属性的配置</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj,<span class="string">&#x27;a&#x27;</span>,&#123;</span><br><span class="line">get:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;a is be get!&#x27;</span>);</span><br><span class="line">&#125;,</span><br><span class="line">set:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;a is be set!&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(obj,<span class="string">&#x27;a&#x27;</span>));</span><br></pre></td></tr></table></figure><p>我们在控制台，简单测试一下：<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200307131508633.png" alt=""><br>问题来了，细心的伙伴，应该发现了上图的问题，当我们get的时候，我们返回的是一个undefined，而且我们set一个值之后，也是获取不到新值，依旧是undefined，如下：<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200307131752670.png" alt=""><br>原因呢，其实就是我们的get函数是有返回值的，如果你不return的话，就会默认返回undefined，不管你怎么set都没用，那么如何解决这个问题呢，请看下面代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj=&#123;</span><br><span class="line">    a:<span class="number">1</span>,</span><br><span class="line">    b:<span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//借助外部变量存储值</span></span><br><span class="line"><span class="keyword">let</span> _value=obj.a;</span><br><span class="line"><span class="comment">//参数说明：1.对象 2.对象的某个属性 3.对于属性的配置</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj,<span class="string">&#x27;a&#x27;</span>,&#123;</span><br><span class="line">get:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;a is be get!&#x27;</span>);</span><br><span class="line"><span class="keyword">return</span> _value;</span><br><span class="line">&#125;,</span><br><span class="line">set:<span class="function"><span class="keyword">function</span>(<span class="params">newVal</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;a is be set!&#x27;</span>);</span><br><span class="line">_value=newVal;</span><br><span class="line"><span class="keyword">return</span> _value;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(obj,<span class="string">&#x27;a&#x27;</span>));</span><br></pre></td></tr></table></figure><p>可以看到，我们必须借助一个外部变量，也就是中转站一样，才能达到我们的get和set效果，这也是vue2 中不太优雅的地方</p><p>然后，查看控制台，解决了上述问题<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200307132357945.png" alt=""></p><h4 id="Vue中从改变一个数据到发生改变的过程"><a href="#Vue中从改变一个数据到发生改变的过程" class="headerlink" title="Vue中从改变一个数据到发生改变的过程"></a>Vue中从改变一个数据到发生改变的过程</h4><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200307132712267.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><h4 id="手写-Vue-2-中响应式原理"><a href="#手写-Vue-2-中响应式原理" class="headerlink" title="手写 Vue 2 中响应式原理"></a>手写 Vue 2 中响应式原理</h4><p>基于上述流程图，我们可以手写一个简单版的Vue2.0实现双向绑定的例子：</p><p>这里我就只实现逻辑，不具体去弄视图渲染了</p><p><strong>文件名：2.js</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Vue响应式手写实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">vue</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.$data=&#123;<span class="attr">a</span>:<span class="number">1</span>&#125;;</span><br><span class="line"><span class="built_in">this</span>.el=<span class="built_in">document</span>.getElementById(<span class="string">&#x27;app&#x27;</span>);</span><br><span class="line"><span class="built_in">this</span>.virtualdom=<span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="built_in">this</span>.observer(<span class="built_in">this</span>.$data)</span><br><span class="line"><span class="built_in">this</span>.render();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注册get和set监听</span></span><br><span class="line">vue.prototype.observer=<span class="function"><span class="keyword">function</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> value; <span class="comment">//借助外部变量</span></span><br><span class="line"><span class="keyword">var</span> self=<span class="built_in">this</span>; <span class="comment">//缓存this</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*下面代码 a可能是data里的某个对象，不是属性</span></span><br><span class="line"><span class="comment">因此在vue2.0中需要for in循环找到属性*/</span></span><br><span class="line"><span class="comment">//Object.defineProperty(obj,&#x27;a&#x27;) </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> obj)&#123;</span><br><span class="line">value=obj[key];</span><br><span class="line"><span class="comment">//判断是否为对象</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> value === <span class="string">&#x27;object&#x27;</span>)&#123;</span><br><span class="line"><span class="built_in">this</span>.observer(value);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(<span class="built_in">this</span>.$data,key,&#123;</span><br><span class="line">get:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="comment">//进行依赖收集</span></span><br><span class="line"><span class="keyword">return</span> value;</span><br><span class="line">&#125;,</span><br><span class="line">set:<span class="function"><span class="keyword">function</span>(<span class="params">newVal</span>)</span>&#123;</span><br><span class="line">value=newVal;</span><br><span class="line"><span class="comment">//视图渲染</span></span><br><span class="line">self.render();</span><br><span class="line">&#125;</span><br><span class="line">&#125;) </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//更新渲染部分</span></span><br><span class="line">vue.prototype.render=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.virtualdom=<span class="string">&quot;i am &quot;</span>+<span class="built_in">this</span>.$data.a;</span><br><span class="line"><span class="built_in">this</span>.el.innerHTML=<span class="built_in">this</span>.virtualdom;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>文件名：index.html</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=<span class="string">&quot;utf-8&quot;</span>&gt;</span><br><span class="line">&lt;title&gt;手写Vue响应式原理&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div id=<span class="string">&#x27;app&#x27;</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span> src=<span class="string">&quot;./2.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> vue();</span><br><span class="line"><span class="comment">//设置set定时器</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;2秒后将值改为123&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(vm.$data);</span><br><span class="line">vm.$data.a=<span class="number">123</span>;</span><br><span class="line">&#125;,<span class="number">2000</span>)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>查看页面，就会有如下效果：<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200307135836555.gif" alt=""></p><p>那么，以后面试如果遇到手写响应式原理，把上述js代码写上去就ok了</p><h4 id="源码分析：响应式原理中的依赖收集"><a href="#源码分析：响应式原理中的依赖收集" class="headerlink" title="源码分析：响应式原理中的依赖收集"></a>源码分析：响应式原理中的依赖收集</h4><p>手写的代码里面对于依赖收集这一块我们进行了省略，下面我们从源码的角度去看依赖收集到底是什么玩意：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Define a reactive property on an Object.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">defineReactive$$1</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    obj,</span></span></span><br><span class="line"><span class="function"><span class="params">    key,</span></span></span><br><span class="line"><span class="function"><span class="params">    val,</span></span></span><br><span class="line"><span class="function"><span class="params">    customSetter,</span></span></span><br><span class="line"><span class="function"><span class="params">    shallow</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>) </span>&#123;</span><br><span class="line">    <span class="comment">//依赖收集</span></span><br><span class="line">    <span class="keyword">var</span> dep = <span class="keyword">new</span> Dep();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> property = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, key);</span><br><span class="line">    <span class="keyword">if</span> (property &amp;&amp; property.configurable === <span class="literal">false</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// cater for pre-defined getter/setters</span></span><br><span class="line">    <span class="keyword">var</span> getter = property &amp;&amp; property.get;</span><br><span class="line">    <span class="keyword">var</span> setter = property &amp;&amp; property.set;</span><br><span class="line">    <span class="keyword">if</span> ((!getter || setter) &amp;&amp; <span class="built_in">arguments</span>.length === <span class="number">2</span>) &#123;</span><br><span class="line">      val = obj[key];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> childOb = !shallow &amp;&amp; observe(val);</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">      enumerable: <span class="literal">true</span>,</span><br><span class="line">      configurable: <span class="literal">true</span>,</span><br><span class="line">      get: <span class="function"><span class="keyword">function</span> <span class="title">reactiveGetter</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> value = getter ? getter.call(obj) : val;</span><br><span class="line">        <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">  <span class="comment">//进行依赖收集</span></span><br><span class="line">          dep.depend();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/*采用依赖收集的原因：*/</span></span><br><span class="line">  </span><br><span class="line">          <span class="comment">//1.data里面的数据并不是所有地方都要用到</span></span><br><span class="line">          <span class="comment">//2.如果我们直接更新整个视图，会造成资源浪费</span></span><br><span class="line">  <span class="comment">//3.将依赖于某个变量的组件收集起来</span></span><br><span class="line">  </span><br><span class="line">          <span class="keyword">if</span> (childOb) &#123;</span><br><span class="line">            childOb.dep.depend();</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">              dependArray(value);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">      &#125;,</span><br><span class="line">      set: <span class="function"><span class="keyword">function</span> <span class="title">reactiveSetter</span> (<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> value = getter ? getter.call(obj) : val;</span><br><span class="line">        <span class="comment">/* eslint-disable no-self-compare */</span></span><br><span class="line">        <span class="keyword">if</span> (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* eslint-enable no-self-compare */</span></span><br><span class="line">        <span class="keyword">if</span> (customSetter) &#123;</span><br><span class="line">          customSetter();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// #7981: for accessor properties without setter</span></span><br><span class="line">        <span class="keyword">if</span> (getter &amp;&amp; !setter) &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">        <span class="keyword">if</span> (setter) &#123;</span><br><span class="line">          setter.call(obj, newVal);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          val = newVal;</span><br><span class="line">        &#125;</span><br><span class="line">        childOb = !shallow &amp;&amp; observe(newVal);</span><br><span class="line">        dep.notify();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="对依赖收集的总结"><a href="#对依赖收集的总结" class="headerlink" title="对依赖收集的总结"></a>对依赖收集的总结</h4><p>在初次渲染时，会触发一次get函数，为了提高效率，节省资源，采用依赖收集，这里以之前手写的为例，get部分，我们就会对<code>this.$data</code>里的每一个属性（即key值）进行收集，看在哪些组件里进行了调用，以此提高效率。</p><p>而在set部分，就会更新我们收集到的依赖 </p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(<span class="built_in">this</span>.$data,key,&#123;</span><br><span class="line">get:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="comment">//进行依赖收集</span></span><br><span class="line"><span class="keyword">return</span> value;</span><br><span class="line">&#125;,</span><br><span class="line">set:<span class="function"><span class="keyword">function</span>(<span class="params">newVal</span>)</span>&#123;</span><br><span class="line">value=newVal;</span><br><span class="line"><span class="comment">//视图渲染</span></span><br><span class="line">self.render();</span><br><span class="line">&#125;</span><br><span class="line">&#125;) </span><br></pre></td></tr></table></figure><h4 id="额外注意——关于数组的监听（探索设计模式）"><a href="#额外注意——关于数组的监听（探索设计模式）" class="headerlink" title="额外注意——关于数组的监听（探索设计模式）"></a>额外注意——关于数组的监听（探索设计模式）</h4><p>从前文我们可以了解到，defineProperty定义的ger和set是对象的属性，那么数组该怎么办呢？</p><p>对于数组呢，在Vue中，你是没有办法像C/C++、Java等语言那样直接通过操作下标来触发更新，只能通过push、pop等方法来触发数据更新</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">arr.push(<span class="number">4</span>);</span><br><span class="line">arr.pop();</span><br><span class="line">arr.shift();</span><br></pre></td></tr></table></figure><p>这里 <strong><font color=red>特别重要!</font></strong></p><p>关于数组这一块里面巧妙运用到了一个设计模式——<font color=blue>装饰者模式</font></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//装饰者模式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//先取出原型</span></span><br><span class="line"><span class="keyword">var</span> arraypro=<span class="built_in">Array</span>.prototype;</span><br><span class="line"><span class="comment">//拷贝一份，原因：避免影响到了原来的原型链</span></span><br><span class="line"><span class="keyword">var</span> arrob=<span class="built_in">Object</span>.create(arraypro);</span><br><span class="line"><span class="comment">//定义一个需要装饰的方法的数组，这里只例举以下三个</span></span><br><span class="line"><span class="keyword">var</span> arr=[<span class="string">&#x27;push&#x27;</span>,<span class="string">&#x27;pop&#x27;</span>,<span class="string">&#x27;shift&#x27;</span>];</span><br><span class="line"><span class="comment">//设置重写方法（装饰者模式）</span></span><br><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">methods,index</span>)</span>&#123;</span><br><span class="line">arrob[method]=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="comment">//先调用原来的方法</span></span><br><span class="line"><span class="keyword">var</span> res=arraypro[method].apply(<span class="built_in">this</span>,<span class="built_in">arguments</span>);</span><br><span class="line"><span class="comment">//触发视图更新</span></span><br><span class="line">dep.notify();</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//接下来将数组的prototype替换到data上的prototype(此处省略)</span></span><br><span class="line"><span class="comment">//这样的话，例如我们push方法，既能push又能触发视图更新了</span></span><br></pre></td></tr></table></figure><p>对于设计模式呢，其实并不是很难，常说难懂，很难学，可能你学设计模式，你看了书，看到的可能就是简单事例，只是一个用法，没有训练思维，正确的做法是：</p><ul><li>提高我们的思维，提高代码质量</li><li>先学透，记住一些定义和一些具体使用，然后去看，去探索</li><li>非常好的一种方式就是结合源码，例如上文我们从Vue数组的监听原理里面剖析出来了装饰者模式</li><li>学以致用</li></ul><h3 id="Vue-3的响应式原理"><a href="#Vue-3的响应式原理" class="headerlink" title="Vue 3的响应式原理"></a>Vue 3的响应式原理</h3><hr/><p>对于2.0响应式原理，我们暂告一段落，接下来，我们讨论Vue 3中的技巧，众所周知，Vue 3将<code>defineProperty</code>替换成了<code>proxy</code></p><h4 id="什么是proxy"><a href="#什么是proxy" class="headerlink" title="什么是proxy"></a>什么是proxy</h4><p>用于定义基本操作的自定义行为</p><blockquote><div>和defineProperty类似，功能几乎一样，只不过用法上有所不同</div></blockquote><p>和上文一样，我们依旧写一个响应式，不过下面的代码是有问题的，读者可以先思考一下。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj=&#123;</span><br><span class="line">    a:<span class="number">1</span>,</span><br><span class="line">    b:<span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//无需借助外部变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Proxy</span>(obj,&#123;</span><br><span class="line"><span class="function"><span class="title">get</span>(<span class="params">target,key,receiver</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(target,key,receiver);</span><br><span class="line"><span class="keyword">return</span> target[key];</span><br><span class="line">&#125;,</span><br><span class="line"><span class="function"><span class="title">set</span>(<span class="params">target,key,value,receiver</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target,key,value);</span><br><span class="line"><span class="comment">//return target[key]=value;</span></span><br><span class="line"><span class="comment">/*上面注释的代码和上一行意思相同*/</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>我们在控制台跑一下上述代码，发现它并没有输出console.log的内容，因此是有问题的<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200307191318942.png" alt=""><br>正确代码如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj=&#123;</span><br><span class="line">    a:<span class="number">1</span>,</span><br><span class="line">    b:<span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//无需借助外部变量</span></span><br><span class="line"><span class="comment">//对于vue 2，提高效率，无需for in 遍历找属性</span></span><br><span class="line"><span class="comment">//不会污染原对象，会返回一个新的代理对象，原对象依旧是原对象</span></span><br><span class="line"><span class="comment">//也是软件工程里的重要知识，尽量不要&quot;污染&quot;原对象，不用给原对象做任何操作</span></span><br><span class="line"><span class="comment">//只需对代理对象进行操作</span></span><br><span class="line"><span class="keyword">var</span> objChildren=<span class="keyword">new</span> <span class="built_in">Proxy</span>(obj,&#123;</span><br><span class="line"><span class="function"><span class="title">get</span>(<span class="params">target,key,receiver</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(target,key,receiver);</span><br><span class="line"><span class="keyword">return</span> target[key];</span><br><span class="line">&#125;,</span><br><span class="line"><span class="function"><span class="title">set</span>(<span class="params">target,key,value,receiver</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target,key,value);</span><br><span class="line"><span class="comment">//return target[key]=value;</span></span><br><span class="line"><span class="comment">/*上面注释的代码和上一行意思相同*/</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="总结：为什么Vue-3中使用proxy"><a href="#总结：为什么Vue-3中使用proxy" class="headerlink" title="总结：为什么Vue 3中使用proxy"></a>总结：为什么Vue 3中使用proxy</h4><ul><li>defineProperty只能监听某个属性，不能对全对象进行监听</li><li>可以省去for in遍历找对象中的属性，提高效率，省去很多代码</li><li>可以监听数组，不用再去单独的对数组进行特异性操作</li><li>不会污染原对象，会返回一个新的代理对象，原对象依旧是原对象</li><li>只需对代理对象进行操作</li></ul><h4 id="手写-Vue-3-中响应式原理"><a href="#手写-Vue-3-中响应式原理" class="headerlink" title="手写 Vue 3 中响应式原理"></a>手写 Vue 3 中响应式原理</h4><p>下面代码，是在上文手写 Vue 2 响应式原理基础上修改的，通过对比，可以发现，我们省去了好多代码，不需要进行for in循环比较复杂、耗时间的操作了</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Vue响应式手写实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">vue</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.$data=&#123;<span class="attr">a</span>:<span class="number">1</span>&#125;;</span><br><span class="line"><span class="built_in">this</span>.el=<span class="built_in">document</span>.getElementById(<span class="string">&#x27;app&#x27;</span>);</span><br><span class="line"><span class="built_in">this</span>.virtualdom=<span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="built_in">this</span>.observer(<span class="built_in">this</span>.$data)</span><br><span class="line"><span class="built_in">this</span>.render();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注册get和set监听</span></span><br><span class="line">vue.prototype.observer=<span class="function"><span class="keyword">function</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> self=<span class="built_in">this</span>;</span><br><span class="line"><span class="built_in">this</span>.$data=<span class="keyword">new</span> <span class="built_in">Proxy</span>(<span class="built_in">this</span>.$data,&#123;</span><br><span class="line"><span class="function"><span class="title">get</span>(<span class="params">target,key</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> target[key];</span><br><span class="line">&#125;,</span><br><span class="line"><span class="function"><span class="title">set</span>(<span class="params">target,key,value</span>)</span>&#123;</span><br><span class="line">target[key]=value;</span><br><span class="line">self.render();</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//更新渲染部分</span></span><br><span class="line">vue.prototype.render=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.virtualdom=<span class="string">&quot;i am &quot;</span>+<span class="built_in">this</span>.$data.a;</span><br><span class="line"><span class="comment">//this.el.innerHTML=this.virtualdom;</span></span><br><span class="line"><span class="built_in">this</span>.el.innerHTML=<span class="built_in">this</span>.virtualdom;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看页面，就会有如下效果：<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200307135836555.gif" alt=""></p><h4 id="proxy这么好用，还能做什么呢？（再遇设计模式）"><a href="#proxy这么好用，还能做什么呢？（再遇设计模式）" class="headerlink" title="proxy这么好用，还能做什么呢？（再遇设计模式）"></a>proxy这么好用，还能做什么呢？（再遇设计模式）</h4><p>我们学习知识并不只是为了应付面试那种程度，对于面试应该作为我们的最低要求，接下来，我们接着去深度研究proxy还能干什么呢？</p><p>在 Vue 3 基本上已经不兼容IE8了，这里简单提及一下</p><ul><li><strong>类型验证</strong></li></ul><p>这里我们就自定义一个实例：创建一个成人的对象，拥有name和age两个属性</p><p>要求：name必须是中文，age必须是数字，并且大于18</p><p>如果用纯原生js做验证的话，可想有多难去验证上述需求，或许你想到的是在构造函数里面去实现，但也不会简单，那么我们看看proxy怎么实现的：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//类型验证</span></span><br><span class="line"><span class="comment">//外部定义一个验证器对象</span></span><br><span class="line"><span class="keyword">var</span> validator=&#123;</span><br><span class="line">name:<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> reg=<span class="regexp">/^[\u4E00-\u9FA5]+$/</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> value==<span class="string">&#x27;string&#x27;</span>&amp;&amp;reg.test(value))&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;,</span><br><span class="line">age:<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> value==<span class="string">&#x27;number&#x27;</span>&amp;&amp;value&gt;=<span class="number">18</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">person</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.name=name;</span><br><span class="line"><span class="built_in">this</span>.age=age;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(<span class="built_in">this</span>,&#123;</span><br><span class="line"><span class="function"><span class="title">get</span>(<span class="params">target,key</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> target[key];</span><br><span class="line">&#125;,</span><br><span class="line"><span class="function"><span class="title">set</span>(<span class="params">target,key,value</span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(validator[key](value))&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target,key,value);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(key+<span class="string">&#x27; is not right!&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里 <strong><font color=red>特别重要!</font></strong></p><p>关于类型验证这一块里面又巧妙运用到了一个设计模式——<font color=blue>策略模式</font></p><p>关于设计模式这一块，此专栏不会细讲，但会在探索源码时发现了好的实例，会提出来一下。</p><p>上述用到了一个正则表达式，关于这个可能面试会问到，这是之前ES 6 里的内容，大家可以看看这篇简单易懂的文章：</p><p><a href="https://blog.csdn.net/weixin_42429718/article/details/104591240">推荐阅读：ES6 面试题：你能说出浏览器上到此支持多少个中文字吗？</a></p><ul><li><strong>私有变量</strong></li></ul><p>关于私有变量这一块，我们就拿 <code>vue-router 源码</code>来进行分析：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//vue-router源码分析</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(<span class="built_in">this</span>,<span class="string">&#x27;$router&#x27;</span>,&#123;<span class="comment">//Router的实例</span></span><br><span class="line"><span class="function"><span class="title">get</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>._root._router;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(<span class="built_in">this</span>,<span class="string">&#x27;$route&#x27;</span>,&#123;</span><br><span class="line"><span class="function"><span class="title">get</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span>&#123;</span><br><span class="line"><span class="comment">//当前路由所在的状态</span></span><br><span class="line">current:<span class="built_in">this</span>._root._router.history.current</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>通过查看源码，提出疑问：为什么要为<code>$router</code>写get方法呢，而且没做什么操作，只是一个return？</p><p>原因：这样可以使得<code>$router</code>不可修改。避免程序员通过set修改了路由，导致路由失效的情况。这里就体现了数据安全思想，前端程序员或许考虑的没有Java程序员多，甚至没有为变量想过某个变量设置不可修改。由于工作的需要，我们也要努力提升自己的代码质量！让自己的职业生涯更加辉煌！</p><h3 id="virtual-dom-和-diff算法"><a href="#virtual-dom-和-diff算法" class="headerlink" title="virtual dom 和 diff算法"></a>virtual dom 和 diff算法</h3><hr/><p>关于diff算法和虚拟dom，也是面试常见的问题，平常容易忽视，这里我也就深入研究了一下：</p><h4 id="虚拟dom"><a href="#虚拟dom" class="headerlink" title="虚拟dom"></a>虚拟dom</h4><p>所谓虚拟dom，如字面意思，它是虚拟的，只在概念里面存在，并不真的存在，在vue中是ast语法树，关于这个语法树本文就不详细介绍了，有兴趣的读者可以深入研究一下。</p><p>下面代码，是一个简单vue template模板，那么解析成虚拟dom是怎样的呢？</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div id=<span class="string">&#x27;dd&#x27;</span>&gt;</span><br><span class="line">&lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;p&gt;abc&lt;/p&gt;</span><br><span class="line">&lt;p&gt;<span class="number">123</span>&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>解析成虚拟dom：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">diff &lt;div&gt;</span><br><span class="line">props:&#123;</span><br><span class="line">id:dd</span><br><span class="line">&#125;,</span><br><span class="line">children:[</span><br><span class="line">diff &lt;p&gt;</span><br><span class="line">props:</span><br><span class="line">children:[</span><br><span class="line"></span><br><span class="line">],</span><br><span class="line">text:xxx,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>上述代码就是概念上的介绍，如果懂一点算法知识的应该就明白了，就是不断地嵌套，但为了让更多伙伴读懂学会虚拟dom，下面来手写一个对象的形式：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div id=<span class="string">&#x27;dd&#x27;</span>&gt;</span><br><span class="line">&lt;p&gt;<span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>&lt;/p&gt;</span><br><span class="line">&lt;p&gt;abc&lt;/p&gt;</span><br><span class="line">&lt;p&gt;<span class="number">123</span>&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> virtual=</span><br><span class="line">&#123;</span><br><span class="line">dom:<span class="string">&#x27;div&#x27;</span>,</span><br><span class="line">props:&#123;</span><br><span class="line">id:dd</span><br><span class="line">&#125;,</span><br><span class="line">children:[</span><br><span class="line">&#123;</span><br><span class="line">dom:<span class="string">&#x27;p&#x27;</span>,</span><br><span class="line">children:[</span><br><span class="line">dom:<span class="string">&#x27;span&#x27;</span>,</span><br><span class="line">children:[]</span><br><span class="line">]</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">dom:<span class="string">&#x27;p&#x27;</span>,</span><br><span class="line">children:[</span><br><span class="line">]</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">dom:<span class="string">&#x27;p&#x27;</span>,</span><br><span class="line">children:[</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码应该就很清晰了，简单来说，就是将最上面的dom结构，解析成下面用js解析成的对象，每一个对象都有一个基础的结构：</p><ul><li>dom元素标签</li><li>props记录挂载了哪些属性</li><li>children记录有哪些子元素（子元素拥有和父元素相同的结构）</li></ul><h4 id="diff算法的比对机制"><a href="#diff算法的比对机制" class="headerlink" title="diff算法的比对机制"></a>diff算法的比对机制</h4><p>下面部分采用了伪代码形式介绍diff算法的比对机制，已经给出了详细的注释说明：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//diff算法匹配机制</span></span><br><span class="line"><span class="function"><span class="title">patchVnode</span>(<span class="params">oldVnode,vnode</span>)</span>&#123;</span><br><span class="line"><span class="comment">//先拿到真实的dom</span></span><br><span class="line"><span class="keyword">const</span> el=vnode.el=oldVnode.el;</span><br><span class="line"><span class="comment">//分别拿出旧节点和新节点的子元素</span></span><br><span class="line"><span class="keyword">let</span> i,oldCh=oldVnode.children,ch=vnode.children;</span><br><span class="line"><span class="comment">//如果新旧节点相同，直接return</span></span><br><span class="line"><span class="keyword">if</span>(oldVnode==vnode) <span class="keyword">return</span>;</span><br><span class="line"><span class="comment">/*分四种情况讨论*/</span></span><br><span class="line"><span class="comment">//1.只有文字节点不同的情况</span></span><br><span class="line"><span class="keyword">if</span>(oldVnode.text!==<span class="literal">null</span>&amp;&amp;vnode.text!==<span class="literal">null</span>&amp;&amp;oldVnode.text!==vnode.text)&#123;</span><br><span class="line">api.setTextContent(el,vnode.text);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">updateEle();</span><br><span class="line"><span class="comment">//2.如果新旧节点的子元素都存在，那么发生的是子元素变动</span></span><br><span class="line"><span class="keyword">if</span>(oldCh&amp;&amp;ch&amp;&amp;oldCh!==ch)&#123;</span><br><span class="line">updateChildren();</span><br><span class="line"><span class="comment">//3.如果只有新节点有子元素，那么发生的是新增子元素</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(ch)&#123;</span><br><span class="line">createEl(vnode);</span><br><span class="line"><span class="comment">//4.如果只有旧节点有子元素，那么发生的是新节点删除了子元素</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(oldCh)&#123;</span><br><span class="line">api.removeChildren(el);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">学如逆水行舟，不进则退</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【软件测试】学习路线&amp;资料整理&amp;摆脱迷茫，突破瓶颈</title>
      <link href="posts/2020627/"/>
      <url>posts/2020627/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><blockquote><p>写这篇博客原因：一位朋友突然很丧，然后找到了我，聊了许久之后，还是觉得没有大的效果，因为迷茫期不是那么容易就过去的。答应整理一份软测学习路线&amp;资料，于是就有了这一篇文章。废话少说，进入正文：</p></blockquote><h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/202006270808572.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""><br>“长江后浪推前浪，前浪死在沙滩上”，曾经一句让人会心一笑的调侃，而今变成了软件测试行业的真实写照。由于软件测试行业入门门槛低，薪资报酬高，不断有新鲜血液冲刷着软件测试行业的“前行者”们，给我们带来了非常大的压力。</p><p>那些入行几年，但是依然是功能测试的同学所面临的的压力可想而知。说到底，软件测试行业还是属于技术岗位。既然是技术岗位，那就要靠技术说话。不断掌握新的技能，提高软件测试“找bug”的能力也就变成了目前软件测试从业人员迫在眉睫需要解决的问题。因此，现在大部分初级功能测试人员都在向自动化、性能、安全靠拢。</p><p>但是还是有不少的软件测试工程师站在“十字路口”迷茫、无助，找不到自己的方向。</p><p>一切的迷茫都是因为想得太多而做的太少！每位软件测试行业从业者都能意识到目前自己面临的窘境，但能及时作出改变，顺应时代变化的人还是太少。多数人明明“泰山崩于前而面色如土”却只能眼睁睁看着自己被行业淘汰吗？</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200627080944697.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""><br>并不是，下面的软件测试工程师发展方向知识架构体系图，会告诉你该往哪里努力：</p><blockquote><p>以上引用【wetester性能测试】作者博文</p></blockquote><h2 id="自学测试-amp-思维导图"><a href="#自学测试-amp-思维导图" class="headerlink" title="自学测试&amp;思维导图"></a>自学测试&amp;思维导图</h2><p><img src= "/img/loading.gif" data-lazy-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL2Nob2NvbGF0ZTE5OTkvY2RuL2ltZy8yMDIwMDYyNzA4MzUwMi5qcGc?x-oss-process=image/format,png" alt=""></p><h2 id="测试心得-amp-学习路线"><a href="#测试心得-amp-学习路线" class="headerlink" title="测试心得&amp;学习路线"></a>测试心得&amp;学习路线</h2><p><a href="https://juejin.im/post/5cd94455f265da038e54ca46">2019软件测试学习教程（学习路线+课程大纲+视频教程+学习工具）</a></p><p><a href="https://juejin.im/post/5bed0ff5e51d4569dc41b397">新人如何入门和学习软件测试？</a></p><p><a href="https://juejin.im/post/5db31c18e51d452a1340ef61">软件测试需要学什么？测试学习大纲梳理</a></p><p><a href="https://juejin.im/post/5ecb56ade51d45789c7e7964">2020软件测试自学全套教程-基于python自动化软件测试-2020新版软件测试中级程序员学习路线</a></p><p><a href="https://juejin.im/post/5ec22fa05188256d776340ad">2020年软件测试工程师需要学什么技能</a></p><p><a href="https://juejin.im/post/5b28bf0351882574e024f0bd">wetester性能测试：选择了软件测试，你后悔吗？</a></p><p><a href="https://juejin.im/post/5ad0689a6fb9a028bd4cbb41">wetester性能测试：8年测试工程师+面试官——写给求职心切的求职者</a></p><p><a href="https://juejin.im/post/5ac03571518825558b3e1149">wetester性能测试：8年软件测试工程师感悟——写给还在迷茫中的朋友</a></p><h2 id="必用工具"><a href="#必用工具" class="headerlink" title="必用工具"></a>必用工具</h2><p><a href="https://juejin.im/post/5c36e5d1f265da612c5e16cc">姜还是老的辣，软件测试常用的工具都在这里了</a></p><h2 id="必知博主"><a href="#必知博主" class="headerlink" title="必知博主"></a>必知博主</h2><p><a href="https://juejin.im/user/5e9d5cc2518825738b422560/posts">爱码小哥</a></p><p><a href="https://www.zhihu.com/people/qin-mu-chu-28/posts">浪晋</a></p><p><a href="https://juejin.im/user/5a460bd4f265da43294e5fc3/posts">wetester性能测试</a></p><h2 id="必刷知乎"><a href="#必刷知乎" class="headerlink" title="必刷知乎"></a>必刷知乎</h2><p><a href="https://zhuanlan.zhihu.com/p/32505591">浪晋：如何从零开始学习软件测试</a></p><h2 id="必学视频"><a href="#必学视频" class="headerlink" title="必学视频"></a>必学视频</h2><p><a href="https://pan.baidu.com/s/1caR1No#list/path=%2Fsharelink1652984595-1003844422654477%2F%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95&parentPath=%2Fsharelink1652984595-1003844422654477">全套软件培训教程–加密版</a></p><p><a href="https://pan.baidu.com/s/12srBs#list/path=%2F&parentPath=%2F">软件测试课程系列（约45.87G）</a></p><h3 id="黑马程序员全家桶系列"><a href="#黑马程序员全家桶系列" class="headerlink" title="黑马程序员全家桶系列"></a>黑马程序员全家桶系列</h3><p><a href="https://www.bilibili.com/video/BV1DW411x7GP?from=search&seid=7878207801742644335">黑马程序员：5天软件测试从入门到精通</a></p><p><a href="https://www.bilibili.com/video/BV1zE41197DG">黑马程序员：软件测试全套教程（共979集）</a></p><p>看完本套视频可以继续观看：</p><p><a href="https://www.bilibili.com/video/BV1PT4y1G7cy">软件测试进阶教程微信小程序测试实战 </a></p><p><a href=" https://www.bilibili.com/video/BV1WJ411S7PH">python实现头条项目接口自动化测试实战</a></p><p><a href="https://www.bilibili.com/video/BV1LJ41137b5">小白也能听懂的接口测试教</a></p><blockquote><p>推荐观看其余教程 ❤❤❤❤❤❤❤❤❤<br>零基础入门移动自动化测试——Appium框架视频：<a href="https://www.bilibili.com/video/BV1B441197rZ">https://www.bilibili.com/video/BV1B441197rZ</a><br>手把手教你搞懂安全渗透之sql注入：<a href="https://www.bilibili.com/video/BV1rC4y1s7YC">https://www.bilibili.com/video/BV1rC4y1s7YC</a></p></blockquote><h3 id="尚学堂全家桶系列"><a href="#尚学堂全家桶系列" class="headerlink" title="尚学堂全家桶系列"></a>尚学堂全家桶系列</h3><p><a href="https://www.bilibili.com/video/BV1nJ411X7aR">【尚学堂】软件测试全栈工程师 1200集（完结）</a></p><h3 id="柠檬班全家桶系列"><a href="#柠檬班全家桶系列" class="headerlink" title="柠檬班全家桶系列"></a>柠檬班全家桶系列</h3><p><a href="https://www.bilibili.com/video/BV1At411Y7Kp">【柠檬班】软件测试干货！史上最全面的软件测试笔试面试就业指南，如何在互联网就业寒冬顺利拿下心仪offer</a></p><h3 id="千峰教育全家桶系列"><a href="#千峰教育全家桶系列" class="headerlink" title="千峰教育全家桶系列"></a>千峰教育全家桶系列</h3><p><a href="https://www.bilibili.com/video/BV1BE411R7QR">【千锋教育】软件测试 600集（学完可就业/2019版）</a></p><p><a href="https://www.bilibili.com/video/BV1cE411F7YE">软件测试教程2019版 500集完全入门 达到软件测试工程师水平</a></p><h2 id="测试思维"><a href="#测试思维" class="headerlink" title="测试思维"></a>测试思维</h2><p><a href="https://www.bilibili.com/video/BV1Lx411X7Pk">震惊！软件测试原来是这么回事？！</a></p><h2 id="面试相关"><a href="#面试相关" class="headerlink" title="面试相关"></a>面试相关</h2><p><a href="https://www.bilibili.com/video/BV1pW411b76C">软件测试-初级&amp;中高级面试都会问你这些问题！-乐搏软件测试</a></p><p><a href="https://juejin.im/post/5ed9fbe3f265da770709d2a0">爱码小哥：我凭借这份30页面试宝典文档资料，拿下了百度、美团、字节跳动、小米等大厂的offer【内含答案】</a></p><p><a href="https://juejin.im/post/5ed3852df265da76ea2e8ea9">爱码小哥：软件测试简历写成这样，还怕HR不招你？</a></p><h2 id="必用搜索资源网站"><a href="#必用搜索资源网站" class="headerlink" title="必用搜索资源网站"></a>必用搜索资源网站</h2><p><a href="https://www.chaonengsou.com/">超能搜</a></p><p><a href="https://search.chongbuluo.com/">虫部落-快搜</a></p><p><a href="http://ilxdh.com/">龙轩导航</a></p><p><a href="https://search.bilibili.com/all?keyword=%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95&from_source=nav_recommend_new">B站软件测试合集</a></p><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>学习资料是收集不完的，学习也是没有止境的。师傅引进门，修行在个人。我们要的不应该是各种学习资料，让自己一下打打鸡血，好像有了方向。而是锻炼自己的学习思维，明白自己应该怎么学，该学什么，怎么学好，这比一大堆学习资料重要的多！因为这样，我们就能清楚自己的目标，然后给自己设定学习方向，什么阶段该干什么事，那么成功对你而言，只是时间问题了。</p><blockquote><p>学如逆水行舟，不进则退</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200627091113246.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><blockquote><p>下文在我阅读之后，觉得是挺不错的，引用了部分内容，原文可在文末查看。</p></blockquote><h2 id="摆脱迷茫，突破瓶颈，关注这些能让你少走弯路"><a href="#摆脱迷茫，突破瓶颈，关注这些能让你少走弯路" class="headerlink" title="摆脱迷茫，突破瓶颈，关注这些能让你少走弯路"></a>摆脱迷茫，突破瓶颈，关注这些能让你少走弯路</h2><blockquote><p>成功有没有捷径，唯一的捷径就是不走弯路。成功对你而言，只是个时间问题。</p></blockquote><h3 id="要清楚自己未来的目标是什么"><a href="#要清楚自己未来的目标是什么" class="headerlink" title="要清楚自己未来的目标是什么"></a>要清楚自己未来的目标是什么</h3><p> 很多人把职场想得太美好，其实不然。如果你没有规划好，你就会难免遇到各种各样的问题：工作不开心；没有前进的动力；工作不是自己想像的那么好；自己的才能无法发挥；看到以前的同学待遇如何如何，便受不了刺激，急切地想跳槽；当初为了生存而找的工作，根本就不适合自己…… </p><p>这是几乎所有初入职场的同学都会面临的问题。而这些问题通常会在步入职场的1-3年之内最明显（3年之后之所以不明显，是因为你已经被现实折磨得太久了，已经被种种不平现象同化了，因此也就习惯了。你曾经的种种抱负被现实碾得粉碎。于是，你也从一个志向远大的年轻人一下子变成了一个碌碌无为、甘于平庸、成天为了生计而奔走的普通打工者）。如果不及早解决这些问题，那么，你就会荒废这3年的时间（有的人可能会更长），而对于一个职场新人来说，这3年至关重要，是锻炼能力、积累资本的黄金3年！一旦错过，则要花费更多的时间，从头再来，重新弥补！更有甚者，可能一辈子都无法弥补！这绝对不是危言耸听！  </p><p> 为什么要清楚自己的目标？因为，有了目标，才有行动的指南。知道自己想干什么，喜欢干什么，这才是你前进的最终动力。工作不开心、动力不足、盲目跳槽的最根本原因是职业目标不清晰。没有目标，便没有了追求，于是，所有的行动只是为了挣一口饭吃。你根本没有考虑过自己的未来应该端什么饭碗。或许你在30岁之前还有挥霍的资本，因为年轻嘛，做什么都不怕。连广告上都说了，“30岁之前，有什么好怕的？！”而一旦过了30岁，你走的每一步都必须要慎之又慎，因为：你要结婚、你要养活老婆孩子、你要供房贷、你要供养年迈的父母、孩子大了还要上学、父母年迈了需要照顾……等等等等，所有的这些责任，都要你来承担。如果没有规划，一旦出现问题，你只能自乱阵脚。</p><p>人生的职业发展如同品牌塑造一样，只不过你的产品就是你自己，也就是你人生的品牌目标。有了目标，就要考虑该怎么走。每走一步，都应该离目标更近，而不是更远。所以，你每做一个决定的时候，要衡量这个决定对不对，唯一的标准就是：它是不是能够帮助你离目标更近？如果不是，那么，赶紧住手，因为，你走的路偏离了你的目标！再走下去，只能错得更离谱！  </p><p>成功的职业生涯规划，并不仅仅是确定一个目标这么简单。确立目标只是职业规划的第一步，更重要的是执行。在执行的过程中，会受到各种因素的影响。因此，针对不同性格类型的人，有什么优势，如何发挥；有什么弱势，如何弥补；容易犯什么错误，如何规避；如何构建自己的知识体系；如何设计自己的职业成长路径，等等，都是在规划范围之内的。</p><h3 id="能力固然重要，但并不能代表全部"><a href="#能力固然重要，但并不能代表全部" class="headerlink" title="能力固然重要，但并不能代表全部"></a>能力固然重要，但并不能代表全部</h3><p>这里所说的能力，是指专业技能。步入职场你会发现，能力其实并没有你想像的那么重要，它并不是是步步高升的全部资本。你会发现一个能力不太强的人做了你的上司，只因为他在这个公司干了10年——这说明“资历”是你高升的本钱；有时候你会发现能力并不怎么强，但是与老板关系非常好的人通常能够得到提拔——这说明“关系”也是本钱。在我原先工作的公司，有两个特别明显的例子。一个有着丰富工作经验的男士，跳槽来到公司，能力也特别强，但就是与同事处理不好关系，自认为自己非常牛，喜欢主动当别人的“导师”，动不动就对别人的工作指手画脚，顶头上司非常讨厌他；而同时进入公司的另外一位女士，能力不是特别强，但是非常踏实、勤奋、与其他同事相处得也很好，能够顾全大局。最后试用期结束时，那位女士得到了公司的认可，而那位男士则收到了公司的辞退通知。</p><blockquote><p>在职场上，一定要对职场有清醒的认识，不要生活在梦幻当中，不要太理想化，不要标新立异，不要恃才傲物，不要认为有能力就可以走遍天下。专业技能固然重要，但是职场发展看的是一个人的综合素质。综合素质高的人，才是职场发展的“潜力股”。</p></blockquote><p>这些综合素质，包括沟通能力、人际关系能力、团队合作能力、管理能力、工作态度及敬业精神等各种“软实力”。对于有些同学而言，可能会对这些“软实力”不屑一顾。很多人会说，如果老板喜欢爱拍马屁的人，难道我就要委屈自己，学着去拍马屁？很不幸，我会告诉你，答案是肯定的，你一定要学会拍马屁，否则吃亏的是自己。但要声明的是，我不是教你诈，拍马屁也有拍马屁的艺术，不一定全是“讨好”或“诌媚”。中国有句成语，叫“外圆内方”，用在人际交往上，就是说你与人相处要学会妥善处理各种关系，但不可因此而失去了内心的准则。尤其在中国这种注重人情的社会，这种人际交往的能力一定要好好练练。真正的高手，三教九流皆不在话下。</p><p>学会欣赏和赞美，别人也会对你抱之以鲜花和微笑。</p><h3 id="要保持一种“空杯心态”"><a href="#要保持一种“空杯心态”" class="headerlink" title="要保持一种“空杯心态”"></a>要保持一种“空杯心态”</h3><blockquote><p>“空杯心态”最直接的含义就是一个装满水的杯子很难接纳新东西，要将心里的“杯子”倒空，将自己所重视、在乎的很多东西以及曾经辉煌的过去从心态上彻底了结清空，只有将心倒空了，才会有外在的松手，才能拥有更大的成功。</p></blockquote><p>这是每一个想在职场发展的人所必须拥有的最重要的心态。它告诉我们一个道理：做事的前提是先要有好心态。如果想学到更多的学问，先要把自己想象成“一个空着的杯子”，而不是骄傲自满。  </p><p>我见过很多的大学毕业生，刚进入公司时常常处处吹牛，说自己在学校如何如何，本来可以找到更好的工作，迫不得已才来到了这里等等之类的话，好像这家公司委屈了自己。在这里提醒一下那些即将步入职场的大学生：这种心态千万要不得！不要认为自己很牛。还是那句你不爱听的话：中国什么都缺，就是不缺人！话又说回来，你要是这么牛，为什么不像比尔·盖茨、戴尔、乔布斯那样，大学没毕业就退学去创办一家世界级的大企业？火车不是推的，牛皮不是吹的。你要是有本事，就用事实证明给人家看，而不是成天抱怨！  </p><p>对于刚刚步入职场的同学而言，这一心态同样重要。中国有一个词，叫“虚怀若谷”。我们都知道，优秀的人有极高的素养，他们都有一个能包容一切的胸怀，有了这样的胸怀，你在职场上就会获得别人的尊重，就会获得更多的发展机会。</p><h3 id="机会只垂青有准备的人"><a href="#机会只垂青有准备的人" class="headerlink" title="机会只垂青有准备的人"></a>机会只垂青有准备的人</h3><p> 无论你再怎么抱怨，再怎么不开心，饭还是要吃的，觉还是要睡的，工作还是要做的，未来的事情永远只属于自己的。买房子也好，娶老婆也罢，压力只有自己扛，老板不会为你操任何心。</p><blockquote><p>与其有时间去抱怨，但不如踏踏实实静下心来，好好提升自己的基本功，用事实证明自己的本事，让别人对你刮目相看，万不可因为自己的书生意气而自做一个自毁前程的“愤青”。</p></blockquote><p>当然，你的准备是多方面的，除了专业技能外，其他的辅助技能也是非常必要的，比如沟通能力、人际关系处理能力、管理能力等等。当然，更重要的是要为自己的未来做一个规划，清楚地知道自己的目标是什么，应该怎么努力才能实现。适当的时候也要充充电，不要舍不得那半个月的工资，这也算是为自己的未来进行投资，有什么舍不得的呢？如果你现在不学会“舍”，以后将永远也“得”不到。  </p><p>有时候，你之所以发展得不好，不是因为没有机遇，而是因为你没有准备好，导致机遇与你擦肩而过。这个社会就是这样，再怎么不合理，再怎么不公平，但是发展机遇是时时都会面临的，只看你有没有准备好。你要是真的练就了一身令人刮目相看的真本事，说不定明天就有人请你做某世界500强的总裁也不一定呢。</p><p><a href="https://juejin.im/post/5ed796736fb9a047e02efa3e#heading-0">以上内容引自：软件测试7年之痒程序员，摆脱迷茫，突破瓶颈，关注这些能让你少走弯路。（推荐阅读）</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本人并不是软件测试方向，因此此篇博文难免会有不太对或整理不好的地方，还望多担待。如若后续有更好的学习资料，还是会继续更新下去的。</p><blockquote><p>我们的征途是星辰大海！</p></blockquote><p>2020年6月27日早<br><img src= "/img/loading.gif" data-lazy-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL2Nob2NvbGF0ZTE5OTkvY2RuL2ltZy8yMDIwMDYxNTE3MDU1OS5qcGc?x-oss-process=image/format,png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
            <tag> 心得 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「成长之路」挥手2020，Chocolate 同学年度总结，所遇 | 所思 | 所学 | 所悟</title>
      <link href="posts/20201231/"/>
      <url>posts/20201231/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>本人双非本科，目前大四在读，JS，TS，LeetCode，Vue，React，算法爱好者。 座右铭：学如逆水行舟，不进则退！</p><blockquote><p>经常看我文章的小伙伴应该都会在结尾看到这一句座右铭了：「学如逆水行舟，不进则退」<br>我觉得不管在任何领域，持续学习是很有必要的，把学习当做一种习惯，受益终身！</p></blockquote><p>2020年，我经历了春招，秋招，求职到主动离职，去过杭州，游过西湖，经历一个offer也没有，到收到满意offer，当然还有一些校园经历，感情经历…你有兴趣继续听我唠嗑，我拿起酒杯与你分享~</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20201229201327746.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70#pic_center" alt=""></p><p>下面我将讲述我在2020年成长之路，所遇 | 所思 | 所学 | 所悟。</p><h2 id="春招求职之路"><a href="#春招求职之路" class="headerlink" title="春招求职之路"></a>春招求职之路</h2><p>2020年春招和秋招对于即将毕业又不考研的本科生显得额外重要，所以我想来说说我的求职之路。</p><p>在2月份自己确定要走前端这条路之后，就开始学习前端，然而当初缺少指导，走过不少弯路，犹记得当初为了学习如何开发一个仿某团网还折腾了一个月，<a href="https://github.com/Chocolate1999/Vue-family-bucket-SSR-Koa2-full-stack-development-from-Meituan">《🚀🚀2020最新Vue全家桶+SSR+Koa2全栈开发☁》</a> 现在 github 上面都有了90 star，这一个月时间我没有注重基础知识的学习，然而技术栈方面对于那个时候的我都显得很新，学完感觉还差火候，这对于我春招整个面试没有很多帮助，尽管面试官对这个项目有兴趣，但是我发现自己没办法理清楚面试官想要的答案。</p><p>整个春招下来，跌跌撞撞，没有收到一个实习offer，但好在自己没有放弃，一直等到了6月份，杭州某电子公司开始了春招实习招聘，我们学校里和我一批的共有6个人一起录用了，那么7月份8月份就是我的实习生活了。</p><blockquote><p>下面几张图片是实习时候随便拍拍</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20201224161715767.png" alt=""></p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20201224161732669.png" alt=""></p><p>总结：</p><p>收到 <code>offer</code> 后，我写下了自己整个春招找实习的心路历程，如下：</p><p><a href="https://yangchaoyi.vip/posts/520521/">《【春招&amp;实习】前端学习の优质资料整理&amp;心路历程》</a></p><p>基本上春招过程通过这一篇总结就完毕了</p><h2 id="实习感悟"><a href="#实习感悟" class="headerlink" title="实习感悟"></a>实习感悟</h2><p>，转眼间，实习时间也过了一段日子，我是时候考虑一下自己未来去向以及是否留在公司转正。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20201224161653355.png" alt=""></p><p>实习阶段，和同事们一起去过嵊泗列岛玩耍过，见过传说中的姐妹沙滩，吃过真真正正、原汁原味的海鲜，第一次吃到大闸蟹、皮皮虾，体验渔民打渔生活。这个主要以旅游业为主的地方也开阔了我的视野，作为南方人真不太习惯原汁原味的海鲜，不过酒店早上白嫖的早餐还是真不错（手动滑稽，露出白嫖的嘴脸~）</p><blockquote><p>在嵊泗列岛也是我第一次体验公司报销的旅游，原来在互联网公司还能有这样的福利，这是我游玩过后的一次感悟。</p></blockquote><p>尽管部门里面许多人不太熟，但一到吃饭聚集了聊着聊着就认识了，也是不错的体验。</p><blockquote><p>当然，也拍了许许多多的照片（黑照居多，这里就不展示了 ⁄(⁄ ⁄•⁄ω⁄•⁄ ⁄)⁄ ）</p></blockquote><p>总结：</p><p>在这两个月实习阶段，体验到了上班日常生活，恰好遇到了部门外出旅游活动，也遇到了优秀的导师，在编码阶段给了很多建议和帮助，不论是技术上，还是工作上，一遇问题都能及时给出帮助，并且我的导师还会主动询问我是否有什么疑问，不懂的地方（即使那段实习阶段部门项目到了后续最忙的阶段）。</p><p>尽管收到了转正录用，但各有选择，离开的原因这里我就不细说了，人生有梦，各自精彩，感恩相遇~</p><h2 id="秋招求职之路"><a href="#秋招求职之路" class="headerlink" title="秋招求职之路"></a>秋招求职之路</h2><p>8月份正式踏入秋招的征途，投递了许许多多的公司，面试过腾讯、字节、滴滴、美团、快手、网易、阿里等公司，也面过一些中小型公司，整个过程也是坎坷，在此简述一下秋招结果：</p><ul><li>腾讯多次倒在一面</li><li>字节跳动跳到二面截止</li><li>滴滴三连面，倒在最后一面</li><li>快手倒在一面</li><li>网易互娱流程走完，等待OC（一直到12月份中旬反馈了offer正在发放）</li><li>美团技术面走完（被毁 offer）</li><li>腾云扣钉收到offer（已签）</li></ul><p>秋招过后，我也像春招找实习那样，写下了一篇总结性文章：</p><p><a href="https://yangchaoyi.vip/posts/20201024/">《「不进则退」2020 Chocolate 同学秋招前端の大厂面经&amp;心路历程&amp;个人经验分享》</a></p><blockquote><p>由于是那个阶段写的，部分内容也没有更新，最终某团没有选择我，不过我感谢它，让我遇见了后面这些事~</p></blockquote><p>关于秋招个人面试经历以及经验分享方面，这里就不再赘述了，感兴趣的小伙伴们可以直接到博客页面溜达阅读~</p><p>总结：</p><p>秋招整体下来经历过低谷，经历过风雨最终还是遇见了彩虹，也遇见了她，再次感谢某团。同样，在整个秋招找工作路程中，认识了一些共奋进的朋友，很高兴的是我们秋招都得到了满意的 offer！</p><h2 id="感情经历"><a href="#感情经历" class="headerlink" title="感情经历"></a>感情经历</h2><p>上文提到了，秋招过程中因为遇到了她，某团给我的打击也显得没那么重要了，我重新燃起了斗志继续闯荡秋招，感恩遇见，以后的日子一起度过~</p><blockquote><p>简单提及一下，低调低调。总之，我可以正大光明地出「写给女友」系列专栏文章啦~</p></blockquote><h2 id="校园经历"><a href="#校园经历" class="headerlink" title="校园经历"></a>校园经历</h2><p>上半年，因为疫情在家里度过漫长的假期，那段时间其实挺想念学校生活的，在宿舍以及在教室里还能和一些伙伴聊聊天，唠嗑唠嗑，真正意义上的校园生活还是在下半年，而这下半年仅仅几门课程，很早就结课了，大学课程终于学完了！</p><blockquote><p>这也意味着要离开学校了，在这之前还有毕业设计要做，因此剩下一段时间就是毕设相关安排了。</p></blockquote><p>在6月份样子，安排了班委换届工作，这也就意味着大三一年班长工作结束了，也意味着整个大学生涯班委工作结束了，过的挺快，因为这些经历，让我成长飞快，看着一批批新的班委们上台发言，不由自主的想到了当年鼓起勇气上台发言的自己，自信的人总会自带光芒~</p><p>在11月份我再次参加了天梯赛，也是由于今年疫情原因，不再是去中南大学比赛了，改为校内线上直播比赛形式，原本老早就退acm了，一方面要找工作了，另一方面感觉打不动了，身边的队友逐渐退出，少了许多干劲，不过这次天梯赛带队老师提了邀请，给了我一队名额，我想着还是最后打这一战，毕业前的最后一次比赛，不管结果如何，不带任何压力轻松比赛就好了，就当是一场愉快地游戏~</p><p>原本大二那会刚参与acm时就拿到了二队名额，当时就是成功参与，拿了80分参与分，不过这次上了138分，最后一道25分题还是最后5分钟，测试都没测试直接交的，居然通过了，当时挺开心的~</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20201229202712131.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70#pic_center" alt=""></p><p>最终我们一队拿到了全国团队三等奖，学校依旧拿到了高校三等奖。想来想去，虽然自己大学acm阶段没有拿到含金量比较高的牌子，但我觉得这份经历丰富了我的大学生活，正是因为有了它，我养成了持续学习的好习惯，同时，在面试准备阶段，算法这一块减少了许多时间。</p><p>在12月份我成功申请到了校级一等奖学金，学分绩点也冲到了班级第一，这是我大二时定下的目标，终于在毕业前实现了！</p><p>同时，我依旧保持收到 <code>三好学生、优秀学生干部</code> 荣誉证书，应该是我大学生活最后的证书了，收藏保留。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20201229203559653.png" alt=""></p><h2 id="我与开源平台"><a href="#我与开源平台" class="headerlink" title="我与开源平台"></a>我与开源平台</h2><p>整个秋招过程，我在 <code>github</code> 算是比较活跃的，这里截一张图。那么提交些什么呢？</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20201229110655210.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><p>一部分当然是代码，这里面包括自己做的小项目，算法刷题。</p><p>主要还是维护自己的前端笔记仓库，<a href="https://github.com/Chocolate1999">https://github.com/Chocolate1999</a> （首页第一个项目）</p><blockquote><p>这个前端笔记，一方面是整理，另一方面是回馈，目前已获350+star了，明年我也依旧持续提交，突破1k+</p></blockquote><h2 id="我与CSDN"><a href="#我与CSDN" class="headerlink" title="我与CSDN"></a>我与CSDN</h2><p>今年3月份，我成功申请到了 csdn 博客专家荣誉称号，当时就写下了下面这篇文章：</p><p><a href="https://chocolate.blog.csdn.net/article/details/104837405">【长文总结】2020 从零到博客专家 过去的我，现在的我，将来的我</a></p><p>挺快的，这不，马上年底了，我又来了一篇总结性文章。</p><p>首先，我想感谢这个社区，从2018年10月份一时兴趣高涨，写下第一篇博客，当时还备注那篇博客（激发变成兴趣），到现在，2020年年底，已经来到社区三年了，这三年内，我几乎每个月都会创作文章，这个从我的文章归档里面就能看到。</p><p>同时，我自己都没想到已经累计写下了830+篇博文了，刚来社区的时候可能写了比较多的水文，文章的深度也不够，当然，也包括文章的质量，以及是否满足读者的阅读兴趣。我觉得通过写博客我的博客文笔也得到了变化与成长，从量变到质变的一个过程。也正因为这个，让我受益良多，我在面试过程中，多次提及了我在 <code>csdn</code> 平台的创作，面试官也对我表示赞扬，这让我在面试中属于一个加分项，同时简历也是可以写进去的。</p><p>其次，说说我对于这个社区的感谢之处，2018年，机缘巧合来到了这里，留下了足迹，尽管是一时兴起像打鸡血一样，然后就停止了写作，但2019年大二的寒假，我想着既然留下了足迹，那就要坚持下来，<code>从这三年时间来看，我确实做到了！</code></p><p>然后，在这个平台认识了一些大佬，许多学弟学妹包括老师们还是我的粉丝，这让我有一些成就感，说到粉丝，我觉得今年也算是一项突破吧，从年初达到100粉（当时为了达到100粉还特意让班上同学悄悄关注我嘿嘿），到现在3100+粉丝，我觉得明年又会有新的突破，总有一天会达到下一个目标：1万粉！</p><p>另外，我积极参与平台提供的活动，这不，现在就在准备着年度征文活动，犹记得过年那会，得到了一个一等奖，送了年度 <code>vip</code> ，这不现在有着 <code>vip</code> 身份了，同时后面在官方征集面试文章的博文下面留下自己写的面试总结，这让我获得了一本技术书籍，是关于 <code>Pyhon</code>爬虫从入门到精通。还有一个奖品呢，就是大家经常会用的：签到抽奖。这个我还真中了，原本以为这个签到抽奖几乎绝缘，没想到中到了一个哆啦A梦的水杯~</p><p>对于社区的优化与改进：</p><p>在2020年9月16日，运营成哥给了我一份调研，关于微社区—社区号的看法：</p><blockquote><p>社区号提供的运营功能和模块更强，除博客之外，还包括独立的社区、独立的资源列表、独立的视频、公开课和代码托管等模块功能。同时还提供针对社区号用户的推送、触达、活动报名等能力，未来还将提供更多的社区运营工具和能力</p></blockquote><p>当时，我就看到了代码托管这一块，因为大学阶段用的比较多的还是 <code>github</code> 和 码云，当时一惊的是平台也有了！诶，或许你也想知道，我就留下传送门咯，可以去体验体验~</p><p><a href="https://codechina.csdn.net/">https://codechina.csdn.net/</a></p><blockquote><p>这里我就不表述我的调研完整回答了，就简述一部分想法了：代码托管还是挺好的，可以将文字与项目进行整合，让更多人看到，对于社区的话，我提到了激励政策，对于运营自己的社区，可以提供等级或者活跃度，到达一定等级或者活跃度了，有一定的奖励，比如粉丝达到多少，会有专属创作者牌牌，然后还提及了关于论坛优化和资源分享方面。</p></blockquote><p>最后，成哥反馈了一个暖心的回答，毕竟我也使用了这么久了，每天都必须刷一刷的，简直就是 <code>CSDN</code> 重度使用者了哈哈哈~</p><p>总结：</p><p>2020年，我目睹了CSDN成长的变化，比如总部迁移到长沙，人才回乡策略，还有是不是今年才开始弄的：重构了后台代码，采用 <code>Vue</code> 重构（因为现在一打开后台管理页面，<code>vue</code>小插件就会高亮，如下所示）同样，后台数据也用了<code>Echarts</code> 图表简单美观地给使用者展示可视化数据，方便博主。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/2020122916554623.png" alt=""></p><p>同时，在平台首页，课程排版及样式也得到了优化，以及手机<code>app</code>应用也更新了许多次，这说明在成长，越来越好。</p><p>这是我与 <code>CSDN</code> 的第三年，未来我依旧不忘初心，与平台一同前行，见证我与平台的第一个十年！<code>CSDN</code>在成长，我也要持续学习跟进！</p><h2 id="前端学习总结"><a href="#前端学习总结" class="headerlink" title="前端学习总结"></a>前端学习总结</h2><p>年初，决定了要走前端，觉得自己当初的选择还算可以，春招阶段也找到了实习，秋招也收获了不错的 offer，现在分享一下自己总结的学习路线：</p><p><a href="https://yangchaoyi.vip/posts/2021520/">https://yangchaoyi.vip/posts/2021520/</a></p><p>很多小伙伴们以及学弟学妹们都来私信我，询问我前端是怎么学习的，想了又想，还是打算写一份自己的前端学习路线，至于为什么要写这一份前端学习路线呢？我觉得有如下几点：</p><ul><li>春招以及秋招过程受很多大佬的教导，最终的offer离不开他们的支持，我想着自己受到过许多人的帮助，而自己写一份学习路线，也是一份 <strong>回馈</strong>。</li><li><strong>很早就想</strong>写一份学习路线图，但整个秋招下来又让我停止了脚步，我觉得还是要继续扎实基础，但现在，我<strong>有了时间</strong>来输出一些文章，因此，这篇文章它来了！</li><li>临近毕业，有许多不舍，我也想留下一些有价值的东西，那就是将自己学习过程中的坑埋住，少走我的坑，让学弟学妹们看到后能有一份<strong>指导</strong>路线。</li><li>一份<strong>挑战</strong>，我也在带人学习，她会参加2021年春招，这份学习路线基本上就是我教导的学习路线，因此即是一份学习路线，也是一份挑战，并且这份路线是会<strong>持续更新</strong>到2021年春招结束。</li><li>座右铭：<strong>学如逆水行舟，不进则退！</strong>  我也在征途中<strong>重温基础知识</strong>，为后续工作做准备。</li></ul><blockquote><p>简简单单，主要就是如上五点了，一些关键理由已经加粗标记啦~</p></blockquote><p>关于技术栈方面的话，年初主要还是学习 <code>Vue</code> 为主，到秋招阶段，已经学习了 <code>Vue</code> 相关源码，同时也学习了 <code>React</code> 和 <code>TS</code>，这些未来工作中我都会需要使用到。</p><p>一提到技术栈这一块，想到有伙伴问过我这个问题：</p><blockquote><p>其它像react这种框架，还有flutter、element这种目前框架中没用到的技术是不是不急着<br>学？</p></blockquote><blockquote><p>我仅代表我个人建议，你觉得你的观点是对的，那就是对的，我不会有任何意见。</p></blockquote><p>前端框架确实也很多，这个也要看自己想学的技术栈和意向公司的招聘信息，比如想去的公司，例如字节跳动，腾讯这些，我觉得学会react在面试中会有更大优势。其次，我觉得这些框架只是一个我们前端工程师使用的工具而已，不管是现在主流的vue还是react框架，说不定未来又有新的框架出来。真正体现前端人能力的还是js能力，js基本功扎实，我觉得这些框架学起来都挺快的，所以不必都学，例如大家可能都在学习vue，那么与一般人的能力差距就在于有没有读过源码，能清晰地分析讲解其中源码实现，这对于面试是一个加分项，也可以作为自己的杀手锏，其实vue源码看了一些了，会发现学习react也不是很难，没有大家所说的react就很难学，这些都只是一个工具而已。综上，如果目前在学的是vue的话，那就往底层学一点，如果已经在学react，也可以去了解一些源码，例如react-fiber，然后讲清楚redux工作流等等。</p><blockquote><p>在这里，我仅发表我自己的观点与想法，如若与你的不同，请 <code>海纳百川有容乃大</code>。当然，你也可以评论提出你自己的观点</p></blockquote><h2 id="2021年のFlag"><a href="#2021年のFlag" class="headerlink" title="2021年のFlag"></a>2021年のFlag</h2><blockquote><p>2020年尽管过的很快，但一回顾下来，还是经历了挺多事情，收获了许多。</p></blockquote><p>2021年，牛气冲天的一年，在此立下新的 <code>Flag</code>：</p><ul><li><input disabled="" type="checkbox"> CSDN发表文章破1K+</li><li><input disabled="" type="checkbox"> CSDN粉丝数突破5000+</li><li><input disabled="" type="checkbox"> 系统学习TS，学习React源码</li><li><input disabled="" type="checkbox"> 公众号：小狮子前端 突破2K+粉丝</li><li><input disabled="" type="checkbox"> 好好工作，好好生活，开心快乐</li><li><input disabled="" type="checkbox"> 成为一名优秀前端博主</li><li><input disabled="" type="checkbox"> 学会剪辑</li><li><input disabled="" type="checkbox"> 开始进行视频创作，出前端学习专栏视频</li><li><input disabled="" type="checkbox"> 完成前端学习路线总结</li><li><input disabled="" type="checkbox"> 生活与她</li><li><input disabled="" type="checkbox"> …</li></ul><blockquote><p>2021即将开启，我们的征途是星辰大海！</p></blockquote><p>【作者：Chocolate <a href="https://chocolate.blog.csdn.net/">https://chocolate.blog.csdn.net/</a>】</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">学如逆水行舟，不进则退</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chocolate </tag>
            
            <tag> 年度总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「斑愿称为最肝」小狮子前端知识食谱 / 生日之际，好运分享 / 秋招和你手摸手入大厂【史上最全指北】</title>
      <link href="posts/2020812/"/>
      <url>posts/2020812/</url>
      
        <content type="html"><![CDATA[<section id="nice" data-tool="mdnice编辑器" data-website="https://www.mdnice.com" style="font-size: 16px; color: black; padding: 0 10px; word-spacing: 0px; word-break: break-word; word-wrap: break-word; text-align: left; line-height: 1.25; font-family: Optima-Regular, Optima, PingFangTC-Light, PingFangSC-light, PingFangTC-light; letter-spacing: 2px; background-image: linear-gradient(90deg, rgba(50, 0, 0, 0.05) 3%, rgba(0, 0, 0, 0) 3%), linear-gradient(360deg, rgba(50, 0, 0, 0.05) 3%, rgba(0, 0, 0, 0) 3%); background-size: 20px 20px; background-position: center center;"><figure data-tool="mdnice编辑器" style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex; flex-direction: column; justify-content: center; align-items: center;"><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/2020081022085286.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70#pic_center" alt style="max-width: 100%; border-radius: 6px; display: block; margin: 20px auto; object-fit: contain; box-shadow: 2px 4px 7px #999;"></figure><h2 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; text-align: left; margin: 20px 10px 0px 0px;"><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 18px; font-weight: bold; display: inline-block; padding-left: 10px; border-left: 5px solid #916dd5;">生日之际，记录自己前端拼搏之路~</span><span class="suffix"></span></h2><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;">2020年8月12日，破壳的一天，<strong style="color: #916dd5; font-weight: bold;"><span>「</span>小狮子の21岁<span>」</span></strong>。特意在前一周准备了这篇博文，记录自己前端拼搏之路。此外，也入驻了掘金社区，发现了许多优秀前端博主，他们的文章内容输出都非常精致，我觉得有必要好好学习一下。</p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;">下文会有一部分自己感想，如果大家想要看干货的话，不妨跳到正文处阅读即可。其余部分闲暇时间阅读一下也是不错的嗷。</p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;"><strong style="color: #916dd5; font-weight: bold;"><span>「</span>生日愿望<span>」</span></strong>：希望拿到一个满意的 offer ，成为一个优秀的前端博主！</p><blockquote data-tool="mdnice编辑器" style="display: block; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; border-left: 3px solid rgba(0, 0, 0, 0.4); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; border-left-color: #d89cf6; background: #f4eeff;"><p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px; margin: 0px; color: black; line-height: 26px;">秋招在即，经过反复思考之后，我想到了一个提高效率的方式。原本的话，我可能会从头开始又把前端分模块复习一遍，但是这样效率不是很高，也 Get 不到重要部分，往往时间周期会比较长。本次呢，我打算采用面经复习法，将别人的面经整理一份知识点来学习。这样既能检测自己会不会这道题，同时也跟着大家步伐更新，个人觉得也是一个事半功倍的方式。</p></blockquote><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;">赶快来关注我吧，接下来的几个月里，我们一起逆风微笑，乘风破浪！</p><h2 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; text-align: left; margin: 20px 10px 0px 0px;"><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 18px; font-weight: bold; display: inline-block; padding-left: 10px; border-left: 5px solid #916dd5;">过去几个月的我</span><span class="suffix"></span></h2><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;">大家好，我是 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #916dd5; font-weight: bolder; background: none;">Chocolate</code>，一个不是只会写业务代码的前端攻城狮（我的文章里有我的故事，所以你要带酒来倾听吗？）</p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;">2020年刚开始的时候，正是疫情蔓延的时候，起初作为学生党的我，丝毫没感觉有啥变化。但当事情变的越来越糟糕时，我又不得不认识到严重性。学校停止开学，封闭在家中没办法出门，各大城市都开始封城...虽然说过年的氛围一年不如一年了，但今年连团聚的机会都没有了。但疫情对我生活的影响也不算很大，毕竟我就很宅... 在家里，我依旧保持着学校的状态，每天都会有固定时间学习。</p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;">大学期间，学习了很多课程，计算机网络，Java，操作系统，数据库，网络安全，物联网，数电，模电，电路分析，甚至还有医学类课程，心理学课程等等。但是前端方面，学校就简单教了 Web，内容都是好几年前的了。正如一句话说：<strong style="color: #916dd5; font-weight: bold;"><span>「</span>师傅引进门，修行靠个人。<span>」</span></strong></p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;">在了解前端后，我决定不走 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #916dd5; font-weight: bolder; background: none;">Java</code>方向了，于是在2月份就开始了我的春招找实习之路了，大家可以随心阅读，里面有我整理的一些优质笔记，这里我就不再赘述了。</p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;"><a href="https://yangchaoyi.vip/posts/520521/" style="text-decoration: none; word-wrap: break-word; color: #916dd5; font-weight: bolder; border-bottom: 1px solid #916dd5;">【春招&amp;实习&amp;秋招】前端学习の优质资料整理&amp;心路历程</a></p><h3 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; color: black; font-size: 16px; font-weight: bold; text-align: center;"><span class="prefix" style="display: none;"></span><span class="content" style="border-bottom: 2px solid #d89cf6;">博客专家之路</span><span class="suffix" style="display: none;"></span></h3><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;">3月份，我成功在 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #916dd5; font-weight: bolder; background: none;">CSDN</code> 平台获得了 <strong style="color: #916dd5; font-weight: bold;"><span>「</span>博客专家<span>」</span></strong> 的称号，两年了，也算是一波小丰收了，看到了坚持的美好。并且这两年的写博客让我养成了习惯，每个自然月我都会出产许多篇博客。</p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;"><a href="https://chocolate.blog.csdn.net/article/details/104837405" style="text-decoration: none; word-wrap: break-word; color: #916dd5; font-weight: bolder; border-bottom: 1px solid #916dd5;">【长文总结】2020 从零到博客专家 过去的我，现在的我，将来的我</a></p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;">到现在，经常看我博客的伙伴可能会发现，我的文章内容越来越丰富了，动不动一篇就是好几w字。个人觉得书写的还是有一定深度的，这一点自信还是有的。至于原因呢，我觉得可以吸取一下<a href="https://juejin.im/post/5e7d4e8b6fb9a03c6422f112" style="text-decoration: none; word-wrap: break-word; color: #916dd5; font-weight: bolder; border-bottom: 1px solid #916dd5;"> <strong style="color: #916dd5; font-weight: bold;"><span>「</span>@神三元大佬<span>」</span></strong></a> 的经验：</p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;">谁的人生不是这么误打误撞过来的呢？那你可能就会问了，你凭什么能够把基础学的那么扎实，通过这些大厂的面试呢？</p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;">我觉得有两点，一点是 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #916dd5; font-weight: bolder; background: none;">外在</code> 的因素，一点是 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #916dd5; font-weight: bolder; background: none;">内在</code> 的因素。</p><blockquote data-tool="mdnice编辑器" style="display: block; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; border-left: 3px solid rgba(0, 0, 0, 0.4); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; border-left-color: #d89cf6; background: #f4eeff;"><p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px; margin: 0px; color: black; line-height: 26px;">对外在的方面，我在输入一些信息的同时，会加入自己的思考和推敲，然后用自己的方式来输出，整理成博客，这使得我能够对知识体系本身有更加深刻的理解，同时也能在忘记这部分知识点之后，重新回顾的时候能够很快捡起来，节省了非常多复习的时间。</p></blockquote><blockquote data-tool="mdnice编辑器" style="display: block; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; border-left: 3px solid rgba(0, 0, 0, 0.4); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; border-left-color: #d89cf6; background: #f4eeff;"><p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px; margin: 0px; color: black; line-height: 26px;">对内在的方面，我觉得自驱力是一个比较重要的因素，即自己驱动自己学习的能力。其实说起来容易，做起来是非常难的，因为外界的诱惑实在是太多，而且学习本身就是脱离舒适区的活动，是一种反人性的活动，本身就是让人不舒服的，因此很多人不愿意主动学习，这是完全可以理解的。那我为什么会有这种强烈的自驱力呢？因为危机感，危机感随之带来了恐惧。</p></blockquote><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;">为什么这么说？</p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;">以前听《得到》APP上的梁宁老师讲过，人性其实只有两大痛点: 一个是愉悦，一个是恐惧。 <strong style="color: #916dd5; font-weight: bold;"><span>「</span>愉悦感可以让人沉浸在一件事情当中干一万小时，成为高手，而恐惧带来的动力更加显著。<span>」</span></strong> 对产品来说，要么就让用户爆爽，要么就去帮助他抵御恐惧，否则就不是一个优秀的产品。那么对于个人的成长而言，你做一件事情，没有找到任何愉悦的感觉，也没有产生过任何恐惧，那么他基本上在这个领域一事无成。换句话说，<strong style="color: #916dd5; font-weight: bold;"><span>「</span>如果一件事情让你非常疯狂地去做，要么这件事让你爆爽，要么它帮助你抵御恐惧。<span>」</span></strong></p><blockquote data-tool="mdnice编辑器" style="display: block; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; border-left: 3px solid rgba(0, 0, 0, 0.4); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; border-left-color: #d89cf6; background: #f4eeff;"><p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px; margin: 0px; color: black; line-height: 26px;">对我来讲，真正驱动我的是后者。危机意识让我挖掘出真正的痛点，发现自己的恐惧所在，从而带来强大的自驱力。如果说仅仅是学一些东西来炫耀一番，或者只是去迎合外界的期望，这种动力可以有，但仅仅只是暂时的。当你走出舒适区，面对外界无数诱惑的时候，真正能 carry 你继续学习的是你内心的痛点。</p></blockquote><blockquote data-tool="mdnice编辑器" style="display: block; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; border-left: 3px solid rgba(0, 0, 0, 0.4); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; border-left-color: #d89cf6; background: #f4eeff;"><p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px; margin: 0px; color: black; line-height: 26px;">我觉得明白这一点，比所谓的学习路径、学习方法重要得多。因为大多数时候我们不是缺少学习资料，或者没有掌握什么高效的学习方法，只是因为你动力不足、容易懈怠罢了。每个人情况都各不相同，但我觉得想要成长，挖掘自己真正的痛点是最重要的一件事情。</p></blockquote><h3 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; color: black; font-size: 16px; font-weight: bold; text-align: center;"><span class="prefix" style="display: none;"></span><span class="content" style="border-bottom: 2px solid #d89cf6;">阶段性反馈机制</span><span class="suffix" style="display: none;"></span></h3><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;">现在8月份了，正是秋招旺季，各大厂都开始招人了。这个模块是介绍过去几个月的我，那我还是先讲讲过去一点事吧。在找到一份个人觉得还不错的实习后，我开始有点懈怠了，尽管每天上班时间我会认认真真完成导师给我的任务。但是下班后以及周末，几乎不会动任何代码，也无心学习。在实习之前我给自己的目标就是边实习边准备秋招，周末阶段学习 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #916dd5; font-weight: bolder; background: none;">React</code> 。<strong style="color: #916dd5; font-weight: bold;"><span>「</span>人都是充满惰性的，而且学习本身就是脱离舒适区的活动，本身就不会让你觉的很舒服。<span>」</span></strong> 那为什么我们在打王者荣耀的时候，会发了疯地想要上分呢？这就要提到一个阶段性反馈机制了：</p><blockquote data-tool="mdnice编辑器" style="display: block; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; border-left: 3px solid rgba(0, 0, 0, 0.4); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; border-left-color: #d89cf6; background: #f4eeff;"><p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px; margin: 0px; color: black; line-height: 26px;">雷军曾经说：野心和执行力，才是一个人最核心的竞争力。一个被巨大野心驱动的人，会极度自律、昼度夜思、殚精竭虑、不知疲倦，因为他不是想赢，而是必须赢。</p></blockquote><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;">反馈机制拿玩王者荣耀举例子太好不过了，对于快节奏的手游，·打野刷完野怪能够获得金币，尤其是当你用很需要操作的英雄击杀对面之后，游戏带来的音效和画面刺激你的大脑，你想赢，也必须赢。这些都是小小的反馈，其次，当你一波上流操作，绝地翻盘带来的快感我想应该更加强烈，你甚至可以为此一天不休息，不疲劳的玩下去。</p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;">从此看来，奖励机制十分重要，所以如果想要努力的做一件事情，就要反复的告诉自己我如果做成功了，能得到什么？比如你爱看动漫，那你可以告诉自己，把这100个单词背完，奖励自己看一集动漫。这里我就想到 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #916dd5; font-weight: bolder; background: none;">英雄联盟</code>里的一个梗了，诶，<strong style="color: #916dd5; font-weight: bold;"><span>「</span>奖励自己一把亚索！<span>」</span></strong> 这句话一出，我想你对反馈机制有了更加深入的了解了，因此，我们在某个小阶段，可以试试这个反馈机制，达成一个小目标给自己一点小奖励，然后不断刷新自己的目标，这样总比刷一天手机，然后感叹一天啥事也没干好很多。至于我们是否能得到最终的结果不重要，而是你在这个努力的过程，潜移默化的形成了一个优秀的习惯！</p><h3 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; color: black; font-size: 16px; font-weight: bold; text-align: center;"><span class="prefix" style="display: none;"></span><span class="content" style="border-bottom: 2px solid #d89cf6;">疫情是恋爱的照明弹</span><span class="suffix" style="display: none;"></span></h3><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;">这个我也是逛了许多博主体会到的，而我自己也是其中一员。作为一个程序员来说，我不擅长写作，但一直觉得自己挺重感情的，每一段感情经历过后，我都需要很久很久才能恢复日常状态。原本看着身边有人发着说说分手了，我没太多在意，甚至有点想笑，在校期间都好好的，为啥还能在网恋的过程中分开了...</p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;">世界就是这样，永远不要笑别人，因为保不准那天你就成了故事里的主人公，成为了被笑的那个。</p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;">没错，我也终究成为了那一个。分手后一段时间内我一直不敢相信这件事，想要试着挽回，但是很明显的体会到有一层冰山一样阻隔。</p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;">这段时间我咆哮过，低沉过，不甘过，不过一切就像 <a href="https://movie.douban.com/subject/1485260/" style="text-decoration: none; word-wrap: break-word; color: #916dd5; font-weight: bolder; border-bottom: 1px solid #916dd5;">本杰明巴顿奇事</a> 里面说的一样：</p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;"><strong style="color: #916dd5; font-weight: bold;"><span>「</span>你可以像疯狗一样对周围一切愤愤不平，可以疯狂咆哮诅咒命运，但到最后一刻，你还得平静的放手而去。<span>」</span></strong></p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;">人生很长，我们要向前看，不能因为某些事一直消沉下去，过去的事，就让它过去。</p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;">我一直觉得，当你在某一方面做的足够好的时候，在其它方面总会有一定缺点，正如一个人总不会是完美的一样。</p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;">最近在看《二十不惑》，其中就有说到：我曾以为自己遇到了命中注定，现在才发现，原来命中是骗局，错过是注定。只是生活多么的奇妙莫测啊，我们永远不会知道，那些命中注定的发生，会把我们带往何地。</p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;">是啊，生活就是这样奇妙莫测，不知道下一秒会发生什么，你笑的别人，或许之后你就成为了故事里的主人公，成为了被笑的那个。关于感情经历，我也不想提及太多，我既然写出来了，代表已经坦荡了，调整好了自己的心态。再者，也不想因为这个让各位博友们看的很压抑，毕竟要传播正能量嘛。</p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;">亚科斯说：<strong style="color: #916dd5; font-weight: bold;"><span>「</span>“我们人生中90%的不幸，都是因为不甘心引起的。”<span>」</span></strong>及时止损是成年人情感中最高标准的自律。</p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;">及时止损和坚持并不冲突，真正的坚持，不是盲目做一件事情，而是及时放弃，调整和取舍。只有这样，人才会在正确的路上越走越远，越行越宽。止损是为了更好地前行，它决定了个人或者企业能否站得更高，走得更远，所以，不懂得止损，不足以谈坚持。（摘自：<a href="https://baijiahao.baidu.com/s?id=1609490526664892548&amp;wfr=spider&amp;for=pc" style="text-decoration: none; word-wrap: break-word; color: #916dd5; font-weight: bolder; border-bottom: 1px solid #916dd5;">懂得及时止损的人，活得更高级</a>）</p><h2 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; text-align: left; margin: 20px 10px 0px 0px;"><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 18px; font-weight: bold; display: inline-block; padding-left: 10px; border-left: 5px solid #916dd5;">成为大人最重要的前提，是阅历</span><span class="suffix"></span></h2><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;">《令人心动的offer》里，papi酱说自己大学毕业后，非常急于摆脱<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #916dd5; font-weight: bolder; background: none;">“学生”</code>的身份，想让别人都承认，自己已经是个大人、社会人了。而社会人的标志就是喝酒。她就总会在饭局上豪饮，一副千杯不醉见过世面的样子，最后趴在马桶边狂吐。</p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;">等到不知不觉真成了大人才发现： <strong style="color: #916dd5; font-weight: bold;"><span>「</span>大人的世界，可比酒苦多了。<span>」</span></strong></p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;">长大就是一座围城，里面的人想出来，外面的人想进去。</p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;">20多岁，现实分界线的年纪。</p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;">现实不是坏事，可丢了从前的热情，是坏事。</p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;">你们应该也听过那句话吧？</p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;">“你要做一个不动声色的大人了，不准情绪化，不准偷偷想念，不准回头看。”</p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;">以前觉得这种克制隐忍的腔调很酷，可岁数越大越发现，逼自己长大，本身就是一个假命题。</p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;">成为大人最重要的前提，是<strong style="color: #916dd5; font-weight: bold;"><span>「</span>阅历<span>」</span></strong>。</p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;">是经历生活砸过来的所有意外，它早晚都会来，你想不接着都不行。</p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;">在没来的时候就早早地逼自己克制，心动时矜持，爆炸时忍耐，装也装不像，图什么呀。</p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;"><strong style="color: #916dd5; font-weight: bold;"><span>「</span>该懂的道理你早晚会懂，该失去的冲动幼稚，你终究都会失去。<span>」</span></strong></p><figure data-tool="mdnice编辑器" style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex; flex-direction: column; justify-content: center; align-items: center;"><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200713163008152.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt style="max-width: 100%; border-radius: 6px; display: block; margin: 20px auto; object-fit: contain; box-shadow: 2px 4px 7px #999;"></figure><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;">早晚有一天，你不会再为婚礼上的神仙爱情流泪，而是去关注婚房地段，婚车排场，婚戒牌子，还有现场布置的到底是真花还是仿花。</p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;">早晚有一天，你会觉得“有情饮水饱”就是放屁，你会坚信贫贱夫妻百事哀，明里暗里关注对方的家境，为那些还敢裸婚私奔的小姑娘叹气。</p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;">你会在短短几年内，否定自己年少时的做派，打着更成熟和现实的名义，一天又一天地被削掉锐气。</p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;">我说真的，你别不信。</p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;">没有人是迪士尼小公主，也没有国王爸爸和白马王子十年如一日地护我们周全。</p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;">你我终将要靠自己，顶天立地。</p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;">到那时，也许你就不会再后悔，年轻时丢过面子，跌过跟头，你只会后悔浪费了时间和锐气。</p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;">说真的，如果还来得及，你可以不用逼自己。</p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;">踢掉高跟鞋，想扎双马尾就扎，喝醉了给喜欢的人打电话，心情不爽就在朋友圈骂人；</p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;">你可以不用假装高情商，很懂人情交际；</p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;">你可以心安理得地说啤酒就是不如可乐好喝；</p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;">大大方方承认那些高逼格的纪录片你没看过；</p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;">幼稚就幼稚吧，还能幼稚几天啊。</p><blockquote data-tool="mdnice编辑器" style="display: block; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; border-left: 3px solid rgba(0, 0, 0, 0.4); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; border-left-color: #d89cf6; background: #f4eeff;"><p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px; margin: 0px; color: black; line-height: 26px;">每个人有自己的时区，不用着急，也不用可惜。以上是我最近看到的，也许就是那么一个时刻，正好读到了这里，发现了不一样的风景，也正好与目前自己处境想法相同。于是就存档一下，以后还能翻阅一下~</p></blockquote><h2 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; text-align: left; margin: 20px 10px 0px 0px;"><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 18px; font-weight: bold; display: inline-block; padding-left: 10px; border-left: 5px solid #916dd5;">正文</span><span class="suffix"></span></h2><blockquote data-tool="mdnice编辑器" style="display: block; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; border-left: 3px solid rgba(0, 0, 0, 0.4); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; border-left-color: #d89cf6; background: #f4eeff;"><p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px; margin: 0px; color: black; line-height: 26px;">不管你是跳转过来，直接来到这里，还是阅读过上文后过来的。接下来，我会整理前端学习知识，让我们一起手摸手的努力~</p></blockquote><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;"><a href="https://github.com/Chocolate1999/Front-end-learning-to-organize-notes" style="text-decoration: none; word-wrap: break-word; color: #916dd5; font-weight: bolder; border-bottom: 1px solid #916dd5;"> 前端笔记Github仓库在这里！</a></p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;"><strong style="color: #916dd5; font-weight: bold;"><span>「</span>危机意识能挖掘出自己真正的痛点，发现自己的恐惧所在，从而带来强大的自驱力。<span>」</span></strong></p><figure data-tool="mdnice编辑器" style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex; flex-direction: column; justify-content: center; align-items: center;"><img src= "/img/loading.gif" data-lazy-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL2Nob2NvbGF0ZTE5OTkvY2RuL2ltZy8yMDIwMDYyOTE3MTMyNC5qcGc?x-oss-process=image/format,png" alt style="max-width: 100%; border-radius: 6px; display: block; margin: 20px auto; object-fit: contain; box-shadow: 2px 4px 7px #999;"></figure><h2 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; text-align: left; margin: 20px 10px 0px 0px;"><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 18px; font-weight: bold; display: inline-block; padding-left: 10px; border-left: 5px solid #916dd5;">CSS篇</span><span class="suffix"></span></h2><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;"><a href="https://juejin.im/post/5da282015188257d2a1c9e1d" style="text-decoration: none; word-wrap: break-word; color: #916dd5; font-weight: bolder; border-bottom: 1px solid #916dd5;">神三元：剖析一些经典的CSS布局问题，为前端开发+面试保驾护航</a></p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;"><a href="https://yangchaoyi.vip/posts/2055211/" style="text-decoration: none; word-wrap: break-word; color: #916dd5; font-weight: bolder; border-bottom: 1px solid #916dd5;">超逸の博客：前端知识梳理之CSS篇</a></p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;"><a href="https://juejin.im/post/5a957bcf6fb9a0635b535812" style="text-decoration: none; word-wrap: break-word; color: #916dd5; font-weight: bolder; border-bottom: 1px solid #916dd5;">CodeDeer：纯CSS画三角原理解析</a></p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;"><a href="https://juejin.im/post/5d4d0ec651882549594e7293" style="text-decoration: none; word-wrap: break-word; color: #916dd5; font-weight: bolder; border-bottom: 1px solid #916dd5;">JowayYoung：灵活运用CSS开发技巧</a></p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;"><a href="https://juejin.im/post/5c8322a9e51d452fee00b70f" style="text-decoration: none; word-wrap: break-word; color: #916dd5; font-weight: bolder; border-bottom: 1px solid #916dd5;">大志前端：【前端帮帮忙】第4期 使用纯CSS制作一个开关按钮</a></p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;"><a href="https://codepen.io/chocolate1999/pen/eYJvOwz" style="text-decoration: none; word-wrap: break-word; color: #916dd5; font-weight: bolder; border-bottom: 1px solid #916dd5;">Chocolate：CSS制作开关按钮源码（演示）</a></p><h2 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; text-align: left; margin: 20px 10px 0px 0px;"><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 18px; font-weight: bold; display: inline-block; padding-left: 10px; border-left: 5px solid #916dd5;">JS篇</span><span class="suffix"></span></h2><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;"><a href="https://juejin.im/entry/589be5b1b123db16a3bec5c2" style="text-decoration: none; word-wrap: break-word; color: #916dd5; font-weight: bolder; border-bottom: 1px solid #916dd5;">追梦子：彻底理解 JS 中 this 的指向</a></p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;"><a href="https://www.cnblogs.com/pssp/p/5215621.html" style="text-decoration: none; word-wrap: break-word; color: #916dd5; font-weight: bolder; border-bottom: 1px solid #916dd5;">追梦子：JavaScript中call,apply,bind方法的总结</a></p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;"><a href="https://github.com/lydiahallie/javascript-questions/blob/master/zh-CN/README-zh_CN.md" style="text-decoration: none; word-wrap: break-word; color: #916dd5; font-weight: bolder; border-bottom: 1px solid #916dd5;">JavaScript 进阶问题列表（测测你有多了解 javascript）</a></p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;"><a href="https://juejin.im/post/5ebb68796fb9a0435432df8e" style="text-decoration: none; word-wrap: break-word; color: #916dd5; font-weight: bolder; border-bottom: 1px solid #916dd5;">金色小芝麻：想自学JS吗？想提升JS底层原理吗？76张脑图带你彻底搞懂原生JS</a></p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;"><a href="https://juejin.im/post/6845166891376312333" style="text-decoration: none; word-wrap: break-word; color: #916dd5; font-weight: bolder; border-bottom: 1px solid #916dd5;">前端小智：周末学会了 10个超级实用 Javascript 技巧!</a></p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;"><a href="https://juejin.im/post/6846687584710557710" style="text-decoration: none; word-wrap: break-word; color: #916dd5; font-weight: bolder; border-bottom: 1px solid #916dd5;">pingan8787：1.2w字 ｜ 初中级前端 JavaScript 自测清单 - 1</a></p><h2 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; text-align: left; margin: 20px 10px 0px 0px;"><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 18px; font-weight: bold; display: inline-block; padding-left: 10px; border-left: 5px solid #916dd5;">ES6-ES10篇</span><span class="suffix"></span></h2><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;"><a href="https://juejin.im/post/5c7e6ccbe51d4541e479db21" style="text-decoration: none; word-wrap: break-word; color: #916dd5; font-weight: bolder; border-bottom: 1px solid #916dd5;">榴莲布丁:【ES6基础】 Map用法总结</a></p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;"><a href="https://juejin.im/post/5dfa5cb86fb9a0165721db1d" style="text-decoration: none; word-wrap: break-word; color: #916dd5; font-weight: bolder; border-bottom: 1px solid #916dd5;">陈大鱼头：从ES6到ES10的新特性万字大总结（不得不收藏）</a></p><h2 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; text-align: left; margin: 20px 10px 0px 0px;"><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 18px; font-weight: bold; display: inline-block; padding-left: 10px; border-left: 5px solid #916dd5;">虚拟DOM（diff算法）</span><span class="suffix"></span></h2><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;"><a href="https://juejin.im/post/5e7ac6365188255de700f7ed" style="text-decoration: none; word-wrap: break-word; color: #916dd5; font-weight: bolder; border-bottom: 1px solid #916dd5;">txm：大厂面试官：请阐述一下你对虚拟DOM和Dom-Diff的理解？</a></p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;"><a href="https://juejin.im/post/5c4a76b4e51d4526e57da225#heading-0" style="text-decoration: none; word-wrap: break-word; color: #916dd5; font-weight: bolder; border-bottom: 1px solid #916dd5;">noobakong：虚拟DOM和Diff算法 - 入门级</a></p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;"><a href="https://juejin.im/post/5d5ffad2518825258a772fa8" style="text-decoration: none; word-wrap: break-word; color: #916dd5; font-weight: bolder; border-bottom: 1px solid #916dd5;">vdk：Vue中的虚拟DOM及diff算法</a></p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;"><a href="https://juejin.im/post/5eac3babf265da7bcd5c4d8b#heading-0" style="text-decoration: none; word-wrap: break-word; color: #916dd5; font-weight: bolder; border-bottom: 1px solid #916dd5;">小小晴:【React】深入理解虚拟dom和diff算法</a></p><h2 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; text-align: left; margin: 20px 10px 0px 0px;"><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 18px; font-weight: bold; display: inline-block; padding-left: 10px; border-left: 5px solid #916dd5;">Node.js篇</span><span class="suffix"></span></h2><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;"><a href="https://www.nodejs.red/#/" style="text-decoration: none; word-wrap: break-word; color: #916dd5; font-weight: bolder; border-bottom: 1px solid #916dd5;">Node.js技术栈</a></p><h2 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; text-align: left; margin: 20px 10px 0px 0px;"><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 18px; font-weight: bold; display: inline-block; padding-left: 10px; border-left: 5px solid #916dd5;">计算机网络篇</span><span class="suffix"></span></h2><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;"><a href="https://juejin.im/post/5e76bd516fb9a07cce750746" style="text-decoration: none; word-wrap: break-word; color: #916dd5; font-weight: bolder; border-bottom: 1px solid #916dd5;">神三元：(建议精读）HTTP灵魂之问，巩固你的 HTTP 知识体系</a></p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;"><a href="https://juejin.im/post/5e527c58e51d4526c654bf41" style="text-decoration: none; word-wrap: break-word; color: #916dd5; font-weight: bolder; border-bottom: 1px solid #916dd5;">神三元：(建议收藏）TCP协议灵魂之问，巩固你的网路底层基础</a></p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;"><a href="https://juejin.im/post/5ca6a109e51d4544e27e3048" style="text-decoration: none; word-wrap: break-word; color: #916dd5; font-weight: bolder; border-bottom: 1px solid #916dd5;">浪里行舟：深入理解HTTPS工作原理</a></p><h2 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; text-align: left; margin: 20px 10px 0px 0px;"><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 18px; font-weight: bold; display: inline-block; padding-left: 10px; border-left: 5px solid #916dd5;">浏览器篇</span><span class="suffix"></span></h2><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;"><a href="https://juejin.im/post/5df5bcea6fb9a016091def69#heading-25" style="text-decoration: none; word-wrap: break-word; color: #916dd5; font-weight: bolder; border-bottom: 1px solid #916dd5;">神三元：(1.6w字）浏览器灵魂之问，请问你能接得住几个？</a></p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;"><a href="https://juejin.im/post/5b1cebece51d4506ae71addf" style="text-decoration: none; word-wrap: break-word; color: #916dd5; font-weight: bolder; border-bottom: 1px solid #916dd5;">浪里行舟：Ajax原理一篇就够了</a></p><h2 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; text-align: left; margin: 20px 10px 0px 0px;"><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 18px; font-weight: bold; display: inline-block; padding-left: 10px; border-left: 5px solid #916dd5;">数据结构与算法篇</span><span class="suffix"></span></h2><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;"><a href="http://www.conardli.top/docs/dataStructure/" style="text-decoration: none; word-wrap: break-word; color: #916dd5; font-weight: bolder; border-bottom: 1px solid #916dd5;">awesome-coding-js：用JS玩转数据结构与算法</a></p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;"><a href="http://scriptoj.mangojuice.top/problems?tag=%E7%BB%8F%E5%85%B8%E7%AC%94%E8%AF%95%E9%A2%98" style="text-decoration: none; word-wrap: break-word; color: #916dd5; font-weight: bolder; border-bottom: 1px solid #916dd5;">ScriptOJ：前端首个 Web 前端开发评测系统</a></p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;"><a href="https://juejin.im/post/5d5b307b5188253da24d3cd1" style="text-decoration: none; word-wrap: break-word; color: #916dd5; font-weight: bolder; border-bottom: 1px solid #916dd5;">ConardLi：前端该如何准备数据结构和算法？</a></p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;"><a href="https://github.com/trekhleb/javascript-algorithms/blob/master/README.zh-CN.md" style="text-decoration: none; word-wrap: break-word; color: #916dd5; font-weight: bolder; border-bottom: 1px solid #916dd5;">JavaScript 算法与数据结构</a></p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;"><a href="https://juejin.im/post/5ee6d9026fb9a047e60815f1" style="text-decoration: none; word-wrap: break-word; color: #916dd5; font-weight: bolder; border-bottom: 1px solid #916dd5;">晨曦时梦见兮：前端电商 sku 的全排列算法很难吗？学会这个套路，彻底掌握排列组合。</a></p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;"><a href="https://juejin.im/post/5e3d3f25e51d45270c276fe3" style="text-decoration: none; word-wrap: break-word; color: #916dd5; font-weight: bolder; border-bottom: 1px solid #916dd5;">Jay_huaxiao：看一遍就理解，图解单链表反转</a></p><h2 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; text-align: left; margin: 20px 10px 0px 0px;"><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 18px; font-weight: bold; display: inline-block; padding-left: 10px; border-left: 5px solid #916dd5;">Vue篇</span><span class="suffix"></span></h2><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;"><a href="https://juejin.im/post/5ee4965a6fb9a047dd27695a" style="text-decoration: none; word-wrap: break-word; color: #916dd5; font-weight: bolder; border-bottom: 1px solid #916dd5;">金色小芝麻：30张脑图带你从零开始学VUE｜VUE基础知识篇</a></p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;"><a href="https://juejin.im/post/5e1b37f6f265da3e51530a39" style="text-decoration: none; word-wrap: break-word; color: #916dd5; font-weight: bolder; border-bottom: 1px solid #916dd5;">小明同学哟：彻底理解Vue组件间通信(6种方式)</a></p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;"><a href="https://juejin.im/post/5cde0b43f265da03867e78d3" style="text-decoration: none; word-wrap: break-word; color: #916dd5; font-weight: bolder; border-bottom: 1px solid #916dd5;">浪里行舟：Vue 组件间通信六种方式（完整版）</a></p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;"><a href="https://juejin.im/post/5b82bcfcf265da4345153343#heading-33" style="text-decoration: none; word-wrap: break-word; color: #916dd5; font-weight: bolder; border-bottom: 1px solid #916dd5;">shotCat：可能比文档还详细--VueRouter完全指北</a></p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;"><a href="https://blog.csdn.net/qq_37816525/article/details/101261248" style="text-decoration: none; word-wrap: break-word; color: #916dd5; font-weight: bolder; border-bottom: 1px solid #916dd5;">柚子233：如何在一个页面使用多个router-view显示不同的内容</a></p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;"><a href="https://juejin.im/post/5ecb8d9b51882543034918fe" style="text-decoration: none; word-wrap: break-word; color: #916dd5; font-weight: bolder; border-bottom: 1px solid #916dd5;">一叶知秋666：vue-router 基本使用</a></p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;"><a href="https://juejin.im/post/5e89f867f265da47dd3982f8" style="text-decoration: none; word-wrap: break-word; color: #916dd5; font-weight: bolder; border-bottom: 1px solid #916dd5;">晨曦时梦见兮：请你说说 Vue 中 slot 和 slot-scope 的原理（2.6.11 深度解析）</a></p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;"><a href="https://juejin.im/post/5e88953b6fb9a03c4e6468a5" style="text-decoration: none; word-wrap: break-word; color: #916dd5; font-weight: bolder; border-bottom: 1px solid #916dd5;">晨曦时梦见兮：Vue 的生命周期之间到底做了什么事清？（源码详解，带你从头梳理组件化流程）</a></p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;"><a href="https://juejin.im/post/5e8694b75188257372503722" style="text-decoration: none; word-wrap: break-word; color: #916dd5; font-weight: bolder; border-bottom: 1px solid #916dd5;">晨曦时梦见兮：为什么 Vue 中不要用 index 作为 key？（diff 算法详解）</a></p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;"><a href="https://juejin.im/post/5e8dd5266fb9a03c703fb168" style="text-decoration: none; word-wrap: break-word; color: #916dd5; font-weight: bolder; border-bottom: 1px solid #916dd5;">晨曦时梦见兮：驳《前端常见的Vue面试题目汇总》</a></p><h2 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; text-align: left; margin: 20px 10px 0px 0px;"><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 18px; font-weight: bold; display: inline-block; padding-left: 10px; border-left: 5px solid #916dd5;">React篇</span><span class="suffix"></span></h2><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;"><a href="https://juejin.im/post/5eeb1fcdf265da02ec0bbf51" style="text-decoration: none; word-wrap: break-word; color: #916dd5; font-weight: bolder; border-bottom: 1px solid #916dd5;">wangly19：一天学习React入门后的千字基础总结</a></p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;"><a href="https://juejin.im/post/6844904021233238024" style="text-decoration: none; word-wrap: break-word; color: #916dd5; font-weight: bolder; border-bottom: 1px solid #916dd5;">秋天不落叶：你真的了解 React 生命周期吗</a></p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;"><a href="https://juejin.im/post/6844904205564526600" style="text-decoration: none; word-wrap: break-word; color: #916dd5; font-weight: bolder; border-bottom: 1px solid #916dd5;">卡颂：阿姨，React源码好难懂，我不想努力了</a></p><h2 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; text-align: left; margin: 20px 10px 0px 0px;"><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 18px; font-weight: bold; display: inline-block; padding-left: 10px; border-left: 5px solid #916dd5;">中间件</span><span class="suffix"></span></h2><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;"><a href="https://juejin.im/post/5e13ea6a6fb9a0482b297e8e" style="text-decoration: none; word-wrap: break-word; color: #916dd5; font-weight: bolder; border-bottom: 1px solid #916dd5;">晨曦时梦见兮：Koa的洋葱中间件，Redux的中间件，Axios的拦截器让你迷惑吗？实现一个精简版的就彻底搞懂了。</a></p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;"><a href="https://juejin.im/post/5e63479ae51d4526cb162bfc" style="text-decoration: none; word-wrap: break-word; color: #916dd5; font-weight: bolder; border-bottom: 1px solid #916dd5;">小畅叙：Koa2 简单入门</a></p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;"><a href="https://juejin.im/post/5c6eb4ac6fb9a049d4426ab2" style="text-decoration: none; word-wrap: break-word; color: #916dd5; font-weight: bolder; border-bottom: 1px solid #916dd5;">xiangzhihong：Koa2开发快速入门</a></p><h2 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; text-align: left; margin: 20px 10px 0px 0px;"><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 18px; font-weight: bold; display: inline-block; padding-left: 10px; border-left: 5px solid #916dd5;">源码篇（手撕原理）</span><span class="suffix"></span></h2><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;"><a href="https://mp.weixin.qq.com/s/jLe09cxuRI_10q95yePkiw" style="text-decoration: none; word-wrap: break-word; color: #916dd5; font-weight: bolder; border-bottom: 1px solid #916dd5;">小鹿动画学编程：动手实践去实现 Vue 2.0 的核心原理</a></p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;"><a href="https://blog.csdn.net/qq_36903042/article/details/106405688" style="text-decoration: none; word-wrap: break-word; color: #916dd5; font-weight: bolder; border-bottom: 1px solid #916dd5;">小鹿动画学编程：阿里面试官让我手写 Vue 2.0核心原理，我都整理好了！</a></p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;"><a href="https://juejin.im/post/5e77888ff265da57187c7278" style="text-decoration: none; word-wrap: break-word; color: #916dd5; font-weight: bolder; border-bottom: 1px solid #916dd5;">小明同学哟：手写源码系列</a></p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;"><a href="https://juejin.im/post/5e8153bf6fb9a03c840d509d#heading-22" style="text-decoration: none; word-wrap: break-word; color: #916dd5; font-weight: bolder; border-bottom: 1px solid #916dd5;">txm：面试时，你被要求手写常见原理了吗？</a></p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;"><a href="https://juejin.im/post/5d845ecdf265da03ce3a122f" style="text-decoration: none; word-wrap: break-word; color: #916dd5; font-weight: bolder; border-bottom: 1px solid #916dd5;">蓝莓圣代：手写jsonp实现原理</a></p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;"><a href="https://juejin.im/post/5e4d41025188254963275929" style="text-decoration: none; word-wrap: break-word; color: #916dd5; font-weight: bolder; border-bottom: 1px solid #916dd5;">迪迪同学：call, apply, bind 区别及原理</a></p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;"><a href="https://juejin.im/post/5e1b3144f265da3e4b5be2e3" style="text-decoration: none; word-wrap: break-word; color: #916dd5; font-weight: bolder; border-bottom: 1px solid #916dd5;">txm：手写一套完整的基于Vue的MVVM原理</a></p><h2 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; text-align: left; margin: 20px 10px 0px 0px;"><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 18px; font-weight: bold; display: inline-block; padding-left: 10px; border-left: 5px solid #916dd5;">Promise篇</span><span class="suffix"></span></h2><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;"><a href="https://juejin.im/post/5e2168626fb9a0300d619c9e" style="text-decoration: none; word-wrap: break-word; color: #916dd5; font-weight: bolder; border-bottom: 1px solid #916dd5;">小明同学哟：一步步教你实现Promise/A+ 规范 完整版</a></p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;"><a href="https://juejin.im/post/5ea6201de51d4546eb52660f#heading-15" style="text-decoration: none; word-wrap: break-word; color: #916dd5; font-weight: bolder; border-bottom: 1px solid #916dd5;">小明同学哟：Promise系列</a></p><h2 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; text-align: left; margin: 20px 10px 0px 0px;"><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 18px; font-weight: bold; display: inline-block; padding-left: 10px; border-left: 5px solid #916dd5;">优秀公众号推文</span><span class="suffix"></span></h2><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;"><a href="https://mp.weixin.qq.com/s/bHclDpsGdfaZQT8u9VRAAw" style="text-decoration: none; word-wrap: break-word; color: #916dd5; font-weight: bolder; border-bottom: 1px solid #916dd5;">前端瓶子君：前端面试基础题集合！赶紧上车！</a></p><h2 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; text-align: left; margin: 20px 10px 0px 0px;"><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 18px; font-weight: bold; display: inline-block; padding-left: 10px; border-left: 5px solid #916dd5;">前端面经大全</span><span class="suffix"></span></h2><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;"><a href="https://juejin.im/post/5e7d4e8b6fb9a03c6422f112#heading-8" style="text-decoration: none; word-wrap: break-word; color: #916dd5; font-weight: bolder; border-bottom: 1px solid #916dd5;">神三元：2020三元同学春招阿里淘系、阿里云、字节跳动面经 &amp; 个人成长经验分享 | 掘金技术征文</a></p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;"><a href="https://juejin.im/post/5eb55ceb6fb9a0436748297d" style="text-decoration: none; word-wrap: break-word; color: #916dd5; font-weight: bolder; border-bottom: 1px solid #916dd5;">LinDaiDai_霖呆呆：霖呆呆的近期面试128题汇总(含超详细答案) | 掘金技术征文</a></p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;"><a href="https://juejin.im/post/5d87985d6fb9a06add4e6ac3" style="text-decoration: none; word-wrap: break-word; color: #916dd5; font-weight: bolder; border-bottom: 1px solid #916dd5;">小明同学哟：初中级前端面试题</a></p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;"><a href="https://juejin.im/post/5e4c0b856fb9a07ccb7e8eca#heading-24" style="text-decoration: none; word-wrap: break-word; color: #916dd5; font-weight: bolder; border-bottom: 1px solid #916dd5;">txm：初中级前端面试题（万字长文）</a></p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;"><strong style="color: #916dd5; font-weight: bold;"><span>「</span>字节跳动2020面试算法题+场景题+智力题100题<span>」</span></strong></p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;"><a href="https://www.nowcoder.com/discuss/425581?source_id=profile_create&amp;channel=666" style="text-decoration: none; word-wrap: break-word; color: #916dd5; font-weight: bolder; border-bottom: 1px solid #916dd5;">题集：字节跳动2020面试算法题+场景题+智力题100题 </a></p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;"><a href="https://www.nowcoder.com/discuss/428158?source_id=profile_create&amp;channel=666" style="text-decoration: none; word-wrap: break-word; color: #916dd5; font-weight: bolder; border-bottom: 1px solid #916dd5;">（答案1）字节跳动算法题+场景题+智力题100题</a></p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;"><a href="https://www.nowcoder.com/discuss/428774?type=2&amp;channel=666&amp;source_id=discuss_terminal_discuss_jinghua" style="text-decoration: none; word-wrap: break-word; color: #916dd5; font-weight: bolder; border-bottom: 1px solid #916dd5;">（答案2）字节跳动算法题+场景题+智力题100题</a></p><h2 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; text-align: left; margin: 20px 10px 0px 0px;"><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 18px; font-weight: bold; display: inline-block; padding-left: 10px; border-left: 5px solid #916dd5;">前端优质博客/Github</span><span class="suffix"></span></h2><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;"><a href="https://yuchengkai.cn/docs/frontend/browser.html" style="text-decoration: none; word-wrap: break-word; color: #916dd5; font-weight: bolder; border-bottom: 1px solid #916dd5;">yck掘金小册：前端进阶之道</a></p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;"><a href="http://www.conardli.top/blog/article/" style="text-decoration: none; word-wrap: break-word; color: #916dd5; font-weight: bolder; border-bottom: 1px solid #916dd5;">ConardLi的blog</a></p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;"><a href="https://blog.poetries.top/FE-Interview-Questions/base/" style="text-decoration: none; word-wrap: break-word; color: #916dd5; font-weight: bolder; border-bottom: 1px solid #916dd5;">FE-Interview 前端面试题整理</a></p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;"><a href="https://lucifer.ren/fe-interview/#/" style="text-decoration: none; word-wrap: break-word; color: #916dd5; font-weight: bolder; border-bottom: 1px solid #916dd5;">大前端面试宝典 - 图解前端</a></p><h2 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; text-align: left; margin: 20px 10px 0px 0px;"><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 18px; font-weight: bold; display: inline-block; padding-left: 10px; border-left: 5px solid #916dd5;">心路历程 / 大佬经验分享</span><span class="suffix"></span></h2><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;"><a href="https://juejin.im/post/5e9ac2006fb9a03c763d174c" style="text-decoration: none; word-wrap: break-word; color: #916dd5; font-weight: bolder; border-bottom: 1px solid #916dd5;">Bestbven：双非院校，成绩不好的他，怎么突然拿到大厂offer了？| 掘金技术征文</a></p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;"><a href="https://juejin.im/post/5e85ec79e51d4547153d0738" style="text-decoration: none; word-wrap: break-word; color: #916dd5; font-weight: bolder; border-bottom: 1px solid #916dd5;">LienJack：艺术喵 2 年前端面试心路历程（字节跳动、YY、虎牙、BIGO）| 掘金技术征文</a></p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;"><a href="https://juejin.im/post/5dfb9d6cf265da339856335b" style="text-decoration: none; word-wrap: break-word; color: #916dd5; font-weight: bolder; border-bottom: 1px solid #916dd5;">LienJack：2019学习学到失恋但是还要继续|2019 与我的技术之路</a></p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;"><a href="https://juejin.im/post/5c36fe50518825253b5e94f4" style="text-decoration: none; word-wrap: break-word; color: #916dd5; font-weight: bolder; border-bottom: 1px solid #916dd5;">LienJack：一位前端 2018 绝地求生记 | 掘金年度征文</a></p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;"><a href="https://juejin.im/post/5cfbcb5951882568862d69f0" style="text-decoration: none; word-wrap: break-word; color: #916dd5; font-weight: bolder; border-bottom: 1px solid #916dd5;">txm：生日之际，记录自己前端拼搏之路~</a></p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;"><a href="https://juejin.im/post/5e7c08bde51d455c4c66ddad" style="text-decoration: none; word-wrap: break-word; color: #916dd5; font-weight: bolder; border-bottom: 1px solid #916dd5;">晨曦时梦见兮：写给初中级前端的高级进阶指南</a></p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;"><a href="https://juejin.im/post/5e7af0685188255dcf4a497e" style="text-decoration: none; word-wrap: break-word; color: #916dd5; font-weight: bolder; border-bottom: 1px solid #916dd5;">晨曦时梦见兮：写给女朋友的中级前端面试秘籍（含详细答案，15k级别）</a></p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;"><a href="https://juejin.im/post/5dfef50751882512444027eb" style="text-decoration: none; word-wrap: break-word; color: #916dd5; font-weight: bolder; border-bottom: 1px solid #916dd5;">yck：看完跳槽少说涨 5 K，前端面试从准备到谈薪完全指南（近万字精华）</a></p><h2 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; text-align: left; margin: 20px 10px 0px 0px;"><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 18px; font-weight: bold; display: inline-block; padding-left: 10px; border-left: 5px solid #916dd5;">鸣谢</span><span class="suffix"></span></h2><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;">本篇博客知识点与相关文字都参照了各位大佬的博客，由于大佬太多了，也不太方便一个一个感谢了，但在本文已经都注明了各位大佬的博客出处，在此表示感谢，感谢各位大佬的优质文章 ✿✿ヽ(°▽°)ノ✿，小伙伴们都可以去他们主页逛逛，总会有一些好的内容等待着你去发掘~</p><h2 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; text-align: left; margin: 20px 10px 0px 0px;"><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 18px; font-weight: bold; display: inline-block; padding-left: 10px; border-left: 5px solid #916dd5;">总结</span><span class="suffix"></span></h2><blockquote data-tool="mdnice编辑器" style="display: block; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; border-left: 3px solid rgba(0, 0, 0, 0.4); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; border-left-color: #d89cf6; background: #f4eeff;"><p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px; margin: 0px; color: black; line-height: 26px;">以下部分引用三元大佬经验分享</p></blockquote><h3 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; color: black; font-size: 16px; font-weight: bold; text-align: center;"><span class="prefix" style="display: none;"></span><span class="content" style="border-bottom: 2px solid #d89cf6;">面试阶段</span><span class="suffix" style="display: none;"></span></h3><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;">从上面的面经中可以看到不同方向、不同级别的面试官各自的偏好不一样，因此对于不同的面试官，采取的策略也应有所不同。但我更想分享的是一些具有共性的地方，这些策略可以适用于绝大部分的面试场景，让自己获得更大的竞争优势。当然，所谓的面试策略，都是基于你前期充分的准备，不然都只是天方夜谭，毫无可行性。</p><h4 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 18px;"><span class="prefix" style="display: none;"></span><span class="content">策略一: 备好杀手锏</span><span class="suffix" style="display: none;"></span></h4><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;">面试官一天可能要面5-6人，甚至十几人，那么你是否想过: 他凭什么对你印象更加深刻？</p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;">心理学有一个效应叫 <strong style="color: #916dd5; font-weight: bold;"><span>「</span>峰终效应<span>」</span></strong> ，就是人在一个有限的活动当中，对一件陌生事物的看法大致由两个时间点所决定: 一个是高潮点，一个是结尾的点。对面试而言，我认为同样是适用，具体来讲，和面试官的交流，其实也就是和一个陌生人的交流，如何来给他留下更深刻的印象？需要在高潮点展现自己，在结尾点保护自己，在面试的过程中适当给面试官一些和别人不一样的回答和见解，使之感到惊艳，而在结尾的时候，你说的话其实更容易被面试官记住，这个时候由于面试已经接近尾声，你可能没有当时那么紧张，这个时候需要适当的谨慎一些，不要彻底放松，避免不小心说出一些对自己处境不利的话。</p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;">其实，我更想强调的是前者，即如何将面试带上一个高潮点，并且让面试官感到惊艳。其实这并不是什么简单的事情，毕竟能惊艳的只是少数，那么如果才能做到这一点呢？在面试前，不妨准备好自己的<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #916dd5; font-weight: bolder; background: none;">杀手锏</code>。什么是杀手锏？就是每当面试官问到相关的问题的时候，你能够有自信比 90% 的人理解得更深刻，回答更出色。以我自己为例，我准备的杀手锏并不少，<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #916dd5; font-weight: bolder; background: none;">HTTPS 所有加密算法</code>，<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #916dd5; font-weight: bolder; background: none;">chromium 进程 IPC 原理</code>，<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #916dd5; font-weight: bolder; background: none;">斐波拉契第 n 数的 logn 解法</code>，<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #916dd5; font-weight: bolder; background: none;">浏览器渲染过程</code>，<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #916dd5; font-weight: bolder; background: none;">vue 编译器架构</code>，<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #916dd5; font-weight: bolder; background: none;">vue 双向绑定</code>，<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #916dd5; font-weight: bolder; background: none;">快排以及手写 V8 排序</code> ......</p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;">在其它基础知识都 OK 的前提下，这些杀手锏是你技术上的核心竞争力，这是你和其他人相比体现不可替代性的地方。当然，时间有限，不可能每个角度都能研究很深入，但如果你不准备，跟大家背一样的答案，很难从人群当中脱颖而出。</p><h4 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 18px;"><span class="prefix" style="display: none;"></span><span class="content">策略二: 适当暗示</span><span class="suffix" style="display: none;"></span></h4><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;">面试的过程其实就是一个和面试官互相试探的过程，一方面是他对你提问，另一方面你需要给他一些信号，引导他去挖掘你的闪光点。</p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;">其实有两个时机可以发一些暗示的信号，一个是自我介绍的环节，这个环节中可以向面试官展示出你之前深入研究过哪一块的技术，指引他往那个方向问，另一个是技术细节的提问，可以在回答的时候适当发挥，大部分面试官是愿意听你展开的。</p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;"><strong style="color: #916dd5; font-weight: bold;"><span>「</span>我们的征途是星辰大海！<span>」</span></strong> 在经验分享处，我说我佩服自己第一次就面腾讯，其实想说自己真的挺傻的，在没有准备好的情况下，直接去面自己想去的公司，相当于当了一次炮灰一样。而且大多数公司都是有面试记录的，太差了也会影响后续面试邀请，比如说字节跳动，自从一面凉了之后，之后所有的投递都投入 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #916dd5; font-weight: bolder; background: none;">“人才库”</code>里。其次，整个面试过程给了我一些毒打，但又让我成长了许多。比如我们去面试，与面试官交流，并不是我们单方面的一问一答，而是 <strong style="color: #916dd5; font-weight: bold;"><span>「</span>交流<span>」</span></strong>，你怎么通过交流体现出你简历上面的能力，比如你的自学能力，你的表达沟通能力，你的领导能力等等。</p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;">另外，<strong style="color: #916dd5; font-weight: bold;"><span>「</span>面试也是一次双向选择的过程<span>」</span></strong>，面试官让你通过面试，也是觉得你可以做它的同事，因为公司拉人，多数也是部门招人，招你过去很有可能就是他的同事了，后续一些工作安排，业务等等都会打交道的。当然面试官要进行筛选，选最合适的那一批人。</p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;">其次，<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #916dd5; font-weight: bolder; background: none;">面试官都是挺好的</code>，可能个别会感觉有点高冷，甚至感觉与你不搭，这也是正常的。面试过程应该是一个轻松的过程，而不是那种一遇到问题就紧张说不出话的那种，尽管有些面试官会为难你，来个难题，也是为了考察你在高压的情况下你会如何判断处理。此时，对于你完全不会的地方，例如你可以这样回答：面试官，关于这一点的话，我本科阶段没有进行了解过，但与这个相关的另外一个知识点我知道，然后xxx，又或者说是关于这一点的话，你可以给我一点提示吗？又或者说是这一点我在本科阶段没有怎么了解过，但是我可以尝试解答一下，然后xxx。通过上述三种回答都比直接说不会要好很多！</p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;">每一次面试都是好的经验，通过写博客总结的形式也是一个输入和输出的过程。这样也可以让自己知识点记得更加牢固一点，这里不得不说两年写博客经历还真是让我收获许多。其次， <strong style="color: #916dd5; font-weight: bold;"><span>「</span>心态和自信方面挺重要的，尽管自己走的很慢，但是不会停下自己的脚步。<span>」</span></strong> 关键是学习前端思维，明白自己要学什么，该怎么学，如何学。那么对于一份好的工作到来，也只是时间问题了。</p><h2 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; text-align: left; margin: 20px 10px 0px 0px;"><span class="prefix" style="display: none;"></span><span class="content" style="font-size: 18px; font-weight: bold; display: inline-block; padding-left: 10px; border-left: 5px solid #916dd5;">结尾</span><span class="suffix"></span></h2><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;">每篇文章制作不易，养成一个阅读好习惯，觉得不错，反手就是一个赞，这样我也能发现你啦~</p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;">另外，Github 已经为前端小伙伴整理了一份完整地笔记，已获100+ star，别错过哟！</p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;"><a href="https://github.com/Chocolate1999/Front-end-learning-to-organize-notes" style="text-decoration: none; word-wrap: break-word; color: #916dd5; font-weight: bolder; border-bottom: 1px solid #916dd5;">小狮子前端笔记仓库传送门</a></p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;">学如逆水行舟，不进则退！我们下期再见！</p><p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: black; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;"><strong style="color: #916dd5; font-weight: bold;"><span>「</span>如果您能在评论区来一句生日祝福，那我就完全心满意足了（祝福必回复，不管是今天还是接下来的日子，祝福虽迟但到！），要继续长成厉害的大人~<span>」</span></strong></p><figure data-tool="mdnice编辑器" style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex; flex-direction: column; justify-content: center; align-items: center;"><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200810222322221.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70#pic_center" alt style="max-width: 100%; border-radius: 6px; display: block; margin: 20px auto; object-fit: contain; box-shadow: 2px 4px 7px #999;"></figure></section>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心得 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「星辰大海」❤前端面经汇总（面向腾讯学习）</title>
      <link href="posts/20210101/"/>
      <url>posts/20210101/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>收获了很多大佬们的经验分享和知识总结，现在来一份诚意满满的回馈，将2020年腾讯前端面经进行一次大整理，同时也会提供答案，希望大家都能参与进来，2021年春招顺利~</p><blockquote><p>答案提供在 <a href="https://github.com/Chocolate1999/Front-end-learning-to-organize-notes">https://github.com/Chocolate1999/Front-end-learning-to-organize-notes</a> （小狮子前端の学习整理笔记），别忘了<code>star</code> ┗|｀O′|┛ 嗷~~</p></blockquote><blockquote><p>最后更新时间：2020/1/6 下午5点  持续更新中…</p></blockquote><h2 id="部门相关"><a href="#部门相关" class="headerlink" title="部门相关"></a>部门相关</h2><blockquote><p>整理从2020年2月份到年底的腾讯面经「仅校招」，数据并不一定真实，仅作参考。</p></blockquote><table><thead><tr><th>部门</th><th>上岸次数</th><th>面经次数</th><th>备注</th></tr></thead><tbody><tr><td>CSIG</td><td>4</td><td>5</td><td></td></tr><tr><td>PCG</td><td>6</td><td>13</td><td></td></tr><tr><td>WXG</td><td>3</td><td>5</td><td></td></tr><tr><td>TEG</td><td>1</td><td>2</td><td></td></tr><tr><td>CDG</td><td>1</td><td>1</td><td></td></tr></tbody></table><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><ul><li>常见状态码知道哪些？ 304 403 405分别是什么</li><li>http状态码 302 504分别代表什么意思</li><li>响应状态码，200(from disk cache)，200（from memory cache），304的区别。</li><li>POST和GET 的区别，除了长度，安全其他的</li><li>http介绍一下，为什么http2.0不普及，websocket的基本指令，性能</li><li>爬虫，网站如何去做防止，如何判断</li><li>tcp和udp区别</li><li>那如果让你做一个视频聊天软件，你用tcp还是udp？为什么？</li><li>tcp是怎么去保证可靠传输的？</li><li>tcp三次握手</li><li>tcp握手结束第一次的包有多大</li><li>TCP的超时重传</li><li>TCP为什么是三次握手呢？</li><li>TCP如何去终止之前发送报文的？</li><li>tcp拥塞控制（四部分）</li><li>CDN的原理是什么</li><li>dns过程</li><li>HTTP协议，1.1和2.0的区别，了解哪些请求方法，请求/响应头部</li><li>为什么项目不用https以及http与https的区别</li><li>https的加密过程以及如何防止中间人攻击</li><li>为什么tcp连接是可靠的（校验和重传）</li><li>通过什么机制处理服务端接收数据乱序丢包等（滑动窗口和拥塞控制）</li><li>在TCP建立连接后，路由器发生了什么变化</li><li>http的header和body  讲的很详细 请求方式 请求头内容 状态码</li><li>http2相关问题。在http1的时代，会经常把很多资源部署在不同域名下，为什么？（有可能是减少cookie的传输量）</li><li>TCP和UDP的区别和场景，又问如果让你设计一个既保证准确性速度又快的协议，怎么做</li><li>OSI7层模型 每层大致用处及相关协议</li><li>https,http2.0，websocket(提了一下)，TLS握手，怎么知道数字证书的真假</li><li>http2.0有了解吗？有抓包看看到底什么个情况吗？</li><li>cookie session区别</li><li>session怎么保存、有多台服务器，sessionid 怎么找</li><li>为什么cookie可以用来保存登录状态</li><li>http头部chunk</li><li>get 发一个 tcp 包，post 发两个 tcp 包，这种情况是一定的吗，什么情况下不是这样</li><li>post 如何把数据放到 url 中</li><li>一个 http 的报文的头和 body 之间有什么分隔</li><li>出现 304 的场景，通过什么协议头来确认（304 的响应头）</li><li>websocket原理，如何实现，和http报文结构有哪些不同（注意是结构不是特性）</li><li>cookie，localStorage，sessionStorage 使用和区别</li><li>ca验证</li><li>wireshark能抓包到https请求的内容吗</li><li>https怎么预防中间人攻击</li><li>http请求的过程中怎么知道数据已经发送完毕要断开连接，怎么断开</li><li>网络的七层模型</li><li>get post head 这些请求方式有什么不同</li><li>了解轮询和websocket吗？</li><li>说一下websocket的四个阶段（websocket不能使用时要怎么处理、使用什么方式来代替websocket）</li></ul><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><ul><li>进程和线程</li><li>进程之间的通信知道吗？node中自己实现过哪种通信？（说了管道，消息队列，套接字，信号量啥的，表示自己不会node，没实现过，说了浏览器的多个tag之间也属于进程通信，表示不满意，不要说应用层上的东西）</li></ul><h2 id="浏览器工作原理"><a href="#浏览器工作原理" class="headerlink" title="浏览器工作原理"></a>浏览器工作原理</h2><ul><li>同源是什么意思，除了那三个没有了么</li><li>事件冒泡和事件捕获，应用？注意？</li><li>事件轮询 Eventloop</li><li>promise、console.log、setTimeout、执行顺序</li><li>重绘和重排</li><li>URl到页面加载过程</li><li>跨域问题，解决，jsonp原理，不受跨域影响的标签</li><li>Etag是什么？</li><li>浏览器储存cookie，localStorage，sessionStorage详细区别</li><li>http缓存，如果缓存还在有效期内，但是资源变更了怎么办</li><li>jsonp跨域的安全问题</li><li>cors 跨域，要支持两个域名怎么做</li><li>js会阻塞加载，怎么阻塞的？</li><li>http缓存更新静态文件的方式</li><li>postmessage</li><li>浏览器卡顿，你怎么去排除？（服务器到后台都讲了一遍，他告诉我如果数据没问题，是浏览器的问题怎么排除，我说了代码中打断点调试，他不满意，说我Chrome的调试工具台掌握很不好）</li><li>PC浏览器的分布？主流浏览器的版本</li><li>缓存问题，Etag和IF-modify-since是怎么来的？</li><li>非同源cookie怎么访问</li><li>如果要你缓存图片你怎么做？</li><li>有多台服务器，sessionid怎么找</li></ul><h2 id="浏览器安全"><a href="#浏览器安全" class="headerlink" title="浏览器安全"></a>浏览器安全</h2><ul><li>知道哪些前端危险？如何防御</li><li>XSS的原理，如何防御XSS？为什么换成实体字符就好了？</li><li>假如说某链接获取到你的敏感信息，发送奇怪请求到服务器，你怎么去防御？</li><li>讲一讲cookie是怎么发送到服务端，具体过程，尽量详细</li><li>csrf token能存储在cookie里吗？其实是可以的，只要服务端不要去从cookie里面取csrf token就行</li><li>黑客是怎么去利用cookie的？这个请求到底是怎么构造的？</li><li>http请求中option主要是干什么的</li><li>xss的原理和防御措施（讲了加强cookie，过滤输入，过滤输出）</li><li>CSRF了解过吗，它的攻击流程是怎样的，如何防御（refencer可不可以被修改、token可不可以被窃取，既然有漏洞那不是白做了）</li></ul><h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><ul><li>div里面嵌套一个tip，当tip改变的时候，div会重新渲染吗，怎么样实现div不会重新渲染</li><li>html5新特性</li><li>HTML跟HTML5的区别（解释了本质区别，框架上的区别）</li></ul><h2 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h2><h3 id="基础问题"><a href="#基础问题" class="headerlink" title="基础问题"></a>基础问题</h3><ul><li>let,const,var的区别。const定义的对象是否可以修改</li><li>js的原型和原型链，原型链的终点在哪里？</li><li>js的基本数据类型</li><li>事件委托，详细讲</li><li>es6新特性，常用语法有哪些</li><li>this的原理，call，apply，bind的区别</li><li>全等和弱等的区别</li><li>构造函数的原型</li><li>函数柯里化</li><li>数组浅拷贝</li><li>立即执行函数</li><li>浏览器事件模型, IE的有什么特殊, 如何兼容(attachEvent与addEventListener)</li><li>js宏任务和微任务</li><li>数组查找的方法</li><li>了解过for…of吗</li><li>class继承和js继承的区别</li><li>{}的原型链</li><li>typeof null是什么，为什么是这个结果。</li><li>typeof和instanceof有什么区别，说说判断的原理</li><li>数组里面新加的方法你有用过哪些？</li><li>微任务有哪些？</li><li>如何判断Array和Object</li><li>js精度问题（0.1+0.2==0.3的问题）</li><li>讲一下generator生成器</li><li>讲一下声明提升</li><li>讲一下块作用域</li><li>原型对象的constructor指向谁</li><li>dom规范跟js规范有什么区别？</li><li>js定时器，设置一个时间，会在那个时间之后准时执行吗？</li><li>transition有什么需要注意的地方？</li><li>.js的错误监控机制有了解吗？</li></ul><h3 id="进阶问题"><a href="#进阶问题" class="headerlink" title="进阶问题"></a>进阶问题</h3><ul><li>闭包，应用</li><li>防抖，节流</li><li>setTimeout第二个参数为0时和匿名自执行函数区别</li><li>js里堆和栈的区别</li><li>new操作符之后的操作</li><li>this指向</li><li>ES6的使用，相比ES5的好处</li><li>简单说一下es6的symbol属性</li><li>ES6的新特性（变量声明，字符串模板，数组的新方法flat，函数的默认值，箭头函数、class继承，promise，await/async 讲的很详细）</li><li>如果要同时启动两个异步任务，怎么做</li><li>深拷贝/浅拷贝问题</li><li>说一下链表的实现</li><li>bind(object).bind(windows) 后的this指向</li><li>构造继承里 Function.call(argu)里传进来的参数argu是什么</li><li>promise介绍，你是怎么用promise的，怎么实现一个promise</li><li>async是什么的语法糖，generator怎么用</li><li>ajax有哪些状态，每个状态分别对应什么</li><li>手动实现一个ajax，这样实现的方法叫什么</li><li>require和import的区别？AMD、CMD、ES6</li><li>callback的缺点，Promise的状态有哪些，generator，async和await</li><li>js溢出怎么解决</li><li>如何实现私有的方法/属性</li><li>ES5实现继承的方法，构造继承，原型链继承，组合继承，寄生组合继承</li><li>怎么用正则判断当前域名是否为qq.com，或者xxx.qq.com</li><li>try…catch…中如果异步代码出错怎么办？</li><li>js怎么删除cookie</li><li>cookie的几个字段的功能</li><li>怎么创建一个Promise，参数是什么，怎么中断一个promise，除了抛异常和return new Promise()还有什么</li><li>怎么判断一个空数组</li><li>箭头函数跟普通函数的区别，普通函数的作用域</li><li>let const, babel 中的实现</li><li>fetch的使用，考察通信是否了解</li><li>事件机制，捕获和冒泡，如何阻止冒泡？</li><li>阻塞、非阻塞和异步同步是对应的吗？一样的吗？</li><li>window.onload和document.ready，onload 是所有资源包括图片都加载完才执行</li><li>如何给不存在的元素绑定事件监听</li><li>可以在捕获阶段实现事件代理吗，为什么业界都用冒泡？（原因应该是，捕获和冒泡没有明显的优劣之分，但是冒泡事件流模型被大多数浏览器支持，兼容性更好）</li><li>promise的api：如果有10个调用请求，那么哪个api能查到最快调用的请求</li><li>promise中不声明async，可以用await吗</li><li>内存泄漏</li><li>怎么判断一个元素有没有被引用</li><li>全局变量为什么不会被垃圾处理</li><li>BOM和DOM的区别,BOM的方法讲完整一点</li><li>点击事件是宏任务还是微任务</li><li>class定义类和function定义类的区别</li></ul><h3 id="输出题"><a href="#输出题" class="headerlink" title="输出题"></a>输出题</h3><ul><li>以下代码执行结果</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;<span class="attr">b</span>: <span class="number">1</span>, <span class="attr">c</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="built_in">this</span>.b)&#125;&#125;</span><br></pre></td></tr></table></figure><ul><li>输出for循环中定时器的输出语句结果</li><li>打印结果是什么</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">a,b</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(b)</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        test:<span class="function"><span class="keyword">function</span>(<span class="params">c</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> test(c,a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> retA = test(<span class="number">0</span>);  retA.test(<span class="number">2</span>);  retA.test(<span class="number">4</span>);  retA.test(<span class="number">8</span>);</span><br><span class="line"><span class="keyword">var</span> retB = test(<span class="number">0</span>).test(<span class="number">2</span>).test(<span class="number">4</span>).test(<span class="number">8</span>);</span><br><span class="line"><span class="keyword">var</span> retC = test(<span class="string">&#x27;good&#x27;</span>).test(<span class="string">&#x27;bad&#x27;</span>);  retC.test(<span class="string">&#x27;good&#x27;</span>);  retC.test(<span class="string">&#x27;bad&#x27;</span>);</span><br></pre></td></tr></table></figure><ul><li>问如何改造，才能实现真正的效果，闭包可以吗，然后用闭包实现一下这个效果</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123; <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(i); &#125;, <span class="number">300</span>); &#125;</span><br></pre></td></tr></table></figure><h2 id="TS"><a href="#TS" class="headerlink" title="TS"></a>TS</h2><ul><li>TS 声明文件</li><li>TS 可选属性</li></ul><h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><ul><li><p>介绍一下css盒模型</p></li><li><p>position的值有哪些，区别是什么</p></li><li><p>bfc是什么。怎么样形成bfc，bfc有哪些用</p></li><li><p>实现一个垂直水平居中</p></li><li><p>左右布局，sider+右侧自适应如何实现</p></li><li><p>animation的参数，怎样实现一个动画</p></li><li><p>说说盒模型和怪异盒模型</p></li><li><p>预处理器sass优点</p></li><li><p>样式框架的原理，布局方法有哪些，flex，grid，还有吗</p></li><li><p>为什么下面的margin可以居中？</p><blockquote><p>.outer { display: flex; } .inner { margin: auto; } </p></blockquote></li><li><p>margin-top为负值，除了绝对定位还有哪些地方碰到过？</p></li><li><p>怎么使两个div并列</p></li><li><p>父元素和子元素宽高不知道的情况如何居中子元素（这个问题其实和父元素高度知不知道无关，因为文档流中父元素默认包裹子元素，高度是由子元素撑开的。）</p></li><li><p>CSS基础好么，知道DEN么？</p></li><li><p>css中隐藏元素的方法，display:none, visibility:hidden,区别？还有什么方式</p></li><li><p>css绝对定位和相对定位都是以谁为基准</p></li><li><p>css弹性盒子</p></li><li><p>CSS和JS实现动画的方式</p></li><li><p>ease-in怎么用js实现？</p></li><li><p>CSS和JS实现动画哪个好？为什么？</p></li><li><p>实现一个块从左到右的移动</p></li><li><p>css设置元素隐藏，两种有什么区别？</p></li><li><p>css选择器有哪些？</p></li><li><p>css怎么实现列表中隔一行变一个颜色</p></li><li><p>实现一个自适应内容的正方形盒子</p></li><li><p>css有哪些单位</p></li><li><p>讲一下css的flex布局</p></li><li><p>px和rem的区别，举个例子说明一下</p></li><li><p>浮动布局和flex布局相比有什么优缺点</p></li><li><p>写CSS喜欢用什么布局</p></li></ul><h2 id="HTML-1"><a href="#HTML-1" class="headerlink" title="HTML"></a>HTML</h2><ul><li>web语义化、语义化标签有哪些、section标签的作用</li></ul><h2 id="node"><a href="#node" class="headerlink" title="node"></a>node</h2><ul><li>node用什么实现模块化管理</li><li>说一下node的nextTick</li><li>说说浏览器和node.js里面捕获错误的方式</li><li>谈谈你对nodejs的理解</li><li>node和浏览器有什么区别吗</li></ul><h2 id="移动端-amp-小程序"><a href="#移动端-amp-小程序" class="headerlink" title="移动端&amp;小程序"></a>移动端&amp;小程序</h2><ul><li>移动端300ms的问题，以及fastclick的原理</li><li>小程序的话，你做了哪些优化？说说吧</li></ul><h2 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h2><ul><li>介绍一下webpack，webpack有哪些配置，loader和plugin有什么区别</li><li>webpack的原理机制、配置了入口之后发生了什么</li><li>Webpack用过么？里面的tree-shaking什么原理？（tree-shaking是因为import静态引入的能力，得以对文件内容进行浅层比较，去掉未被使用的代码。）</li><li>webpack的打包时间优化</li><li>webpack的打包流程</li><li>Require/import如何解决循环引用 Webpack是怎么做的</li><li>webpack异步加载路由需要怎么配置，问还有优化首屏渲染的其他方法吗</li><li>webpack loader在什么时期起作用</li><li>写一个webpack插件应该怎么写</li><li>webpack中如何实现按需加载的</li><li>webpack依赖node吗？</li><li>有了解过webpack里面的拆包吗，说一下你的拆包策略</li><li>你觉得拆包的意义在哪，结合http的缓存详细说下拆包你觉得拆包的意义在哪，结合http的缓存详细说下拆包</li><li>拆包过程有遇到过什么坑吗，如何解决的（有个webpack的bundle和module的id自增导致缓存失效的问题）</li><li>了解PWA吗，webpack怎么做PWA</li></ul><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><ul><li>设计模型 策略模式，单例模式，工厂模式</li></ul><h2 id="前端框架"><a href="#前端框架" class="headerlink" title="前端框架"></a>前端框架</h2><ul><li>了解有哪些框架，脏数据检测的原理、数据劫持的原理、订阅者发布者</li><li>用过哪些前端router，实现方式原理[hash、history]</li><li>框架的好处，坏处，单页面应用，seo如何解决</li><li>jquery的each</li><li>jquery的ready</li><li>ready和upload区别</li></ul><h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><ul><li>VUE的生命周期，create和mounted之间发生了什么</li><li>vue created 和 beforemount 之前会发生什么</li><li>vue什么生命周期以后就不会被监听了</li><li>钩子？</li><li>让你实现一个弹窗组件需要注意什么？</li><li>vue数据双项绑定+diff算法</li><li>既然有双向绑定，为什么VUE还有虚拟dom这个机制，以及这个机制的好处</li><li>VUE路由的实现原理</li><li>怎么去实现vue的计算属性</li><li>vue构建v-dom树过程</li><li>vue-cli做了哪些代码的优化，在开发环境到生产环境</li><li>Vue的预渲染这个插件，具体是怎么去做的？</li><li>Vue的子组件与子组件之间的通信讲讲吧</li><li>父子组件的通信和子父组件的通信是不是也可以实现呢？</li><li>说说你对Vue的总体看法，特点，以及与其他框架的不同的地方</li><li>Vue的spa首屏优化怎么做的，说具体思路</li><li>vue中通过一个按钮控制input获得焦点，怎么实现，通过ref获取对象跟原生的js有什么不同</li><li>vue的高级组件了解吗？</li><li>Vue的computed和watch有什么区别</li><li>如果要计算页面渲染时间，应该在哪个阶段为止</li><li>Vue生命周期中的mounted,在原生js中怎么实现？</li><li>Vue的虚拟DOM和patch算法</li><li>vue跟jquery的不同，操作DOM,组件化，MVVM,虚拟DOM</li><li>Vuex 5个概念 为什么mutations不能异步？异步会怎样？</li><li>对vue中data进行更新会发生什么（生命周期进行更新、渲染）</li><li>如果要复用项目中的某一块逻辑，你怎么做</li><li>vue中兄弟组件的通信方式（vuex，vue组件传递分配props）</li><li>说说v-if和v-show的区别</li><li>假设界面显示价格为9.99元，现在我去拉取了后台的价格，现在数据为8.88元。当你把数据设置为8.88后再到页面显示成8.88元。在这个期间你了不了解vue帮你做了什么事情？</li><li>介绍vuex的各个模块和简单讲讲原理</li><li>dispatch和commit的区别</li><li>vue父组件先mounted还是子组件mounted</li><li>Vue中的nextTick了解吗？</li><li>vue里面的key有什么作用</li></ul><h2 id="React"><a href="#React" class="headerlink" title="React"></a>React</h2><ul><li>介绍一下react生命周期</li><li>react diff有了解么</li><li>介绍一下redux</li><li>react数据流传递</li><li>react父组件子组件兄弟组件传递信息</li><li>react16新特性</li><li>this.setState执行后干了什么</li><li>为什么引进redux</li><li>react事件机制</li><li>render在什么时候被调用</li><li>js和react垃圾处理机制和回收</li><li>为什么要用到redux，redux的原理</li></ul><h2 id="项目工程"><a href="#项目工程" class="headerlink" title="项目工程"></a>项目工程</h2><ul><li>登录功能，从前端到后台是怎么处理的</li><li>用户登录怎么实现的，怎么知道是同一个用户（用userId，那手机号不就没用了吗）</li><li>手机号验证怎么做的，正则表达式的方法</li><li>发送验证码功能，向同一个手机发送多次验证码（攻击），怎么处理</li><li>项目前端怎么优化（<a href="https://juejin.cn/post/6844903568130965517">2018 前端性能优化清单</a>）</li><li>最近最熟悉的项目，遇到最难解决的问题</li><li>搜索框优化，防抖节流，还有？</li><li>jQuery用过吗，token如何实现验证登录</li><li>如果我从前端要请求一张图片，你觉得从前端到后端的整个流程是怎样的，详细讲讲在后端的处理流程，随便扯了点路由匹配啥的</li><li>很大的日志读取，ip出现最多的十次，怎么分片</li><li>你是怎么压缩图片的？</li><li>项目上线之后，怎样排除js中存在的问题？</li><li>如何上传文件，pc端</li><li>本地存储你有做什么特别处理吗？</li><li>说一下缓加载怎么实现的</li><li>有50g的QQ号数据，一次只能运行20g，想要找出出现次数最多的前十个qq号，怎么做？</li><li>图片压缩后台怎么实现你知道吗？怎么牺牲图片的画质呢？</li><li>输入 有做什么安全处理吗？（xss攻击，常见的字符转义处理有哪些？）</li><li>知道Base64吗</li><li>如果说要展示一个十万的数据在移动端的网页上怎么做</li><li>自己做一个登录系统从前端到后端需要注意什么</li><li>介绍一下雅虎的性能优化原则</li><li>海量日志中找ip最多出现次数</li><li>超大的日志文件, 提取其中的IP地址</li><li>前后端通信数据格式</li><li>用什么实现离线应用：manifest，原理呢？</li><li>如何提高首屏加载速度</li><li>图片懒加载怎么实现</li><li>博客的话，做过哪些方面的优化呢？</li><li>场景题：现在手机QQ要做个成语接龙，你怎么去做，说说思路吧</li><li>你有什么较好的算法可以尽量减少成语库的数量吗？</li><li>有没有想过前端如何去检测用户输入的是不是成语？</li><li>SSR</li><li>SEO怎么做的，说说技术细节</li><li>用ajax上传图片</li><li>预渲染prerender怎么做的，说说技术细节,具体说一下预渲染的原理</li><li>如何减少白屏时间和首屏时间</li><li>如果部署上去的项目有人打开后一直是白屏，怎么去收集这种情况</li><li>用户第二次访问网页，会快很多，是什么原理？</li><li>让你设计一个登录、注册、忘记密码的页面你会怎么设计？</li><li>组件化开发是为了什么</li><li>5000条数据展示</li><li>如何知道用户发生的错误（<code>window.onerror</code>）</li><li>富文本编辑器怎么实现？（给标签设置contenteditable属性，然后使用浏览器支持的document.execCommand 命令模式API）</li><li>富文本编辑器的安全问题</li><li>如果要实现在离线情况下编辑且不丢失数据，怎么办？（先回答的是使用localStorage，回答之后不断追问，还问了能否直接用对象存，后面扯到了引擎方面的问题。）</li><li>从底层谈谈map数据结构的设计。如果容量不够了怎么办，扩容过程中可能会耗费比较多的时间，如果在扩容时要访问怎么办；</li><li>微信附近的人这个功能，如何设计</li><li>severless的优点</li><li>git相关操作</li><li>如何实现一个可编辑的可以无限延伸的表格？</li><li>除了websocket外还有什么方法能实现后端推送？</li><li>自动化测试是怎么做的，怎么判断输出是不是符合期望</li><li>100ms请求事件，有几种写法</li><li>如何能只发送信息，不进行数据缓存</li><li>前端要加载一个图片有哪些方式，然后还问到了base64是怎么实现的，有什么缺点，icon是怎么实现的</li><li>后端一下子给你几万条数据，你要怎么处理。（一开始我说，这种情况下后端一定会分页的，然后又问没分页怎么办。然后我说前端手动分页，然后讲了一下具体的实现方法。）</li><li>有一个高频触发的请求，你会怎么处理，这个饶了好久，一开始没get到面试官的点，一开始谈到了节流和防抖，然后面试官说这样会影响用户体验，而且这个需求就是需要高频触发，然后又说了一下需要高频请求的场景，一开始说到表单，然后说到购物车抢购。然后我又说加个16位随机字符串的参数，然后面试官说这样只是可以区分请求，在网络传输过程中，请求不一定是按先后顺序到达服务器的，那么服务器怎么知道请求的先后顺序呢，其实答案很简单，就是加个时间戳参数。不过当时一下子没反应过来，还谈到了域名发散，面试官说太复杂，然后才谈到加表明各个请求之间关系的参数。</li><li>性能优化（讲了雅虎军规（资源加载、代码规范、缓存、服务器）下次可以优化讲成通用性能优化的方案雅虎军规+vue项目的优化）</li><li>怎么保证token的安全性，拿到你的token就可以做全部的事情了吗？</li><li>弱类型语言的缺点，平时哪些地方让你抓狂</li><li>封装统一的网络请求的好处</li><li>说一下babel是怎么实现各个浏览器兼容的，讲了一下babel的工作流程和AST树</li><li>垃圾回收，如何使用这个方法来优化，主流的浏览器垃圾回收的算法，具体流程</li><li>标记清除为什么比引用清除好</li><li>要在页面上实行一个特别慢的 js 代码，会遇到什么问题，假设页面已经加载好，用户点击之后开始计算，造成没有响应的现象的原因（被禁用还是被延迟）</li><li>阻塞会造成什么后果</li><li>很大的计算，会让页面卡顿，有什么办法可以使页面不卡顿，也让任务完成（我回答了异步的方法，面试官问还有没有其他的方式，例如 html5 的新特性）</li><li>实现百度搜索,foucs有下拉框，根据输入内容能模糊查询</li><li>无限滚动列表优化问题</li><li>假如说我们的网页有一个表单，有人模拟 http 的 post 绕过了表单将数据发送到了后台应该怎么办</li><li>怎么去实现一个多人在线文档（从技术和需求说，来自腾讯文档，怎么做到数据的渲染、怎么获取到数据、网络上需要做什么处理）</li><li>详细说明一下你是怎么通过设置请求头解决了缓存问题吗？</li><li>图片懒加载原理（节流是什么）</li><li>点击穿透</li><li>fastClick原理</li><li>说说不用nuxt框架怎么实现SSR，数据预取怎么实现的</li></ul><h2 id="可能会问到的后端问题"><a href="#可能会问到的后端问题" class="headerlink" title="可能会问到的后端问题"></a>可能会问到的后端问题</h2><ul><li>RESTful的原理</li><li>数据库百万条数据，有几种语文，数学，计算平均分，排序出来，如何解决</li><li>后台有注解，前端有吗？装饰器用过吗？</li><li>关系型和非关系型数据库</li><li>数据库的索引的原理和用法</li><li>数据库的事务知道吗？</li><li>连接查询有哪些方式？</li><li>你知道Java为啥能够运行在几乎所有系统上吗？</li><li>linux相关操作（查看进程用ps）</li><li>mysql跟mongondb的不同</li><li>数据库优化方法</li><li>pm2查看日志的命令</li><li>koa的底层原理</li><li>koa的洋葱模型，和express有什么区别</li><li>事务的原理了解吗</li><li>什么是内外连接</li><li>索引了解吗，为什么索引能加快速度</li><li>同步和异步的区别</li><li>如果有六百万名考生的高考成绩要排序应该怎么做</li><li>web服务用过哪些？</li><li>你提到了nginx，有做过一些负载均衡吗？</li></ul><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><ul><li>找出数组中n项，n项的和为m</li><li>口述快速排序</li><li>冒泡，及冒泡的优化</li><li>讲讲迪杰斯特拉算法</li><li>讲讲最小生成树算法</li><li>讲讲hash算法</li><li>堆排序</li><li>数组三分，如果一个数组能够分成非空的三个部分，每个部分和相等，则返回true</li><li>查找算法应该用堆还是用栈</li><li>数据结构有那些</li><li>快排时间复杂度+快排什么时候最慢</li><li>洗牌算法</li><li>dp和二叉树</li><li>二叉树根据一个节点查找下一个节点</li><li>从一个数组的后十个数中找出3个和为10的数字</li><li>找出两个字符串（str1,str2）的最大公共子长度</li><li>一次可以跳一步，两步，三步，问n步的路有多少种到达终点方式？（斐波那契，写了个尾递归）</li><li>大量数据的数组，怎么找出排名前n个数</li><li>给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 -1</li><li>实现 string的indexOf() 函数</li><li>罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。<br>字符 数值<br>I 1<br>V 5<br>X 10<br>L 50<br>C 100<br>D 500<br>M 1000<br>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。<br>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：<br>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。<br>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。<br>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。<br>给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</li><li>大数相加</li><li>链表反转</li><li>二叉树排序</li><li>二叉树的翻转</li><li>出现最多的字母个数</li><li>找一篇文章中出现最多的英文单词</li><li>正则匹配字符串</li><li>现在给你一个树状对象，{value:1,children:{value:2,children:{…}}}这样的结构，如何把所有value删去，返回一个新对象？</li><li>如何判断一个对象中有没有叫value的属性？不要考虑代码的复杂性，能说几种说几种</li><li>说说你知道的排序和查找算法吧</li><li>堆排序是如何实现的？时间复杂度是多少？</li><li>有1000步的台阶，每次只能选择走1步、2步或者3步，走完台阶一共有多少种走法</li><li>长度为1亿的字符串，寻找字符串包含’tencent’子串的数量</li><li>无序数组中选择第k大的数，分析算法时间复杂度</li><li>两个整数求和会超过int范围 怎么运算</li><li>DFS非递归 先序遍历</li><li>数组中超过一半的数是同一个数，找出那个数（分析复杂度，如何优化）</li><li>手撕二叉树的题目，leetcode124</li><li>生成一个8*8的01棋盘，每行每列不能多于1个1，输出生成的棋盘和符不符合规定</li><li>数组和链表随机访问的时间复杂度</li><li>O(N) 寻找最长的连续字符串</li><li>小明从老板那里拿到了一个密码表，说是如果解开密码表中的秘密，就可以升职加薪，赢取白富美，走向人生巅峰。这个密码表是一个 CSV 文件，里面的数据由数字（没有小数点）、字母组成。小明需要提取每个数据中的数字（例如 1a2b3c 提取后得到 123，提取后的数字整体看作一个十进制数），把数值为奇数的项相加，就可以解开这个秘密。请你实现一个函数 sum，帮小明完成这项工作。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">input: string</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> input.split(<span class="regexp">/[,\n]/</span>)</span><br><span class="line"></span><br><span class="line">    .map(<span class="function"><span class="params">item</span> =&gt;</span> <span class="built_in">Number</span>(item.replace(<span class="regexp">/[a-z]/ig</span>, <span class="string">&quot;&quot;</span>)))</span><br><span class="line"></span><br><span class="line">    .filter(<span class="function"><span class="params">num</span> =&gt;</span> num % <span class="number">2</span> === <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    .reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在一个字符串中找出连续重复的字符，这个字符可以是数字、字母和中文等</li><li>有效括号 - 判断一个字符串中括号是否都能匹配</li><li>一个字符串里面有一些不可见的字符，如”\n”，写一个算法剔除它们</li></ul><h2 id="手撕"><a href="#手撕" class="headerlink" title="手撕"></a>手撕</h2><ul><li>数据绑定实现【框架和抛开框架，手撕】</li><li>排序数组，查询某个值，存在则返回索引，不存在返回插入位置；优化，for~二分 【手撕】</li><li>js实现阶乘</li><li>创建一个 Person 类，其包含公有属性 name 和私有属性 age 以及公有方法 setAge ；创建一个 Teacher 类，使其继承 Person ，并包含私有属性 studentCount 和私有方法 setStudentCount </li><li>实现一个类似百度输入框的功能，根据用户的输入，找出一个数组中匹配到的数显示出来</li><li>一个输入框实现百度搜索那样的autocomplete效果</li><li>请写一个函数，计算一篇英文文章中出现次数最多的单词及出现次数</li><li>怎么用js实现队列</li><li>js观察者模式</li><li>数组扁平化</li><li>实现一个实数的堆栈，使得其 push pop max 方法的时间复杂度为 O(1)</li><li>有一个整数二维数组，每行的元素个数不同，输出它的全排列，同一行的数互斥。要求不使用递归完成</li><li>实现一个函数，检查二叉树是否平衡。</li><li>实现一个 Http 请求池，需要能够限制并发数</li><li>合并二叉树</li><li>奇偶链表</li><li>使用闭包实现变量自加一</li><li>双向链表转二叉树，二叉树转双向链表</li><li>url正则匹配</li><li>nlogn排序算法有哪些，快排稳定么</li><li>构建排序二叉树</li><li>搜索二叉树找第k大的数</li><li>手写原生ajax，new XMLHttpRequest()</li><li>手写对象深拷贝</li><li>获取标签名称为div的元素的个数，并且判断是不是数组，考察类型判断</li><li>给两个构造函数A和B，如何实现A继承B</li><li>用户权限认证过程</li><li>写个模块导出的案例</li><li>说下异步的问题，写个promise的使用小案例</li><li>拖拽代码 (手写)</li><li>手撕代码：大数相乘</li><li>手撕代码：函数无限柯里化（有n个参数，函数调用n+1次得到结果）</li><li>手撕代码：实现一个轮询器，主要考察Promise</li><li>用es5的let实现一个闭包</li><li>继承（实现私有属性和私有方法）</li><li>设计实现一个固定执行顺序的script加载</li><li>手写代码题：找出字符串中出现次数最多的字符及出现次数</li><li>编程题（对输入的一段字符串（有逗号 有回车，挑出其中的数字，然后求和，求和之后再把数中的奇数加） 1.正则做法 2.字符串遍历做法，挑出数字 ， 换行，再按换行分割，再按，号分割，数组扁平，求和，变字符串，遍历</li><li>数组去重手写，越多越好</li><li>将一个平铺的数组用js写成树的结构</li><li>完成函数的实现，使得它可以实现达到 <code>Array.prototype.forEach</code> 相同的功能</li><li>看下面代码执行结果，说明原因</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span>=&gt;</span>&#123;</span><br><span class="line">resolve();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;).then(<span class="function">()=&gt;</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><ul><li><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20210106165903412.png" alt=""></li><li>token过期怎么做</li><li>怎么知道用户和token的对应关系</li><li>token和cookie区别</li><li>token为什么比cookie更不容易受到攻击，为什么要用cookie</li><li>手撕Event bus</li><li>手撕函数组合</li><li>手撕对象扁平化</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">请实现 flatten(input) 函数，input 为一个 javascript 对象（<span class="built_in">Object</span> 或者 <span class="built_in">Array</span>），返回值为扁平化后的结果。</span><br><span class="line"> * 示例：</span><br><span class="line"> *   <span class="keyword">var</span> input = &#123;</span><br><span class="line"> *     a: <span class="number">1</span>,</span><br><span class="line"> *     b: [ <span class="number">1</span>, <span class="number">2</span>, &#123; <span class="attr">c</span>: <span class="literal">true</span> &#125;, [ <span class="number">3</span> ] ],</span><br><span class="line"> *     d: &#123; <span class="attr">e</span>: <span class="number">2</span>, <span class="attr">f</span>: <span class="number">3</span> &#125;,</span><br><span class="line"> *     g: <span class="literal">null</span>, </span><br><span class="line"> *   &#125;</span><br><span class="line"> *   <span class="keyword">var</span> output = flatten(input);</span><br><span class="line"> *   output如下</span><br><span class="line"> *   &#123;</span><br><span class="line"> *     <span class="string">&quot;a&quot;</span>: <span class="number">1</span>,</span><br><span class="line"> *     <span class="string">&quot;b[0]&quot;</span>: <span class="number">1</span>,</span><br><span class="line"> *     <span class="string">&quot;b[1]&quot;</span>: <span class="number">2</span>,</span><br><span class="line"> *     <span class="string">&quot;b[2].c&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"> *     <span class="string">&quot;b[3][0]&quot;</span>: <span class="number">3</span>,</span><br><span class="line"> *     <span class="string">&quot;d.e&quot;</span>: <span class="number">2</span>,</span><br><span class="line"> *     <span class="string">&quot;d.f&quot;</span>: <span class="number">3</span>,</span><br><span class="line"> *     <span class="comment">// &quot;g&quot;: null,  值为null或者undefined，丢弃</span></span><br><span class="line"> *  &#125;</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><ul><li>给列表中的li（里面是a标签）绑定点击事件，点击时弹出其在列表中的顺序（页面不跳转）</li><li>JS实现一个JSON.stringify()功能的函数</li><li>三次重试：假设有一个函数名为job,调用job后会执行一些异步任务，并返回一个Promise,但job执行的异步任务任务有可能会失败<br>请实现函数retry,把job作为retry函数的参数传入，当retry执行后会尝试调用job,如果job返回成功（即Promise fulfilled），则retry函数返回job函数的返回内容；<br>如果job返回失败（即Promise rejected）,retry函数会再次尝试调用job函数。<br>如果job连续三次均返回失败，retry则不再尝试调用，并返回其最后一次失败的内容。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">job</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">               <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                   <span class="keyword">var</span> num = <span class="built_in">Math</span>.ceil(<span class="built_in">Math</span>.random() * <span class="number">20</span>); <span class="comment">//生成1-10的随机数</span></span><br><span class="line">                   <span class="built_in">console</span>.log(<span class="string">&#x27;随机数生成的值：&#x27;</span>, num)</span><br><span class="line">                   <span class="keyword">if</span> (num &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">                       <span class="built_in">console</span>.log(<span class="string">&#x27;符合条件，值为&#x27;</span> + num)</span><br><span class="line">                       resolve(num);</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">else</span> &#123;</span><br><span class="line">                       reject(<span class="string">&#x27;数字大于1了执行失败&#x27;</span>);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;, <span class="number">2000</span>);</span><br><span class="line">           &#125;)</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">function</span> <span class="title">retry</span>(<span class="params">job, times, delay</span>) </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">               <span class="function"><span class="keyword">function</span> <span class="title">attempt</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                   job().then(<span class="function"><span class="params">num</span> =&gt;</span> &#123;</span><br><span class="line">                       resolve(num);</span><br><span class="line">                   &#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">                       <span class="built_in">console</span>.log(<span class="string">&#x27;还有&#x27;</span>, times - <span class="number">1</span>, <span class="string">&#x27;次尝试&#x27;</span>);</span><br><span class="line">                       <span class="keyword">if</span> (<span class="number">0</span> == times - <span class="number">1</span>) &#123;</span><br><span class="line">                           reject(err);</span><br><span class="line">                       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                           times--;</span><br><span class="line">                           <span class="built_in">setTimeout</span>(attempt(), delay);</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;)</span><br><span class="line">               &#125;</span><br><span class="line">               attempt();</span><br><span class="line">           &#125;)</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       retry(job, <span class="number">3</span>, <span class="number">1000</span>).then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">           <span class="built_in">console</span>.log(result);</span><br><span class="line">       &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(err); &#125;);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">job</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">             <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                 <span class="keyword">var</span> num = <span class="built_in">Math</span>.ceil(<span class="built_in">Math</span>.random() * <span class="number">20</span>); <span class="comment">//生成1-10的随机数</span></span><br><span class="line">                 <span class="built_in">console</span>.log(<span class="string">&#x27;随机数生成的值：&#x27;</span>, num)</span><br><span class="line">                 <span class="keyword">if</span> (num &lt;= <span class="number">10</span>) &#123;</span><br><span class="line">                     <span class="built_in">console</span>.log(<span class="string">&#x27;符合条件，值为&#x27;</span> + num)</span><br><span class="line">                     resolve(num);</span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="keyword">else</span> &#123;</span><br><span class="line">                     reject(<span class="string">&#x27;数字大于10了执行失败&#x27;</span>);</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;, <span class="number">2000</span>);</span><br><span class="line">         &#125;)</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">retry</span>(<span class="params">job, times</span>) </span>&#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; times; i++) &#123;</span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">await</span> job();</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">             &#125; <span class="keyword">catch</span>(err)&#123;</span><br><span class="line">                 <span class="keyword">if</span>(i == times-<span class="number">1</span>)&#123;</span><br><span class="line">                     <span class="keyword">return</span> err;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">finally</span> &#123;</span><br><span class="line">                 <span class="built_in">console</span>.log(<span class="string">&#x27;还有&#x27;</span>, times - i - <span class="number">1</span>, <span class="string">&#x27;次机会&#x27;</span>);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     retry(job, <span class="number">3</span>).then(<span class="function"><span class="params">num</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(num) &#125;)</span><br></pre></td></tr></table></figure><ul><li>给了一个代码片段，大概就是一个产生随机数的for循环，然后把这个随机数当作参数传到一个异步函数，问怎么保证输出顺序也是有序的，其实就是类似于同时发送几个http请求，怎么保证响应顺序也按照请求顺序依次返回</li><li>写了个类型判断函数</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getType</span>(<span class="params">param</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> type = <span class="built_in">Object</span>.prototype.toString.call(param).slice(<span class="number">8</span>, -<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (type === <span class="string">&quot;Object&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> param.constructor.name;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> type;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>遍历根结点下所有子节点</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">traverseDom</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = [];</span><br><span class="line">    <span class="keyword">let</span> queue = [root];</span><br><span class="line">    <span class="keyword">while</span> (queue.length) &#123;</span><br><span class="line">        <span class="keyword">let</span> cur = queue.shift();</span><br><span class="line">        result.push(cur);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; cur.children.length; i++) &#123;</span><br><span class="line">            queue.push(cur.children[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>实现页脚在内容最底部<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20210107092724752.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        * &#123;</span><br><span class="line">            margin: 0;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        html,</span><br><span class="line">        body &#123;</span><br><span class="line">            height: 100%;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"><span class="css">        <span class="selector-class">.container</span> &#123;</span></span><br><span class="line">            min-height: 100%;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"><span class="css">        <span class="selector-class">.content</span> &#123;</span></span><br><span class="line">            background: goldenrod;</span><br><span class="line">            color: white;</span><br><span class="line">            text-align: center;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"><span class="css">        <span class="selector-class">.placeholder</span> &#123;</span></span><br><span class="line">            height: 50px;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"><span class="css">        <span class="selector-class">.footer</span> &#123;</span></span><br><span class="line">            height: 50px;</span><br><span class="line">            background: greenyellow;</span><br><span class="line">            margin-top: -50px;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span>我是内容<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;placeholder&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;footer&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="智力题"><a href="#智力题" class="headerlink" title="智力题"></a>智力题</h2><ul><li>100人教室70人喜欢足球，80人喜欢篮球，问同时喜欢足球和篮球的人数</li><li>试探玻璃杯破碎的楼层</li><li>时针与分针夹角</li><li>5.25时针和分针夹角</li><li>上一题拓展:X时Y分夹角</li><li>一个班里60%喜欢A, 70%喜欢B, 80%喜欢C, 问同时喜欢ABC的</li><li>一瓶汽水一块钱，俩空瓶可以换一瓶汽水，给你20块钱，最多喝多少瓶？</li><li>给你一个A4纸张，随便剪掉一个随意位置宽高的矩形，给你一个没有刻度的尺子和笔，怎么一刀把剩下的A4纸张分成面积同样大小的两半。</li><li>如何洗开一副扑克牌</li><li>a和b两个人投掷硬币，朝上a得1分，反之b得分，现在a8分、b7分，请问a和b先到10分的概率各是多少。</li><li>一根不均匀绳子烧完一个小时，问怎么使用多根这种绳子来计算15分钟</li><li>一个烤盘，每次最多烤两块肉，一面烤10min，问要烤几分钟</li><li>20个瓶子，有19个瓶子每颗药1g，有一个瓶子每颗药1.1g，问怎么用一把称一次找出1.1g的瓶子</li></ul><h2 id="拓展问题"><a href="#拓展问题" class="headerlink" title="拓展问题"></a>拓展问题</h2><ul><li>excel同步/冲突</li><li>OT算法</li></ul><h2 id="非技术相关"><a href="#非技术相关" class="headerlink" title="非技术相关"></a>非技术相关</h2><ul><li>讲一下你觉得最自豪的项目</li><li>对该职位的学习方式（根据对方的回答，需要的人员应该是看过专业书籍，有去了解这一方面的大佬并针对其技术分享进 行学习。而不只是用的时候再学，野网站学习。可以简洁为愿意并且会主动地学习）</li><li>认为前端开发中比较难、比较重要的地方</li><li>除了react还用了哪些技术</li><li>遇到过的难点，如何解决的？</li><li>有读英文文档的习惯吗？</li><li>ts和java对比，ts和es6对比，js对比框架</li><li>面试过其他什么公司</li><li>什么时候开始学习前端的，学习前端的方式，平时都看过哪些书？</li><li>平时学前端看什么书呀？说说学习路线吧</li><li>你看书或者看博客学习的时候，是怎么做总结的</li><li>最近都有再看什么书？</li><li>写文章的时候总有个先后顺序或者一定的结构吧，你是怎么做的</li><li>没有试过思维导图</li><li>在前端上未来有什么打算？有没有什么想学的东西？是只想找个工作还是想怎么发展？</li><li>为什么说自己擅长沟通和有抗压能力</li><li>问了计算机组成，问我cache知道吗，我大概说了说，然后问为什么cache更快</li><li>操作系统，银行家算法，死锁怎么解决</li><li>为什么学习前端</li><li>我在学习过程中遇到了哪些困难，怎么解决的。</li><li>有没有关注前端的新技术</li><li>flutter有了解吗</li><li>h5有写过吗，移动端有了解吗</li><li>了解过小程序吗</li><li>如何衡量一个软件的质量？如何保证产品的质量？（软件工程的思想，敏捷中的测试驱动开发）</li><li>找出不多于三个关键词形容自己</li><li>怎么跟一个不懂前端的人介绍前端</li></ul><h2 id="HR问题"><a href="#HR问题" class="headerlink" title="HR问题"></a>HR问题</h2><ul><li>自我介绍</li><li>讲一讲最近收获最大的一个项目，在项目担任的角色</li><li>有什么爱好，为什么喜欢</li><li>是否为独生子女</li><li>是否去过深圳</li><li>是否考研</li><li>什么专业，为什么不选择省外的高校</li><li>是否有其它公司offer</li><li>入职时间，可实习多久</li><li>说说自己性格的优点和缺点</li><li>你怎么看我们部门</li><li>你了解过我们是做什么的吗</li><li>你平常怎么学习</li><li>你的未来规划是什么</li><li>你女朋友不让你来深圳怎么办</li><li>什么时候能入职 能做多久</li><li>参加过什么比赛，拿过什么奖</li><li>老师和同学对自己评价的优缺点</li><li>成绩在年级上的位置</li><li>说下团队的规模，在团队的角色</li><li>觉得自己技术怎么样</li><li>什么时候开始用GitHub，更新频率怎么样</li></ul><h2 id="总监面"><a href="#总监面" class="headerlink" title="总监面"></a>总监面</h2><ul><li>如何学习全新的框架</li><li>一个卡顿的项目交给你，怎么去进行优化</li><li>周围有人拿到腾讯offer了吗？</li><li>介绍了一下我的专业干啥的</li><li>日常开发中遇到问题怎么解决</li><li>建立中的项目有啥亮点</li><li>前端处理耗时比较长的计算问题，如何防止页面卡顿的优化方案</li><li>bilibili上面一键三连怎么实现</li><li>自己的职业规划</li></ul>]]></content>
      
      
      <categories>
          
          <category> 写给女友 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 腾讯 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「星辰大海」写给女友的一系列 JS 数组操作</title>
      <link href="posts/20201202/"/>
      <url>posts/20201202/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近和女友，咳咳…（说出来可能会被打s）学习JS数组方法，用几个字形容的话就是<code>听说过</code>，实际使用、遇到的时候就分不清具体方法会得到怎样的结果。</p><p>今天我将通过这篇文章好好整理一下关于JS数组的方法，让大家通过这一篇文章 <code>掌握</code> 数组一系列操作，同时，在面试或者工作的时候也能写出<code>简洁、优雅、美观、高效</code>的代码。其次，这篇写给女友，她看到会感动到哭嘛？会吗会吗会吗？</p><p>话说我有女友吗？</p><blockquote><p>啊这，这…这重要吗？</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e7da87b88b014e78bbc915044d911eac~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><blockquote><p>（手机端可能看不清）获取高清PDF，请在微信公众号【小狮子前端Vue】回复【数组方法】</p></blockquote><h2 id="阅读须知"><a href="#阅读须知" class="headerlink" title="阅读须知"></a>阅读须知</h2><p>开门见山，我先介绍一下本文整体目录结构，介绍我将输出的大概内容。</p><p>显然，数组的方法有很多很多，但是实际工作或者面试过程中有些用到的少之又少，因此，我不会将所有的方法都提出来，然后解析。那么，我会将重要程度比较高的方法尽量用详细简洁的语言带过，同时例举几个样例，自测案例为你加深巩固。</p><p>其次，本文还会提及面试常考问题，比如经典<strong>扁平化</strong>问题，数组<strong>去重</strong>、<strong>合并</strong>、排序、<strong>改变原数组的方法</strong>、<strong>不改变原数组</strong>的方法等等。</p><p>好了，让我们进入正文~</p><h2 id="数组的遍历"><a href="#数组的遍历" class="headerlink" title="数组的遍历"></a>数组的遍历</h2><p>犹记得今年快手面试官就问了一道经典面试题：说说你所知道的数组的遍历方法？</p><p>我想这个问题小伙伴们面试时应该也会遇到过吧，面试官问这个问题其一就是考察你对数组方法掌握程度，其二可以通过你说的方法选择其中一个继续深度询问，比如 <code>reduce</code>、<code>map</code>使用等等，因此，我将 <strong>数组遍历</strong> 作为第一个模块来讲解。</p><h3 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 5</span></span><br></pre></td></tr></table></figure><h3 id="for-of-循环"><a href="#for-of-循环" class="headerlink" title="for..of 循环"></a>for..of 循环</h3><p>摘自<code>MDN</code>上一句话，<code>for...of</code> 语句遍历<strong>可迭代对象</strong>定义要迭代的数据。简单来说，<code>for...of</code>遍历的就是 <code>value</code>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;Chocolate&#x27;</span>, <span class="string">&#x27;zhlll&#x27;</span>, <span class="string">&#x27;lionkk&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> val <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Chocolate</span></span><br><span class="line"><span class="comment">// zhlll</span></span><br><span class="line"><span class="comment">// lionkk</span></span><br></pre></td></tr></table></figure><h3 id="for…in-循环"><a href="#for…in-循环" class="headerlink" title="for…in 循环"></a>for…in 循环</h3><p>摘自<code>MDN</code>上一句话，<code>for...in</code> 语句以任意顺序迭代对象的<strong>可枚举属性</strong>。简单来说，<code>for...in</code>遍历的就是 <code>key</code>。对于数组，<code>key</code>对应着的是数组的<strong>下标索引</strong>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;Chocolate&#x27;</span>, <span class="string">&#x27;zhlll&#x27;</span>, <span class="string">&#x27;lionkk&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> arr) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h3 id="array-forEach-方法"><a href="#array-forEach-方法" class="headerlink" title="array.forEach() 方法"></a>array.forEach() 方法</h3><p>先来介绍语法：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">array.forEach(callback(currentValue, index, arr), thisArg)</span><br></pre></td></tr></table></figure><blockquote><p>callback:为数组中每个元素执行的函数，该函数接收一至三个参数<br>currentValue 数组中正在处理的当前元素<br> index (可选)  数组中正在处理的当前元素的索引<br> arr (可选)    forEach() 方法正在操作的数组<br> thisArg      可选参数,当执行回调函数callback,用作this值</p></blockquote><p>简单例子：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;Chocolate&#x27;</span>, <span class="string">&#x27;zhlll&#x27;</span>, <span class="string">&#x27;lionkk&#x27;</span>];</span><br><span class="line"></span><br><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">cur, index, arr</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(cur, index, arr);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Chocolate 0 [ &#x27;Chocolate&#x27;, &#x27;zhlll&#x27;, &#x27;lionkk&#x27; ]</span></span><br><span class="line"><span class="comment">// zhlll 1 [ &#x27;Chocolate&#x27;, &#x27;zhlll&#x27;, &#x27;lionkk&#x27; ]</span></span><br><span class="line"><span class="comment">// lionkk 2 [ &#x27;Chocolate&#x27;, &#x27;zhlll&#x27;, &#x27;lionkk&#x27; ]</span></span><br></pre></td></tr></table></figure><p>从上述例子中，了解到 <code>forEach</code>需要传递一个回调函数，而那三个参数，后面两个是可选的，那么如何让代码更加优雅美观一点呢，同时，后面两个参数按需添加即可：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;Chocolate&#x27;</span>, <span class="string">&#x27;zhlll&#x27;</span>, <span class="string">&#x27;lionkk&#x27;</span>];</span><br><span class="line"></span><br><span class="line">arr.forEach(<span class="function">(<span class="params">cur</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(cur);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// Chocolate</span></span><br><span class="line"><span class="comment">// zhlll</span></span><br><span class="line"><span class="comment">// lionkk</span></span><br></pre></td></tr></table></figure><p><strong>疑难点</strong>，我想小伙伴们，应该对最后一个 <code>thisArg</code> 有疑问吧，现在就来解释一下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.sum = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">this</span>.cnt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在原型上添加一个名为 doSth 方法</span></span><br><span class="line">Foo.prototype.doSth = <span class="function"><span class="keyword">function</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  arr.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">cur</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.sum += cur;</span><br><span class="line">    <span class="built_in">this</span>.cnt++;</span><br><span class="line">  &#125;, <span class="built_in">this</span>) <span class="comment">// this 指向实例对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">new</span> Foo();</span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">foo.doSth(arr);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(foo.sum, foo.cnt);</span><br><span class="line"><span class="comment">// 6 3</span></span><br><span class="line"><span class="comment">// 解释： 6 === (1+2+3)  3 === (1+1+1)</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：如果使用<code>箭头函数表达式</code>来传入函数参数， thisArg 参数会被忽略，因为箭头函数在词法上绑定了 this 值。</p></blockquote><p>因此，如果对于普通函数的话，可以看做是将 <code>this</code> 通过传参的形式解决<strong>无法继承</strong> 问题，当然，通过箭头函数的方式是一个不错的选择！</p><h3 id="map-遍历"><a href="#map-遍历" class="headerlink" title="map 遍历"></a>map 遍历</h3><p>定义：返回一个新数组，其结果是该数组中的每个元素是调用一次提供的回调函数后的返回值。</p><p>先来介绍语法：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> newArray = array.map(<span class="function"><span class="keyword">function</span>(<span class="params">currentValue, index, arr</span>), <span class="title">thisArg</span>)</span></span><br></pre></td></tr></table></figure><blockquote><p>callback:为数组中每个元素执行的函数，该函数接收一至三个参数<br>currentValue 数组中正在处理的当前元素<br>index (可选)  数组中正在处理的当前元素的索引<br>arr (可选)    map() 方法正在操作的数组<br>thisArg      可选参数,当执行回调函数callback,用作this值</p></blockquote><p>简单例子：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;Chocolate&#x27;</span>, <span class="string">&#x27;zhlll&#x27;</span>, <span class="string">&#x27;lionkk&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> newArr = arr.map(<span class="function"><span class="keyword">function</span> (<span class="params">cur, index, arr</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(cur, index, arr);</span><br><span class="line">  <span class="keyword">return</span> cur + index;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// Chocolate 0 [ &#x27;Chocolate&#x27;, &#x27;zhlll&#x27;, &#x27;lionkk&#x27; ]</span></span><br><span class="line"><span class="comment">// zhlll 1 [ &#x27;Chocolate&#x27;, &#x27;zhlll&#x27;, &#x27;lionkk&#x27; ]</span></span><br><span class="line"><span class="comment">// lionkk 2 [ &#x27;Chocolate&#x27;, &#x27;zhlll&#x27;, &#x27;lionkk&#x27; ]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(newArr)</span><br><span class="line"><span class="comment">// [ &#x27;Chocolate0&#x27;, &#x27;zhlll1&#x27;, &#x27;lionkk2&#x27; ]</span></span><br></pre></td></tr></table></figure><p><strong>疑难点</strong>，我想小伙伴们，有了前置问题了，这次理解 <code>thisArg</code> 应该没有太多问题了吧，看看下面例子：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.sum = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">this</span>.cnt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在原型上添加一个名为 doSth 方法</span></span><br><span class="line">Foo.prototype.doSth = <span class="function"><span class="keyword">function</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> newArr = arr.map(<span class="function"><span class="keyword">function</span> (<span class="params">cur</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.sum += cur;</span><br><span class="line">    <span class="built_in">this</span>.cnt++;</span><br><span class="line">    <span class="keyword">return</span> cur + <span class="number">10</span>;</span><br><span class="line">  &#125;, <span class="built_in">this</span>) <span class="comment">// this 指向实例对象</span></span><br><span class="line">  <span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">new</span> Foo();</span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(foo.doSth(arr)); <span class="comment">// [ 11, 12, 13 ]</span></span><br><span class="line"><span class="built_in">console</span>.log(foo.sum);<span class="comment">// 6</span></span><br><span class="line"><span class="built_in">console</span>.log(foo.cnt);<span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p><strong>一些小操作</strong>~</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>];</span><br><span class="line"><span class="keyword">let</span> res = arr.map(<span class="built_in">Math</span>.sqrt); <span class="comment">// 传入Math中sqrt得到数组中每个元素的平方根</span></span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// [ 1, 2, 3, 4 ]</span></span><br></pre></td></tr></table></figure><p><strong>总结</strong>：</p><ul><li><code>map</code> 不修改调用它的原数组本身（当然可以在 <code>callback</code> 执行时改变原数组）<br>回调函数不返回值时，最后新数组的每个值都为<code>undefined</code></li><li><code>this</code> 的值最终相对于 <code>callback</code> 函数的可观察性是依据this规则，也就是 <code>this</code> 指向问题</li><li><code>map</code> 会返回一个新数组</li></ul><h3 id="reduce-遍历"><a href="#reduce-遍历" class="headerlink" title="reduce 遍历"></a>reduce 遍历</h3><p>定义：对数组中的每个元素执行一个由您提供的 <code>reducer</code> 函数(升序执行)，将其结果汇总为单个返回值。</p><p>先来介绍语法：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> res= array.reduce(callback(accumulator, currentValue, currentIndex, array), initialValue)</span><br></pre></td></tr></table></figure><blockquote><p>callback:为数组中每个元素执行的函数，该函数接收一至4个参数<br>accumulator 累计器<br>currentValue 当前值<br>currentIndex 当前索引<br>array 数组<br>initialValue 作为第一次调用 callback函数时的第一个参数的值。 如果没有提供初始值，则将使用数组中的第一个元素。 在没有初始值的空数组上调用 reduce 将报错。</p></blockquote><p>简单例子：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">let</span> res = arr.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">acc, cur, index, arr</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(acc, cur, index, arr);</span><br><span class="line">  <span class="keyword">return</span> acc + cur;</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="comment">// 0 3 0 [ 3, 5, 7, 1, 2 ]</span></span><br><span class="line"><span class="comment">// 3 5 1 [ 3, 5, 7, 1, 2 ]</span></span><br><span class="line"><span class="comment">// 8 7 2 [ 3, 5, 7, 1, 2 ]</span></span><br><span class="line"><span class="comment">// 15 1 3 [ 3, 5, 7, 1, 2 ]</span></span><br><span class="line"><span class="comment">// 16 2 4 [ 3, 5, 7, 1, 2 ]</span></span><br><span class="line"><span class="built_in">console</span>.log(res);</span><br><span class="line"><span class="comment">// 18</span></span><br></pre></td></tr></table></figure><p>看完上面代码，你可能还是蒙的，怎么一下输出这么多，结合下面 <code>gif</code> 动图再来理解一下吧：<br><img src= "/img/loading.gif" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8964ecb3bc7f465087852555aee0a044~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p><strong>疑难点</strong>，我想小伙伴们对于参数那么多应该一下给看懵了，下面用一些小操作展示一下，并且提供一点自测题目加深巩固~</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> res = arr.reduce(<span class="function">(<span class="params">acc, cur</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> acc + cur;</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="built_in">console</span>.log(res);<span class="comment">// 15</span></span><br></pre></td></tr></table></figure><p>自测题：看看下面输出什么?</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].reduce(<span class="function">(<span class="params">x, y</span>) =&gt;</span> <span class="built_in">console</span>.log(x, y));</span><br></pre></td></tr></table></figure><ul><li>A: <code>1</code> <code>2</code> and <code>3</code> <code>3</code> and <code>6</code> <code>4</code></li><li>B: <code>1</code> <code>2</code> and <code>2</code> <code>3</code> and <code>3</code> <code>4</code></li><li>C: <code>1</code> <code>undefined</code> and <code>2</code> <code>undefined</code> and <code>3</code> <code>undefined</code> and <code>4</code> <code>undefined</code></li><li>D: <code>1</code> <code>2</code> and <code>undefined</code> <code>3</code> and <code>undefined</code> <code>4</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-D"><a href="#答案-D" class="headerlink" title="答案: D"></a>答案: D</h4><p><code>reducer</code> 函数接收4个参数:</p><ol><li>Accumulator (acc) (累计器)</li><li>Current Value (cur) (当前值)</li><li>Current Index (idx) (当前索引)</li><li>Source Array (src) (源数组)</li></ol><p><code>reducer</code> 函数的返回值将会分配给累计器，该返回值在数组的每个迭代中被记住，并最后成为最终的单个结果值。</p><p><code>reducer</code> 函数还有一个可选参数<code>initialValue</code>, 该参数将作为第一次调用回调函数时的第一个参数的值。如果没有提供<code>initialValue</code>，则将使用数组中的第一个元素。</p><p>在上述例子，<code>reduce</code>方法接收的第一个参数(Accumulator)是<code>x</code>, 第二个参数(Current Value)是<code>y</code>。</p><p>在第一次调用时，累加器<code>x</code>为<code>1</code>，当前值<code>“y”</code>为<code>2</code>，打印出累加器和当前值：<code>1</code>和<code>2</code>。</p><p>例子中我们的回调函数没有返回任何值，只是打印累加器的值和当前值。如果函数没有返回值，则默认返回<code>undefined</code>。 在下一次调用时，累加器为<code>undefined</code>，当前值为“3”, 因此<code>undefined</code>和<code>3</code>被打印出。</p><p>在第四次调用时，回调函数依然没有返回值。 累加器再次为 <code>undefined</code> ，当前值为“4”。 <code>undefined</code>和<code>4</code>被打印出。</p></p></details><hr><p><strong>总结</strong>：</p><ul><li>如果数组为空且没有提供 <code>initialValue</code>，会抛出<code>TypeError</code> 。</li><li>如果没有提供 <code>initialValue</code>，<code>reduce</code> 会从索引1的地方开始执行 <code>callback</code> 方法，跳过第一个索引。如果提供 <code>initialValue</code> ，从索引0开始。</li><li><code>acc</code>为传入函数的返回值，如果是 <code>console.log</code>，则返回默认值 <code>undefined</code></li></ul><h3 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h3><p>定义：创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。</p><p>先来介绍语法：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> newArray = array.filter(<span class="function"><span class="keyword">function</span>(<span class="params">currentValue, index, arr</span>), <span class="title">thisArg</span>)</span></span><br></pre></td></tr></table></figure><blockquote><p>callback:为数组中每个元素执行的函数，该函数接收一至三个参数<br>currentValue 数组中正在处理的当前元素<br>index (可选)  数组中正在处理的当前元素的索引<br>arr (可选)    filter() 方法正在操作的数组<br>thisArg（可选参数）,当执行回调函数callback,用作this值</p></blockquote><p>简单例子：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> newArr = arr.filter(<span class="function"><span class="keyword">function</span> (<span class="params">cur, index</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(cur, index);</span><br><span class="line">  <span class="keyword">return</span> cur % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 1 0</span></span><br><span class="line"><span class="comment">// 2 1</span></span><br><span class="line"><span class="comment">// 3 2</span></span><br><span class="line"><span class="comment">// 4 3</span></span><br><span class="line"><span class="comment">// 5 4</span></span><br><span class="line"><span class="built_in">console</span>.log(newArr); <span class="comment">// [ 2, 4 ]</span></span><br></pre></td></tr></table></figure><p>关于 <code>thisArg</code> 相关可以参考上文 <code>array.forEach() 方法</code> 部分。</p><p>简单来说，就是返回满足条件的结果。</p><h3 id="every"><a href="#every" class="headerlink" title="every()"></a>every()</h3><p>定义：测试一个数组内的所有元素是否<strong>都能通过</strong>某个指定函数的测试，它返回的是一个 <code>Boolean</code> 类型的值。</p><p>先来介绍语法：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">array.every(<span class="function"><span class="keyword">function</span>(<span class="params">currentValue, index, arr</span>), <span class="title">thisArg</span>)</span></span><br></pre></td></tr></table></figure><blockquote><p>callback:为数组中每个元素执行的函数，该函数接收一至三个参数<br> currentValue 数组中正在处理的当前元素<br>index (可选)  数组中正在处理的当前元素的索引<br>arr (可选)  every() 方法正在操作的数组<br>thisArg 可选参数,当执行回调函数callback,用作this值</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> res1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].every(<span class="function"><span class="keyword">function</span> (<span class="params">cur</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> cur &gt; <span class="number">10</span>;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(res1); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> res2 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].every(<span class="function"><span class="keyword">function</span> (<span class="params">cur</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> cur &gt;= <span class="number">1</span>;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(res2); <span class="comment">// true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>关于 <code>thisArg</code> 相关可以参考上文 <code>array.forEach() 方法</code> 部分。</p><p>简单来说，就是返回是否<strong>都能满足</strong>特定条件的结果，用布尔值返回。</p><h3 id="some"><a href="#some" class="headerlink" title="some()"></a>some()</h3><p>定义：测试数组中是不是<strong>至少有1个元素通过</strong>了被提供的函数测试，它返回的是一个 <code>Boolean</code> 类型的值</p><p>先来介绍语法：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">array.some(<span class="function"><span class="keyword">function</span>(<span class="params">currentValue, index, arr</span>), <span class="title">thisArg</span>)</span></span><br></pre></td></tr></table></figure><blockquote><p>callback:为数组中每个元素执行的函数，该函数接收一至三个参数<br>currentValue 数组中正在处理的当前元素<br>index (可选)  数组中正在处理的当前元素的索引<br>arr (可选)    some() 方法正在操作的数组<br> thisArg     （可选参数）,当执行回调函数callback,用作this值</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> res1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].some(<span class="function"><span class="keyword">function</span> (<span class="params">cur</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> cur &gt; <span class="number">10</span>;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(res1); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> res2 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].some(<span class="function"><span class="keyword">function</span> (<span class="params">cur</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> cur === <span class="number">1</span>;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(res2); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>关于 <code>thisArg</code> 相关可以参考上文 <code>array.forEach() 方法</code> 部分。</p><p>简单来说，就是返回是否<strong>至少有1个满足</strong>特定条件的结果，用布尔值返回。</p><h3 id="find-和-findIndex"><a href="#find-和-findIndex" class="headerlink" title="find 和 findIndex"></a>find 和 findIndex</h3><blockquote><p>该方法在ECMAScript 6规范中被加入，可能不存在于某些实现中。</p></blockquote><p>定义：</p><p><code>find</code>:  返回数组中满足提供的测试函数的第一个元素的值。否则返回  <code>undefined</code>。</p><p><code>findIndex</code>：数组中通过提供测试函数的第一个元素的索引。否则，返回 <code>-1</code>。</p><p>先来介绍语法：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> ele = array.find(<span class="function"><span class="keyword">function</span>(<span class="params">elemnet, index, arr</span>), <span class="title">thisArg</span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">let</span> <span class="title">eleIndex</span> = <span class="title">array</span>.<span class="title">findIndex</span>(<span class="params"><span class="keyword">function</span>(elemnet, index, arr), thisArg</span>)</span></span><br></pre></td></tr></table></figure><blockquote><p>callback:为数组中每个元素执行的函数，该函数接收一至三个参数<br> elemnet 数组中正在处理的当前元素<br> index (可选)  数组中正在处理的当前元素的索引<br>arr (可选)     find方法正在操作的数组<br>thisArg      可选参数,当执行回调函数callback,用作this值</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> res1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].find(<span class="function"><span class="keyword">function</span> (<span class="params">cur</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> cur &gt; <span class="number">2</span>;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(res1); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> res2 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].findIndex(<span class="function"><span class="keyword">function</span> (<span class="params">cur</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> cur &gt; <span class="number">2</span>;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(res2); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h3 id="keys-与-values-与-entries"><a href="#keys-与-values-与-entries" class="headerlink" title="keys 与 values 与 entries"></a>keys 与 values 与 entries</h3><p>定义：</p><ul><li><code>keys()</code> 方法返回一个包含数组中每个索引键的 <strong>Array Iterator</strong> 对象。</li><li><code>values()</code> 方法返回一个新的 <code>Array Iterator</code> 对象，该对象包含数组每个<strong>索引的值</strong></li><li><code>entries()</code> 方法返回一个新的 <code>Array Iterator</code> 对象，该对象包含数组中每个<strong>索引的键/值对</strong>。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arr.keys()</span><br><span class="line">arr.values()</span><br><span class="line">arr.entries()</span><br></pre></td></tr></table></figure><p>简单例子：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;Chocolate&#x27;</span>, <span class="string">&#x27;zhlll&#x27;</span>, <span class="string">&#x27;lionkk&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> itKeys = arr.keys();</span><br><span class="line"><span class="keyword">let</span> itVals = arr.values();</span><br><span class="line"><span class="keyword">let</span> itEntries = arr.entries();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> it <span class="keyword">of</span> itKeys) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(it);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> it <span class="keyword">of</span> itVals) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(it);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Chocolate</span></span><br><span class="line"><span class="comment">// zhlll</span></span><br><span class="line"><span class="comment">// lionkk</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> it <span class="keyword">of</span> itEntries) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(it);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [ 0, &#x27;Chocolate&#x27; ]</span></span><br><span class="line"><span class="comment">// [ 1, &#x27;zhlll&#x27; ]</span></span><br><span class="line"><span class="comment">// [ 2, &#x27;lionkk&#x27; ]</span></span><br></pre></td></tr></table></figure><hr><p>好了，到此关于数组的遍历方式基本上介绍完毕了，也许还有其它方法，但是万变不离其宗，接下来我们将探究 <strong>改变原数组</strong> 的方法。</p><h2 id="改变原始数组方法"><a href="#改变原始数组方法" class="headerlink" title="改变原始数组方法"></a>改变原始数组方法</h2><p>看过我之前关于 <code>Vue</code> 数据劫持源码分析<a href="https://juejin.cn/post/6882210480040263693">那篇博客文章</a>小伙伴应该知道，里面就有提到了用<strong>装饰者模式</strong>解决无法处理数组问题。其中就有提到对于改变原始数组的方法，这些需要继续递归观察。那么，接下来，我们就来分别探讨一下它们的使用：</p><h3 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h3><blockquote><p>至于为什么我会排第一个，对，面试遇到过，当时我说对某手面试官说默认按照从小到大进行排序，通过学习后，我发现不是的…</p></blockquote><p>先来介绍语法：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arr.sort([compareFunction])</span><br></pre></td></tr></table></figure><blockquote><p>compareFunction 可选，用来指定按某种顺序进行排列的函数。<br>如果省略，元素按照转换为的字符串的各个字符的Unicode位点进行排序。<br>否则，如果指明了compareFunction：<br> 如果 compareFunction(a, b) 小于 0 ，那么 a 会被排列到 b 之前；<br> 如果 compareFunction(a, b) 等于 0 ， a 和 b 的相对位置不变。<br> 如果 compareFunction(a, b) 大于 0 ， b 会被排列到 a 之前。</p></blockquote><p>简单例子：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">10</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">arr.sort(); <span class="comment">// 默认</span></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [ 1, 10, 2, 3, 5, 8 ]</span></span><br><span class="line"></span><br><span class="line">arr.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b); <span class="comment">// 从小到大排序</span></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [ 1, 2, 3, 5, 8, 10 ]</span></span><br><span class="line"></span><br><span class="line">arr.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> b - a); <span class="comment">// 从大到小排序</span></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [ 10, 8, 5, 3, 2, 1 ]</span></span><br></pre></td></tr></table></figure><h3 id="push"><a href="#push" class="headerlink" title="push()"></a>push()</h3><blockquote><p>类似栈、队列的一些操作</p></blockquote><p><strong>注意</strong>，<code>push()</code> 成功之后会返回数组的长度。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>];</span><br><span class="line"><span class="keyword">let</span> res = arr.push(<span class="number">100</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [ 1, 2, 100 ]</span></span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><h3 id="pop"><a href="#pop" class="headerlink" title="pop()"></a>pop()</h3><blockquote><p>类似栈、队列的一些操作</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">100</span>];</span><br><span class="line"><span class="keyword">let</span> res = arr.pop();</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [ 1, 2 ]</span></span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// 100</span></span><br></pre></td></tr></table></figure><h3 id="shift"><a href="#shift" class="headerlink" title="shift()"></a>shift()</h3><blockquote><p>类似栈、队列的一些操作</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">100</span>];</span><br><span class="line"><span class="keyword">let</span> res = arr.shift();</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [ 2, 100 ]</span></span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h3 id="unshift"><a href="#unshift" class="headerlink" title="unshift()"></a>unshift()</h3><p>定义：将一个或多个元素添加到 <strong>数组的开头</strong>，并 (该方法修改原有数组)</p><p><strong>注意</strong>：该方法会返回该数组的新长度</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">100</span>];</span><br><span class="line"><span class="keyword">let</span> res = arr.unshift(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [ 4, 5, 6, 1, 2, 100 ]</span></span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><h3 id="reverse"><a href="#reverse" class="headerlink" title="reverse()"></a>reverse()</h3><p>定义：将数组中元素的位置颠倒，并返回该数组。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr.reverse();</span><br><span class="line"><span class="built_in">console</span>.log(arr);<span class="comment">// [ 3, 2, 1 ]</span></span><br></pre></td></tr></table></figure><h3 id="splice"><a href="#splice" class="headerlink" title="splice()"></a>splice()</h3><blockquote><p>这个我放最后一个也是有原因的，它比其它几个要更复杂一点，刚开始我也是花了老长时间才理解，而且原本一直与 <code>split()</code> 这些分不清楚。</p></blockquote><p>定义：</p><p>通过<strong>删除或替换</strong>现有元素或者原地添加新的元素来修改数组,并以数组形式返回被修改的内容。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">array.splice(start,deleteCount,item1,.....,itemX)z</span><br></pre></td></tr></table></figure><blockquote><p>start: 指定修改的开始位置（从0计数）<br>        1. 如果超出了数组的长度，则从数组末尾开始添加内容<br>        2. 如果是负值，则表示从数组末位开始的第几位（从-1计数，这意味着-n是倒数第n个元素，并且等价于array.length-n）<br>        3. 如果负数的绝对值大于数组的长度，则表示开始位置为第0位</p></blockquote><blockquote><p>deleteCount(可选) : 整数,表示要移除的数组元素个数<br>        1. 如果 deleteCount 大于 start 之后的元素的总数，则从 start 后面的元素都将被            删除(含第 start 位)<br>        2. 如果 deleteCount 被省略了，或者它的值大于等于array.length - start(也就是           说，如果它大于或者等于start之后的所有元素的数量)，那么start之后数组的所有元素都会被删除。<br>        3. 如果 deleteCount 是 0 或者负数，则不移除元素。这种情况下，至少应添加一个新           元素。</p></blockquote><blockquote><p>item1, item2, …(可选)<br>要添加进数组的元素,从start 位置开始。如果不指定，则 splice() 将只删除数组元素。</p></blockquote><p>从第2位开始插入“Chocolate”</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>];</span><br><span class="line"></span><br><span class="line">arr.splice(<span class="number">2</span>, <span class="number">0</span>, <span class="string">&#x27;Chocolate&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr);<span class="comment">// [ &#x27;one&#x27;, &#x27;two&#x27;, &#x27;Chocolate&#x27;, &#x27;three&#x27; ]</span></span><br></pre></td></tr></table></figure><p>从第 2 位开始删除 1 个元素，然后插入“Chocolate”</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>];</span><br><span class="line"></span><br><span class="line">arr.splice(<span class="number">2</span>, <span class="number">1</span>, <span class="string">&#x27;Chocolate&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr);<span class="comment">// [ &#x27;one&#x27;, &#x27;two&#x27;, &#x27;Chocolate&#x27; ]</span></span><br></pre></td></tr></table></figure><blockquote><p>主流的还是这7个方法，对于改变原数组还有 <code>fill()</code> 和 <code>copyWithin()</code> 方法，小伙伴们可以继续研究~</p></blockquote><hr><h2 id="数组的映射"><a href="#数组的映射" class="headerlink" title="数组的映射"></a>数组的映射</h2><h3 id="Array-map-方法"><a href="#Array-map-方法" class="headerlink" title="Array.map()方法"></a>Array.map()方法</h3><blockquote><p>上文已经介绍</p></blockquote><h3 id="Array-from-方法"><a href="#Array-from-方法" class="headerlink" title="Array.from()方法"></a>Array.from()方法</h3><p>定义：通过在每个数组项上使用 <code>callback</code> 调用结果来创建一个新数组。</p><p>先来介绍语法：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from(<span class="built_in">Array</span>,callback(currentValue, index, arr))</span><br></pre></td></tr></table></figure><p>简单例子：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> newArr = <span class="built_in">Array</span>.from(arr, <span class="function"><span class="keyword">function</span> (<span class="params">cur</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> cur + <span class="number">10</span>;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(newArr);<span class="comment">// [ 11, 12, 13 ]</span></span><br></pre></td></tr></table></figure><hr><h2 id="数组的连接"><a href="#数组的连接" class="headerlink" title="数组的连接"></a>数组的连接</h2><h3 id="Array-concat-方法"><a href="#Array-concat-方法" class="headerlink" title="Array.concat() 方法"></a>Array.concat() 方法</h3><p><code>array.concat(array1[, array2, ...])</code> 将一个或多个数组连接到原始数组。如下所示，连接两个数组：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arrA = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> arrB = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="keyword">let</span> ans = arrA.concat(arrB);</span><br><span class="line"><span class="built_in">console</span>.log(ans);<span class="comment">// [ 1, 2, 3, 4, 5, 6 ]</span></span><br></pre></td></tr></table></figure><h3 id="展开操作符"><a href="#展开操作符" class="headerlink" title="展开操作符"></a>展开操作符</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arrA = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> arrB = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="keyword">let</span> ans = [...arrA, ...arrB];</span><br><span class="line"><span class="built_in">console</span>.log(ans);<span class="comment">// [ 1, 2, 3, 4, 5, 6 ]</span></span><br></pre></td></tr></table></figure><hr><h2 id="获取数组的片段"><a href="#获取数组的片段" class="headerlink" title="获取数组的片段"></a>获取数组的片段</h2><h3 id="Array-slice-方法"><a href="#Array-slice-方法" class="headerlink" title="Array.slice() 方法"></a>Array.slice() 方法</h3><p>定义：<br>返回一个新的数组对象，这一对象是一个由 <code>begin</code> 和 <code>end</code> 决定的原数组的<strong>浅拷贝</strong>（包括 <code>begin</code>，不包括 <code>end</code>）——原始数组不会被改变。</p><p>先介绍语法：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arr.slice([begin[, end]])</span><br></pre></td></tr></table></figure><blockquote><p>begin (可选)</p></blockquote><ol><li>提取起始处的索引（从 0 开始），从该索引开始提取原数组元素。</li><li>如果该参数为负数，则表示从原数组中的倒数第几个元素开始提取</li><li>slice(-2) 表示提取原数组中的倒数第二个元素到最后一个元素（包含最后一个元素）</li><li>如果省略 begin，则 slice 从索引 0 开始。</li><li>如果 begin 大于原数组的长度，则会返回空数组。    </li></ol><blockquote><p>end   (可选)</p></blockquote><ol><li>slice(1,4) 会提取原数组中从第二个元素开始一直到第四个元素的所有元素 （索引为 1, 2, 3的元素）</li><li>如果该参数为负数， 则它表示在原数组中的倒数第几个元素结束抽取。</li><li>如果 end 被省略，则 slice 会一直提取到原数组末尾。</li><li>如果 end 大于数组的长度，slice 也会一直提取到原数组末尾。</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fruits = [<span class="string">&#x27;Banana&#x27;</span>, <span class="string">&#x27;Orange&#x27;</span>, <span class="string">&#x27;Lemon&#x27;</span>, <span class="string">&#x27;Apple&#x27;</span>, <span class="string">&#x27;Mango&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> res = fruits.slice(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">let</span> res1 = fruits.slice(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> res2 = fruits.slice(-<span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> res3 = fruits.slice(<span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// [ &#x27;Orange&#x27;, &#x27;Lemon&#x27; ]</span></span><br><span class="line"><span class="built_in">console</span>.log(res1);<span class="comment">// [ &#x27;Orange&#x27;, &#x27;Lemon&#x27;, &#x27;Apple&#x27;, &#x27;Mango&#x27; ]</span></span><br><span class="line"><span class="built_in">console</span>.log(res2);<span class="comment">// [ &#x27;Mango&#x27; ]</span></span><br><span class="line"><span class="built_in">console</span>.log(res3);<span class="comment">// [ &#x27;Banana&#x27;, &#x27;Orange&#x27;, &#x27;Lemon&#x27;, &#x27;Apple&#x27; ]</span></span><br></pre></td></tr></table></figure><hr><h2 id="转换数组"><a href="#转换数组" class="headerlink" title="转换数组"></a>转换数组</h2><h3 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h3><p>定义：</p><p>将一个数组（或一个类数组对象）的所有元素连接成一个字符串并返回这个字符串。如果数组只有一个项目，那么将返回该项目而不使用分隔符。</p><p>语法:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arr.join(separator)</span><br></pre></td></tr></table></figure><p>简单例子：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> res = arr.join(<span class="string">&#x27;^&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> res1 = arr.join(<span class="string">&#x27;&amp;&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// one^two^three</span></span><br><span class="line"><span class="built_in">console</span>.log(res1); <span class="comment">// one&amp;two&amp;three</span></span><br></pre></td></tr></table></figure><h3 id="split"><a href="#split" class="headerlink" title="split()"></a>split()</h3><p>定义：</p><p>使用指定的分隔符字符串将一个 <code>String</code> 对象分割成子字符串数组，以一个指定的分割字串来决定每个拆分的位置。 </p><p>语法：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">str.split([separator[, limit]])</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&#x27;The best Chocolate&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> words = str.split(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(words); <span class="comment">// [ &#x27;The&#x27;, &#x27;best&#x27;, &#x27;Chocolate&#x27; ]</span></span><br><span class="line"><span class="built_in">console</span>.log(words[<span class="number">2</span>]); <span class="comment">// Chocolate</span></span><br></pre></td></tr></table></figure><h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h3><p>定义：</p><p>返回一个字符串，表示指定的数组及其元素。</p><blockquote><p>当一个数组被作为文本值或者进行字符串连接操作时，将会<code>自动调用</code>其 <code>toString</code> 方法。</p></blockquote><p>语法:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arr.toString()</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.toString()); <span class="comment">// one,two,three</span></span><br></pre></td></tr></table></figure><hr><h2 id="数组的扁平化"><a href="#数组的扁平化" class="headerlink" title="数组的扁平化"></a>数组的扁平化</h2><h3 id="flat"><a href="#flat" class="headerlink" title="flat()"></a>flat()</h3><p>定义：</p><p>按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个<code>新数组</code>返回。</p><p>语法：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> newArray = arr.flat([depth])</span><br></pre></td></tr></table></figure><blockquote><p>参数<br>depth 可选<br>指定要提取嵌套数组的结构深度，默认值为 1。<br>返回值<br>一个包含将数组与子数组中所有元素的新数组。</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]];</span><br><span class="line"><span class="built_in">console</span>.log(arr1.flat()); <span class="comment">// [ 0, 1, 2, 3, 4 ]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, [[[<span class="number">3</span>, <span class="number">4</span>]]]];</span><br><span class="line"><span class="built_in">console</span>.log(arr2.flat(<span class="number">2</span>)); <span class="comment">// [ 0, 1, 2, [ 3, 4 ] ]</span></span><br></pre></td></tr></table></figure><hr><h2 id="备忘录"><a href="#备忘录" class="headerlink" title="备忘录"></a>备忘录</h2><p><img src= "/img/loading.gif" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d5b18b7727bb4ad1acbaa7afba2d7c34~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><blockquote><p>女朋友表示说：感动了！</p></blockquote><h2 id="本文参考"><a href="#本文参考" class="headerlink" title="本文参考"></a>本文参考</h2><p>感谢大佬~</p><ul><li><a href="https://juejin.cn/post/6846687601806557192">「数组方法」从详细操作js数组到浅析v8中array.js</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array">MDN_Array</a></li><li><a href="https://juejin.cn/post/6844904004703485966">通过事例重温一下 JS 中 常见的15 种数组操作(备忘清单)</a></li><li><a href="https://juejin.cn/post/6844904194919366669">JS数组奇巧淫技</a></li><li><a href="https://juejin.cn/post/6844903801107775496">JS之数组的几个不low操作</a></li></ul><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>文章产出不易，还望各位小伙伴们支持一波！</p><p>往期精选：</p><p><a href="https://github.com/Chocolate1999/Front-end-learning-to-organize-notes">小狮子前端の笔记仓库</a></p><p><a href="https://github.com/Chocolate1999/leetcode-javascript">leetcode-javascript：LeetCode 力扣的 JavaScript 解题仓库，前端刷题路线（思维导图）</a></p><p>小伙伴们可以在Issues中提交自己的解题代码，🤝 欢迎Contributing，可打卡刷题，Give a ⭐️ if this project helped you!</p><p><a href="https://yangchaoyi.vip/">访问超逸の博客</a>，方便小伙伴阅读玩耍~</p><p><img src= "/img/loading.gif" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/55bb174589004a4d8619cb479efaa07b~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">学如逆水行舟，不进则退</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 写给女友 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> JS </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「星辰大海」Chocolate 同学 前端学习路线总结【建议收藏】</title>
      <link href="posts/2021520/"/>
      <url>posts/2021520/</url>
      
        <content type="html"><![CDATA[<h2 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h2><p>哈喽，小伙伴，很高兴你能阅读我的这篇文章，能点进来也是一份缘分，在这篇文章你将收获许多干货。</p><blockquote><p>简短介绍：【CSDN】【掘金】【B站】【知乎】【Github】【<a href="https://yangchaoyi.vip】【公众号：小狮子前端】重度使用者。">https://yangchaoyi.vip】【公众号：小狮子前端】重度使用者。</a><br>JS，TS，LeetCode，Vue，React，算法爱好者。<br>座右铭：学如逆水行舟，不进则退！ </p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近很多小伙伴们以及学弟学妹们都来私信我，询问我前端是怎么学习的，想了又想，还是打算写一份自己的前端学习路线，至于为什么要写这一份前端学习路线呢？我觉得有如下几点：</p><ul><li>春招以及秋招过程受很多大佬的教导，最终的offer离不开他们的支持，我想着自己受到过许多人的帮助，而自己写一份学习路线，也是一份 <strong>回馈</strong>。</li><li><strong>很早就想</strong>写一份学习路线图，但整个秋招下来又让我停止了脚步，我觉得还是要继续扎实基础，但现在，我<strong>有了时间</strong>来输出一些文章，因此，这篇文章它来了！</li><li>临近毕业，有许多不舍，我也想留下一些有价值的东西，那就是将自己学习过程中的坑埋住，少走我的坑，让学弟学妹们看到后能有一份<strong>指导</strong>路线。</li><li>一份<strong>挑战</strong>，我也在带人学习，她会参加2021年春招，这份学习路线基本上就是我教导的学习路线，因此即是一份学习路线，也是一份挑战，并且这份路线是会<strong>持续更新</strong>到2021年春招结束。</li><li>座右铭：<strong>学如逆水行舟，不进则退！</strong>  我也在征途中<strong>重温基础知识</strong>，为后续工作做准备。</li></ul><blockquote><p>简简单单，主要就是如上五点了，一些关键理由已经加粗标记啦~</p></blockquote><h3 id="小狮子前端-技术交流"><a href="#小狮子前端-技术交流" class="headerlink" title="小狮子前端 技术交流"></a>小狮子前端 技术交流</h3><p>友情提醒：博主建了一个【小狮子前端】技术交流群：<code>666151691</code> 欢迎大家加入，在此我会分享前端体系的知识，为你的春秋招保驾护航。群主：<code>Chocolate 同学</code>，同时 <code>小周同学</code> 也会分享优质文章。</p><p>微信公众号同名【小狮子前端】资源、书籍、思维导图会放在这里面，需要的小伙伴自取即可~</p><p><strong>前端博客友链</strong>：</p><p><a href="https://yangchaoyi.vip/">超逸の博客</a>： <a href="https://yangchaoyi.vip/">https://yangchaoyi.vip/</a></p><p> <a href="https://hearling.github.io/">HearLingの博客</a>: <a href="https://hearling.github.io/">https://hearling.github.io/</a></p><blockquote><p>我们的征途是星辰大海，祝愿我们都能见证努力之后的成功！</p></blockquote><h2 id="阅读须知"><a href="#阅读须知" class="headerlink" title="阅读须知"></a>阅读须知</h2><p>这一模块<strong>一定要阅读！一定要阅读！一定要阅读！</strong></p><blockquote><p>本篇文章是会不断更新的，首发在 <a href="https://yangchaoyi.vip/">yangchaoyi.vip</a> 超逸の博客上。建议收藏在书签栏，或者记住我的域名 <code>yangchaoyi.vip</code>。</p></blockquote><p>上文已经介绍，这篇博客将会持续更新到 <code>2021年春招结束</code>，我想到那时候应该是一份比较<strong>详细完备</strong>的前端学习路线了，在此，也承诺（<code>promise</code>）本篇文章绝对不鸽，同时，你也可以评论区来催更我（尽管不一定有效，但评论留个言踩个脚印又不是不可以是吧？）</p><blockquote><p>其次，本文会推荐一些我在学习过程中用到的一些小工具，一些优质文章，还有一些课程，当然，我觉得 <code>为知识而付费</code> 是有必要的，但是我会尽可能减少你的学习花费，一些相关资源我会在文章中提供给你。</p></blockquote><p>那么，关于 <code>Chocolate</code> 同学前端学习路线文章正式出炉 <code>✿✿ヽ(°▽°)ノ✿</code></p><h2 id="开篇：学好计算机网络，很重要"><a href="#开篇：学好计算机网络，很重要" class="headerlink" title="开篇：学好计算机网络，很重要"></a>开篇：学好计算机网络，很重要</h2><h3 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h3><blockquote><p>可能你会疑问，啊这，前端不就是 <code>html,css,js</code>这些吗？（前端小白的疑问）如果你有这个疑问，你能阅读到这篇文章简直是起飞，这将颠覆你对前端的认知。</p></blockquote><p>我觉得不管是前端还是后端，甚至只要是技术岗位，计算机网络这一门学科都是重中之重，因此在开篇，我们就来系统学习计算机网络原理知识。</p><blockquote><p>尽管我们在学校一般都会开设计算机网络原理的课程，但大学课程很少能让我们掌握的很扎实，基本上学完大部分知识就还给老师了，离谱的可能当天学当天就忘了。</p></blockquote><h3 id="Chocolate-同学的提问"><a href="#Chocolate-同学的提问" class="headerlink" title="Chocolate 同学的提问"></a>Chocolate 同学的提问</h3><blockquote><p>希望你能带着这几个问题学习，同时你在复盘时也可以根据如下问题进行检验。</p></blockquote><ul><li>说说 HTTP 特点</li><li>有了解过 HTTP 队头阻塞吗？如何解决？</li><li>HTTP 中常见请求方法</li><li>例举一些常见 HTTP 状态码</li><li>get 和 post 有什么区别，说一说</li><li>HTTP 报文组成</li><li>例举 HTTP 比较常见的一些首部字段</li><li>说一说 HTTP 中的内容编码与压缩</li><li>Transfer-Encoding 有了解过么</li><li>说一说多部分对象集合(Multipart)</li><li>如何获取部分内容的范围请求？</li><li>HTTP/2 有哪些改进？</li><li>说说你对 Cookie 的理解以及在安全性上面的问题</li><li>为什么需要 HTTPS ，它解决了哪些问题</li><li>说说 HTTP 与 HTTPS 的区别</li><li>对称加密与非对称加密的区别</li><li>怎样验证数签名？</li><li>请你细说一下 HTTPS 加密通信方法具体过程</li><li>SSL/TLS 有了解过么，说一说</li><li>为何不是所有网站都用HTTPS？</li><li>说一说 TCP 和 UDP 的区别？</li><li>TCP 三次握手的过程</li><li>为什么 TCP 需要三次握手，而不是两次，又或者四次以及更多？</li><li>说说 TCP 四次挥手的过程</li><li>为什么需要四次挥手，三次可以吗？</li><li>四次挥手中等待 2MSL 有什么意义？</li><li>说说半连接队列和 SYN Flood 攻击</li><li>TCP 快速打开的原理(TFO) 有了解过么？</li><li>说一说 TCP 的流量控制以及滑动窗口的理解？</li><li>说说 TCP 的拥塞控制？（慢启动、拥塞避免、快速重传和快速恢复）</li><li>什么是跨域？浏览器如何拦截响应？如何解决？</li></ul><h3 id="优质文章推荐"><a href="#优质文章推荐" class="headerlink" title="优质文章推荐"></a>优质文章推荐</h3><p>下面是我在学习 <code>HTTP</code> 经常会看的文章，因此，也建议你 <strong>细读，精读，多读</strong>，整理一份自己的博客，最好也配上思维导图。</p><ul><li><a href="https://juejin.cn/post/6844904127466569736">🐲【1】ShutdownHTTP系列-基础篇</a></li><li><a href="https://juejin.cn/post/6844904168549777422">🐲【2】ShutdownHTTP系列-HTTP报文篇</a></li><li><a href="https://juejin.cn/post/6861605642256252936">🐲【3】Shutdown HTTP系列-Cookie篇</a></li><li><a href="https://juejin.cn/post/6889068972542459917">🐲【4】Shutdown HTTP系列-HTTPS篇</a></li></ul><blockquote><p>当你学完上面四篇文章后，可以继续挑战下面两篇文章，灵魂之问，巩固知识~</p></blockquote><ul><li><a href="https://juejin.cn/post/6844904070889603085">(建议收藏)TCP协议灵魂之问，巩固你的网路底层基础</a></li><li><a href="https://juejin.cn/post/6844904100035821575">（建议精读）HTTP灵魂之问，巩固你的 HTTP 知识体系</a></li></ul><h3 id="小狮子有话说"><a href="#小狮子有话说" class="headerlink" title="小狮子有话说"></a>小狮子有话说</h3><p>最近有粉丝私信看了我对于网络方面的认识，也提出了不仅仅是这些，还有其它部分，例如计算字节存储分辨率大小，对网络带宽影响情况这一系列问题等等，但是我觉得学习应该是持续、坚持的过程，本章节网络方面能够涉及的知识何止这些，简直太多太多，我们能做的是先把基础打牢，这样我们学习其它方面知识也会融会贯通。在没有实际项目经验之前，掌握基础知识，在遇到实际项目时，通过项目让自己成长~</p><blockquote><p>每一发奋努力的背后，必有加倍的赏赐。</p></blockquote><h2 id="互联网的“咽喉”：浏览器工作原理"><a href="#互联网的“咽喉”：浏览器工作原理" class="headerlink" title="互联网的“咽喉”：浏览器工作原理"></a>互联网的“咽喉”：浏览器工作原理</h2><h3 id="前言-2"><a href="#前言-2" class="headerlink" title="前言"></a>前言</h3><p>浏览器工作原理这一块能扯到很多很多的知识，为此我还做了思维导图，一图胜千言。</p><blockquote><p>或许你会好奇这份思维导图怎么出来的，当然是学的呀（滑稽）</p></blockquote><p>进入正题，在此比较推荐极客时间李兵老师讲授的课程 ↓ ，前文也说了减少大家学习的成本与费用，这个课程在极客时间新人价只要1元，我觉得是挺好的，强烈建议大家去阅读。</p><p><a href="https://time.geekbang.org/column/intro/216">浏览器工作原理与实践—透过浏览器看懂前端本质</a></p><blockquote><p>这门课程我是已经获得到了课程证书了，并且最后的知识测评也拿到了100分，有一次在公众号【小狮子前端】推送过文章，文末就有相关图片，感兴趣的小狮子们可以溜达溜达~</p></blockquote><blockquote><p>那么，不是新人用户怎么办，不用担心，我又在 <code>github</code>上找到了相关笔记，<a href="https://blog.poetries.top/browser-working-principle/">极客浏览器工作原理与实践传送门</a></p></blockquote><p>不过对比来的话没有进行更新了，如果你是极客时间新人用户的话，还是建议通过 1 元 购买一份课程，毕竟还是要<strong>支持原创</strong>！</p><h3 id="Chocolate-同学的提问-1"><a href="#Chocolate-同学的提问-1" class="headerlink" title="Chocolate 同学的提问"></a>Chocolate 同学的提问</h3><blockquote><p>希望你能带着这几个问题学习，同时你在复盘时也可以根据如下问题进行检验。</p></blockquote><h4 id="浏览器中的页面"><a href="#浏览器中的页面" class="headerlink" title="浏览器中的页面"></a>浏览器中的页面</h4><blockquote><p>浏览器工作原理思维导图</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20201215100759302.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70#pic_center" alt=""></p><blockquote><p>（手机端可能看不清）获取高清PDF，请在微信公众号【小狮子前端】回复【浏览器工作原理】</p></blockquote><blockquote><p>导航渲染流程思维导图</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/2020121816374542.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70#pic_center" alt=""></p><blockquote><p>（手机端可能看不清）获取高清PDF，请在微信公众号【小狮子前端】回复【导航渲染流程】</p></blockquote><ul><li>进程和线程之间的区别</li><li>为什么很多站点第二次打开速度会很快？</li><li>登录状态是如何保持的？</li><li>HTTP 请求流程（8点）</li><li>导航流程：从输入URL到页面展示，这中间发生了什么？</li><li>渲染流程的具体过程</li><li>重排、重绘与合成它们之间有何区别？</li></ul><h4 id="浏览器安全"><a href="#浏览器安全" class="headerlink" title="浏览器安全"></a>浏览器安全</h4><blockquote><p>浏览器安全思维导图</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20201218163642549.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70#pic_center" alt=""></p><blockquote><p>（手机端可能看不清）获取高清PDF，请在微信公众号【小狮子前端】回复【浏览器安全】</p></blockquote><ul><li>说说你对同源策略的理解</li><li>同源策略、CSP、CROS之间的关系？</li><li>为什么XMLHttpRequest不能跨域请求资源？</li><li>跨站脚本攻击（XSS）有了解过么？如何预防？</li><li>CSRF攻击的理解，如何防范？</li><li>有了解过安全沙箱吗？说一说</li></ul><h4 id="浏览器中的页面循环系统"><a href="#浏览器中的页面循环系统" class="headerlink" title="浏览器中的页面循环系统"></a>浏览器中的页面循环系统</h4><blockquote><p>事件循环系统思维导图</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20201218170231685.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70#pic_center" alt=""></p><blockquote><p>（手机端可能看不清）获取高清PDF，请在微信公众号【小狮子前端】回复【事件循环】</p></blockquote><ul><li>说说你对宏任务、微任务以及消息队列的理解</li><li>各种输出题（见推荐博文↓）</li></ul><h4 id="promise-知识"><a href="#promise-知识" class="headerlink" title="promise 知识"></a>promise 知识</h4><blockquote><p>promise 知识思维导图</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20201218170504232.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70#pic_center" alt=""></p><blockquote><p>（手机端可能看不清）获取高清PDF，请在微信公众号【小狮子前端】回复【promise知识】</p></blockquote><ul><li>谈谈你对 promise 的理解，解决了哪些问题</li><li>async / await 怎么捕获错误</li><li>Promise.all | Promise.race 区别</li><li>如何理解 promise 的固化 | 多层嵌套</li><li>各种输出题（见推荐博文↓）</li></ul><h3 id="优质文章推荐-1"><a href="#优质文章推荐-1" class="headerlink" title="优质文章推荐"></a>优质文章推荐</h3><ul><li><a href="https://juejin.cn/post/6902032954034225159">「导航渲染流程」你真的知道从输入URL到页面展示发生了什么吗？（内附思维导图）</a></li><li><a href="https://juejin.cn/post/6900916440845516814">「浏览器安全」你可能需要的一份浏览器安全的总结（内附思维导图）</a></li><li><a href="https://juejin.cn/post/6846687590540640263">「浏览器工作原理」写给女友的秘籍-浏览器组成&amp;网络请求篇（1.2W字)</a></li><li><a href="https://juejin.cn/post/6847902222349500430">「浏览器工作原理」写给女友的秘籍-渲染流程篇（1.1W字）</a></li><li><a href="https://juejin.cn/post/6902942813097459720">「高频面试题」女友：消息队列 和 事件循环系统终于弄明白了！（内附思维导图）</a></li><li><a href="https://juejin.cn/post/6906106922605543432">「星辰大海」你可能需要知道的 promise 知识的总结（内附思维导图）</a></li><li><a href="https://juejin.cn/post/6854573215830933512">「查缺补漏」送你18道浏览器面试题</a></li><li><a href="https://juejin.cn/post/6847902222349500430">「浏览器工作原理」写给女友的秘籍-渲染流程篇（1.1W字）</a></li></ul><h3 id="小狮子有话说-1"><a href="#小狮子有话说-1" class="headerlink" title="小狮子有话说"></a>小狮子有话说</h3><p>关于浏览器这一块，真算是 <code>互联网的“咽喉”</code>，在前端领域浏览器这块知识非常重要，还是非常建议大家看一看李兵老师的文章，这对于你理解浏览器渲染机制以及思维方面很有帮助。</p><blockquote><p>自己选的路，跪着也要走完。</p></blockquote><h2 id="前端工程师能力体现：JavaScript"><a href="#前端工程师能力体现：JavaScript" class="headerlink" title="前端工程师能力体现：JavaScript"></a>前端工程师能力体现：JavaScript</h2><h3 id="前言-3"><a href="#前言-3" class="headerlink" title="前言"></a>前言</h3><p>对于JS来说，我觉得是整个前端工程师能力的体现，JS基本功扎实，不仅对于面试很有帮助，还对于源码理解，框架使用方面都大有用处。比如大家都觉得 <code>React</code>很难，然后都去学习 <code>Vue</code>，那么如果一个岗位就是只招 <code>React</code>，那么如果你会的话，岂不是一下少了很多竞争对手，并且在我看来，<code>Vue</code> 和 <code>React</code> 只是方便我们开发的一个工具，只要 <code>JS</code> 能力足够强，学起来也不是很难的。</p><blockquote><p>那么，我们现在来整理一下如何学习JS（持续更新）</p></blockquote><p>首先，我觉得看书是很有必要的，我想前端小伙伴应该都知道一本大家都很推崇的书：<code>红宝书</code>，今年已经出了第四版了，作为前端爱好者，必须购买一本啦。此时，就有小伙伴问了，我不太爱看纸质版的，爱看电子版的，并且我又想 <strong>白嫖</strong> 。</p><blockquote><p>我就知道会有一部分白嫖党这样想，小狮子已经为你们准备好了，在【小狮子前端】回复【红宝书】即可领取第四版红宝书电子版书籍，如有失效请及时联系~</p></blockquote><p>其次，观看学习视频也是很有必要的，对于小白直接上手红宝书可能还有一些困难，并且现在第四版红宝书整体都是用 <code>ES6</code> 来写了，这又给这本书阅读提升了门槛，但是我觉得第一遍读没必要一个字一个字完全弄明白，看个大概就好了，至于怎么去看红宝书，下面给了一份思维导图（转自 <code>蜗牛老湿_大圣</code>：<a href="https://juejin.cn/post/6895304726822027277">【前端红宝书】精读训练营开始拉！一起来学习吧</a>）。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20201219104753174.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70#pic_center" alt=""><br>然后我们就去看一些 <code>js</code> 教程视频，这里比较推荐的是 <a href="https://space.bilibili.com/282190994/video">后盾人教程视频</a>，在里面有比较完整 <code>js</code> 学习课程，将许多问题分成了一小节，这样你空闲的时候没事刷上一两集，日复一日，你就能学完整套课程了~</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20201219105505760.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70#pic_center" alt=""></p><p>有了上文铺垫之后，你的 <code>js</code> 基础知识应该足够了，但是此时可能没有形成思维体系，并且实践方面也会比较少，可能记着记着忘记很多了，那么就需要进行手写实践了，也就是下文我给你提出的问题。</p><h3 id="Chocolate-同学的提问-2"><a href="#Chocolate-同学的提问-2" class="headerlink" title="Chocolate 同学的提问"></a>Chocolate 同学的提问</h3><blockquote><p>希望你能带着这几个问题学习，同时你在复盘时也可以根据如下问题进行检验。</p></blockquote><ul><li>说说你所知道的数组的一系列方法</li><li>数组方法中改变原数组的方法你知道的有哪些，说说？</li><li>数组扁平化你怎么做？有几种方式？</li><li>数组去重你怎么做？有几种方式？</li><li>说说你对 reduce 的理解</li></ul><blockquote><p>待更新…</p></blockquote><h4 id="JS-数组操作"><a href="#JS-数组操作" class="headerlink" title="JS 数组操作"></a>JS 数组操作</h4><blockquote><p>JS 数组操作思维导图</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20201219094137740.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70#pic_center" alt=""></p><blockquote><p>（手机端可能看不清）获取高清PDF，请在微信公众号【小狮子前端】回复【数组方法】</p></blockquote><h3 id="优质文章推荐-2"><a href="#优质文章推荐-2" class="headerlink" title="优质文章推荐"></a>优质文章推荐</h3><ul><li><a href="https://juejin.cn/post/6901621560444977160">「数组方法」写给女友的一系列 JS 数组操作（建议收藏 | 内附思维导图）</a></li><li><a href="https://yangchaoyi.vip/posts/20201127/">星辰大海」JS自测清单（一）</a></li><li><a href="https://yangchaoyi.vip/posts/20201128/">星辰大海」JS自测清单（二）</a></li><li><a href="https://yangchaoyi.vip/posts/20201129/">星辰大海」JS自测清单（三）</a></li><li><a href="https://yangchaoyi.vip/posts/2020916/">「JavaScript灵魂之问」前端知识梳理之 JS 篇（上篇）</a></li><li><a href="https://yangchaoyi.vip/posts/2020917/">「JavaScript灵魂之问」前端知识梳理之 JS 篇（中篇）</a></li><li><a href="https://yangchaoyi.vip/posts/2020919/">「JavaScript灵魂之问」前端知识梳理之 JS 篇（下篇）</a></li><li><a href="https://yangchaoyi.vip/posts/2020922/">「JavaScript灵魂之问」前端知识梳理之 JS 篇（中秋特别篇）</a></li></ul><hr/><p>神三元的 <code>JS</code> 灵魂之问系列，个人觉得有必要读一读~</p><ul><li><a href="https://juejin.cn/post/6844903974378668039">(建议收藏)原生JS灵魂之问, 请问你能接得住几个？(上)</a></li><li><a href="https://juejin.cn/post/6844903986479251464">(建议精读)原生JS灵魂之问(中)，检验自己是否真的熟悉JavaScript？</a></li><li><a href="https://juejin.cn/post/6844904004007247880">(2.4w字,建议收藏)😇原生JS灵魂之问(下), 冲刺🚀进阶最后一公里(附个人成长经验分享)</a></li></ul><hr/><p>TianTianUp 博主的文章，也值得大家去阅读~</p><ul><li><a href="https://juejin.cn/post/6855129007852093453">「一劳永逸」送你21道高频JavaScript手写面试题</a></li><li><a href="https://juejin.cn/post/6854573211443544078">「查缺补漏」送你 54 道 JavaScript 面试题</a></li></ul><p>LinDaiDai_霖呆呆 博主的文章推荐：</p><ul><li><a href="https://juejin.cn/post/6844904118453010445">读《三元-JS灵魂之问》总结,给自己的一份原生JS补给(上)</a></li><li><a href="https://juejin.cn/post/6844904105874472974">【精】从206个console.log()完全弄懂数据类型转换的前世今生(上)</a></li><li><a href="https://juejin.cn/post/6844904114099322893">【精】从206个console.log()完全弄懂数据类型转换的前世今生(下)</a></li><li><a href="https://juejin.cn/post/6844904077537574919">【建议星星】要就来45道Promise面试题一次爽到底(1.1w字用心整理)</a></li><li><a href="https://juejin.cn/post/6844904083707396109">【建议👍】再来40道this面试题酸爽继续(1.2w字用手整理)</a></li><li><a href="https://juejin.cn/post/6844904098941108232">💦【何不三连】做完这48道题彻底弄懂JS继承(1.7w字含辛整理-返璞归真)</a></li><li><a href="https://juejin.cn/post/6844904094948130824">🔥【何不三连】比继承家业还要简单的JS继承题-封装篇(牛刀小试)</a></li></ul><blockquote><p>待更新…</p></blockquote><h3 id="小狮子有话说-2"><a href="#小狮子有话说-2" class="headerlink" title="小狮子有话说"></a>小狮子有话说</h3><p>关于 <code>JS</code> 这一块是整个前端的核心，那么要整理这一模块知识是需要花大量时间，因此我会持续更新这个模块知识体系。</p><blockquote><p>非常建议大家能来交流群一起交流JS，大家一起学会更有动力，【小狮子前端】技术交流群：<code>666151691</code> 欢迎大家加入。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 写给女友 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 总结 </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「星辰大海」女友：消息队列 和 事件循环系统终于弄明白了！（内附思维导图）</title>
      <link href="posts/20201205/"/>
      <url>posts/20201205/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近又和女友，咳咳…（说出来可能又会被打s）学习事件循环，这不，学会（废）了之后，赶紧写一篇博客复盘总结一下~</p><p>接上一期<a href="https://juejin.cn/post/6901621560444977160">「数组方法」写给女友的一系列 JS 数组操作（建议收藏 | 内附思维导图）</a> 文章发出去之后，有些小伙伴还真发给自己女友了，不知道“感动”了没有哈（手动滑稽）。</p><p>那么，这次女友直接说明白了，那么我就从“头”开始讲讲事件循环系统，通过一篇文章搞定这一块知识点。</p><blockquote><p>事件循环非常底层且非常重要，学会它能让你理解页面到底是如何运行的。</p></blockquote><p>话说女友会点开这篇文章么？</p><blockquote><p>我“啪”地一下就醒过来了，啊这，这…这还重要吗？</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20201205231137194.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70#pic_center" alt=""></p><blockquote><p>（手机端可能看不清）获取高清PDF，请在微信公众号【小狮子前端Vue】回复【事件循环】</p></blockquote><p>另外，可能小狮子们会问到我的作图工具是啥，这里先提前告诉大家（考虑的这么周到，这还不来<strong>点个赞支持一下</strong>？）</p><p><a href="https://excalidraw.com/">作图工具：excalidraw</a></p><p>此外，我们可以通过使用 <code>Loupe</code> ( <code>Loupe</code>是一种可视化工具，可以帮助您了解JavaScript的调用堆栈/事件循环/回调队列如何相互影响)工具来了解代码的执行情况</p><p><a href="http://latentflip.com/loupe">Loupe 可视化工具</a></p><h2 id="阅读须知"><a href="#阅读须知" class="headerlink" title="阅读须知"></a>阅读须知</h2><p>关于消息队列和事件循环这一块，不仅底层而且面试经常性问到，答的一知半解，对于整场面试而言也许会降低很多期望分。</p><p>今年春招乃至秋招，博主也被这些问题问到，可能不会直接问你相关概念，一般情况下就是给你一段代码，然后问你输出结果，得到输出结果后再让你解释其中奥妙。如果能迅速正确地解答，对于整场面试而言的话是一个高潮加分点。</p><p>好了，让我们快速进入正文~</p><h2 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h2><p>在阅读本篇文章之前，先推荐讲解 <code>event loop</code> 非常好的视频，看完视频后再配合本文将会更佳哈~</p><ul><li><a href="https://www.youtube.com/watch?v=cCOL7MC4Pl0&t=1592s">What the heck is the event loop anyway? | Philip Roberts | JSConf EU</a></li><li><a href="https://www.youtube.com/watch?v=8aGhZQkoFbQ">Jake Archibald: In The Loop - JSConf.Asia</a></li></ul><p>在正式介绍事件循环系统之前，先来看看在<strong>WHATWG 规范</strong>中是怎么定义事件循环机制的，大致流程如下：</p><ul><li>先从多个消息队列中选出一个最老的任务，这个任务称为 <code>oldestTask</code></li><li>然后循环系统记录任务开始执行的时间，并把这个 <code>oldestTask</code> 设置为当前正在执行的任务</li><li>当任务执行完成之后，删除当前正在执行的任务，并从对应的消息队列中删除掉这个 <code>oldestTask</code></li><li>最后统计执行完成的时长等信息</li></ul><p>以上就是<strong>消息队列</strong>中<strong>宏任务</strong>的执行过程。</p><blockquote><p>显然，这就包含了一些专有名词，别担心，后文我会逐一介绍，那我们就带着问题愉快地阅读本文吧~（觉得不错，三连支持一下哈）</p></blockquote><h2 id="单线程处理安排好的任务"><a href="#单线程处理安排好的任务" class="headerlink" title="单线程处理安排好的任务"></a>单线程处理安排好的任务</h2><p>既然要从“头”开始讲解，那么我们就从比较简单的场景开始啦，比如在大学里面我们会举行班级活动，假设是班主任要求举行一次关于 <code>职业规划与梦想</code>相关的主题班会（老班委了hh），而班长就会和班委们集思广益一起探讨相关任务。</p><ul><li>任务 1：确定主题名称 <code>我们的征途是星辰大海</code></li><li>任务 2：写好活动策划书，班委各司其职</li><li>任务 3：采购物资与班会地点安排</li><li>任务 4：进行复盘总结</li></ul><p>而对于单线程处理任务就类似上述活动安排，班主任提出需求，此时线程开始了，班长和班委们一起分配任务，将任务按照顺序依次执行，等所有任务执行完了，此次班会圆满结束，线程会自动退出。可以参考下图来直观地理解下其执行过程：</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20201203204714660.png#pic_center" alt=""></p><h3 id="出现问题"><a href="#出现问题" class="headerlink" title="出现问题"></a>出现问题</h3><p>然而，班委们尤其是新任班委，并不一定会将任务一开始就安排的很好，可能在执行的过程中某个班委又提出了新的任务，那么上述情况可能就不太好解决了。</p><h3 id="引入循环机制"><a href="#引入循环机制" class="headerlink" title="引入循环机制"></a>引入循环机制</h3><p>那么，<strong>要想在线程运行过程中，能接收并执行新的任务，就需要采用事件循环机制。</strong> </p><p>既然有新的任务需要采纳，那么我们就加一个 <code>for</code> 循环嘛，这样线程就会一直循环执行了。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20201203213057423.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70#pic_center" alt=""></p><h2 id="处理其它线程发送过来的任务"><a href="#处理其它线程发送过来的任务" class="headerlink" title="处理其它线程发送过来的任务"></a>处理其它线程发送过来的任务</h2><p>在上文中，我们提到了班委完成任务，通过引入循环机制，解决任务并不一定事先就确定好的问题。但是这些任务都是来自于班委组织内部的（即线程内部），如果另外一个线程想让主线程执行一个任务，上文可能又没办法解决了，就比如班委组织活动，但是班级里积极性比较高的非班委同学也想来参与，也提出相关任务安排，这又该怎么解决呢？</p><p>下面我们就来看看其他线程是如何发送消息给渲染主线程的，具体形式你可以参考下图：</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20201204090245424.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70#pic_center" alt=""><br>从上图可以看出，渲染主线程会频繁接收到来自于 <code>IO 线程</code> 的一些任务，接收到这些任务之后，渲染进程就需要着手处理，比如接收到资源加载完成的消息后，渲染进程就要着手进行 <code>DOM</code> 解析了；接收到鼠标点击的消息后，渲染主线程就要开始执行相应的 <code>JavaScript</code> 脚本来处理该点击事件。</p><blockquote><p>那么如何设计好一个线程模型，能让其能够接收其它线程发送的消息呢？</p></blockquote><p>作为班长，收到班级内同学的积极反馈，当然需要采纳意见与想法，一个不错的方式是将这些任务 <strong>“存”</strong> 起来，我们吃饭都还要排队，不妨将这些任务也存起来，依次排队。</p><h3 id="引入消息队列"><a href="#引入消息队列" class="headerlink" title="引入消息队列"></a>引入消息队列</h3><p>上述比较好的解决方式就是<strong>引入消息队列</strong>。熟悉队列的小狮子们应该很好理解，<strong>消息队列是一种数据结构，可以存放要执行的任务</strong>。它符合队列 <strong>“先进先出”</strong> 的特点，也就是说<strong>要添加任务的话，添加到队列的尾部；要取出任务的话，从队列头部去取</strong>。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20201204092932568.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70#pic_center" alt=""><br>一图胜前言，有了消息队列机制后，我们就可以改造一下之前的模型了，如下图所示：</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20201204094049494.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70#pic_center" alt=""></p><h2 id="处理其它进程发送过来的任务"><a href="#处理其它进程发送过来的任务" class="headerlink" title="处理其它进程发送过来的任务"></a>处理其它进程发送过来的任务</h2><p>上文我们解决了非班委内部（即班级内积极的同学）提出的任务，不过有可能我们班级活动会有联谊呢，即可能其它班级也会参与这次活动策划，此时又要麻烦班长大人呐~ </p><p>那么我们又要怎么解决呢？可以直接参考下图：</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/2020120409534555.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70#pic_center" alt=""><br>从图中可以看出，<strong>渲染进程专门有一个 IO 线程用来接收其他进程传进来的消息</strong>，接收到消息之后，会将这些消息组装成任务发送给渲染主线程，后续的步骤就与上文一样了，这里就不再赘述了。</p><h2 id="消息队列中的任务类型"><a href="#消息队列中的任务类型" class="headerlink" title="消息队列中的任务类型"></a>消息队列中的任务类型</h2><p>到此，通过图示和班委任务安排故事，你已经知道了主线程是如何接受外部任务的了，接下来我们看看消息队列中的任务类型有哪些。这里面包含了很多内部消息类型，如输入事件（鼠标滚动、点击、移动）、微任务、文件读写、WebSocket、JavaScript 定时器等等。</p><p>除此之外，消息队列中还包含了很多与页面相关的事件，如 JavaScript 执行、解析 DOM、样式计算、布局计算、CSS 动画等。</p><p>以上这些事件都是在主线程中执行的，所以在编写 Web 应用时，你还需要衡量这些事件所占用的时长，并想办法解决单个任务占用主线程过久的问题。</p><h2 id="如何安全退出"><a href="#如何安全退出" class="headerlink" title="如何安全退出"></a>如何安全退出</h2><p>确定要退出当前页面时，页面主线程会设置一个退出标志的变量，在每次执行完一个任务时，判断是否有设置退出标志。如果设置了，那么就直接中断当前的所有任务，退出线程。</p><hr><h2 id="带你了解WebAPI：setTimeout"><a href="#带你了解WebAPI：setTimeout" class="headerlink" title="带你了解WebAPI：setTimeout"></a>带你了解WebAPI：setTimeout</h2><p>一提到事件循环，我想小狮子们应该就会联想到 <code>setTimeout</code>，想必都不会陌生，它就是一个<strong>定时器</strong>，<strong>用来指定某个函数在多少毫秒之后执行</strong>。它会返回一个整数，表示定时器的编号，同时你还可以通过该编号来取消这个定时器。</p><p>通过上文，我们知道渲染进程中所有运行在主线程上的任务都需要先添加到消息队列，然后事件循环系统再按照顺序执行消息队列中的任务。</p><blockquote><p>举点例子吧，当接收到 <code>HTML</code> 文档数据，渲染引擎就会将 <code>“解析 DOM”</code> 事件添加到消息队列中；当触发了 <code>JavaScript</code> 引擎垃圾回收机制，渲染引擎会将 <code>“垃圾回收”</code> 任务添加到消息队列中。</p></blockquote><p>同样，如果要执行一段<code>异步 JavaScript</code>代码，也是需要将执行任务添加到消息队列中。</p><p>不过通过定时器设置回调函数有点特别，它们需要在指定的时间间隔内被调用，但消息队列中的任务是按照顺序执行的，因此，不能将定时器的回调函数直接添加到消息队列中。于是 <code>Chrome</code> 又维护了一个另外一个消息队列，用来<strong>存放延迟执行的任务列表</strong>。（这里我就叫做 <code>延迟队列</code> 了）</p><p>那么，我们就知道了，对于定时器而言，它会<strong>等待主线程消息队列处理完之后，才会去拿延迟队列里面的任务</strong>，这也就是为什么尽管定时器设置了倒计时，然而实际上并不一定是在这个时间后立即执行了。</p><h3 id="使用-setTimeout-的一些注意事项"><a href="#使用-setTimeout-的一些注意事项" class="headerlink" title="使用 setTimeout 的一些注意事项"></a>使用 setTimeout 的一些注意事项</h3><p>上文带小狮子们了解了 <code>setTimeout</code>，那么在使用它的时候有哪些需要注意的嘛？接下来一起来看看吧：</p><h4 id="1-如果当前任务执行时间过久，会影响定时器任务的执行"><a href="#1-如果当前任务执行时间过久，会影响定时器任务的执行" class="headerlink" title="1. 如果当前任务执行时间过久，会影响定时器任务的执行"></a>1. 如果当前任务执行时间过久，会影响定时器任务的执行</h4><p>对于消息队列，如果任务执行时间过久，那么延迟队列里面的任务一直不会处理，势必会影响定时器任务的执行。</p><h4 id="2-如果-setTimeout-存在嵌套调用，那么系统会设置最短时间间隔为-4-毫秒"><a href="#2-如果-setTimeout-存在嵌套调用，那么系统会设置最短时间间隔为-4-毫秒" class="headerlink" title="2. 如果 setTimeout 存在嵌套调用，那么系统会设置最短时间间隔为 4 毫秒"></a>2. 如果 setTimeout 存在嵌套调用，那么系统会设置最短时间间隔为 4 毫秒</h4><p>例如下述代码，我们进行了嵌套调用：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cb</span>(<span class="params"></span>) </span>&#123; <span class="built_in">setTimeout</span>(cb, <span class="number">0</span>); &#125;</span><br><span class="line"><span class="built_in">setTimeout</span>(cb, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>在 <code>Chrome</code> 中，定时器被嵌套调用 <strong>5 次以上</strong>，系统会判断该函数方法被阻塞了，如果定时器的调用时间间隔小于 4 毫秒，那么浏览器会将每次调用的时间间隔设置为 4 毫秒。</p><h4 id="3-未激活的页面，setTimeout-执行最小间隔是-1000-毫秒"><a href="#3-未激活的页面，setTimeout-执行最小间隔是-1000-毫秒" class="headerlink" title="3. 未激活的页面，setTimeout 执行最小间隔是 1000 毫秒"></a>3. 未激活的页面，setTimeout 执行最小间隔是 1000 毫秒</h4><p>未被激活的页面中定时器最小值大于 1000 毫秒，也就是说，如果标签不是当前的激活标签，那么定时器最小的时间间隔是 1000 毫秒，目的是<strong>为了优化后台页面的加载损耗以及降低耗电量</strong>。</p><h4 id="4-延时执行时间有最大值"><a href="#4-延时执行时间有最大值" class="headerlink" title="4. 延时执行时间有最大值"></a>4. 延时执行时间有最大值</h4><p>还有一点需要注意下，那就是 Chrome、Safari、Firefox 都是以 32 个 bit 来存储延时值的，32bit 最大只能存放的数字是 2147483647 毫秒，这就意味着，如果 setTimeout 设置的延迟值大于 2147483647 毫秒（大约 <code>24.8</code> 天）时就会溢出，那么相当于延时值被设置为 0 了，这导致定时器会被立即执行。</p><p>例如下述代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showName</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;小狮子前端Vue&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> timeId = <span class="built_in">setTimeout</span>(showName,<span class="number">2147483648</span>);<span class="comment">//超过最大值，调用执行</span></span><br></pre></td></tr></table></figure><h4 id="5-使用-setTimeout-设置的回调函数中的-this-不符合直觉"><a href="#5-使用-setTimeout-设置的回调函数中的-this-不符合直觉" class="headerlink" title="5. 使用 setTimeout 设置的回调函数中的 this 不符合直觉"></a>5. 使用 setTimeout 设置的回调函数中的 this 不符合直觉</h4><p>如果被 setTimeout 推迟执行的回调函数是某个对象的方法，那么该方法中的 this 关键字将指向全局环境，而不是定义时所在的那个对象。</p><blockquote><p>这个与作用域相关，后期我也会出一篇关于 <code>this</code> 指向的文章，感兴趣的小狮子们可以持续关注哈~</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name= <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> myObj= &#123;</span><br><span class="line">  name: <span class="number">2</span>,</span><br><span class="line">  showName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">setTimeout</span>(myObj.showName,<span class="number">1000</span>) <span class="comment">// 输出1</span></span><br></pre></td></tr></table></figure><p>输出结果是 <code>1</code>，因为这段代码在编译的时候，执行上下文中的 this 会被设置为全局 <code>window</code>，如果是严格模式，会被设置为 <code>undefined</code>。</p><blockquote><p>怎么解决上述 <code>this</code> 指向问题呢？</p></blockquote><p>比较好的一种解决方式就是通过 <code>bind</code> 改变一下 <code>this</code> 指向，如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(myObj.showName.bind(myObj), <span class="number">1000</span>)</span><br></pre></td></tr></table></figure><h2 id="宏任务-和-微任务-你又知多少"><a href="#宏任务-和-微任务-你又知多少" class="headerlink" title="宏任务 和 微任务 你又知多少"></a>宏任务 和 微任务 你又知多少</h2><h3 id="先来介绍宏任务"><a href="#先来介绍宏任务" class="headerlink" title="先来介绍宏任务"></a>先来介绍宏任务</h3><p>上文我们有介绍过，页面中大部分任务都在 <strong>主线程</strong> 上执行，包括：</p><ul><li>渲染事件（如解析 DOM、计算布局、绘制）</li><li>用户交互事件（如鼠标点击、滚动页面、放大缩小等）</li><li>JavaScript 脚本执行事件</li><li>网络请求完成、文件读写完成事件</li></ul><blockquote><p>具体来讲的话就是如下几种类型：</p></blockquote><ul><li>script(整体代码)</li><li>setTimeout()</li><li>setInterval()</li><li>postMessage</li><li>I/O</li><li>UI交互事件</li></ul><blockquote><p>为了协调这些任务有条不紊地在主线程上执行，页面进程引入了 <code>消息队列</code> 和 <code>事件循环机制</code> ，渲染进程内部会维护多个消息队列，比如<code>延迟执行队列</code>和<code>普通的消息队列</code>。然后主线程采用一个 <code>for</code> 循环，不断地从这些任务队列中取出任务并执行任务。我们把这些消息队列中的任务称为 <strong>宏任务</strong>。</p></blockquote><h4 id="宏任务有什么不足点"><a href="#宏任务有什么不足点" class="headerlink" title="宏任务有什么不足点"></a>宏任务有什么不足点</h4><p>上文我们介绍过，页面的渲染事件、各种 IO 的完成事件、执行 JavaScript 脚本的事件、用户交互的事件等都随时有可能被添加到消息队列中，而且<strong>添加事件是由系统操作</strong>的，JavaScript 代码<strong>不能准确掌控任务要添加到队列中的位置</strong>。</p><p>那么，控制不了任务在消息队列中的位置，所以<strong>很难控制开始执行任务的时间</strong>。</p><p>例如我们想通过 setTimeout 来设置两个回调任务，并让它们按照前后顺序来执行，中间也不插入其他的任务，避免影响第二个定时器的执行时间。</p><p>通过 <code>Performance</code> 工具，可以看到任务的执行过程，如下图所示：</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20201204151117673.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70#pic_center" alt=""></p><blockquote><p><code>setTimeout</code> 函数触发的回调函数都是宏任务，如图中，左右两个黄色块就是 <code>setTimeout</code> 触发的两个定时器任务。</p></blockquote><blockquote><p>观察上图中间<code>浅红色</code>区域，这里有很多一段一段的任务，这些是被渲染引擎插在两个定时器任务中间的任务。</p></blockquote><p>试想一下，如果中间被插入的任务执行时间过久的话，那么就会影响到后面任务的执行了。</p><p>因此，宏任务的时间粒度比较大，执行的时间间隔是不能精确控制的，对一些<strong>高实时性</strong>的需求就不太符合了。</p><blockquote><p>那么，为了解决实时性的问题，我们就需要了解微任务了。</p></blockquote><h2 id="再来介绍微任务"><a href="#再来介绍微任务" class="headerlink" title="再来介绍微任务"></a>再来介绍微任务</h2><p>微任务就是一个需要异步执行的函数，执行时机是在<strong>主函数执行结束之后、当前宏任务结束之前</strong>。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20201205173129422.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70#pic_center" alt=""><br>可以看到 <code>Macrotask</code> (宏任务)也就是回调队列上面还有一个 <code>Microtask</code>（微任务）</p><p><code>Microtask</code>（微任务）虽然是队列，但并不是一个一个放入执行栈，而是当执行栈清空，会执行全部 <code>Microtask</code>（微任务）队列中的任务，最后才是取回调队列的第一个 <code>Macrotask</code> (宏任务)</p><blockquote><p>可能到目前为止，你对微任务还不是很理解，没关系，接下来我们会逐一讲解，然后通过例题和一些动画让你加深巩固。</p></blockquote><h3 id="从V8引擎层面来看微任务"><a href="#从V8引擎层面来看微任务" class="headerlink" title="从V8引擎层面来看微任务"></a>从V8引擎层面来看微任务</h3><blockquote><p>当 JavaScript 执行一段脚本的时候，V8 会为其创建一个全局执行上下文，在创建全局执行上下文的同时，V8 引擎也会在内部创建一个 <code>微任务队列</code>。顾名思义，这个微任务队列就是用来存放微任务的，因为在当前宏任务执行的过程中，有时候会产生多个微任务，这时候就需要使用这个微任务队列来保存这些微任务了。<code>不过这个微任务队列是给 V8 引擎内部使用的，所以你是无法通过 JavaScript 直接访问的</code>。</p></blockquote><p>那么，也就是每个宏任务都关联一个<strong>微任务队列</strong>，那么微任务产生时机和执行时机又分别是什么呢？我们接下来一起来看看：</p><h3 id="微任务的产生时机"><a href="#微任务的产生时机" class="headerlink" title="微任务的产生时机"></a>微任务的产生时机</h3><p>在现代浏览器里面，产生微任务有两种方式：</p><p>第一种方式是使用 <code>MutationObserver</code> 监控某个 DOM 节点，然后再通过 <code>JavaScript</code> 来修改这个节点，或者为这个节点添加、删除部分子节点，当 DOM 节点发生变化时，就会产生 DOM 变化记录的微任务。</p><p>第二种方式是使用 <code>Promise</code>，当调用 <code>Promise.resolve()</code> 或者 <code>Promise.reject()</code> 的时候，也会产生微任务。</p><blockquote><p>通过 DOM 节点变化产生的微任务或者使用 Promise 产生的微任务都会被 JavaScript 引擎按照顺序保存到微任务队列中。</p></blockquote><h3 id="微任务何时被执行"><a href="#微任务何时被执行" class="headerlink" title="微任务何时被执行"></a>微任务何时被执行</h3><p>通常情况下，在当前宏任务中的 <code>JavaScript</code> 快执行完成时，也就在 <code>JavaScript</code> 引擎<strong>准备退出全局执行上下文并清空调用栈</strong>的时候，<code>JavaScript</code> 引擎会检查全局执行上下文中的微任务队列，然后按照顺序执行队列中的微任务。<strong>WHATWG</strong> 把执行微任务的时间点称为 <code>检查点</code>。</p><blockquote><p>如果在执行微任务的过程中，产生了新的微任务，同样会将该微任务添加到微任务队列中，V8 引擎一直循环执行微任务队列中的任务，直到队列为空才算执行结束。也就是说 <code>在执行微任务过程中产生的新的微任务并不会推迟到下个宏任务中执行，而是在当前的宏任务中继续执行</code>。</p></blockquote><p>结合下面两张图示，应该就能直观理解微任务了：<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20201205112212220.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70#pic_center" alt=""><br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20201205112220930.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70#pic_center" alt=""><br>该示意图是在执行一个 <code>ParseHTML</code> 的宏任务，在执行过程中，遇到了 <code>JavaScript</code> 脚本，那么就暂停解析流程，进入到 JavaScript 的执行环境。从图中可以看到，全局上下文中包含了微任务列表。</p><p>在 JavaScript 脚本的后续执行过程中，分别通过 <code>Promise</code> 和 <code>removeChild</code> 创建了两个微任务，并被添加到微任务列表中。接着 <code>JavaScript</code> 执行结束，<strong>准备退出全局执行上下文</strong>，这时候就到了检查点了，<code>JavaScript</code> 引擎会检查微任务列表，发现微任务列表中有微任务，那么接下来，依次执行这两个微任务。等微任务队列清空之后，就退出全局执行上下文。</p><h3 id="宏任务和微任务关系（总结）"><a href="#宏任务和微任务关系（总结）" class="headerlink" title="宏任务和微任务关系（总结）"></a>宏任务和微任务关系（总结）</h3><ul><li><p>微任务和宏任务是绑定的，<code>每个宏任务在执行时，会创建自己的微任务队列</code>。</p></li><li><p>宏任务和微任务之间的关系。 因为在微任务中产生的宏任务也是要插入到消息队列或者是延迟队列的末尾的，这肯定是需要下一次事件循环才有可能被执行的，而微任务在这一次的事件循环之前就会被执行。 <code>因此，无论什么情况下，微任务都早于宏任务执行。</code></p></li><li><p><code>微任务的执行时长会影响到当前宏任务的时长</code>。比如一个宏任务在执行过程中，产生了 100 个微任务，执行每个微任务的时间是 10 毫秒，那么执行这 100 个微任务的时间就是 1000 毫秒，也可以说这 100 个微任务让宏任务的执行时间延长了 1000 毫秒。所以你在写代码的时候一定要注意控制微任务的执行时长。</p></li></ul><hr><h2 id="通过动画与例题加深巩固"><a href="#通过动画与例题加深巩固" class="headerlink" title="通过动画与例题加深巩固"></a>通过动画与例题加深巩固</h2><blockquote><p>上文，我们花了很长篇幅来介绍宏任务和微任务，大佬或许已经明白了离开了本页面，但是我倒觉得本篇最有价值的部分就在这了（赶快给阅读到这里的自己鼓个掌~）</p></blockquote><p>ok，现在我们正式来做一做例题，面试的时候关于事件循环这一块，面试官一般也会这样考察，GO！</p><h3 id="例题一"><a href="#例题一" class="headerlink" title="例题一"></a>例题一</h3><p>下面这一道题算是比较基本的题目了，可以先不看下面动画效果，自己测一测，看看预期结果与实际结果有没有差别~</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;start&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;promise1&#x27;</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;promise2&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;end&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20201205175403179.gif#pic_center" alt=""></p><ul><li>全局代码压入执行栈执行，输出 <code>start</code></li><li>setTimeout压入 <code>macrotask</code> 队列，<code>promise.then</code> 回调放入 microtask队列，最后执行 <code>console.log(&#39;end&#39;)</code>，输出 end</li><li>调用栈中的代码执行完成（全局代码属于宏任务），接下来开始执行微任务队列中的代码，执行promise回调，输出 <code>promise1</code>, promise回调函数默认返回 <code>undefined</code>, promise状态变成 <code>fulfilled</code> ，触发接下来的 then 回调，继续压入 microtask队列，此时产生了新的微任务，会接着把当前的微任务队列执行完，此时执行第二个 promise.then回调，输出 <code>promise2</code></li><li>此时，<code>microtask</code> 队列 已清空，接下来会会执行 <code>UI</code> 渲染工作（如果有的话），然后开始下一轮 event loop, 执行 setTimeout的回调，输出 <code>setTimeout</code></li></ul><p>最后结果如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">start</span><br><span class="line">end</span><br><span class="line">promise1</span><br><span class="line">promise2</span><br><span class="line"><span class="built_in">setTimeout</span></span><br></pre></td></tr></table></figure><h3 id="例题二"><a href="#例题二" class="headerlink" title="例题二"></a>例题二</h3><blockquote><p>下面这道题是特别特别经典的一道题了！</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;async1 start&#x27;</span>);</span><br><span class="line">    <span class="keyword">await</span> async2();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;async1 end&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;async2&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script start&#x27;</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line">async1();</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise1&#x27;</span>);</span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise2&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script end&#x27;</span>);</span><br></pre></td></tr></table></figure><h3 id="解答-1"><a href="#解答-1" class="headerlink" title="解答"></a>解答</h3><blockquote><p>总体思路就是：先执行宏任务（当前代码块也算是宏任务），然后执行当前宏任务产生的微任务，然后接着执行宏任务</p></blockquote><ul><li>从上往下执行代码，先执行同步代码，输出 <code>script start</code></li><li>遇到 <code>setTimeout</code> ，现把 <code>setTimeout</code> 的代码放到宏任务队列中</li><li>执行 <code>async1()</code>，输出 <code>async1 start</code>, 然后执行 <code>async2()</code>, 输出 <code>async2</code>，把 <code>async2()</code> 后面的代码 <code>console.log(&#39;async1 end&#39;)</code>放到微任务队列中</li><li>接着往下执行，输出 <code>promise1</code>，把 .then() 放到微任务队列中；<strong>注意 Promise 本身是同步的立即执行函数，.then是异步执行函数</strong></li><li>接着往下执行， 输出 <code>script end</code>。同步代码（同时也是宏任务）执行完成，接下来开始执行刚才放到微任务中的代码</li><li>依次执行微任务中的代码，依次输出 <code>async1 end</code>、 <code>promise2</code>, 微任务中的代码执行完成后，开始执行宏任务中的代码，输出 <code>setTimeout</code></li></ul><p>最后结果如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">script start</span><br><span class="line">async1 start</span><br><span class="line">async2</span><br><span class="line">promise1</span><br><span class="line">script end</span><br><span class="line">async1 end</span><br><span class="line">promise2</span><br><span class="line"><span class="built_in">setTimeout</span></span><br></pre></td></tr></table></figure><h3 id="例题三"><a href="#例题三" class="headerlink" title="例题三"></a>例题三</h3><blockquote><p>再来一道好题，这道题跟上面题目不同之处在于，执行代码会产生很多个宏任务，每个宏任务中又会产生微任务</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;start&#x27;</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;children2&#x27;</span>);</span><br><span class="line">    <span class="built_in">Promise</span>.resolve().then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;children3&#x27;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;children4&#x27;</span>);</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;children5&#x27;</span>);</span><br><span class="line">        resolve(<span class="string">&#x27;children6&#x27;</span>)</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;children7&#x27;</span>);</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res);</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="解答-2"><a href="#解答-2" class="headerlink" title="解答"></a>解答</h3><ul><li>从上往下执行代码，先执行同步代码，输出 <code>start</code></li><li>遇到setTimeout，先把 setTimeout 的代码放到宏任务队列①中</li><li>接着往下执行，输出 <code>children4</code>, 遇到setTimeout，先把 setTimeout 的代码放到宏任务队列②中，此时<code>.then</code>并不会被放到微任务队列中，因为 <code>resolve</code> 是放到 setTimeout中执行的</li><li>代码执行完成之后，会查找微任务队列中的事件，发现并没有，于是开始执行宏任务①，即第一个 <code>setTimeout</code> ， 输出 <code>children2</code>，此时，会把 Promise.resolve().then放到微任务队列中。</li><li>宏任务①中的代码执行完成后，会查找微任务队列，于是输出 <code>children3</code>；然后开始执行宏任务②，即第二个 setTimeout，输出 <code>children5</code>，此时将<code>.then</code>放到微任务队列中。</li><li>宏任务②中的代码执行完成后，会查找微任务队列，于是输出 <code>children7</code>，遇到 setTimeout，放到宏任务队列中。此时微任务执行完成，开始执行宏任务，输出 <code>children6</code></li></ul><p>最后结果如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">start</span><br><span class="line">children4</span><br><span class="line">children2</span><br><span class="line">children3</span><br><span class="line">children5</span><br><span class="line">children7</span><br><span class="line">children6</span><br></pre></td></tr></table></figure><h2 id="本文参考"><a href="#本文参考" class="headerlink" title="本文参考"></a>本文参考</h2><ul><li><a href="https://www.jianshu.com/p/23fad3814398">高频面试题：JavaScript事件循环机制解析</a></li><li><a href="https://juejin.cn/post/6844903553031634952">图解搞懂JavaScript引擎Event Loop</a></li><li><a href="http://lynnelv.github.io/js-event-loop-browser">深入理解js事件循环机制（浏览器篇）</a></li><li><a href="https://time.geekbang.org/column/article/135624">浏览器工作原理与实践</a></li><li><a href="https://juejin.cn/post/6880419772127772679">【前端进阶】深入浅出浏览器事件循环【内附练习题】</a></li></ul><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>文章产出不易，还望各位小伙伴们支持一波！</p><p>往期精选：</p><p><a href="https://github.com/Chocolate1999/Front-end-learning-to-organize-notes">小狮子前端の笔记仓库</a></p><p><a href="https://github.com/Chocolate1999/leetcode-javascript">leetcode-javascript：LeetCode 力扣的 JavaScript 解题仓库，前端刷题路线（思维导图）</a></p><p>小伙伴们可以在Issues中提交自己的解题代码，🤝 欢迎Contributing，可打卡刷题，Give a ⭐️ if this project helped you!</p><p><a href="https://yangchaoyi.vip/">访问超逸の博客</a>，方便小伙伴阅读玩耍~</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/chocolate1999/cdn/img/20201206092507.png#pic_center" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 写给女友 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「星辰大海」JS自测清单（二）</title>
      <link href="posts/20201128/"/>
      <url>posts/20201128/</url>
      
        <content type="html"><![CDATA[<h2 id="星辰大海」JS自测清单（二）"><a href="#星辰大海」JS自测清单（二）" class="headerlink" title="星辰大海」JS自测清单（二）"></a>星辰大海」JS自测清单（二）</h2><p>转载自 <a href="https://github.com/lydiahallie/javascript-questions">javascript-questions</a>（star支持一波）</p><blockquote><p>我们的征途是星辰大海~</p></blockquote><p>答案在问题下方的折叠部分，点击即可展开问题。祝你好运 :heart:</p><h6 id="56-输出是什么"><a href="#56-输出是什么" class="headerlink" title="56. 输出是什么?"></a>56. 输出是什么?</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(set);</span><br></pre></td></tr></table></figure><ul><li>A: <code>[1, 1, 2, 3, 4]</code></li><li>B: <code>[1, 2, 3, 4]</code></li><li>C: <code>&#123;1, 1, 2, 3, 4&#125;</code></li><li>D: <code>&#123;1, 2, 3, 4&#125;</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-D"><a href="#答案-D" class="headerlink" title="答案: D"></a>答案: D</h4><p><code>Set</code>对象是独一无二的值的集合：也就是说同一个值在其中仅出现一次。</p><p>我们传入了数组<code>[1, 1, 2, 3, 4]</code>，他有一个重复值<code>1</code>.以为一个集合里不能有两个重复的值，其中一个就被移除了。所以结果是 <code>&#123;1, 2, 3, 4&#125;</code>.</p></p></details><hr><h6 id="57-输出是什么"><a href="#57-输出是什么" class="headerlink" title="57. 输出是什么?"></a>57. 输出是什么?</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// counter.js</span></span><br><span class="line"><span class="keyword">let</span> counter = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> counter;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> myCounter <span class="keyword">from</span> <span class="string">&quot;./counter&quot;</span>;</span><br><span class="line"></span><br><span class="line">myCounter += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(myCounter);</span><br></pre></td></tr></table></figure><ul><li>A: <code>10</code></li><li>B: <code>11</code></li><li>C: <code>Error</code></li><li>D: <code>NaN</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-C"><a href="#答案-C" class="headerlink" title="答案: C"></a>答案: C</h4><p>引入的模块是 <em>只读</em> 的: 你不能修改引入的模块。只有导出他们的模块才能修改其值。</p><p>当我们给<code>myCounter</code>增加一个值的时候会抛出一个异常： <code>myCounter</code>是只读的，不能被修改。</p></p></details><hr><h6 id="58-输出是什么"><a href="#58-输出是什么" class="headerlink" title="58. 输出是什么?"></a>58. 输出是什么?</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">&quot;Lydia&quot;</span>;</span><br><span class="line">age = <span class="number">21</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">delete</span> name);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">delete</span> age);</span><br></pre></td></tr></table></figure><ul><li>A: <code>false</code>, <code>true</code></li><li>B: <code>&quot;Lydia&quot;</code>, <code>21</code></li><li>C: <code>true</code>, <code>true</code></li><li>D: <code>undefined</code>, <code>undefined</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-A"><a href="#答案-A" class="headerlink" title="答案: A"></a>答案: A</h4><p><code>delete</code>操作符返回一个布尔值： <code>true</code>指删除成功，否则返回<code>false</code>. 但是通过 <code>var</code>, <code>const</code> 或 <code>let</code> 关键字声明的变量无法用 <code>delete</code> 操作符来删除。</p><p><code>name</code>变量由<code>const</code>关键字声明，所以删除不成功:返回 <code>false</code>. 而我们设定<code>age</code>等于<code>21</code>时,我们实际上添加了一个名为<code>age</code>的属性给全局对象。对象中的属性是可以删除的，全局对象也是如此，所以<code>delete age</code>返回<code>true</code>.</p></p></details><hr><h6 id="59-输出是什么"><a href="#59-输出是什么" class="headerlink" title="59. 输出是什么?"></a>59. 输出是什么?</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> [y] = numbers;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(y);</span><br></pre></td></tr></table></figure><ul><li>A: <code>[[1, 2, 3, 4, 5]]</code></li><li>B: <code>[1, 2, 3, 4, 5]</code></li><li>C: <code>1</code></li><li>D: <code>[1]</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-C-1"><a href="#答案-C-1" class="headerlink" title="答案: C"></a>答案: C</h4><p>我们可以通过解构赋值来解析来自对象的数组或属性的值，比如说：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[a, b] = [<span class="number">1</span>, <span class="number">2</span>];</span><br></pre></td></tr></table></figure><img src= "/img/loading.gif" data-lazy-src="https://i.imgur.com/ADFpVop.png" width="200"><p><code>a</code>的值现在是<code>1</code>，<code>b</code>的值现在是<code>2</code>.而在题目中，我们是这么做的:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[y] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br></pre></td></tr></table></figure><img src= "/img/loading.gif" data-lazy-src="https://i.imgur.com/NzGkMNk.png" width="200"><p>也就是说，<code>y</code>等于数组的第一个值就是数字<code>1</code>.我们输出<code>y</code>， 返回<code>1</code>.</p></p></details><hr><h6 id="60-输出是什么"><a href="#60-输出是什么" class="headerlink" title="60. 输出是什么?"></a>60. 输出是什么?</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> user = &#123; <span class="attr">name</span>: <span class="string">&quot;Lydia&quot;</span>, <span class="attr">age</span>: <span class="number">21</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> admin = &#123; <span class="attr">admin</span>: <span class="literal">true</span>, ...user &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(admin);</span><br></pre></td></tr></table></figure><ul><li>A: <code>&#123; admin: true, user: &#123; name: &quot;Lydia&quot;, age: 21 &#125; &#125;</code></li><li>B: <code>&#123; admin: true, name: &quot;Lydia&quot;, age: 21 &#125;</code></li><li>C: <code>&#123; admin: true, user: [&quot;Lydia&quot;, 21] &#125;</code></li><li>D: <code>&#123; admin: true &#125;</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-B"><a href="#答案-B" class="headerlink" title="答案: B"></a>答案: B</h4><p>扩展运算符<code>...</code>为对象的组合提供了可能。你可以复制对象中的键值对，然后把它们加到另一个对象里去。在本例中，我们复制了<code>user</code>对象键值对，然后把它们加入到<code>admin</code>对象中。<code>admin</code>对象就拥有了这些键值对，所以结果为<code>&#123; admin: true, name: &quot;Lydia&quot;, age: 21 &#125;</code>.</p></p></details><hr><h6 id="61-输出是什么"><a href="#61-输出是什么" class="headerlink" title="61. 输出是什么?"></a>61. 输出是什么?</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123; <span class="attr">name</span>: <span class="string">&quot;Lydia&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">&quot;age&quot;</span>, &#123; <span class="attr">value</span>: <span class="number">21</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(person));</span><br></pre></td></tr></table></figure><ul><li>A: <code>&#123; name: &quot;Lydia&quot;, age: 21 &#125;</code>, <code>[&quot;name&quot;, &quot;age&quot;]</code></li><li>B: <code>&#123; name: &quot;Lydia&quot;, age: 21 &#125;</code>, <code>[&quot;name&quot;]</code></li><li>C: <code>&#123; name: &quot;Lydia&quot;&#125;</code>, <code>[&quot;name&quot;, &quot;age&quot;]</code></li><li>D: <code>&#123; name: &quot;Lydia&quot;&#125;</code>, <code>[&quot;age&quot;]</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-B-1"><a href="#答案-B-1" class="headerlink" title="答案: B"></a>答案: B</h4><p>通过<code>defineProperty</code>方法，我们可以给对象添加一个新属性，或者修改已经存在的属性。而我们使用<code>defineProperty</code>方法给对象添加了一个属性之后，属性默认为 <em>不可枚举(not enumerable)</em>. <code>Object.keys</code>方法仅返回对象中 <em>可枚举(enumerable)</em> 的属性，因此只剩下了<code>&quot;name&quot;</code>.</p><p>用<code>defineProperty</code>方法添加的属性默认不可变。你可以通过<code>writable</code>, <code>configurable</code> 和 <code>enumerable</code>属性来改变这一行为。这样的话， 相比于自己添加的属性，<code>defineProperty</code>方法添加的属性有了更多的控制权。</p></p></details><hr><h6 id="62-输出是什么"><a href="#62-输出是什么" class="headerlink" title="62. 输出是什么?"></a>62. 输出是什么?</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> settings = &#123;</span><br><span class="line">  username: <span class="string">&quot;lydiahallie&quot;</span>,</span><br><span class="line">  level: <span class="number">19</span>,</span><br><span class="line">  health: <span class="number">90</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> data = <span class="built_in">JSON</span>.stringify(settings, [<span class="string">&quot;level&quot;</span>, <span class="string">&quot;health&quot;</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(data);</span><br></pre></td></tr></table></figure><ul><li>A: <code>&quot;&#123;&quot;level&quot;:19, &quot;health&quot;:90&#125;&quot;</code></li><li>B: <code>&quot;&#123;&quot;username&quot;: &quot;lydiahallie&quot;&#125;&quot;</code></li><li>C: <code>&quot;[&quot;level&quot;, &quot;health&quot;]&quot;</code></li><li>D: <code>&quot;&#123;&quot;username&quot;: &quot;lydiahallie&quot;, &quot;level&quot;:19, &quot;health&quot;:90&#125;&quot;</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-A-1"><a href="#答案-A-1" class="headerlink" title="答案: A"></a>答案: A</h4><p><code>JSON.stringify</code>的第二个参数是 <em>替代者(replacer)</em>. 替代者(replacer)可以是个函数或数组，用以控制哪些值如何被转换为字符串。</p><p>如果替代者(replacer)是个 <em>数组</em> ，那么就只有包含在数组中的属性将会被转化为字符串。在本例中，只有名为<code>&quot;level&quot;</code> 和 <code>&quot;health&quot;</code> 的属性被包括进来， <code>&quot;username&quot;</code>则被排除在外。 <code>data</code> 就等于 <code>&quot;&#123;&quot;level&quot;:19, &quot;health&quot;:90&#125;&quot;</code>.</p><p>而如果替代者(replacer)是个 _函数_，这个函数将被对象的每个属性都调用一遍。<br>函数返回的值会成为这个属性的值，最终体现在转化后的JSON字符串中（译者注：Chrome下，经过实验，如果所有属性均返回同一个值的时候有异常，会直接将返回值作为结果输出而不会输出JSON字符串），而如果返回值为<code>undefined</code>，则该属性会被排除在外。</p></p></details><hr><h6 id="63-输出是什么"><a href="#63-输出是什么" class="headerlink" title="63. 输出是什么?"></a>63. 输出是什么?</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> increaseNumber = <span class="function">() =&gt;</span> num++;</span><br><span class="line"><span class="keyword">const</span> increasePassedNumber = <span class="function"><span class="params">number</span> =&gt;</span> number++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> num1 = increaseNumber();</span><br><span class="line"><span class="keyword">const</span> num2 = increasePassedNumber(num1);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(num1);</span><br><span class="line"><span class="built_in">console</span>.log(num2);</span><br></pre></td></tr></table></figure><ul><li>A: <code>10</code>, <code>10</code></li><li>B: <code>10</code>, <code>11</code></li><li>C: <code>11</code>, <code>11</code></li><li>D: <code>11</code>, <code>12</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-A-2"><a href="#答案-A-2" class="headerlink" title="答案: A"></a>答案: A</h4><p>一元操作符 <code>++</code> <em>先返回</em> 操作值, <em>再累加</em> 操作值。<code>num1</code>的值是<code>10</code>, 因为<code>increaseNumber</code>函数首先返回<code>num</code>的值，也就是<code>10</code>，随后再进行 <code>num</code>的累加。</p><p><code>num2</code>是<code>10</code>因为我们将 <code>num1</code>传入<code>increasePassedNumber</code>. <code>number</code>等于<code>10</code>（<code>num1</code>的值。同样道理，<code>++</code> <em>先返回</em> 操作值, <em>再累加</em> 操作值。） <code>number</code>是<code>10</code>，所以<code>num2</code>也是<code>10</code>.</p></p></details><hr><h6 id="64-输出什么"><a href="#64-输出什么" class="headerlink" title="64. 输出什么?"></a>64. 输出什么?</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> value = &#123; <span class="attr">number</span>: <span class="number">10</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> multiply = <span class="function">(<span class="params">x = &#123; ...value &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x.number *= <span class="number">2</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">multiply();</span><br><span class="line">multiply();</span><br><span class="line">multiply(value);</span><br><span class="line">multiply(value);</span><br></pre></td></tr></table></figure><ul><li>A: <code>20</code>, <code>40</code>, <code>80</code>, <code>160</code></li><li>B: <code>20</code>, <code>40</code>, <code>20</code>, <code>40</code></li><li>C: <code>20</code>, <code>20</code>, <code>20</code>, <code>40</code></li><li>D: <code>NaN</code>, <code>NaN</code>, <code>20</code>, <code>40</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-C-2"><a href="#答案-C-2" class="headerlink" title="答案: C"></a>答案: C</h4><p>在ES6中，我们可以使用默认值初始化参数。如果没有给函数传参，或者传的参值为 <code>&quot;undefined&quot;</code> ，那么参数的值将是默认值。上述例子中，我们将 <code>value</code> 对象进行了解构并传到一个新对象中，因此 <code>x</code> 的默认值为 <code>&#123;number：10&#125;</code> 。</p><p>默认参数在调用时才会进行计算，每次调用函数时，都会创建一个新的对象。我们前两次调用 <code>multiply</code> 函数且不传递值，那么每一次 <code>x</code> 的默认值都为 <code>&#123;number：10&#125;</code> ，因此打印出该数字的乘积值为<code>20</code>。</p><p>第三次调用 <code>multiply</code> 时，我们传递了一个参数，即对象<code>value</code>。 <code>*=</code>运算符实际上是<code>x.number = x.number * 2</code>的简写，我们修改了<code>x.number</code>的值，并打印出值<code>20</code>。</p><p>第四次，我们再次传递<code>value</code>对象。 <code>x.number</code>之前被修改为<code>20</code>，所以<code>x.number * = 2</code>打印为<code>40</code>。</p></p></details><hr><h6 id="65-输出什么"><a href="#65-输出什么" class="headerlink" title="65. 输出什么?"></a>65. 输出什么?</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].reduce(<span class="function">(<span class="params">x, y</span>) =&gt;</span> <span class="built_in">console</span>.log(x, y));</span><br></pre></td></tr></table></figure><ul><li>A: <code>1</code> <code>2</code> and <code>3</code> <code>3</code> and <code>6</code> <code>4</code></li><li>B: <code>1</code> <code>2</code> and <code>2</code> <code>3</code> and <code>3</code> <code>4</code></li><li>C: <code>1</code> <code>undefined</code> and <code>2</code> <code>undefined</code> and <code>3</code> <code>undefined</code> and <code>4</code> <code>undefined</code></li><li>D: <code>1</code> <code>2</code> and <code>undefined</code> <code>3</code> and <code>undefined</code> <code>4</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-D-1"><a href="#答案-D-1" class="headerlink" title="答案: D"></a>答案: D</h4><p><code>reducer</code> 函数接收4个参数:</p><ol><li>Accumulator (acc) (累计器)</li><li>Current Value (cur) (当前值)</li><li>Current Index (idx) (当前索引)</li><li>Source Array (src) (源数组)</li></ol><p><code>reducer</code> 函数的返回值将会分配给累计器，该返回值在数组的每个迭代中被记住，并最后成为最终的单个结果值。</p><p><code>reducer</code> 函数还有一个可选参数<code>initialValue</code>, 该参数将作为第一次调用回调函数时的第一个参数的值。如果没有提供<code>initialValue</code>，则将使用数组中的第一个元素。</p><p>在上述例子，<code>reduce</code>方法接收的第一个参数(Accumulator)是<code>x</code>, 第二个参数(Current Value)是<code>y</code>。</p><p>在第一次调用时，累加器<code>x</code>为<code>1</code>，当前值<code>“y”</code>为<code>2</code>，打印出累加器和当前值：<code>1</code>和<code>2</code>。</p><p>例子中我们的回调函数没有返回任何值，只是打印累加器的值和当前值。如果函数没有返回值，则默认返回<code>undefined</code>。 在下一次调用时，累加器为<code>undefined</code>，当前值为“3”, 因此<code>undefined</code>和<code>3</code>被打印出。</p><p>在第四次调用时，回调函数依然没有返回值。 累加器再次为 <code>undefined</code> ，当前值为“4”。 <code>undefined</code>和<code>4</code>被打印出。</p></p></details><hr><h6 id="66-使用哪个构造函数可以成功继承Dog类"><a href="#66-使用哪个构造函数可以成功继承Dog类" class="headerlink" title="66. 使用哪个构造函数可以成功继承Dog类?"></a>66. 使用哪个构造函数可以成功继承<code>Dog</code>类?</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Labrador</span> <span class="keyword">extends</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 1 </span></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name, size</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.size = size;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 2</span></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name, size</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(name);</span><br><span class="line">    <span class="built_in">this</span>.size = size;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 3</span></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">size</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(name);</span><br><span class="line">    <span class="built_in">this</span>.size = size;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 4 </span></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name, size</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.size = size;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>A: 1</li><li>B: 2</li><li>C: 3</li><li>D: 4</li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-B-2"><a href="#答案-B-2" class="headerlink" title="答案: B"></a>答案: B</h4><p>在子类中，在调用<code>super</code>之前不能访问到<code>this</code>关键字。 如果这样做，它将抛出一个<code>ReferenceError</code>：1和4将引发一个引用错误。</p><p>使用<code>super</code>关键字，需要用给定的参数来调用父类的构造函数。 父类的构造函数接收<code>name</code>参数，因此我们需要将<code>name</code>传递给<code>super</code>。</p><p><code>Labrador</code>类接收两个参数，<code>name</code>参数是由于它继承了<code>Dog</code>，<code>size</code>作为<code>Labrador</code>类的额外属性，它们都需要传递给<code>Labrador</code>的构造函数，因此使用构造函数2正确完成。</p></p></details><hr><h6 id="67-输出什么"><a href="#67-输出什么" class="headerlink" title="67. 输出什么?"></a>67. 输出什么?</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;running index.js&#x27;</span>);</span><br><span class="line"><span class="keyword">import</span> &#123; sum &#125; <span class="keyword">from</span> <span class="string">&#x27;./sum.js&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// sum.js</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;running sum.js&#x27;</span>);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> sum = <span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b;</span><br></pre></td></tr></table></figure><ul><li>A: <code>running index.js</code>, <code>running sum.js</code>, <code>3</code></li><li>B: <code>running sum.js</code>, <code>running index.js</code>, <code>3</code></li><li>C: <code>running sum.js</code>, <code>3</code>, <code>running index.js</code></li><li>D: <code>running index.js</code>, <code>undefined</code>, <code>running sum.js</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-B-3"><a href="#答案-B-3" class="headerlink" title="答案: B"></a>答案: B</h4><p><code>import</code>命令是编译阶段执行的，在代码运行之前。因此这意味着被导入的模块会先运行，而导入模块的文件会后执行。</p><p>这是CommonJS中<code>require（）</code>和<code>import</code>之间的区别。使用<code>require()</code>，您可以在运行代码时根据需要加载依赖项。 如果我们使用<code>require</code>而不是<code>import</code>，<code>running index.js</code>，<code>running sum.js</code>，<code>3</code>会被依次打印。</p></p></details><hr><h6 id="68-输出什么"><a href="#68-输出什么" class="headerlink" title="68. 输出什么?"></a>68. 输出什么?</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="number">2</span>) === <span class="built_in">Number</span>(<span class="number">2</span>))</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="literal">false</span>) === <span class="built_in">Boolean</span>(<span class="literal">false</span>))</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>) === <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>))</span><br></pre></td></tr></table></figure><ul><li>A: <code>true</code>, <code>true</code>, <code>false</code></li><li>B: <code>false</code>, <code>true</code>, <code>false</code></li><li>C: <code>true</code>, <code>false</code>, <code>true</code></li><li>D: <code>true</code>, <code>true</code>, <code>true</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-A-3"><a href="#答案-A-3" class="headerlink" title="答案: A"></a>答案: A</h4><p>每个<code>Symbol</code>都是完全唯一的。传递给<code>Symbol</code>的参数只是给<code>Symbol</code>的一个描述。 <code>Symbol</code>的值不依赖于传递的参数。 当我们测试相等时，我们创建了两个全新的符号：第一个<code>Symbol（&#39;foo&#39;）</code>，第二个<code>Symbol（&#39;foo&#39;）</code>, 这两个值是唯一的，彼此不相等，因此返回<code>false</code>。</p></p></details><hr><h6 id="69-输出什么"><a href="#69-输出什么" class="headerlink" title="69. 输出什么?"></a>69. 输出什么?</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">&quot;Lydia Hallie&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(name.padStart(<span class="number">13</span>))</span><br><span class="line"><span class="built_in">console</span>.log(name.padStart(<span class="number">2</span>))</span><br></pre></td></tr></table></figure><ul><li>A: <code>&quot;Lydia Hallie&quot;</code>, <code>&quot;Lydia Hallie&quot;</code></li><li>B: <code>&quot;           Lydia Hallie&quot;</code>, <code>&quot;  Lydia Hallie&quot;</code> (<code>&quot;[13x whitespace]Lydia Hallie&quot;</code>, <code>&quot;[2x whitespace]Lydia Hallie&quot;</code>)</li><li>C: <code>&quot; Lydia Hallie&quot;</code>, <code>&quot;Lydia Hallie&quot;</code> (<code>&quot;[1x whitespace]Lydia Hallie&quot;</code>, <code>&quot;Lydia Hallie&quot;</code>)</li><li>D: <code>&quot;Lydia Hallie&quot;</code>, <code>&quot;Lyd&quot;</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-C-3"><a href="#答案-C-3" class="headerlink" title="答案: C"></a>答案: C</h4><p>使用<code>padStart</code>方法，我们可以在字符串的开头添加填充。传递给此方法的参数是字符串的总长度（包含填充）。字符串<code>Lydia Hallie</code>的长度为<code>12</code>, 因此<code>name.padStart（13）</code>在字符串的开头只会插入1（<code>13 - 12 = 1</code>）个空格。</p><p>如果传递给<code>padStart</code>方法的参数小于字符串的长度，则不会添加填充。</p></p></details><hr><h6 id="70-输出什么"><a href="#70-输出什么" class="headerlink" title="70. 输出什么?"></a>70. 输出什么?</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;🥑&quot;</span> + <span class="string">&quot;💻&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li>A: <code>&quot;🥑💻&quot;</code></li><li>B: <code>257548</code></li><li>C: A string containing their code points</li><li>D: Error</li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-A-4"><a href="#答案-A-4" class="headerlink" title="答案: A"></a>答案: A</h4><p>使用<code>+</code>运算符，您可以连接字符串。 上述情况，我们将字符串<code>“🥑”</code>与字符串<code>”💻“</code>连接起来，产生<code>”🥑💻“</code>。</p></p></details><hr><h6 id="71-如何能打印出console-log语句后注释掉的值？"><a href="#71-如何能打印出console-log语句后注释掉的值？" class="headerlink" title="71. 如何能打印出console.log语句后注释掉的值？"></a>71. 如何能打印出<code>console.log</code>语句后注释掉的值？</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">startGame</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> 答案 = <span class="keyword">yield</span> <span class="string">&quot;Do you love JavaScript?&quot;</span>;</span><br><span class="line">  <span class="keyword">if</span> (答案 !== <span class="string">&quot;Yes&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Oh wow... Guess we&#x27;re gone here&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;JavaScript loves you back ❤️&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> game = startGame();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="comment">/* 1 */</span>); <span class="comment">// Do you love JavaScript?</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="comment">/* 2 */</span>); <span class="comment">// JavaScript loves you back ❤️</span></span><br></pre></td></tr></table></figure><ul><li>A: <code>game.next(&quot;Yes&quot;).value</code> and <code>game.next().value</code></li><li>B: <code>game.next.value(&quot;Yes&quot;)</code> and <code>game.next.value()</code></li><li>C: <code>game.next().value</code> and <code>game.next(&quot;Yes&quot;).value</code></li><li>D: <code>game.next.value()</code> and <code>game.next.value(&quot;Yes&quot;)</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-C-4"><a href="#答案-C-4" class="headerlink" title="答案: C"></a>答案: C</h4><p><code>generator</code>函数在遇到<code>yield</code>关键字时会“暂停”其执行。 首先，我们需要让函数产生字符串<code>Do you love JavaScript?</code>，这可以通过调用<code>game.next().value</code>来完成。上述函数的第一行就有一个<code>yield</code>关键字，那么运行立即停止了，<code>yield</code>表达式本身没有返回值，或者说总是返回<code>undefined</code>, 这意味着此时变量 <code>答案</code> 为<code>undefined</code></p><p><code>next</code>方法可以带一个参数，该参数会被当作上一个 <code>yield</code> 表达式的返回值。当我们调用<code>game.next(&quot;Yes&quot;).value</code>时，先前的 <code>yield</code> 的返回值将被替换为传递给<code>next()</code>函数的参数<code>&quot;Yes&quot;</code>。此时变量 <code>答案</code> 被赋值为 <code>&quot;Yes&quot;</code>，<code>if</code>语句返回<code>false</code>，所以<code>JavaScript loves you back ❤️</code>被打印。</p></p></details><hr><h6 id="72-输出什么"><a href="#72-输出什么" class="headerlink" title="72. 输出什么?"></a>72. 输出什么?</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.raw<span class="string">`Hello\nworld`</span>);</span><br></pre></td></tr></table></figure><ul><li>A: <code>Hello world!</code></li><li>B: <code>Hello</code> <br />&nbsp; &nbsp; &nbsp;<code>world</code></li><li>C: <code>Hello\nworld</code></li><li>D: <code>Hello\n</code> <br /> &nbsp; &nbsp; &nbsp;<code>world</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-C-5"><a href="#答案-C-5" class="headerlink" title="答案: C"></a>答案: C</h4><p><code>String.raw</code>函数是用来获取一个模板字符串的原始字符串的，它返回一个字符串，其中忽略了转义符（<code>\n</code>，<code>\v</code>，<code>\t</code>等）。但反斜杠可能造成问题，因为你可能会遇到下面这种类似情况：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="string">`C:\Documents\Projects\table.html`</span></span><br><span class="line"><span class="built_in">String</span>.raw<span class="string">`<span class="subst">$&#123;path&#125;</span>`</span></span><br></pre></td></tr></table></figure><p>这将导致：</p><p><code>&quot;C:DocumentsProjects able.html&quot;</code></p><p>直接使用<code>String.raw</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span>.raw<span class="string">`C:\Documents\Projects\table.html`</span></span><br></pre></td></tr></table></figure><p>它会忽略转义字符并打印：<code>C:\Documents\Projects\table.html</code></p><p>上述情况，字符串是<code>Hello\nworld</code>被打印出。</p></p></details><hr><h6 id="73-输出什么"><a href="#73-输出什么" class="headerlink" title="73. 输出什么?"></a>73. 输出什么?</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">&quot;I made it!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> data = getData();</span><br><span class="line"><span class="built_in">console</span>.log(data);</span><br></pre></td></tr></table></figure><ul><li>A: <code>&quot;I made it!&quot;</code></li><li>B: <code>Promise &#123;&lt;resolved&gt;: &quot;I made it!&quot;&#125;</code></li><li>C: <code>Promise &#123;&lt;pending&gt;&#125;</code></li><li>D: <code>undefined</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-C-6"><a href="#答案-C-6" class="headerlink" title="答案: C"></a>答案: C</h4><p>异步函数始终返回一个promise。<code>await</code>仍然需要等待promise的解决：当我们调用<code>getData()</code>并将其赋值给<code>data</code>，此时<code>data</code>为<code>getData</code>方法返回的一个挂起的promise，该promise并没有解决。</p><p>如果我们想要访问已解决的值<code>&quot;I made it!&quot;</code>，可以在<code>data</code>上使用<code>.then()</code>方法：</p><p><code>data.then(res =&gt; console.log(res))</code></p><p>这样将打印 <code>&quot;I made it!&quot;</code></p></p></details><hr><h6 id="74-输出什么"><a href="#74-输出什么" class="headerlink" title="74. 输出什么?"></a>74. 输出什么?</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addToList</span>(<span class="params">item, list</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> list.push(item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = addToList(<span class="string">&quot;apple&quot;</span>, [<span class="string">&quot;banana&quot;</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure><ul><li>A: <code>[&#39;apple&#39;, &#39;banana&#39;]</code></li><li>B: <code>2</code></li><li>C: <code>true</code></li><li>D: <code>undefined</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-B-4"><a href="#答案-B-4" class="headerlink" title="答案: B"></a>答案: B</h4><p><code>push()</code>方法返回新数组的长度。一开始，数组包含一个元素（字符串<code>&quot;banana&quot;</code>），长度为1。 在数组中添加字符串<code>&quot;apple&quot;</code>后，长度变为2，并将从<code>addToList</code>函数返回。</p><p><code>push</code>方法修改原始数组，如果你想从函数返回数组而不是数组长度，那么应该在push <code>item</code>之后返回<code>list</code>。</p></p></details><hr><h6 id="75-输出什么"><a href="#75-输出什么" class="headerlink" title="75. 输出什么?"></a>75. 输出什么?</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> box = &#123; <span class="attr">x</span>: <span class="number">10</span>, <span class="attr">y</span>: <span class="number">20</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.freeze(box);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> shape = box;</span><br><span class="line">shape.x = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">console</span>.log(shape)</span><br></pre></td></tr></table></figure><ul><li>A: <code>&#123; x: 100, y: 20 &#125;</code></li><li>B: <code>&#123; x: 10, y: 20 &#125;</code></li><li>C: <code>&#123; x: 100 &#125;</code></li><li>D: <code>ReferenceError</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-B-5"><a href="#答案-B-5" class="headerlink" title="答案: B"></a>答案: B</h4><p><code>Object.freeze</code>使得无法添加、删除或修改对象的属性（除非属性的值是另一个对象）。</p><p>当我们创建变量<code>shape</code>并将其设置为等于冻结对象<code>box</code>时，<code>shape</code>指向的也是冻结对象。你可以使用<code>Object.isFrozen</code>检查一个对象是否被冻结，上述情况，<code>Object.isFrozen（shape）</code>将返回<code>true</code>。</p><p>由于<code>shape</code>被冻结，并且<code>x</code>的值不是对象，所以我们不能修改属性<code>x</code>。 <code>x</code>仍然等于<code>10</code>，<code>&#123;x：10，y：20&#125;</code>被打印。</p><p>注意，上述例子我们对属性<code>x</code>进行修改，可能会导致抛出TypeError异常（最常见但不仅限于严格模式下时）。</p></p></details><hr><h6 id="76-输出什么"><a href="#76-输出什么" class="headerlink" title="76. 输出什么?"></a>76. 输出什么?</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; <span class="attr">name</span>: myName &#125; = &#123; <span class="attr">name</span>: <span class="string">&quot;Lydia&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(name);</span><br></pre></td></tr></table></figure><ul><li>A: <code>&quot;Lydia&quot;</code></li><li>B: <code>&quot;myName&quot;</code></li><li>C: <code>undefined</code></li><li>D: <code>ReferenceError</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-D-2"><a href="#答案-D-2" class="headerlink" title="答案: D"></a>答案: D</h4><p>当我们从右侧的对象解构属性<code>name</code>时，我们将其值<code>Lydia</code>分配给名为<code>myName</code>的变量。</p><p>使用<code>&#123;name：myName&#125;</code>，我们是在告诉JavaScript我们要创建一个名为<code>myName</code>的新变量，并且其值是右侧对象的<code>name</code>属性的值。</p><p>当我们尝试打印<code>name</code>，一个未定义的变量时，就会引发<code>ReferenceError</code>。</p></p></details><hr><h6 id="77-以下是个纯函数么"><a href="#77-以下是个纯函数么" class="headerlink" title="77. 以下是个纯函数么?"></a>77. 以下是个纯函数么?</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>A: Yes</li><li>B: No</li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-B-6"><a href="#答案-B-6" class="headerlink" title="答案: B"></a>答案: B</h4><p>纯函数一种若输入参数相同，则永远会得到相同输出的函数。</p><p>在特定情况下，即使输入相同参数，也不能得到相同的返回值：</p><pre>var a = b = {}a[Symbol.toPrimitive] = b[Symbol.toPrimitive] = () => Math.random()sum(a, b) // Uncertain</pre><p>所以它不是一个纯函数。</p></p></details><hr><h6 id="78-输出什么"><a href="#78-输出什么" class="headerlink" title="78. 输出什么?"></a>78. 输出什么?</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> add = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> cache = &#123;&#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">num</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (num <span class="keyword">in</span> cache) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">`From cache! <span class="subst">$&#123;cache[num]&#125;</span>`</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> result = num + <span class="number">10</span>;</span><br><span class="line">      cache[num] = result;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">`Calculated! <span class="subst">$&#123;result&#125;</span>`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> addFunction = add();</span><br><span class="line"><span class="built_in">console</span>.log(addFunction(<span class="number">10</span>));</span><br><span class="line"><span class="built_in">console</span>.log(addFunction(<span class="number">10</span>));</span><br><span class="line"><span class="built_in">console</span>.log(addFunction(<span class="number">5</span> * <span class="number">2</span>));</span><br></pre></td></tr></table></figure><ul><li>A: <code>Calculated! 20</code> <code>Calculated! 20</code> <code>Calculated! 20</code></li><li>B: <code>Calculated! 20</code> <code>From cache! 20</code> <code>Calculated! 20</code></li><li>C: <code>Calculated! 20</code> <code>From cache! 20</code> <code>From cache! 20</code></li><li>D: <code>Calculated! 20</code> <code>From cache! 20</code> <code>Error</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-C-7"><a href="#答案-C-7" class="headerlink" title="答案: C"></a>答案: C</h4><p><code>add</code>函数是一个记忆函数。 通过记忆化，我们可以缓存函数的结果，以加快其执行速度。上述情况，我们创建一个<code>cache</code>对象，用于存储先前返回过的值。</p><p>如果我们使用相同的参数多次调用<code>addFunction</code>函数，它首先检查缓存中是否已有该值，如果有，则返回缓存值，这将节省执行时间。如果没有，那么它将计算该值，并存储在缓存中。</p><p>我们用相同的值三次调用了<code>addFunction</code>函数：</p><p>在第一次调用，<code>num</code>等于<code>10</code>时函数的值尚未缓存，if语句<code>num in cache</code>返回<code>false</code>，else块的代码被执行：<code>Calculated! 20</code>，并且其结果被添加到缓存对象，<code>cache</code>现在看起来像<code>&#123;10：20&#125;</code>。</p><p>第二次，<code>cache</code>对象包含<code>10</code>的返回值。 if语句 <code>num in cache</code> 返回<code>true</code>，<code>From cache! 20</code>被打印。</p><p>第三次，我们将<code>5 * 2</code>(值为10)传递给函数。 <code>cache</code>对象包含<code>10</code>的返回值。 if语句 <code>num in cache</code> 返回<code>true</code>，<code>From cache! 20</code>被打印。</p></p></details><hr><h6 id="79-输出什么"><a href="#79-输出什么" class="headerlink" title="79. 输出什么?"></a><a name=20190726></a>79. 输出什么?</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myLifeSummedUp = [<span class="string">&quot;☕&quot;</span>, <span class="string">&quot;💻&quot;</span>, <span class="string">&quot;🍷&quot;</span>, <span class="string">&quot;🍫&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">in</span> myLifeSummedUp) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> myLifeSummedUp) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>A: <code>0</code> <code>1</code> <code>2</code> <code>3</code> and <code>&quot;☕&quot;</code> <code>&quot;💻&quot;</code> <code>&quot;🍷&quot;</code> <code>&quot;🍫&quot;</code></li><li>B: <code>&quot;☕&quot;</code> <code>&quot;💻&quot;</code> <code>&quot;🍷&quot;</code> <code>&quot;🍫&quot;</code> and <code>&quot;☕&quot;</code> <code>&quot;💻&quot;</code> <code>&quot;🍷&quot;</code> <code>&quot;🍫&quot;</code></li><li>C: <code>&quot;☕&quot;</code> <code>&quot;💻&quot;</code> <code>&quot;🍷&quot;</code> <code>&quot;🍫&quot;</code> and <code>0</code> <code>1</code> <code>2</code> <code>3</code></li><li>D:  <code>0</code> <code>1</code> <code>2</code> <code>3</code> and <code>&#123;0: &quot;☕&quot;, 1: &quot;💻&quot;, 2: &quot;🍷&quot;, 3: &quot;🍫&quot;&#125;</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-A-5"><a href="#答案-A-5" class="headerlink" title="答案: A"></a>答案: A</h4><p>通过<code>for-in</code>循环，我们可以遍历一个对象<strong>自有的</strong>、<strong>继承的</strong>、<strong>可枚举的</strong>、<strong>非Symbol的</strong>属性。 在数组中，可枚举属性是数组元素的“键”， 即它们的索引。 类似于下面这个对象：</p><p><code>&#123;0: &quot;☕&quot;, 1: &quot;💻&quot;, 2: &quot;🍷&quot;, 3: &quot;🍫&quot;&#125;</code></p><p>其中键则是可枚举属性，因此 <code>0</code>，<code>1</code>，<code>2</code>，<code>3</code>被记录。</p><p>通过<code>for-of</code>循环，我们可以迭代<strong>可迭代对象</strong>（包括 <code>Array</code>，<code>Map</code>，<code>Set</code>，<code>String</code>，<code>arguments</code>等）。当我们迭代数组时，在每次迭代中，不同属性的值将被分配给变量<code>item</code>, 因此<code>“☕”</code>，<code>“💻”</code>，<code>“🍷”</code>，<code>“🍫”</code>被打印。</p></p></details><hr><h6 id="80-输出什么"><a href="#80-输出什么" class="headerlink" title="80. 输出什么?"></a>80. 输出什么?</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> list = [<span class="number">1</span> + <span class="number">2</span>, <span class="number">1</span> * <span class="number">2</span>, <span class="number">1</span> / <span class="number">2</span>]</span><br><span class="line"><span class="built_in">console</span>.log(list)</span><br></pre></td></tr></table></figure><ul><li>A: <code>[&quot;1 + 2&quot;, &quot;1 * 2&quot;, &quot;1 / 2&quot;]</code></li><li>B: <code>[&quot;12&quot;, 2, 0.5]</code></li><li>C: <code>[3, 2, 0.5]</code></li><li>D:  <code>[1, 1, 1]</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-C-8"><a href="#答案-C-8" class="headerlink" title="答案: C"></a>答案: C</h4><p>数组元素可以包含任何值。 数字，字符串，布尔值，对象，数组，<code>null</code>，<code>undeifned</code>, 以及其他表达式，如日期，函数和计算。</p><p>元素将等于返回的值。 <code>1 + 2</code>返回<code>3</code>，<code>1 * 2</code>返回’2<code>，&#39;1 / 2</code>返回<code>0.5</code>。</p></p></details><hr><h6 id="81-输出什么"><a href="#81-输出什么" class="headerlink" title="81. 输出什么?"></a>81. 输出什么?</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`Hi there, <span class="subst">$&#123;name&#125;</span>`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sayHi())</span><br></pre></td></tr></table></figure><ul><li>A: <code>Hi there,</code></li><li>B: <code>Hi there, undefined</code></li><li>C: <code>Hi there, null</code></li><li>D:  <code>ReferenceError</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-B-7"><a href="#答案-B-7" class="headerlink" title="答案: B"></a>答案: B</h4><p>默认情况下，如果不给函数传参，参数的值将为<code>undefined</code>。 上述情况，我们没有给参数<code>name</code>传值。 <code>name</code>等于<code>undefined</code>，并被打印。</p><p>在ES6中，我们可以使用默认参数覆盖此默认的<code>undefined</code>值。 例如：</p><p><code>function sayHi（name =“Lydia”）&#123;...&#125;</code></p><p>在这种情况下，如果我们没有传递值或者如果我们传递<code>undefined</code>，<code>name</code>总是等于字符串<code>Lydia</code></p></p></details><hr><h6 id="82-输出什么"><a href="#82-输出什么" class="headerlink" title="82. 输出什么?"></a>82. 输出什么?</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> status = <span class="string">&quot;😎&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> status = <span class="string">&quot;😍&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> data = &#123;</span><br><span class="line">    status: <span class="string">&quot;🥑&quot;</span>,</span><br><span class="line">    <span class="function"><span class="title">getStatus</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.status</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(data.getStatus())</span><br><span class="line">  <span class="built_in">console</span>.log(data.getStatus.call(<span class="built_in">this</span>))</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><ul><li>A: <code>&quot;🥑&quot;</code> and <code>&quot;😍&quot;</code></li><li>B: <code>&quot;🥑&quot;</code> and <code>&quot;😎&quot;</code></li><li>C: <code>&quot;😍&quot;</code> and <code>&quot;😎&quot;</code></li><li>D: <code>&quot;😎&quot;</code> and <code>&quot;😎&quot;</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-B-8"><a href="#答案-B-8" class="headerlink" title="答案: B"></a>答案: B</h4><p><code>this</code>关键字的指向取决于使用它的位置。 在<strong>函数</strong>中，比如<code>getStatus</code>，<code>this</code>指向的是调用它的对象，上述例子中<code>data</code>对象调用了<code>getStatus</code>，因此<code>this</code>指向的就是<code>data</code>对象。 当我们打印<code>this.status</code>时，<code>data</code>对象的<code>status</code>属性被打印，即<code>&quot;🥑&quot;</code>。</p><p>使用<code>call</code>方法，可以更改<code>this</code>指向的对象。<code>data.getStatus.call(this)</code>是将<code>this</code>的指向由<code>data</code>对象更改为全局对象。在全局对象上，有一个名为<code>status</code>的变量，其值为<code>”😎“</code>。 因此打印<code>this.status</code>时，会打印<code>“😎”</code>。</p></p></details><hr><h6 id="83-输出什么"><a href="#83-输出什么" class="headerlink" title="83. 输出什么?"></a>83. 输出什么?</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  name: <span class="string">&quot;Lydia&quot;</span>,</span><br><span class="line">  age: <span class="number">21</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> city = person.city</span><br><span class="line">city = <span class="string">&quot;Amsterdam&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person)</span><br></pre></td></tr></table></figure><ul><li>A: <code>&#123; name: &quot;Lydia&quot;, age: 21 &#125;</code></li><li>B: <code>&#123; name: &quot;Lydia&quot;, age: 21, city: &quot;Amsterdam&quot; &#125;</code></li><li>C: <code>&#123; name: &quot;Lydia&quot;, age: 21, city: undefined &#125;</code></li><li>D: <code>&quot;Amsterdam&quot;</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-A-6"><a href="#答案-A-6" class="headerlink" title="答案: A"></a>答案: A</h4><p>我们将变量<code>city</code>设置为等于<code>person</code>对象上名为<code>city</code>的属性的值。 这个对象上没有名为<code>city</code>的属性，因此变量<code>city</code>的值为<code>undefined</code>。</p><p>请注意，我们没有引用<code>person</code>对象本身，只是将变量<code>city</code>设置为等于<code>person</code>对象上<code>city</code>属性的当前值。</p><p>然后，我们将<code>city</code>设置为等于字符串<code>“Amsterdam”</code>。 这不会更改person对象：没有对该对象的引用。</p><p>因此打印<code>person</code>对象时，会返回未修改的对象。</p></p></details><hr><h6 id="84-输出什么"><a href="#84-输出什么" class="headerlink" title="84. 输出什么?"></a>84. 输出什么?</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkAge</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (age &lt; <span class="number">18</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> message = <span class="string">&quot;Sorry, you&#x27;re too young.&quot;</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> message = <span class="string">&quot;Yay! You&#x27;re old enough!&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> message</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(checkAge(<span class="number">21</span>))</span><br></pre></td></tr></table></figure><ul><li>A: <code>&quot;Sorry, you&#39;re too young.&quot;</code></li><li>B: <code>&quot;Yay! You&#39;re old enough!&quot;</code></li><li>C: <code>ReferenceError</code></li><li>D: <code>undefined</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-C-9"><a href="#答案-C-9" class="headerlink" title="答案: C"></a>答案: C</h4><p><code>const</code>和<code>let</code>声明的变量是具有<strong>块级作用域</strong>的，块是大括号（<code>&#123;&#125;</code>）之间的任何东西, 即上述情况<code>if / else</code>语句的花括号。 由于块级作用域，我们无法在声明的块之外引用变量，因此抛出<code>ReferenceError</code>。</p></p></details><hr><h6 id="85-什么样的信息将被打印"><a href="#85-什么样的信息将被打印" class="headerlink" title="85. 什么样的信息将被打印?"></a>85. 什么样的信息将被打印?</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fetch(<span class="string">&#x27;https://www.website.com/api/user/1&#x27;</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> res.json())</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br></pre></td></tr></table></figure><ul><li>A: <code>fetch</code>方法的结果</li><li>B: 第二次调用<code>fetch</code>方法的结果</li><li>C: 前一个<code>.then()</code>中回调方法返回的结果</li><li>D: 总是<code>undefined</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-C-10"><a href="#答案-C-10" class="headerlink" title="答案: C"></a>答案: C</h4><p>第二个<code>.then</code>中<code>res</code>的值等于前一个<code>.then</code>中的回调函数返回的值。 你可以像这样继续链接<code>.then</code>，将值传递给下一个处理程序。</p></p></details><hr><h6 id="86-哪个选项是将hasName设置为true的方法，前提是不能将true作为参数传递"><a href="#86-哪个选项是将hasName设置为true的方法，前提是不能将true作为参数传递" class="headerlink" title="86. 哪个选项是将hasName设置为true的方法，前提是不能将true作为参数传递?"></a>86. 哪个选项是将<code>hasName</code>设置为<code>true</code>的方法，前提是不能将<code>true</code>作为参数传递?</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> hasName = <span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>A: <code>!!name</code></li><li>B: <code>name</code></li><li>C: <code>new Boolean(name)</code></li><li>D: <code>name.length</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-A-7"><a href="#答案-A-7" class="headerlink" title="答案: A"></a>答案: A</h4><p>使用逻辑非运算符<code>!</code>，将返回一个布尔值，使用<code>!! name</code>，我们可以确定<code>name</code>的值是真的还是假的。 如果<code>name</code>是真实的，那么<code>!name</code>返回<code>false</code>。 <code>!false</code>返回<code>true</code>。</p><p>通过将<code>hasName</code>设置为<code>name</code>，可以将<code>hasName</code>设置为等于传递给<code>getName</code>函数的值，而不是布尔值<code>true</code>。</p><p><code>new Boolean（true）</code>返回一个对象包装器，而不是布尔值本身。</p><p><code>name.length</code>返回传递的参数的长度，而不是布尔值<code>true</code>。</p></p></details><h6 id="87-输出什么"><a href="#87-输出什么" class="headerlink" title="87. 输出什么?"></a>87. 输出什么?</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;I want pizza&quot;</span>[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><ul><li>A: <code>&quot;&quot;&quot;</code></li><li>B: <code>&quot;I&quot;</code></li><li>C: <code>SyntaxError</code></li><li>D: <code>undefined</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-B-9"><a href="#答案-B-9" class="headerlink" title="答案: B"></a>答案: B</h4><p>可以使用方括号表示法获取字符串中特定索引的字符，字符串中的第一个字符具有索引0，依此类推。 在这种情况下，我们想要得到索引为0的元素，字符<code>&#39;I&#39;</code>被记录。</p><p>请注意，IE7及更低版本不支持此方法。 在这种情况下，应该使用<code>.charAt（）</code></p></p></details><hr><h6 id="88-输出什么"><a href="#88-输出什么" class="headerlink" title="88. 输出什么?"></a>88. 输出什么?</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2 = num1</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(num1 + num2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><ul><li>A: <code>NaN</code></li><li>B: <code>20</code></li><li>C: <code>ReferenceError</code></li><li>D: <code>undefined</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-B-10"><a href="#答案-B-10" class="headerlink" title="答案: B"></a>答案: B</h4><p>您可以将默认参数的值设置为函数的另一个参数，只要另一个参数定义在其之前即可。 我们将值<code>10</code>传递给<code>sum</code>函数。 如果<code>sum</code>函数只接收1个参数，则意味着没有传递<code>num2</code>的值，这种情况下，<code>num1</code>的值等于传递的值<code>10</code>。 <code>num2</code>的默认值是<code>num1</code>的值，即<code>10</code>。 <code>num1 + num2</code>返回<code>20</code>。</p><p>如果您尝试将默认参数的值设置为后面定义的参数，则可能导致参数的值尚未初始化，从而引发错误。比如：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">m = n, n = <span class="number">2</span></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(m, n)</span><br><span class="line">&#125;</span><br><span class="line">test() <span class="comment">// Uncaught ReferenceError: Cannot access &#x27;n&#x27; before initialization</span></span><br><span class="line">test(<span class="number">3</span>) <span class="comment">// 3 2</span></span><br><span class="line">test(<span class="number">3</span>, <span class="number">4</span>) <span class="comment">// 3 4</span></span><br></pre></td></tr></table></figure></p></details><hr><h6 id="89-输出什么"><a href="#89-输出什么" class="headerlink" title="89. 输出什么?"></a>89. 输出什么?</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// module.js </span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> () =&gt; <span class="string">&quot;Hello world&quot;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> name = <span class="string">&quot;Lydia&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// index.js </span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> data <span class="keyword">from</span> <span class="string">&quot;./module&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(data)</span><br></pre></td></tr></table></figure><ul><li>A: <code>&#123; default: function default(), name: &quot;Lydia&quot; &#125;</code></li><li>B: <code>&#123; default: function default() &#125;</code></li><li>C: <code>&#123; default: &quot;Hello world&quot;, name: &quot;Lydia&quot; &#125;</code></li><li>D: Global object of <code>module.js</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-A-8"><a href="#答案-A-8" class="headerlink" title="答案: A"></a>答案: A</h4><p>使用<code>import * as name</code>语法，我们将<code>module.js</code>文件中所有<code>export</code>导入到<code>index.js</code>文件中，并且创建了一个名为<code>data</code>的新对象。 在<code>module.js</code>文件中，有两个导出：默认导出和命名导出。 默认导出是一个返回字符串“Hello World”的函数，命名导出是一个名为<code>name</code>的变量，其值为字符串<code>“Lydia”</code>。</p><p><code>data</code>对象具有默认导出的<code>default</code>属性，其他属性具有指定exports的名称及其对应的值。</p></p></details><hr><h6 id="90-输出什么"><a href="#90-输出什么" class="headerlink" title="90. 输出什么?"></a>90. 输出什么?</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> member = <span class="keyword">new</span> Person(<span class="string">&quot;John&quot;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> member)</span><br></pre></td></tr></table></figure><ul><li>A: <code>&quot;class&quot;</code></li><li>B: <code>&quot;function&quot;</code></li><li>C: <code>&quot;object&quot;</code></li><li>D: <code>&quot;string&quot;</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-C-11"><a href="#答案-C-11" class="headerlink" title="答案: C"></a>答案: C</h4><p>类是构造函数的语法糖，如果用构造函数的方式来重写<code>Person</code>类则将是：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>new</code>来调用构造函数，将会生成构造函数<code>Person</code>的实例，对实例执行<code>typeof</code>关键字将返回<code>&quot;object&quot;</code>，上述情况打印出<code>&quot;object&quot;</code>。</p></p></details><hr><h6 id="91-输出什么"><a href="#91-输出什么" class="headerlink" title="91. 输出什么?"></a>91. 输出什么?</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> newList = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].push(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(newList.push(<span class="number">5</span>))</span><br></pre></td></tr></table></figure><ul><li>A: <code>[1, 2, 3, 4, 5]</code></li><li>B: <code>[1, 2, 3, 5]</code></li><li>C: <code>[1, 2, 3, 4]</code></li><li>D: <code>Error</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-D-3"><a href="#答案-D-3" class="headerlink" title="答案: D"></a>答案: D</h4><p><code>.push</code>方法返回数组的长度，而不是数组本身！ 通过将<code>newList</code>设置为<code>[1,2,3].push(4)</code>，实际上<code>newList</code>等于数组的新长度：<code>4</code>。</p><p>然后，尝试在<code>newList</code>上使用<code>.push</code>方法。 由于<code>newList</code>是数值<code>4</code>，抛出TypeError。</p></p></details><hr><h6 id="92-输出什么"><a href="#92-输出什么" class="headerlink" title="92. 输出什么?"></a>92. 输出什么?</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">giveLydiaPizza</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;Here is pizza!&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> giveLydiaChocolate = <span class="function">() =&gt;</span> <span class="string">&quot;Here&#x27;s chocolate... now go hit the gym already.&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(giveLydiaPizza.prototype)</span><br><span class="line"><span class="built_in">console</span>.log(giveLydiaChocolate.prototype)</span><br></pre></td></tr></table></figure><ul><li>A: <code>&#123; constructor: ...&#125;</code> <code>&#123; constructor: ...&#125;</code> </li><li>B: <code>&#123;&#125;</code> <code>&#123; constructor: ...&#125;</code> </li><li>C: <code>&#123; constructor: ...&#125;</code> <code>&#123;&#125;</code></li><li>D: <code>&#123; constructor: ...&#125;</code> <code>undefined</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-D-4"><a href="#答案-D-4" class="headerlink" title="答案: D"></a>答案: D</h4><p>常规函数，例如<code>giveLydiaPizza</code>函数，有一个<code>prototype</code>属性，它是一个带有<code>constructor</code>属性的对象（原型对象）。 然而，箭头函数，例如<code>giveLydiaChocolate</code>函数，没有这个<code>prototype</code>属性。 尝试使用<code>giveLydiaChocolate.prototype</code>访问<code>prototype</code>属性时会返回<code>undefined</code>。</p></p></details><hr><h6 id="93-输出什么"><a href="#93-输出什么" class="headerlink" title="93. 输出什么?"></a>93. 输出什么?</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  name: <span class="string">&quot;Lydia&quot;</span>,</span><br><span class="line">  age: <span class="number">21</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> [x, y] <span class="keyword">of</span> <span class="built_in">Object</span>.entries(person)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x, y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>A: <code>name</code> <code>Lydia</code> and <code>age</code> <code>21</code></li><li>B: <code>[&quot;name&quot;, &quot;Lydia&quot;]</code> and <code>[&quot;age&quot;, 21]</code> </li><li>C: <code>[&quot;name&quot;, &quot;age&quot;]</code> and <code>undefined</code></li><li>D: <code>Error</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-A-9"><a href="#答案-A-9" class="headerlink" title="答案: A"></a>答案: A</h4><p><code>Object.entries()</code>方法返回一个给定对象自身可枚举属性的键值对数组，上述情况返回一个二维数组，数组每个元素是一个包含键和值的数组：</p><p><code>[[&#39;name&#39;，&#39;Lydia&#39;]，[&#39;age&#39;，21]]</code></p><p>使用<code>for-of</code>循环，我们可以迭代数组中的每个元素，上述情况是子数组。 我们可以使用<code>const [x，y]</code>在<code>for-of</code>循环中解构子数组。 <code>x</code>等于子数组中的第一个元素，<code>y</code>等于子数组中的第二个元素。</p><p>第一个子阵列是<code>[“name”，“Lydia”]</code>，其中<code>x</code>等于<code>name</code>，而<code>y</code>等于<code>Lydia</code>。<br>第二个子阵列是<code>[“age”，21]</code>，其中<code>x</code>等于<code>age</code>，而<code>y</code>等于<code>21</code>。</p></p></details><hr><h6 id="94-输出什么"><a href="#94-输出什么" class="headerlink" title="94. 输出什么?"></a>94. 输出什么?</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getItems</span>(<span class="params">fruitList, ...args, favoriteFruit</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [...fruitList, ...args, favoriteFruit]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getItems([<span class="string">&quot;banana&quot;</span>, <span class="string">&quot;apple&quot;</span>], <span class="string">&quot;pear&quot;</span>, <span class="string">&quot;orange&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li>A: <code>[&quot;banana&quot;, &quot;apple&quot;, &quot;pear&quot;, &quot;orange&quot;]</code></li><li>B: <code>[[&quot;banana&quot;, &quot;apple&quot;], &quot;pear&quot;, &quot;orange&quot;]</code> </li><li>C: <code>[&quot;banana&quot;, &quot;apple&quot;, [&quot;pear&quot;], &quot;orange&quot;]</code></li><li>D: <code>SyntaxError</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-D-5"><a href="#答案-D-5" class="headerlink" title="答案: D"></a>答案: D</h4><p><code>... args</code>是剩余参数，剩余参数的值是一个包含所有剩余参数的数组，<strong>并且只能作为最后一个参数</strong>。上述示例中，剩余参数是第二个参数，这是不可能的，并会抛出语法错误。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getItems</span>(<span class="params">fruitList, favoriteFruit, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [...fruitList, ...args, favoriteFruit]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getItems([<span class="string">&quot;banana&quot;</span>, <span class="string">&quot;apple&quot;</span>], <span class="string">&quot;pear&quot;</span>, <span class="string">&quot;orange&quot;</span>)</span><br></pre></td></tr></table></figure><p>上述例子是有效的，将会返回数组：<code>[ &#39;banana&#39;, &#39;apple&#39;, &#39;orange&#39;, &#39;pear&#39; ]</code></p></p></details><hr><h6 id="95-输出什么"><a href="#95-输出什么" class="headerlink" title="95. 输出什么?"></a><a name=20190817></a>95. 输出什么?</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">nums</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span></span><br><span class="line">  (a &gt; b)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;a is bigger&#x27;</span>)</span><br><span class="line">  <span class="keyword">else</span> </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;b is bigger&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span> </span><br><span class="line">  a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(nums(<span class="number">4</span>, <span class="number">2</span>))</span><br><span class="line"><span class="built_in">console</span>.log(nums(<span class="number">1</span>, <span class="number">2</span>))</span><br></pre></td></tr></table></figure><ul><li>A: <code>a is bigger</code>, <code>6</code> and <code>b is bigger</code>, <code>3</code></li><li>B: <code>a is bigger</code>, <code>undefined</code> and <code>b is bigger</code>, <code>undefined</code></li><li>C: <code>undefined</code> and <code>undefined</code></li><li>D: <code>SyntaxError</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-B-11"><a href="#答案-B-11" class="headerlink" title="答案: B"></a>答案: B</h4><p>在JavaScript中，我们不必显式地编写分号(<code>;</code>)，但是JavaScript引擎仍然在语句之后自动添加分号。这称为<strong>自动分号插入</strong>。例如，一个语句可以是变量，或者像<code>throw</code>、<code>return</code>、<code>break</code>这样的关键字。</p><p>在这里，我们在新的一行上写了一个<code>return</code>语句和另一个值<code>a + b</code>。然而，由于它是一个新行，引擎并不知道它实际上是我们想要返回的值。相反，它会在<code>return</code>后面自动添加分号。你可以这样看:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span>;</span><br><span class="line">a + b</span><br></pre></td></tr></table></figure><p>这意味着永远不会到达<code>a + b</code>，因为函数在<code>return</code>关键字之后停止运行。如果没有返回值，就像这里，函数返回<code>undefined</code>。注意，在<code>if/else</code>语句之后没有自动插入!</p></p></details><hr><h6 id="96-输出什么"><a href="#96-输出什么" class="headerlink" title="96. 输出什么?"></a>96. 输出什么?</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&quot;Lydia&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person = <span class="class"><span class="keyword">class</span> <span class="title">AnotherPerson</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&quot;Sarah&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> member = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="built_in">console</span>.log(member.name)</span><br></pre></td></tr></table></figure><ul><li>A: <code>&quot;Lydia&quot;</code></li><li>B: <code>&quot;Sarah&quot;</code></li><li>C: <code>Error: cannot redeclare Person</code></li><li>D: <code>SyntaxError</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-B-12"><a href="#答案-B-12" class="headerlink" title="答案: B"></a>答案: B</h4><p>我们可以将类设置为等于其他类/函数构造函数。 在这种情况下，我们将<code>Person</code>设置为<code>AnotherPerson</code>。 这个构造函数的名字是<code>Sarah</code>，所以新的<code>Person</code>实例<code>member</code>上的name属性是<code>Sarah</code>。</p></p></details><hr><h6 id="97-输出什么"><a href="#97-输出什么" class="headerlink" title="97. 输出什么?"></a>97. 输出什么?</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> info = &#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>(<span class="string">&#x27;a&#x27;</span>)]: <span class="string">&#x27;b&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(info)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(info))</span><br></pre></td></tr></table></figure><ul><li>A: <code>&#123;Symbol(&#39;a&#39;): &#39;b&#39;&#125;</code> and <code>[&quot;&#123;Symbol(&#39;a&#39;)&quot;]</code></li><li>B: <code>&#123;&#125;</code> and <code>[]</code></li><li>C: <code>&#123; a: &quot;b&quot; &#125;</code> and <code>[&quot;a&quot;]</code></li><li>D: <code>&#123;Symbol(&#39;a&#39;): &#39;b&#39;&#125;</code> and <code>[]</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-D-6"><a href="#答案-D-6" class="headerlink" title="答案: D"></a>答案: D</h4><p><code>Symbol</code>类型是不可枚举的。<code>Object.keys</code>方法返回对象上的所有可枚举的键属性。<code>Symbol</code>类型是不可见的，并返回一个空数组。 记录整个对象时，所有属性都是可见的，甚至是不可枚举的属性。</p><p>这是<code>Symbol</code>的众多特性之一：除了表示完全唯一的值（防止对象意外名称冲突，例如当使用2个想要向同一对象添加属性的库时），您还可以<code>隐藏</code>这种方式对象的属性（尽管不完全。你仍然可以使用<code>Object.getOwnPropertySymbols()</code>方法访问 <code>Symbol</code>。</p></p></details><hr><h6 id="98-输出什么"><a href="#98-输出什么" class="headerlink" title="98. 输出什么?"></a>98. 输出什么?</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> getList = <span class="function">(<span class="params">[x, ...y]</span>) =&gt;</span> [x, y]</span><br><span class="line"><span class="keyword">const</span> getUser = <span class="function"><span class="params">user</span> =&gt;</span> &#123; <span class="attr">name</span>: user.name, <span class="attr">age</span>: user.age &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">const</span> user = &#123; <span class="attr">name</span>: <span class="string">&quot;Lydia&quot;</span>, <span class="attr">age</span>: <span class="number">21</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(getList(list))</span><br><span class="line"><span class="built_in">console</span>.log(getUser(user))</span><br></pre></td></tr></table></figure><ul><li>A: <code>[1, [2, 3, 4]]</code> and <code>undefined</code></li><li>B: <code>[1, [2, 3, 4]]</code> and <code>&#123; name: &quot;Lydia&quot;, age: 21 &#125;</code></li><li>C: <code>[1, 2, 3, 4]</code> and <code>&#123; name: &quot;Lydia&quot;, age: 21 &#125;</code></li><li>D: <code>Error</code> and <code>&#123; name: &quot;Lydia&quot;, age: 21 &#125;</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-A-10"><a href="#答案-A-10" class="headerlink" title="答案: A"></a>答案: A</h4><p><code>getList</code>函数接收一个数组作为其参数。 在<code>getList</code>函数的括号之间，我们立即解构这个数组。 您可以将其视为：</p><p> <code>[x, ...y] = [1, 2, 3, 4]</code></p><p>使用剩余的参数<code>... y</code>，我们将所有剩余参数放在一个数组中。 在这种情况下，其余的参数是<code>2</code>，<code>3</code>和<code>4</code>。 <code>y</code>的值是一个数组，包含所有其余参数。 在这种情况下，<code>x</code>的值等于<code>1</code>，所以当我们打印<code>[x，y]</code>时，会打印<code>[1，[2,3,4]]</code>。</p><p> <code>getUser</code>函数接收一个对象。对于箭头函数，如果只返回一个值，我们不必编写花括号。但是，如果您想从一个箭头函数返回一个对象，您必须在圆括号之间编写它，否则不会返回任何值!下面的函数将返回一个对象:</p><p><code>const getUser = user =&gt; (&#123; name: user.name, age: user.age &#125;)</code></p><p>由于在这种情况下不返回任何值，因此该函数返回<code>undefined</code>。</p></p></details><hr><h6 id="99-输出什么"><a href="#99-输出什么" class="headerlink" title="99. 输出什么?"></a>99. 输出什么?</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">&quot;Lydia&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(name())</span><br></pre></td></tr></table></figure><ul><li>A: <code>SyntaxError</code></li><li>B: <code>ReferenceError</code></li><li>C: <code>TypeError</code></li><li>D: <code>undefined</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-C-12"><a href="#答案-C-12" class="headerlink" title="答案: C"></a>答案: C</h4><p>变量<code>name</code>保存字符串的值，该字符串不是函数，因此无法调用。</p><p>当值不是预期类型时，会抛出<code>TypeErrors</code>。 JavaScript期望<code>name</code>是一个函数，因为我们试图调用它。 但它是一个字符串，因此抛出<code>TypeError</code>：<code>name is not a function</code></p><p>当你编写了一些非有效的JavaScript时，会抛出语法错误，例如当你把<code>return</code>这个词写成<code>retrun</code>时。<br>当JavaScript无法找到您尝试访问的值的引用时，抛出<code>ReferenceErrors</code>。</p></p></details><hr><h6 id="100-输出什么"><a href="#100-输出什么" class="headerlink" title="100. 输出什么?"></a>100. 输出什么?</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 🎉✨ This is my 100th question! ✨🎉</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> output = <span class="string">`<span class="subst">$&#123;[] &amp;&amp; <span class="string">&#x27;Im&#x27;</span>&#125;</span>possible!</span></span><br><span class="line"><span class="string">You should<span class="subst">$&#123;<span class="string">&#x27;&#x27;</span> &amp;&amp; <span class="string">`n&#x27;t`</span>&#125;</span> see a therapist after so much JavaScript lol`</span></span><br></pre></td></tr></table></figure><ul><li>A: <code>possible! You should see a therapist after so much JavaScript lol</code></li><li>B: <code>Impossible! You should see a therapist after so much JavaScript lol</code></li><li>C: <code>possible! You shouldn&#39;t see a therapist after so much JavaScript lol</code></li><li>D: <code>Impossible! You shouldn&#39;t see a therapist after so much JavaScript lol</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-B-13"><a href="#答案-B-13" class="headerlink" title="答案: B"></a>答案: B</h4><p><code>[]</code>是一个真值。 使用<code>&amp;&amp;</code>运算符，如果左侧值是真值，则返回右侧值。 在这种情况下，左侧值<code>[]</code>是一个真值，所以返回<code>Im</code>。</p><p><code>&quot;&quot;</code>是一个假值。 如果左侧值是假的，则不返回任何内容。 <code>n&#39;t</code>不会被退回。</p></p></details><hr><h6 id="101-输出什么"><a href="#101-输出什么" class="headerlink" title="101.输出什么?"></a>101.输出什么?</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> one = (<span class="literal">false</span> || &#123;&#125; || <span class="literal">null</span>)</span><br><span class="line"><span class="keyword">const</span> two = (<span class="literal">null</span> || <span class="literal">false</span> || <span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> three = ([] || <span class="number">0</span> || <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(one, two, three)</span><br></pre></td></tr></table></figure><ul><li>A: <code>false</code> <code>null</code> <code>[]</code></li><li>B: <code>null</code> <code>&quot;&quot;</code> <code>true</code></li><li>C: <code>&#123;&#125;</code> <code>&quot;&quot;</code> <code>[]</code></li><li>D: <code>null</code> <code>null</code> <code>true</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-C-13"><a href="#答案-C-13" class="headerlink" title="答案: C"></a>答案: C</h4><p>使用<code>||</code>运算符，我们可以返回第一个真值。 如果所有值都是假值，则返回最后一个值。</p><p><code>（false || &#123;&#125; || null）</code>：空对象<code>&#123;&#125;</code>是一个真值。 这是第一个（也是唯一的）真值，它将被返回。<code>one</code>等于<code>&#123;&#125;</code>。</p><p><code>（null || false ||“”）</code>：所有值都是假值。 这意味着返回传递的值<code>&quot;&quot;</code>。 <code>two</code>等于<code>&quot;&quot;</code>。</p><p><code>（[] || 0 ||“”）</code>：空数组<code>[]</code>是一个真值。 这是第一个返回的真值。 <code>three</code>等于<code>[]</code>。</p></p></details><hr><h6 id="102-依次输出什么"><a href="#102-依次输出什么" class="headerlink" title="102. 依次输出什么?"></a>102. 依次输出什么?</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myPromise = <span class="function">() =&gt;</span> <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;I have resolved!&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">firstFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  myPromise().then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;second&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">secondFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">await</span> myPromise())</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;second&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">firstFunction()</span><br><span class="line">secondFunction()</span><br></pre></td></tr></table></figure><ul><li>A: <code>I have resolved!</code>, <code>second</code> and <code>I have resolved!</code>, <code>second</code></li><li>B: <code>second</code>, <code>I have resolved!</code> and <code>second</code>, <code>I have resolved!</code></li><li>C: <code>I have resolved!</code>, <code>second</code> and <code>second</code>, <code>I have resolved!</code></li><li>D: <code>second</code>, <code>I have resolved!</code> and <code>I have resolved!</code>, <code>second</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-D-7"><a href="#答案-D-7" class="headerlink" title="答案: D"></a>答案: D</h4><p>有了promise，我们通常会说：当我想要调用某个方法，但是由于它可能需要一段时间，因此暂时将它放在一边。只有当某个值被resolved/rejected，并且执行栈为空时才使用这个值。</p><p>我们可以在<code>async</code>函数中通过<code>.then</code>和<code>await</code>关键字获得该值。 尽管我们可以通过<code>.then</code>和<code>await</code>获得promise的价值，但是它们的工作方式有所不同。</p><p>在 <code>firstFunction</code>中，当运行到<code>myPromise</code>方法时我们将其放在一边，即promise进入微任务队列，其他后面的代码（<code>console.log(&#39;second&#39;)</code>）照常运行，因此<code>second</code>被打印出，<code>firstFunction</code>方法到此执行完毕，执行栈中宏任务队列被清空，此时开始执行微任务队列中的任务，<code>I have resolved</code>被打印出。</p><p>在<code>secondFunction</code>方法中，我们通过<code>await</code>关键字，暂停了后面代码的执行，直到异步函数的值被解析才开始后面代码的执行。这意味着，它会等着直到 <code>myPromise</code> 以值<code>I have resolved</code>被解决之后，下一行<code>second</code>才开始执行。</p></p></details><hr><h6 id="103-输出什么"><a href="#103-输出什么" class="headerlink" title="103. 输出什么?"></a>103. 输出什么?</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line"></span><br><span class="line">set.add(<span class="number">1</span>)</span><br><span class="line">set.add(<span class="string">&quot;Lydia&quot;</span>)</span><br><span class="line">set.add(&#123; <span class="attr">name</span>: <span class="string">&quot;Lydia&quot;</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> set) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item + <span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>A: <code>3</code>, <code>NaN</code>, <code>NaN</code></li><li>B: <code>3</code>, <code>7</code>, <code>NaN</code></li><li>C: <code>3</code>, <code>Lydia2</code>, <code>[Object object]2</code></li><li>D: <code>&quot;12&quot;</code>, <code>Lydia2</code>, <code>[Object object]2</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-C-14"><a href="#答案-C-14" class="headerlink" title="答案: C"></a>答案: C</h4><p>“+”运算符不仅用于添加数值，还可以使用它来连接字符串。 每当JavaScript引擎发现一个或多个值不是数字时，就会将数字强制为字符串。 </p><p>第一个是数字1。 1 + 2返回数字3。</p><p>但是，第二个是字符串“Lydia”。 “Lydia”是一个字符串，2是一个数字：2被强制转换为字符串。 “Lydia”和“2”被连接起来，产生字符串“Lydia2”。</p><p><code>&#123;name：“ Lydia”&#125;</code>是一个对象。 数字和对象都不是字符串，因此将二者都字符串化。 每当我们对常规对象进行字符串化时，它就会变成<code>[Object object]</code>。 与“2”串联的“ [Object object]”成为“[Object object]2”。</p></p></details><hr><h6 id="104-结果是什么"><a href="#104-结果是什么" class="headerlink" title="104. 结果是什么?"></a>104. 结果是什么?</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="number">5</span>)</span><br></pre></td></tr></table></figure><ul><li>A: <code>5</code></li><li>B: <code>Promise &#123;&lt;pending&gt;: 5&#125;</code></li><li>C: <code>Promise &#123;&lt;fulfilled&gt;: 5&#125;</code></li><li>D: <code>Error</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-C-15"><a href="#答案-C-15" class="headerlink" title="答案: C"></a>答案: C</h4><p>我们可以将我们想要的任何类型的值传递<code>Promise.resolve</code>，无论是否<code>promise</code>。 该方法本身返回带有已解析值的<code>Promise</code> (<code>&lt;fulfilled&gt;</code>)。 如果您传递常规函数，它将是具有常规值的已解决<code>promise</code>。 如果你通过了promise，它将是一个已经resolved的且带有传的值的promise。</p><p>上述情况，我们传了数字5，因此返回一个resolved状态的promise，resolve值为<code>5</code></p></p></details><h6 id="105-输出什么"><a href="#105-输出什么" class="headerlink" title="105. 输出什么?"></a>105. 输出什么?</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compareMembers</span>(<span class="params">person1, person2 = person</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (person1 !== person2) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Not the same!&quot;</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;They are the same!&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = &#123; <span class="attr">name</span>: <span class="string">&quot;Lydia&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line">compareMembers(person)</span><br></pre></td></tr></table></figure><ul><li>A: <code>Not the same!</code></li><li>B: <code>They are the same!</code></li><li>C: <code>ReferenceError</code></li><li>D: <code>SyntaxError</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-B-14"><a href="#答案-B-14" class="headerlink" title="答案: B"></a>答案: B</h4><p>对象通过引用传递。 当我们检查对象的严格相等性（===）时，我们正在比较它们的引用。</p><p>我们将“person2”的默认值设置为“person”对象，并将“person”对象作为“person1”的值传递。</p><p>这意味着两个值都引用内存中的同一位置，因此它们是相等的。</p><p>运行“ else”语句中的代码块，并记录<code>They are the same!</code> 。</p></p></details><hr><h6 id="106-输出什么"><a href="#106-输出什么" class="headerlink" title="106. 输出什么?"></a>106. 输出什么?</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> colorConfig = &#123;</span><br><span class="line">  red: <span class="literal">true</span>,</span><br><span class="line">  blue: <span class="literal">false</span>,</span><br><span class="line">  green: <span class="literal">true</span>,</span><br><span class="line">  black: <span class="literal">true</span>,</span><br><span class="line">  yellow: <span class="literal">false</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> colors = [<span class="string">&quot;pink&quot;</span>, <span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(colorConfig.colors[<span class="number">1</span>])</span><br></pre></td></tr></table></figure><ul><li>A: <code>true</code></li><li>B: <code>false</code></li><li>C: <code>undefined</code></li><li>D: <code>TypeError</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-D-8"><a href="#答案-D-8" class="headerlink" title="答案: D"></a>答案: D</h4><p>在JavaScript中，我们有两种访问对象属性的方法：括号表示法或点表示法。 在此示例中，我们使用点表示法（<code>colorConfig.colors</code>）代替括号表示法（<code>colorConfig [“ colors”]</code>）。</p><p>使用点表示法，JavaScript会尝试使用该确切名称在对象上查找属性。 在此示例中，JavaScript尝试在colorconfig对象上找到名为colors的属性。 没有名为“colors”的属性，因此返回“undefined”。<br>然后，我们尝试使用<code>[1]</code>访问第一个元素的值。 我们无法对未定义的值执行此操作，因此会抛出<code>Cannot read property &#39;1&#39; of undefined</code>。</p><p>JavaScript解释（或取消装箱）语句。 当我们使用方括号表示法时，它会看到第一个左方括号<code>[</code>并一直进行下去，直到找到右方括号<code>]</code>。 只有这样，它才会评估该语句。 如果我们使用了colorConfig [colors [1]]，它将返回colorConfig对象上red属性的值。</p></p></details><hr><h6 id="107-输出什么"><a href="#107-输出什么" class="headerlink" title="107. 输出什么?"></a>107. 输出什么?</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;❤️&#x27;</span> === <span class="string">&#x27;❤️&#x27;</span>)</span><br></pre></td></tr></table></figure><ul><li>A: <code>true</code></li><li>B: <code>false</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-A-11"><a href="#答案-A-11" class="headerlink" title="答案: A"></a>答案: A</h4><p>在内部，表情符号是unicode。 heat表情符号的unicode是<code>“ U + 2764 U + FE0F”</code>。 对于相同的表情符号，它们总是相同的，因此我们将两个相等的字符串相互比较，这将返回true。</p></p></details><hr><h6 id="108-哪些方法修改了原数组"><a href="#108-哪些方法修改了原数组" class="headerlink" title="108. 哪些方法修改了原数组?"></a>108. 哪些方法修改了原数组?</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> emojis = [<span class="string">&#x27;✨&#x27;</span>, <span class="string">&#x27;🥑&#x27;</span>, <span class="string">&#x27;😍&#x27;</span>]</span><br><span class="line"></span><br><span class="line">emojis.map(<span class="function"><span class="params">x</span> =&gt;</span> x + <span class="string">&#x27;✨&#x27;</span>)</span><br><span class="line">emojis.filter(<span class="function"><span class="params">x</span> =&gt;</span> x !== <span class="string">&#x27;🥑&#x27;</span>)</span><br><span class="line">emojis.find(<span class="function"><span class="params">x</span> =&gt;</span> x !== <span class="string">&#x27;🥑&#x27;</span>)</span><br><span class="line">emojis.reduce(<span class="function">(<span class="params">acc, cur</span>) =&gt;</span> acc + <span class="string">&#x27;✨&#x27;</span>)</span><br><span class="line">emojis.slice(<span class="number">1</span>, <span class="number">2</span>, <span class="string">&#x27;✨&#x27;</span>) </span><br><span class="line">emojis.splice(<span class="number">1</span>, <span class="number">2</span>, <span class="string">&#x27;✨&#x27;</span>)</span><br></pre></td></tr></table></figure><ul><li>A: <code>All of them</code></li><li>B: <code>map</code> <code>reduce</code> <code>slice</code> <code>splice</code></li><li>C: <code>map</code> <code>slice</code> <code>splice</code> </li><li>D: <code>splice</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-D-9"><a href="#答案-D-9" class="headerlink" title="答案: D"></a>答案: D</h4><p>使用<code>splice</code>方法，我们通过删除，替换或添加元素来修改原始数组。 在这种情况下，我们从索引1中删除了2个元素（我们删除了<code>&#39;🥑&#39;</code>和<code>&#39;😍&#39;</code>），同时添加了✨emoji表情。</p><p><code>map</code>，<code>filter</code>和<code>slice</code>返回一个新数组，<code>find</code>返回一个元素，而<code>reduce</code>返回一个减小的值。</p></p></details><hr><h6 id="109-输出什么"><a href="#109-输出什么" class="headerlink" title="109. 输出什么?"></a><a name=20191009></a>109. 输出什么?</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> food = [<span class="string">&#x27;🍕&#x27;</span>, <span class="string">&#x27;🍫&#x27;</span>, <span class="string">&#x27;🥑&#x27;</span>, <span class="string">&#x27;🍔&#x27;</span>]</span><br><span class="line"><span class="keyword">const</span> info = &#123; <span class="attr">favoriteFood</span>: food[<span class="number">0</span>] &#125;</span><br><span class="line"></span><br><span class="line">info.favoriteFood = <span class="string">&#x27;🍝&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(food)</span><br></pre></td></tr></table></figure><ul><li>A: <code>[&#39;🍕&#39;, &#39;🍫&#39;, &#39;🥑&#39;, &#39;🍔&#39;]</code></li><li>B: <code>[&#39;🍝&#39;, &#39;🍫&#39;, &#39;🥑&#39;, &#39;🍔&#39;]</code></li><li>C: <code>[&#39;🍝&#39;, &#39;🍕&#39;, &#39;🍫&#39;, &#39;🥑&#39;, &#39;🍔&#39;]</code> </li><li>D: <code>ReferenceError</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-A-12"><a href="#答案-A-12" class="headerlink" title="答案: A"></a>答案: A</h4><p>我们将<code>info</code>对象上的<code>favoriteFood</code>属性的值设置为披萨表情符号“🍕”的字符串。字符串是原始数据类型。在JavaScript中，原始数据类型通过值起作用</p><p>在这种情况下，我们将<code>info</code>对象上的<code>favoriteFood</code>属性的值设置为等于<code>food</code>数组中的第一个元素的值，字符串为披萨表情符号（<code>&#39;🍕&#39;</code> ）。字符串是原始数据类型，并且通过值进行交互，我们更改<code>info</code>对象上<code>favoriteFood</code>属性的值。 food数组没有改变，因为favoriteFood的值只是该数组中第一个元素的值的复制，并且与该元素上的元素没有相同的内存引用食物<code>[0]</code>。当我们记录食物时，它仍然是原始数组<code>[&#39;🍕&#39;，&#39;🍫&#39;，&#39;🥑&#39;，&#39;🍔&#39;]</code>。</p></p></details><hr>]]></content>
      
      
      <categories>
          
          <category> 写给女友 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「星辰大海」JS自测清单（三）</title>
      <link href="posts/20201129/"/>
      <url>posts/20201129/</url>
      
        <content type="html"><![CDATA[<h2 id="星辰大海」JS自测清单（三）"><a href="#星辰大海」JS自测清单（三）" class="headerlink" title="星辰大海」JS自测清单（三）"></a>星辰大海」JS自测清单（三）</h2><p>转载自 <a href="https://github.com/lydiahallie/javascript-questions">javascript-questions</a>（star支持一波）</p><blockquote><p>我们的征途是星辰大海~</p></blockquote><p>答案在问题下方的折叠部分，点击即可展开问题。祝你好运 :heart:</p><h6 id="110-这个函数干了什么"><a href="#110-这个函数干了什么" class="headerlink" title="110. 这个函数干了什么?"></a>110. 这个函数干了什么?</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.parse()</span><br></pre></td></tr></table></figure><ul><li>A: Parses JSON to a JavaScript value</li><li>B: Parses a JavaScript object to JSON</li><li>C: Parses any JavaScript value to JSON</li><li>D: Parses JSON to a JavaScript object only</li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-A"><a href="#答案-A" class="headerlink" title="答案: A"></a>答案: A</h4><p>使用<code>JSON.parse()</code>方法，我们可以将JSON字符串解析为JavaScript值。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将数字字符串化为有效的JSON，然后将JSON字符串解析为JavaScript值:</span></span><br><span class="line"><span class="keyword">const</span> jsonNumber = <span class="built_in">JSON</span>.stringify(<span class="number">4</span>) <span class="comment">// &#x27;4&#x27;</span></span><br><span class="line"><span class="built_in">JSON</span>.parse(jsonNumber) <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将数组值字符串化为有效的JSON，然后将JSON字符串解析为JavaScript值:</span></span><br><span class="line"><span class="keyword">const</span> jsonArray = <span class="built_in">JSON</span>.stringify([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment">// &#x27;[1, 2, 3]&#x27;</span></span><br><span class="line"><span class="built_in">JSON</span>.parse(jsonArray) <span class="comment">// [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将对象字符串化为有效的JSON，然后将JSON字符串解析为JavaScript值:</span></span><br><span class="line"><span class="keyword">const</span> jsonArray = <span class="built_in">JSON</span>.stringify(&#123; <span class="attr">name</span>: <span class="string">&quot;Lydia&quot;</span> &#125;) <span class="comment">// &#x27;&#123;&quot;name&quot;:&quot;Lydia&quot;&#125;&#x27;</span></span><br><span class="line"><span class="built_in">JSON</span>.parse(jsonArray) <span class="comment">// &#123; name: &#x27;Lydia&#x27; &#125;</span></span><br></pre></td></tr></table></figure></p></details><hr><h6 id="111-输出什么"><a href="#111-输出什么" class="headerlink" title="111. 输出什么?"></a>111. 输出什么?</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;Lydia&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name)</span><br><span class="line">  <span class="keyword">let</span> name = <span class="string">&#x27;Sarah&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getName()</span><br></pre></td></tr></table></figure><ul><li>A: Lydia</li><li>B: Sarah</li><li>C: <code>undefined</code></li><li>D: <code>ReferenceError</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-D"><a href="#答案-D" class="headerlink" title="答案: D"></a>答案: D</h4><p>每个函数都有其自己的执行上下文。 <code>getName</code>函数首先在其自身的上下文（范围）内查找，以查看其是否包含我们尝试访问的变量<code>name</code>。 上述情况，<code>getName</code>函数包含其自己的<code>name</code>变量：我们用<code>let</code>关键字和<code>Sarah</code>的值声明变量<code>name</code>。</p><p>带有<code>let</code>关键字（和<code>const</code>）的变量被提升，但是与<code>var</code>不同，它不会被<strong><em>初始化</em></strong>。 在我们声明（初始化）它们之前，无法访问它们。 这称为“暂时性死区”。 当我们尝试在声明变量之前访问变量时，JavaScript会抛出<code>ReferenceError: Cannot access &#39;name&#39; before initialization</code>。</p><p>如果我们不在<code>getName</code>函数中声明<code>name</code>变量，则javascript引擎会查看原型练。会找到其外部作用域有一个名为<code>name</code>的变量，其值为<code>Lydia</code>。 在这种情况下，它将打印<code>Lydia</code>：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;Lydia&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getName() <span class="comment">// Lydia</span></span><br></pre></td></tr></table></figure></p></details><hr><h6 id="112-输出什么？"><a href="#112-输出什么？" class="headerlink" title="112. 输出什么？"></a>112. 输出什么？</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generatorOne</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generatorTwo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span>* [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> one = generatorOne()</span><br><span class="line"><span class="keyword">const</span> two = generatorTwo()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(one.next().value)</span><br><span class="line"><span class="built_in">console</span>.log(two.next().value)</span><br></pre></td></tr></table></figure><ul><li>A: <code>a</code> and <code>a</code></li><li>B: <code>a</code> and <code>undefined</code></li><li>C: <code>[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</code> and <code>a</code></li><li>D: <code>a</code> and <code>[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-C"><a href="#答案-C" class="headerlink" title="答案: C"></a>答案: C</h4><p>通过 <code>yield</code> 关键字, 我们在 <code>Generator</code> 函数里执行<code>yield</code>表达式. 通过 <code>yield*</code> 关键字, 我们可以在一个<code>Generator</code> 函数里面执行（<code>yield</code>表达式）另一个 <code>Generator</code> 函数, 或可遍历的对象 (如数组).</p><p>在函数 <code>generatorOne</code> 中, 我们通过 <code>yield</code> 关键字 yield 了一个完整的数组 <code>[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</code>。函数<code>one</code>通过<code>next</code>方法返回的对象的<code>value</code> 属性的值 (<code>one.next().value</code>) 等价于数组 <code>[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</code>.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(one.next().value) <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></span><br><span class="line"><span class="built_in">console</span>.log(one.next().value) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>在函数 <code>generatorTwo</code> 中, 我们使用 <code>yield*</code> 关键字。就相当于函数<code>two</code>第一个<code>yield</code>的值, 等价于在迭代器中第一个 <code>yield</code> 的值。数组<code>[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</code>就是这个迭代器. 第一个 <code>yield</code> 的值就是 <code>a</code>, 所以我们第一次调用 <code>two.next().value</code>时, 就返回<code>a</code>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(two.next().value) <span class="comment">// &#x27;a&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(two.next().value) <span class="comment">// &#x27;b&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(two.next().value) <span class="comment">// &#x27;c&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(two.next().value) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></p></details><hr><h6 id="113-输出什么？"><a href="#113-输出什么？" class="headerlink" title="113. 输出什么？"></a>113. 输出什么？</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;(x =&gt; x)(<span class="string">&#x27;I love&#x27;</span>)&#125;</span> to program`</span>)</span><br></pre></td></tr></table></figure><ul><li>A: <code>I love to program</code></li><li>B: <code>undefined to program</code></li><li>C: <code>$&#123;(x =&gt; x)(&#39;I love&#39;) to program</code></li><li>D: <code>TypeError</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-A-1"><a href="#答案-A-1" class="headerlink" title="答案: A"></a>答案: A</h4><p>带有模板字面量的表达式首先被执行。相当于字符串会包含表达式，这个立即执行函数 <code>(x =&gt; x)(&#39;I love&#39;)</code> 返回的值. 我们向箭头函数 <code>x =&gt; x</code> 传递 <code>&#39;I love&#39;</code> 作为参数。<code>x</code> 等价于返回的 <code>&#39;I love&#39;</code>。这就是结果 <code>I love to program</code>。</p></p></details><hr><h6 id="114-将会发生什么"><a href="#114-将会发生什么" class="headerlink" title="114. 将会发生什么?"></a>114. 将会发生什么?</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> config = &#123;</span><br><span class="line">  alert: <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Alert!&#x27;</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">config = <span class="literal">null</span></span><br></pre></td></tr></table></figure><ul><li>A: <code>setInterval</code> 的回调不会被调用</li><li>B: <code>setInterval</code> 的回调被调用一次</li><li>C: <code>setInterval</code> 的回调仍然会被每秒钟调用</li><li>D: 我们从没调用过 <code>config.alert()</code>, config 为 <code>null</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-C-1"><a href="#答案-C-1" class="headerlink" title="答案: C"></a>答案: C</h4><p>一般情况下当我们将对象赋值为 <code>null</code>, 那些对象会被进行 <em>垃圾回收（garbage collected）</em> 因为已经没有对这些对象的引用了。然而，<code>setInterval</code>的参数是一个箭头函数（所以上下文绑定到对象 <code>config</code> 了），回调函数仍然保留着对 <code>config</code>的引用。只要存在引用，对象就不会被垃圾回收。因为没有被垃圾回收，<code>setInterval</code> 的回调每1000ms (1s)会被调用一次。</p></p></details><hr><h6 id="115-哪一个方法会返回-39-Hello-world-39-？"><a href="#115-哪一个方法会返回-39-Hello-world-39-？" class="headerlink" title="115. 哪一个方法会返回 &#39;Hello world!&#39; ？"></a>115. 哪一个方法会返回 <code>&#39;Hello world!&#39;</code> ？</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line"><span class="keyword">const</span> myFunc = <span class="function">() =&gt;</span> <span class="string">&#x27;greeting&#x27;</span></span><br><span class="line"></span><br><span class="line">myMap.set(myFunc, <span class="string">&#x27;Hello world!&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//1</span></span><br><span class="line">myMap.get(<span class="string">&#x27;greeting&#x27;</span>)</span><br><span class="line"><span class="comment">//2</span></span><br><span class="line">myMap.get(myFunc)</span><br><span class="line"><span class="comment">//3</span></span><br><span class="line">myMap.get(<span class="function">() =&gt;</span> <span class="string">&#x27;greeting&#x27;</span>)</span><br></pre></td></tr></table></figure><ul><li>A: 1</li><li>B: 2</li><li>C: 2 and 3</li><li>D: All of them</li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-B"><a href="#答案-B" class="headerlink" title="答案: B"></a>答案: B</h4><p>当通过 <code>set</code> 方法添加一个键值对，一个传递给 <code>set</code>方法的参数将会是键名，第二个参数将会是值。在这个case里，键名为 <em>函数</em> <code>() =&gt; &#39;greeting&#39;</code>，值为<code>&#39;Hello world&#39;</code>。 <code>myMap</code> 现在就是 <code>&#123; () =&gt; &#39;greeting&#39; =&gt; &#39;Hello world!&#39; &#125;</code>。</p><p>1 是错的，因为键名不是 <code>&#39;greeting&#39;</code> 而是 <code>() =&gt; &#39;greeting&#39;</code>。<br>3 是错的，因为我们给<code>get</code> 方法传递了一个新的函数。对象受 <em>引用</em> 影响。函数也是对象，因此两个函数严格上并不等价，尽管他们相同：他们有两个不同的内存引用地址。</p></p></details><hr><h6 id="116-输出什么？"><a href="#116-输出什么？" class="headerlink" title="116. 输出什么？"></a>116. 输出什么？</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  name: <span class="string">&quot;Lydia&quot;</span>,</span><br><span class="line">  age: <span class="number">21</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> changeAge = <span class="function">(<span class="params">x = &#123; ...person &#125;</span>) =&gt;</span> x.age += <span class="number">1</span></span><br><span class="line"><span class="keyword">const</span> changeAgeAndName = <span class="function">(<span class="params">x = &#123; ...person &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  x.age += <span class="number">1</span></span><br><span class="line">  x.name = <span class="string">&quot;Sarah&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">changeAge(person)</span><br><span class="line">changeAgeAndName()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person)</span><br></pre></td></tr></table></figure><ul><li>A: <code>&#123;name: &quot;Sarah&quot;, age: 22&#125;</code></li><li>B: <code>&#123;name: &quot;Sarah&quot;, age: 23&#125;</code></li><li>C: <code>&#123;name: &quot;Lydia&quot;, age: 22&#125;</code></li><li>D: <code>&#123;name: &quot;Lydia&quot;, age: 23&#125;</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-C-2"><a href="#答案-C-2" class="headerlink" title="答案: C"></a>答案: C</h4><p>函数 <code>changeAge</code> 和函数 <code>changeAgeAndName</code> 有着不同的参数，定义一个 <em>新</em> 生成的对象 <code>&#123; ...person &#125;</code>。这个对象有着所有 <code>person</code> 对象 中 k/v 值的副本。</p><p>首项, 我们调用 <code>changeAge</code> 函数并传递 <code>person</code> 对象作为它的参数。这个函数对 <code>age</code> 属性进行加一操作。<code>person</code> 现在是 <code>&#123; name: &quot;Lydia&quot;, age: 22 &#125;</code>。</p><p>然后，我们调用函数 <code>changeAgeAndName</code> ，然而我们没有传递参数。取而代之，<code>x</code> 的值等价 <em>new</em> 生成的对象: <code>&#123; ...person &#125;</code>。因为它是一个新生成的对象，它并不会对对象 <code>person</code> 造成任何副作用。<code>person</code> 仍然等价于 <code>&#123; name: &quot;Lydia&quot;, age: 22 &#125;</code>。</p></p></details><hr><h6 id="117-下面那个选项将会返回-6"><a href="#117-下面那个选项将会返回-6" class="headerlink" title="117. 下面那个选项将会返回 6?"></a>117. 下面那个选项将会返回 <code>6</code>?</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sumValues</span>(<span class="params">x, y, z</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x + y + z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>A: <code>sumValues([...1, 2, 3])</code></li><li>B: <code>sumValues([...[1, 2, 3]])</code></li><li>C: <code>sumValues(...[1, 2, 3])</code></li><li>D: <code>sumValues([1, 2, 3])</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-C-3"><a href="#答案-C-3" class="headerlink" title="答案: C"></a>答案: C</h4><p>通过展开操作符 <code>...</code>，我们可以 <em>暂开</em> 单个可迭代的元素。函数 <code>sumValues</code> function 接收三个参数： <code>x</code>, <code>y</code> 和 <code>z</code>。<code>...[1, 2, 3]</code> 的执行结果为 <code>1, 2, 3</code>，将会传递给函数 <code>sumValues</code>。</p></p></details><hr><h6 id="118-输出什么？"><a href="#118-输出什么？" class="headerlink" title="118. 输出什么？"></a>118. 输出什么？</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> list = [<span class="string">&quot;🥳&quot;</span>, <span class="string">&quot;🤠&quot;</span>, <span class="string">&quot;🥰&quot;</span>, <span class="string">&quot;🤪&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(list[(num += <span class="number">1</span>)]);</span><br></pre></td></tr></table></figure><ul><li>A: <code>🤠</code></li><li>B: <code>🥰</code></li><li>C: <code>SyntaxError</code></li><li>D: <code>ReferenceError</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-B-1"><a href="#答案-B-1" class="headerlink" title="答案: B"></a>答案: B</h4><p>通过 <code>+=</code> 操作符，我们对值 <code>num</code> 进行加 <code>1</code> 操作。 <code>num</code> 有初始值 <code>1</code>，因此 <code>1 + 1</code> 的执行结果为 <code>2</code>。数组 <code>list</code> 的第二项为 🥰，<code>console.log(list[2])</code> 输出 🥰.</p></p></details><hr><h6 id="119-输出什么？"><a href="#119-输出什么？" class="headerlink" title="119. 输出什么？"></a>119. 输出什么？</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">firstName: <span class="string">&quot;Lydia&quot;</span>,</span><br><span class="line">lastName: <span class="string">&quot;Hallie&quot;</span>,</span><br><span class="line">pet: &#123;</span><br><span class="line">name: <span class="string">&quot;Mara&quot;</span>,</span><br><span class="line">breed: <span class="string">&quot;Dutch Tulip Hound&quot;</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="function"><span class="title">getFullName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.firstName&#125;</span> <span class="subst">$&#123;<span class="built_in">this</span>.lastName&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.pet?.name);</span><br><span class="line"><span class="built_in">console</span>.log(person.pet?.family?.name);</span><br><span class="line"><span class="built_in">console</span>.log(person.getFullName?.());</span><br><span class="line"><span class="built_in">console</span>.log(member.getLastName?.());</span><br></pre></td></tr></table></figure><ul><li>A: <code>undefined</code> <code>undefined</code> <code>undefined</code> <code>undefined</code></li><li>B: <code>Mara</code> <code>undefined</code> <code>Lydia Hallie</code> <code>undefined</code></li><li>C: <code>Mara</code> <code>null</code> <code>Lydia Hallie</code> <code>null</code></li><li>D: <code>null</code> <code>ReferenceError</code> <code>null</code> <code>ReferenceError</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-B-2"><a href="#答案-B-2" class="headerlink" title="答案: B"></a>答案: B</h4><p>通过 ES10 或 TS3.7+<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/%E5%8F%AF%E9%80%89%E9%93%BE">可选链操作符 <code>?.</code></a>，我们不再需要显式检测更深层的嵌套值是否有效。如果我们尝试获取 <code>undefined</code> 或 <code>null</code> 的值 (<em>nullish</em>)，表达将会短路并返回 <code>undefined</code>.</p><p><code>person.pet?.name</code>： <code>person</code> 有一个名为 <code>pet</code> 的属性： <code>person.pet</code> 不是 nullish。它有个名为 <code>name</code> 的属性，并返回字符串 <code>Mara</code>。<br><code>person.pet?.family?.name</code>： <code>person</code> 有一个名为 <code>pet</code> 的属性： <code>person.pet</code> 不是 nullish. <code>pet</code> <em>并没有</em> 一个名为 <code>family</code> 的属性, <code>person.pet.family</code> 是 nullish。表达式返回 <code>undefined</code>。<br><code>person.getFullName?.()</code>： <code>person</code> 有一个名为 <code>getFullName</code> 的属性： <code>person.getFullName()</code> 不是 nullish 并可以被调用，返回字符串 <code>Lydia Hallie</code>。<br><code>member.getLastName?.()</code>: <code>member</code> is not defined: <code>member.getLastName()</code> is nullish. The expression returns <code>undefined</code>.</p></p></details><hr><h6 id="120-输出什么？"><a href="#120-输出什么？" class="headerlink" title="120. 输出什么？"></a>120. 输出什么？</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> groceries = [<span class="string">&quot;banana&quot;</span>, <span class="string">&quot;apple&quot;</span>, <span class="string">&quot;peanuts&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (groceries.indexOf(<span class="string">&quot;banana&quot;</span>)) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;We have to buy bananas!&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`We don&#x27;t have to buy bananas!`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>A: We have to buy bananas!</li><li>B: We don’t have to buy bananas</li><li>C: <code>undefined</code></li><li>D: <code>1</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-B-3"><a href="#答案-B-3" class="headerlink" title="答案: B"></a>答案: B</h4><p>我们传递了一个状态 <code>groceries.indexOf(&quot;banana&quot;)</code> 给if条件语句。<code>groceries.indexOf(&quot;banana&quot;)</code> 返回 <code>0</code>， 一个 falsy 的值。因为if条件语句的状态为 falsy，<code>else</code> 块区内的代码执行，并且 <code>We don&#39;t have to buy bananas!</code> 被输出.</p></p></details><hr><h6 id="121-输出什么"><a href="#121-输出什么" class="headerlink" title="121. 输出什么?"></a>121. 输出什么?</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">languages: [],</span><br><span class="line"><span class="keyword">set</span> <span class="title">language</span>(<span class="params">lang</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.languages.push(lang);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(config.language);</span><br></pre></td></tr></table></figure><ul><li>A: <code>function language(lang) &#123; this.languages.push(lang &#125;</code></li><li>B: <code>0</code></li><li>C: <code>[]</code></li><li>D: <code>undefined</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-D-1"><a href="#答案-D-1" class="headerlink" title="答案: D"></a>答案: D</h4><p>方法 <code>language</code> 是一个 <code>setter</code>。Setters 并不保存一个实际值，它们的使命在于 <em>修改</em> 属性。当调用方法 <code>setter</code>， 返回 <code>undefined</code>。</p></p></details><hr><h6 id="122-输出什么？"><a href="#122-输出什么？" class="headerlink" title="122. 输出什么？"></a>122. 输出什么？</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">&quot;Lydia Hallie&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(!<span class="keyword">typeof</span> name === <span class="string">&quot;object&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(!<span class="keyword">typeof</span> name === <span class="string">&quot;string&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li>A: <code>false</code> <code>true</code></li><li>B: <code>true</code> <code>false</code></li><li>C: <code>false</code> <code>false</code></li><li>D: <code>true</code> <code>true</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-C-4"><a href="#答案-C-4" class="headerlink" title="答案: C"></a>答案: C</h4><p><code>typeof name</code> 返回 <code>&quot;string&quot;</code>。字符串 <code>&quot;string&quot;</code> 是一个 truthy 的值，因此 <code>!typeof name</code> 返回一个布尔值 <code>false</code>。 <code>false === &quot;object&quot;</code> 和 <code>false === &quot;string&quot;</code> 都返回 <code>false</code>。</p><p>（如果我们想检测一个值的类型，我们应该用 <code>!==</code> 而不是 <code>!typeof</code>）</p></p></details><hr><h6 id="123-输出什么"><a href="#123-输出什么" class="headerlink" title="123. 输出什么?"></a>123. 输出什么?</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> add = <span class="function"><span class="params">x</span> =&gt;</span> <span class="function"><span class="params">y</span> =&gt;</span> <span class="function"><span class="params">z</span> =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(x, y, z);</span><br><span class="line"><span class="keyword">return</span> x + y + z;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">add(<span class="number">4</span>)(<span class="number">5</span>)(<span class="number">6</span>);</span><br></pre></td></tr></table></figure><ul><li>A: <code>4</code> <code>5</code> <code>6</code></li><li>B: <code>6</code> <code>5</code> <code>4</code></li><li>C: <code>4</code> <code>function</code> <code>function</code></li><li>D: <code>undefined</code> <code>undefined</code> <code>6</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-A-2"><a href="#答案-A-2" class="headerlink" title="答案: A"></a>答案: A</h4><p>函数 <code>add</code> 是一个返回 返回箭头函数的箭头函数 的箭头函数（still with me?）。第一个函数接收一个值为 <code>4</code> 的参数 <code>x</code>。我们调用第二个函数，它接收一个值为 <code>5</code> 的参数 <code>y</code>。然后我们调用第三个函数，它接收一个值为 <code>6</code> 的参数 <code>z</code>。当我们尝试在最后一个箭头函数中获取 <code>x</code>, <code>y</code> 和 <code>z</code> 的值，JS 引擎根据作用域链去找 <code>x</code> 和 <code>y</code> 的值。得到 <code>4</code> <code>5</code> <code>6</code>.</p></p></details><hr><h6 id="124-输出什么？"><a href="#124-输出什么？" class="headerlink" title="124. 输出什么？"></a>124. 输出什么？</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span>* <span class="title">range</span>(<span class="params">start, end</span>) </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line"><span class="keyword">yield</span> <span class="built_in">Promise</span>.resolve(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line"><span class="keyword">const</span> gen = range(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">const</span> item <span class="keyword">of</span> gen) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><ul><li>A: <code>Promise &#123;1&#125;</code> <code>Promise &#123;2&#125;</code> <code>Promise &#123;3&#125;</code></li><li>B: <code>Promise &#123;&lt;pending&gt;&#125;</code> <code>Promise &#123;&lt;pending&gt;&#125;</code> <code>Promise &#123;&lt;pending&gt;&#125;</code></li><li>C: <code>1</code> <code>2</code> <code>3</code></li><li>D: <code>undefined</code> <code>undefined</code> <code>undefined</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-C-5"><a href="#答案-C-5" class="headerlink" title="答案: C"></a>答案: C</h4><p>我们给 函数range 传递： <code>Promise&#123;1&#125;</code>, <code>Promise&#123;2&#125;</code>, <code>Promise&#123;3&#125;</code>，Generator 函数 <code>range</code> 返回一个全是 async object promise 数组。我们将 async object 赋值给变量 <code>gen</code>，之后我们使用<code>for await ... of</code> 进行循环遍历。我们将返回的 Promise 实例赋值给 <code>item</code>： 第一个返回 <code>Promise&#123;1&#125;</code>， 第二个返回 <code>Promise&#123;2&#125;</code>，之后是 <code>Promise&#123;3&#125;</code>。因为我们正 <em>awaiting</em> <code>item</code> 的值，resolved 状态的 promsie，promise数组的resolved <em>值</em> 以此为： <code>1</code>，<code>2</code>，<code>3</code>.</p></p></details><hr><h6 id="125-输出什么？"><a href="#125-输出什么？" class="headerlink" title="125. 输出什么？"></a>125. 输出什么？</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myFunc = <span class="function">(<span class="params">&#123; x, y, z &#125;</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(x, y, z);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">myFunc(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><ul><li>A: <code>1</code> <code>2</code> <code>3</code></li><li>B: <code>&#123;1: 1&#125;</code> <code>&#123;2: 2&#125;</code> <code>&#123;3: 3&#125;</code></li><li>C: <code>&#123; 1: undefined &#125;</code> <code>undefined</code> <code>undefined</code></li><li>D: <code>undefined</code> <code>undefined</code> <code>undefined</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-D-2"><a href="#答案-D-2" class="headerlink" title="答案: D"></a>答案: D</h4><p><code>myFunc</code> 期望接收一个包含 <code>x</code>, <code>y</code> 和 <code>z</code> 属性的对象作为它的参数。因为我们仅仅传递三个单独的数字值 (1, 2, 3) 而不是一个含有 <code>x</code>, <code>y</code> 和 <code>z</code> 属性的对象 ({x: 1, y: 2, z: 3})， <code>x</code>, <code>y</code> 和 <code>z</code> 有着各自的默认值 <code>undefined</code>.</p></p></details><hr><h6 id="126-输出什么？"><a href="#126-输出什么？" class="headerlink" title="126. 输出什么？"></a>126. 输出什么？</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFine</span>(<span class="params">speed, amount</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> formattedSpeed = <span class="keyword">new</span> <span class="built_in">Intl</span>.NumberFormat(&#123;</span><br><span class="line">    <span class="string">&#x27;en-US&#x27;</span>,</span><br><span class="line">    &#123; <span class="attr">style</span>: <span class="string">&#x27;unit&#x27;</span>, <span class="attr">unit</span>: <span class="string">&#x27;mile-per-hour&#x27;</span> &#125;</span><br><span class="line">  &#125;).format(speed)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> formattedAmount = <span class="keyword">new</span> <span class="built_in">Intl</span>.NumberFormat(&#123;</span><br><span class="line">    <span class="string">&#x27;en-US&#x27;</span>,</span><br><span class="line">    &#123; <span class="attr">style</span>: <span class="string">&#x27;currency&#x27;</span>, <span class="attr">currency</span>: <span class="string">&#x27;USD&#x27;</span> &#125;</span><br><span class="line">  &#125;).format(amount)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="string">`The driver drove <span class="subst">$&#123;formattedSpeed&#125;</span> and has to pay <span class="subst">$&#123;formattedAmount&#125;</span>`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(getFine(<span class="number">130</span>, <span class="number">300</span>))</span><br></pre></td></tr></table></figure><ul><li>A: The driver drove 130 and has to pay 300</li><li>B: The driver drove 130 mph and has to pay $300.00</li><li>C: The driver drove undefined and has to pay undefined</li><li>D: The driver drove 130.00 and has to pay 300.00</li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-B-4"><a href="#答案-B-4" class="headerlink" title="答案: B"></a>答案: B</h4><p>通过方法 <code>Intl.NumberFormat</code>，我们可以格式化任意区域的数字值。我们对数字值 <code>130</code> 进行 <code>mile-per-hour</code> 作为 <code>unit</code> 的 <code>en-US</code> 区域 格式化，结果为 <code>130 mph</code>。对数字值 <code>300</code> 进行 <code>USD</code> 作为 <code>currentcy</code> 的 <code>en-US</code> 区域格式化，结果为 <code>$300.00</code>.</p></p></details><hr><h6 id="127-输出什么？"><a href="#127-输出什么？" class="headerlink" title="127. 输出什么？"></a>127. 输出什么？</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> spookyItems = [<span class="string">&quot;👻&quot;</span>, <span class="string">&quot;🎃&quot;</span>, <span class="string">&quot;🕸&quot;</span>];</span><br><span class="line">(&#123; <span class="attr">item</span>: spookyItems[<span class="number">3</span>] &#125; = &#123; <span class="attr">item</span>: <span class="string">&quot;💀&quot;</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(spookyItems);</span><br></pre></td></tr></table></figure><ul><li>A: <code>[&quot;👻&quot;, &quot;🎃&quot;, &quot;🕸&quot;]</code></li><li>B: <code>[&quot;👻&quot;, &quot;🎃&quot;, &quot;🕸&quot;, &quot;💀&quot;]</code></li><li>C: <code>[&quot;👻&quot;, &quot;🎃&quot;, &quot;🕸&quot;, &#123; item: &quot;💀&quot; &#125;]</code></li><li>D: <code>[&quot;👻&quot;, &quot;🎃&quot;, &quot;🕸&quot;, &quot;[object Object]&quot;]</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-B-5"><a href="#答案-B-5" class="headerlink" title="答案: B"></a>答案: B</h4><p>通过解构对象们，我们可以从右手边的对象中拆出值，并且将拆出的值分配给左手边对象同名的属性。在这种情况下，我们将值 “💀” 分配给 <code>spookyItems[3]</code>。相当于我们正在篡改数组 <code>spookyItems</code>，我们给它添加了值 “💀”。当输出 <code>spookyItems</code> 时，结果为 <code>[&quot;👻&quot;, &quot;🎃&quot;, &quot;🕸&quot;, &quot;💀&quot;]</code>。</p></p></details><hr><h6 id="128-输出什么？"><a href="#128-输出什么？" class="headerlink" title="128. 输出什么？"></a>128. 输出什么？</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">&quot;Lydia Hallie&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> age = <span class="number">21</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isNaN(name));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isNaN(age));</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(name));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(age));</span><br></pre></td></tr></table></figure><ul><li>A: <code>true</code> <code>false</code> <code>true</code> <code>false</code></li><li>B: <code>true</code> <code>false</code> <code>false</code> <code>false</code></li><li>C: <code>false</code> <code>false</code> <code>true</code> <code>false</code></li><li>D: <code>false</code> <code>true</code> <code>false</code> <code>true</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-C-6"><a href="#答案-C-6" class="headerlink" title="答案: C"></a>答案: C</h4><p>通过方法 <code>Number.isNaN</code>，你可以检测你传递的值是否为 <em>数字值</em> 并且是否等价于 <code>NaN</code>。<code>name</code> 不是一个数字值，因此 <code>Number.isNaN(name)</code> 返回 <code>false</code>。<code>age</code> 是一个数字值，但它不等价于 <code>NaN</code>，因此 <code>Number.isNaN(age)</code> 返回 <code>false</code>.</p><p>通过方法 <code>isNaN</code>， 你可以检测你传递的值是否一个 number。<code>name</code> 不是一个 <code>number</code>，因此 <code>isNaN(name)</code> 返回 <code>true</code>. <code>age</code> 是一个 <code>number</code> 因此 <code>isNaN(age)</code> 返回 <code>false</code>.</p></p></details><hr><h6 id="129-输出什么？"><a href="#129-输出什么？" class="headerlink" title="129. 输出什么？"></a>129. 输出什么？</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> randomValue = <span class="number">21</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getInfo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> randomValue);</span><br><span class="line"><span class="keyword">const</span> randomValue = <span class="string">&quot;Lydia Hallie&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getInfo();</span><br></pre></td></tr></table></figure><ul><li>A: <code>&quot;number&quot;</code></li><li>B: <code>&quot;string&quot;</code></li><li>C: <code>undefined</code></li><li>D: <code>ReferenceError</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-D-3"><a href="#答案-D-3" class="headerlink" title="答案: D"></a>答案: D</h4><p>通过 <code>const</code> 关键字声明的变量在被初始化之前不可被引用：这被称之为 _暂时性死区_。在函数 <code>getInfo</code> 中, 变量 <code>randomValue</code> 声明在<code>getInfo</code> 的作用域的此法环境中。在想要对 <code>typeof randomValue</code> 进行log之前，变量 <code>randomValue</code> 仍未被初始化： 错误<code>ReferenceError</code> 被抛出! JS引擎并不会根据作用域链网上寻找该变量，因为我们已经在 <code>getInfo</code> 函数中声明了 <code>randomValue</code> 变量。</p></p></details><hr><h6 id="130-输出什么？"><a href="#130-输出什么？" class="headerlink" title="130. 输出什么？"></a>130. 输出什么？</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myPromise = <span class="built_in">Promise</span>.resolve(<span class="string">&quot;Woah some cool data&quot;</span>);</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">await</span> myPromise);</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`Oops didn&#x27;t work`</span>);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;Oh finally!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><ul><li>A: <code>Woah some cool data</code></li><li>B: <code>Oh finally!</code></li><li>C: <code>Woah some cool data</code> <code>Oh finally!</code></li><li>D: <code>Oops didn&#39;t work</code> <code>Oh finally!</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-C-7"><a href="#答案-C-7" class="headerlink" title="答案: C"></a>答案: C</h4><p>在 <code>try</code> 块区，我们打印 <code>myPromise</code> 变量的 awaited 值： <code>&quot;Woah some cool data&quot;</code>。因为<code>try</code> 块区没有错误抛出，<code>catch</code> 块区的代码并不执行。<code>finally</code> 块区的代码 <em>总是</em> 执行，<code>&quot;Oh finally!&quot;</code> 被输出。</p></p></details><hr><h6 id="131-输出什么？"><a href="#131-输出什么？" class="headerlink" title="131. 输出什么？"></a>131. 输出什么？</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> emojis = [<span class="string">&quot;🥑&quot;</span>, [<span class="string">&quot;✨&quot;</span>, <span class="string">&quot;✨&quot;</span>, [<span class="string">&quot;🍕&quot;</span>, <span class="string">&quot;🍕&quot;</span>]]];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(emojis.flat(<span class="number">1</span>));</span><br></pre></td></tr></table></figure><ul><li>A: <code>[&#39;🥑&#39;, [&#39;✨&#39;, &#39;✨&#39;, [&#39;🍕&#39;, &#39;🍕&#39;]]]</code></li><li>B: <code>[&#39;🥑&#39;, &#39;✨&#39;, &#39;✨&#39;, [&#39;🍕&#39;, &#39;🍕&#39;]]</code></li><li>C: <code>[&#39;🥑&#39;, [&#39;✨&#39;, &#39;✨&#39;, &#39;🍕&#39;, &#39;🍕&#39;]]</code></li><li>D: <code>[&#39;🥑&#39;, &#39;✨&#39;, &#39;✨&#39;, &#39;🍕&#39;, &#39;🍕&#39;]</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-B-6"><a href="#答案-B-6" class="headerlink" title="答案: B"></a>答案: B</h4><p>通过方法 <code>flat</code>， 我们可以创建一个新的, 已被扁平化的数组。被扁平化的深度取决于我们传递的值。在这个case里，我们传递了值 <code>1</code> (并不必要，这是默认值)，相当于只有第一层的数组才会被连接。即这个 case 里的 <code>[&#39;🥑&#39;]</code> and <code>[&#39;✨&#39;, &#39;✨&#39;, [&#39;🍕&#39;, &#39;🍕&#39;]]</code>。连接这两个数组得到结果 <code>[&#39;🥑&#39;, &#39;✨&#39;, &#39;✨&#39;, [&#39;🍕&#39;, &#39;🍕&#39;]]</code>.</p></p></details><hr><h6 id="132-输出什么？"><a href="#132-输出什么？" class="headerlink" title="132. 输出什么？"></a><a name=20191224></a>132. 输出什么？</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.count = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">increment</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.count++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> counterOne = <span class="keyword">new</span> Counter();</span><br><span class="line">counterOne.increment();</span><br><span class="line">counterOne.increment();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> counterTwo = counterOne;</span><br><span class="line">counterTwo.increment();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(counterOne.count);</span><br></pre></td></tr></table></figure><ul><li>A: <code>0</code></li><li>B: <code>1</code></li><li>C: <code>2</code></li><li>D: <code>3</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-D-4"><a href="#答案-D-4" class="headerlink" title="答案: D"></a>答案: D</h4><p><code>counterOne</code> 是类 <code>Counter</code> 的一个实例。类 Counter 包含一个<code>count</code> 属性在它的构造函数里， 和一个 <code>increment</code> 方法。首先，我们通过 <code>counterOne.increment()</code> 调用方法 <code>increment</code> 两次。现在, <code>counterOne.count</code> 为 <code>2</code>.</p><img src= "/img/loading.gif" data-lazy-src="https://i.imgur.com/KxLlTm9.png" width="400"><p>然后，我们创建一个新的变量 <code>counterTwo</code> 并将 <code>counterOne</code> 的引用地址赋值给它。因为对象受引用地址的影响，我们刚刚创建了一个新的对象，其引用地址和 <code>counterOne</code> 的等价。因此它们指向同一块内存地址，任何对其的副作用都会影响 <code>counterTwo</code>。现在 <code>counterTwo.count</code> 为 <code>2</code>。</p><p>我们调用 <code>counterTwo.increment()</code> 将 <code>count</code> 的值设为 <code>3</code>。然后，我们打印 <code>counterOne</code> 里的count，结果为 <code>3</code>。</p><img src= "/img/loading.gif" data-lazy-src="https://i.imgur.com/BNBHXmc.png" width="400"></p></details><hr><h6 id="133-输出什么？"><a href="#133-输出什么？" class="headerlink" title="133. 输出什么？"></a>133. 输出什么？</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myPromise = <span class="built_in">Promise</span>.resolve(<span class="built_in">Promise</span>.resolve(<span class="string">&quot;Promise!&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funcOne</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">myPromise.then(<span class="function"><span class="params">res</span> =&gt;</span> res).then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res));</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;Timeout!&quot;</span>, <span class="number">0</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;Last line!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">funcTwo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">const</span> res = <span class="keyword">await</span> myPromise;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">await</span> res);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;Timeout!&quot;</span>, <span class="number">0</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;Last line!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">funcOne();</span><br><span class="line">funcTwo();</span><br></pre></td></tr></table></figure><ul><li>A: <code>Promise! Last line! Promise! Last line! Last line! Promise!</code></li><li>B: <code>Last line! Timeout! Promise! Last line! Timeout! Promise!</code></li><li>C: <code>Promise! Last line! Last line! Promise! Timeout! Timeout!</code></li><li>D: <code>Last line! Promise! Promise! Last line! Timeout! Timeout!</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-D-5"><a href="#答案-D-5" class="headerlink" title="答案: D"></a>答案: D</h4><p>首先，我们调用 <code>funcOne</code>。在函数 <code>funcOne</code> 的第一行，我们调用<code>myPromise</code> promise <em>异步操作_。当JS引擎在忙于执行 promise，它继续执行函数 <code>funcOne</code>。下一行 _异步操作</em> <code>setTimeout</code>，其回调函数被 Web API 调用。 (详情请参考我关于event loop的文章.)</p><p>promise 和 timeout 都是异步操作，函数继续执行当JS引擎忙于执行promise 和 处理 <code>setTimeout</code> 的回调。相当于 <code>Last line!</code> 首先被输出， 因为它不是异步操作。执行完 <code>funcOne</code> 的最后一行，promise 状态转变为 resolved，<code>Promise!</code> 被打印。然而，因为我们调用了 <code>funcTwo()</code>, 调用栈不为空，<code>setTimeout</code> 的回调仍不能入栈。</p><p>我们现在处于 <code>funcTwo</code>，先 <em>awaiting</em> myPromise。通过 <code>await</code> 关键字， 我们暂停了函数的执行直到 promise 状态变为 resolved (或 rejected)。然后，我们输出 <code>res</code> 的 awaited 值（因为 promise 本身返回一个 promise）。 接着输出 <code>Promise!</code>。</p><p>下一行就是 <em>异步操作</em> <code>setTimeout</code>，其回调函数被 Web API 调用。</p><p>我们执行到函数 <code>funcTwo</code> 的最后一行，输出 <code>Last line!</code>。现在，因为 <code>funcTwo</code> 出栈，调用栈为空。在事件队列中等待的回调函数（<code>() =&gt; console.log(&quot;Timeout!&quot;)</code> from <code>funcOne</code>, and <code>() =&gt; console.log(&quot;Timeout!&quot;)</code> from <code>funcTwo</code>）以此入栈。第一个回调输出 <code>Timeout!</code>，并出栈。然后，第二个回调输出 <code>Timeout!</code>，并出栈。得到结果 <code>Last line! Promise! Promise! Last line! Timeout! Timeout!</code></p></p></details><hr><h6 id="134-我们怎样才能在-index-js-中调用-sum-js-中的-sum？"><a href="#134-我们怎样才能在-index-js-中调用-sum-js-中的-sum？" class="headerlink" title="134. 我们怎样才能在 index.js 中调用 sum.js? 中的 sum？"></a>134. 我们怎样才能在 <code>index.js</code> 中调用 <code>sum.js?</code> 中的 <code>sum</code>？</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sum.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x + x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> sum <span class="keyword">from</span> <span class="string">&quot;./sum&quot;</span>;</span><br></pre></td></tr></table></figure><ul><li>A: <code>sum(4)</code></li><li>B: <code>sum.sum(4)</code></li><li>C: <code>sum.default(4)</code></li><li>D: 默认导出不用 <code>*</code> 来导入，只能具名导出</li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-C-8"><a href="#答案-C-8" class="headerlink" title="答案: C"></a>答案: C</h4><p>使用符号 <code>*</code>，我们引入文件中的所有值，包括默认和具名。如果我们有以下文件：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// info.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> name = <span class="string">&quot;Lydia&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> age = <span class="number">21</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="string">&quot;I love JavaScript&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> info <span class="keyword">from</span> <span class="string">&quot;./info&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(info);</span><br></pre></td></tr></table></figure><p>将会输出以下内容：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">default</span>: <span class="string">&quot;I love JavaScript&quot;</span>,</span><br><span class="line">  name: <span class="string">&quot;Lydia&quot;</span>,</span><br><span class="line">  age: <span class="number">21</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以 <code>sum</code> 为例，相当于以下形式引入值 <code>sum</code>：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123; <span class="attr">default</span>: <span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">x</span>) </span>&#123; <span class="keyword">return</span> x + x &#125; &#125;</span><br></pre></td></tr></table></figure><p>我们可以通过调用 <code>sum.default</code> 来调用该函数</p></p></details><hr><h6 id="135-输出什么？"><a href="#135-输出什么？" class="headerlink" title="135. 输出什么？"></a>135. 输出什么？</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">set: <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;Added a new property!&quot;</span>),</span><br><span class="line">get: <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;Accessed a property!&quot;</span>)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, handler);</span><br><span class="line"></span><br><span class="line">person.name = <span class="string">&quot;Lydia&quot;</span>;</span><br><span class="line">person.name;</span><br></pre></td></tr></table></figure><ul><li>A: <code>Added a new property!</code></li><li>B: <code>Accessed a property!</code></li><li>C: <code>Added a new property!</code> <code>Accessed a property!</code></li><li>D: 没有任何输出</li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-C-9"><a href="#答案-C-9" class="headerlink" title="答案: C"></a>答案: C</h4><p>使用 Proxy 对象，我们可以给一个对象添加自定义行为。在这个 case，我们传递一个包含以下属性的对象 <code>handler</code> : <code>set</code> and <code>get</code>。每当我门 <em>设置</em> 属性值时 <code>set</code> 被调用，每当我们 <em>获取</em> 时 <code>get</code> 被调用。</p><p>第一个参数是一个空对象 <code>&#123;&#125;</code>，作为 <code>person</code> 的值。对于这个对象，自定义行为被定义在对象 <code>handler</code>。如果我们向对象 <code>person</code> 添加属性，<code>set</code> 将被调用。如果我们获取 <code>person</code> 的属性, <code>get</code> 将被调用。</p><p>首先，我们向 proxy 对象(<code>person.name = &quot;Lydia&quot;</code>)添加一个属性 <code>name</code>。<code>set</code> 被调用并输出 <code>&quot;Added a new property!&quot;</code>。</p><p>然后，我们获取 proxy 对象的一个属性，对象 handler 的属性 <code>get</code> 被调用。输出 <code>&quot;Accessed a property!&quot;</code>。</p></p></details><hr><h6 id="136-以下哪一项会对对象-person-有副作用？"><a href="#136-以下哪一项会对对象-person-有副作用？" class="headerlink" title="136. 以下哪一项会对对象 person 有副作用？"></a>136. 以下哪一项会对对象 <code>person</code> 有副作用？</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123; <span class="attr">name</span>: <span class="string">&quot;Lydia Hallie&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.seal(person);</span><br></pre></td></tr></table></figure><ul><li>A: <code>person.name = &quot;Evan Bacon&quot;</code></li><li>B: <code>person.age = 21</code></li><li>C: <code>delete person.name</code></li><li>D: <code>Object.assign(person, &#123; age: 21 &#125;)</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-A-3"><a href="#答案-A-3" class="headerlink" title="答案: A"></a>答案: A</h4><p>使用 <code>Object.seal</code> 我们可以防止新属性 <em>被添加_，或者存在属性 _被移除</em>.</p><p>然而，你仍然可以对存在属性进行更改。</p></p></details><hr><h6 id="137-以下哪一项会对对象-person-有副作用？"><a href="#137-以下哪一项会对对象-person-有副作用？" class="headerlink" title="137. 以下哪一项会对对象 person 有副作用？"></a>137. 以下哪一项会对对象 <code>person</code> 有副作用？</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">name: <span class="string">&quot;Lydia Hallie&quot;</span>,</span><br><span class="line">address: &#123;</span><br><span class="line">street: <span class="string">&quot;100 Main St&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.freeze(person);</span><br></pre></td></tr></table></figure><ul><li>A: <code>person.name = &quot;Evan Bacon&quot;</code></li><li>B: <code>delete person.address</code></li><li>C: <code>person.address.street = &quot;101 Main St&quot;</code></li><li>D: <code>person.pet = &#123; name: &quot;Mara&quot; &#125;</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-C-10"><a href="#答案-C-10" class="headerlink" title="答案: C"></a>答案: C</h4><p>使用方法 <code>Object.freeze</code> 对一个对象进行 _冻结_。不能对属性进行添加，修改，删除。</p><p>然而，它仅 对对象进行 <em>浅</em> 冻结，意味着只有 对象中的 <em>直接</em> 属性被冻结。如果属性是另一个 object，像案例中的 <code>address</code>，<code>address</code> 中的属性没有被冻结，仍然可以被修改。</p></p></details><hr><h6 id="138-输出什么？"><a href="#138-输出什么？" class="headerlink" title="138. 输出什么？"></a>138. 输出什么？</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> add = <span class="function"><span class="params">x</span> =&gt;</span> x + x;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunc</span>(<span class="params">num = <span class="number">2</span>, value = add(num)</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(num, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myFunc();</span><br><span class="line">myFunc(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><ul><li>A: <code>2</code> <code>4</code> and <code>3</code> <code>6</code></li><li>B: <code>2</code> <code>NaN</code> and <code>3</code> <code>NaN</code></li><li>C: <code>2</code> <code>Error</code> and <code>3</code> <code>6</code></li><li>D: <code>2</code> <code>4</code> and <code>3</code> <code>Error</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-A-4"><a href="#答案-A-4" class="headerlink" title="答案: A"></a>答案: A</h4><p>首先我们不传递任何参数调用 <code>myFunc()</code>。因为我们没有传递参数，<code>num</code> 和 <code>value</code> 获取它们各自的默认值：num 为 <code>2</code>, 而 <code>value</code> 为函数 <code>add</code> 的返回值。对于函数 <code>add</code>，我们传递值为2的 <code>num</code> 作为参数。函数 <code>add</code> 返回 <code>4</code> 作为 <code>value</code> 的值。</p><p>然后，我们调用 <code>myFunc(3)</code> 并传递值 <code>3</code> 参数 <code>num</code> 的值。我们没有给 <code>value</code> 传递值。因为我们没有给参数 <code>value</code> 传递值，它获取默认值：函数 <code>add</code> 的返回值。对于函数 <code>add</code>，我们传递值为3的 <code>num</code>给它。函数 <code>add</code> 返回 <code>6</code> 作为 <code>value</code> 的值。</p></p></details><hr><h6 id="139-输出什么？"><a href="#139-输出什么？" class="headerlink" title="139. 输出什么？"></a>139. 输出什么？</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">  #number = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">increment</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.#number++</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">getNum</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.#number</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> counter = <span class="keyword">new</span> Counter()</span><br><span class="line">counter.increment()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(counter.#number)</span><br></pre></td></tr></table></figure><ul><li>A: <code>10</code></li><li>B: <code>11</code></li><li>C: <code>undefined</code></li><li>D: <code>SyntaxError</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-D-6"><a href="#答案-D-6" class="headerlink" title="答案: D"></a>答案: D</h4><p>在 ES2020 中，通过 <code>#</code> 我们可以给 class 添加私有变量。在 class 的外部我们无法获取该值。当我们尝试输出 <code>counter.#number</code>，语法错误被抛出：我们无法在 class <code>Counter</code> 外部获取它!</p></p></details><hr><h6 id="140-选择哪一个？"><a href="#140-选择哪一个？" class="headerlink" title="140. 选择哪一个？"></a>140. 选择哪一个？</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> teams = [</span><br><span class="line">&#123; <span class="attr">name</span>: <span class="string">&quot;Team 1&quot;</span>, <span class="attr">members</span>: [<span class="string">&quot;Paul&quot;</span>, <span class="string">&quot;Lisa&quot;</span>] &#125;,</span><br><span class="line">&#123; <span class="attr">name</span>: <span class="string">&quot;Team 2&quot;</span>, <span class="attr">members</span>: [<span class="string">&quot;Laura&quot;</span>, <span class="string">&quot;Tim&quot;</span>] &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">getMembers</span>(<span class="params">members</span>) </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; members.length; i++) &#123;</span><br><span class="line"><span class="keyword">yield</span> members[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">getTeams</span>(<span class="params">teams</span>) </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; teams.length; i++) &#123;</span><br><span class="line"><span class="comment">// ✨ SOMETHING IS MISSING HERE ✨</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = getTeams(teams);</span><br><span class="line">obj.next(); <span class="comment">// &#123; value: &quot;Paul&quot;, done: false &#125;</span></span><br><span class="line">obj.next(); <span class="comment">// &#123; value: &quot;Lisa&quot;, done: false &#125;</span></span><br></pre></td></tr></table></figure><ul><li>A: <code>yield getMembers(teams[i].members)</code></li><li>B: <code>yield* getMembers(teams[i].members)</code></li><li>C: <code>return getMembers(teams[i].members)</code></li><li>D: <code>return yield getMembers(teams[i].members)</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-B-7"><a href="#答案-B-7" class="headerlink" title="答案: B"></a>答案: B</h4><p>为了遍历 <code>teams</code> 数组中对象的属性 <code>members</code> 中的每一项，我们需要将 <code>teams[i].members</code> 传递给 Generator 函数 <code>getMembers</code>。Generator 函数返回一个 generator 对象。为了遍历这个 generator 对象中的每一项，我们需要使用 <code>yield*</code>.</p><p>如果我们没有写 <code>yield</code>，<code>return yield</code> 或者 <code>return</code>，整个 Generator 函数不会第一时间 return 当我们调用 <code>next</code> 方法.</p></p></details><hr><h6 id="141-输出什么？"><a href="#141-输出什么？" class="headerlink" title="141. 输出什么？"></a>141. 输出什么？</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">name: <span class="string">&quot;Lydia Hallie&quot;</span>,</span><br><span class="line">hobbies: [<span class="string">&quot;coding&quot;</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addHobby</span>(<span class="params">hobby, hobbies = person.hobbies</span>) </span>&#123;</span><br><span class="line">hobbies.push(hobby);</span><br><span class="line"><span class="keyword">return</span> hobbies;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">addHobby(<span class="string">&quot;running&quot;</span>, []);</span><br><span class="line">addHobby(<span class="string">&quot;dancing&quot;</span>);</span><br><span class="line">addHobby(<span class="string">&quot;baking&quot;</span>, person.hobbies);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.hobbies);</span><br></pre></td></tr></table></figure><ul><li>A: <code>[&quot;coding&quot;]</code></li><li>B: <code>[&quot;coding&quot;, &quot;dancing&quot;]</code></li><li>C: <code>[&quot;coding&quot;, &quot;dancing&quot;, &quot;baking&quot;]</code></li><li>D: <code>[&quot;coding&quot;, &quot;running&quot;, &quot;dancing&quot;, &quot;baking&quot;]</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-C-11"><a href="#答案-C-11" class="headerlink" title="答案: C"></a>答案: C</h4><p>函数 <code>addHobby</code> 接受两个参数，<code>hobby</code> 和有着对象 <code>person</code> 中数组 <code>hobbies</code> 默认值的 <code>hobbies</code>。</p><p>首相，我们调用函数 <code>addHobby</code>，并给 <code>hobby</code> 传递 <code>&quot;running&quot;</code> 以及给 <code>hobbies</code> 传递一个空数组。因为我们给 <code>hobbies</code> 传递了空数组，<code>&quot;running&quot;</code> 被添加到这个空数组。</p><p>然后，我们调用函数 <code>addHobby</code>，并给 <code>hobby</code> 传递 <code>&quot;dancing&quot;</code>。我们不向 <code>hobbies</code> 传递值，因此它获取其默认值 —— 对象 <code>person</code> 的 属性 <code>hobbies</code>。我们向数组 <code>person.hobbies</code> push <code>dancing</code>。</p><p>最后，我们调用函数 <code>addHobby</code>，并向 <code>hobby</code> 传递 值 <code>&quot;bdaking&quot;</code>，并且向 <code>hobbies</code> 传递 <code>person.hobbies</code>。我们向数组 <code>person.hobbies</code> push <code>dancing</code>。</p><p>pushing <code>dancing</code> 和 <code>baking</code> 之后，<code>person.hobbies</code> 的值为 <code>[&quot;coding&quot;, &quot;dancing&quot;, &quot;baking&quot;]</code></p></p></details><hr><h6 id="142-输出什么？"><a href="#142-输出什么？" class="headerlink" title="142. 输出什么？"></a>142. 输出什么？</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;I&#x27;m a bird. 🦢&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flamingo</span> <span class="keyword">extends</span> <span class="title">Bird</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;I&#x27;m pink. 🌸&quot;</span>);</span><br><span class="line"><span class="built_in">super</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pet = <span class="keyword">new</span> Flamingo();</span><br></pre></td></tr></table></figure><ul><li>A: <code>I&#39;m pink. 🌸</code></li><li>B: <code>I&#39;m pink. 🌸</code> <code>I&#39;m a bird. 🦢</code></li><li>C: <code>I&#39;m a bird. 🦢</code> <code>I&#39;m pink. 🌸</code></li><li>D: Nothing, we didn’t call any method</li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-B-8"><a href="#答案-B-8" class="headerlink" title="答案: B"></a>答案: B</h4><p>我们创建了类 <code>Flamingo</code> 的实例 <code>pet</code>。当我们实例化这个实例，<code>Flamingo</code> 中的 <code>constructor</code> 被调用。首相，输出 <code>&quot;I&#39;m pink. 🌸&quot;</code>, 之后我们调用<code>super()</code>。<code>super()</code> 调用父类的构造函数，<code>Bird</code>。<code>Bird</code> 的构造函数被调用，并输出 <code>&quot;I&#39;m a bird. 🦢&quot;</code>。</p></p></details><hr><h6 id="143-哪一个选项会导致报错？"><a href="#143-哪一个选项会导致报错？" class="headerlink" title="143. 哪一个选项会导致报错？"></a>143. 哪一个选项会导致报错？</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> emojis = [<span class="string">&quot;🎄&quot;</span>, <span class="string">&quot;🎅🏼&quot;</span>, <span class="string">&quot;🎁&quot;</span>, <span class="string">&quot;⭐&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 1 */</span> emojis.push(<span class="string">&quot;🦌&quot;</span>);</span><br><span class="line"><span class="comment">/* 2 */</span> emojis.splice(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">/* 3 */</span> emojis = [...emojis, <span class="string">&quot;🥂&quot;</span>];</span><br><span class="line"><span class="comment">/* 4 */</span> emojis.length = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><ul><li>A: 1</li><li>B: 1 and 2</li><li>C: 3 and 4</li><li>D: 3</li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-D-7"><a href="#答案-D-7" class="headerlink" title="答案: D"></a>答案: D</h4><p><code>const</code> 关键字意味着我们不能 <em>重定义</em> 变量中的值，它 _仅可读_。而然，值本身不可修改。数组 <code>emojis</code> 中的值可被修改，如 push 新的值, 拼接，又或者将数组的长度设置为0。</p></p></details><hr><h6 id="144-我们需要向对象-person-添加什么，以致执行-person-时获得形如-quot-Lydia-Hallie-quot-21-的输出？"><a href="#144-我们需要向对象-person-添加什么，以致执行-person-时获得形如-quot-Lydia-Hallie-quot-21-的输出？" class="headerlink" title="144. 我们需要向对象 person 添加什么，以致执行 [...person] 时获得形如 [&quot;Lydia Hallie&quot;, 21] 的输出？"></a>144. 我们需要向对象 <code>person</code> 添加什么，以致执行 <code>[...person]</code> 时获得形如 <code>[&quot;Lydia Hallie&quot;, 21]</code> 的输出？</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  name: <span class="string">&quot;Lydia Hallie&quot;</span>,</span><br><span class="line">  age: <span class="number">21</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[...person] <span class="comment">// [&quot;Lydia Hallie&quot;, 21]</span></span><br></pre></td></tr></table></figure><ul><li>A: 不需要，对象默认就是可迭代的</li><li>B: <code>*[Symbol.iterator]() &#123; for (let x in this) yield* this[x] &#125;</code></li><li>C: <code>*[Symbol.iterator]() &#123; for (let x in this) yield* Object.values(this) &#125;</code></li><li>D: <code>*[Symbol.iterator]() &#123; for (let x in this) yield this &#125;</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-C-12"><a href="#答案-C-12" class="headerlink" title="答案: C"></a>答案: C</h4><p>对象默认并不是可迭代的。如果迭代规则被定义，则一个对象是可迭代的（An iterable is an iterable if the iterator protocol is present）。我们可以通过添加迭代器symbol <code>[Symbol.iterator]</code> 来定义迭代规则，其返回一个 generator 对象，比如说构建一个 generator 函数 <code>*[Symbol.iterator]() &#123;&#125;</code>。如果我们想要返回数组 <code>[&quot;Lydia Hallie&quot;, 21]</code>: <code>yield* Object.values(this)</code>，这个 generator 函数一定要 yield 对象 <code>person</code> 的<code>Object.values</code>。</p></p></details><hr><h6 id="145-输出什么？"><a href="#145-输出什么？" class="headerlink" title="145. 输出什么？"></a>145. 输出什么？</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> nums = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">nums.forEach(<span class="function"><span class="params">num</span> =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (num) count += <span class="number">1</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(count)</span><br></pre></td></tr></table></figure><ul><li>A: 1</li><li>B: 2</li><li>C: 3</li><li>D: 4<details><summary><b>答案</b></summary><p></li></ul><h4 id="答案-C-13"><a href="#答案-C-13" class="headerlink" title="答案: C"></a>答案: C</h4><p>在 <code>forEach</code> 循环内部的 <code>if</code> 会判断 <code>num</code> 的值是truthy或者是falsy。因为 <code>nums</code> 数组的第一个数字是 <code>0</code>，一个falsy值， <code>if</code> 语句代码块不会被执行。<code>count</code> 仅仅在 <code>nums</code> 数组的其他3个数字 <code>1</code>，<code>2</code>，<code>3</code> 时加1。因为 <code>count</code> 执行了3次加 <code>1</code> 运算，所以 <code>count</code> 的值为 <code>3</code>。</p></p></details><hr><h6 id="146-输出是什么？"><a href="#146-输出是什么？" class="headerlink" title="146. 输出是什么？"></a>146. 输出是什么？</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFruit</span>(<span class="params">fruits</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(fruits?.[<span class="number">1</span>]?.[<span class="number">1</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getFruit([[<span class="string">&#x27;🍊&#x27;</span>, <span class="string">&#x27;🍌&#x27;</span>], [<span class="string">&#x27;🍍&#x27;</span>]])</span><br><span class="line">getFruit()</span><br><span class="line">getFruit([[<span class="string">&#x27;🍍&#x27;</span>], [<span class="string">&#x27;🍊&#x27;</span>, <span class="string">&#x27;🍌&#x27;</span>]])</span><br></pre></td></tr></table></figure><ul><li>A: <code>null</code>, <code>undefined</code>, 🍌</li><li>B: <code>[]</code>, <code>null</code>, 🍌</li><li>C: <code>[]</code>, <code>[]</code>, 🍌</li><li>D: <code>undefined</code>, <code>undefined</code>, 🍌</li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-D-8"><a href="#答案-D-8" class="headerlink" title="答案: D"></a>答案: D</h4><p><code>?</code> 允许我们去选择性地访问对象内部更深层的嵌套属性。 我们尝试打印 <code>fruits</code> 数组索引值为 <code>1</code> 的子数组内部的索引值为 <code>1</code> 的元素。 如果在 <code>fruits</code> 数组索引值 为 <code>1</code> 的位置不存在元素，会直接返回 <code>undefined</code>。 如果 <code>fruits</code> 数组在索引值为 <code>1</code> 的位置存在元素，但是子数组在索引值为 <code>1</code> 的位置不存在元素，也会返回 <code>undefined</code>。</p><p>首先，我们尝试打印 <code>[[&#39;🍊&#39;, &#39;🍌&#39;], [&#39;🍍&#39;]]</code> 的子数组 <code>[&#39;🍍&#39;]</code> 的第2个元素。这个子数组只包含一个元素，也就意味着在索引值为 <code>1</code> 的位置不存在元素，所以返回的是 <code>undefined</code> 。</p><p>其次，我们在没有传入任何参数调用了 <code>getFruits</code> 函数，也就意味着形参 <code>fruits</code> 的默认值为<code>undefined</code>。因为我们选择性地链接了 <code>fruits</code> 在索引值为 <code>1</code> 的元素，因为在索引值为 <code>1</code> 的位置不存在元素，因此返回的是 <code>undefined</code> 。</p><p>最后，我们尝试打印 <code>[&#39;🍍&#39;], [&#39;🍊&#39;, &#39;🍌&#39;]</code> 的子数组 <code>[&#39;🍊&#39;, &#39;🍌&#39;]</code> 的第2个元素。子数组索引值为 <code>1</code>的位置为 <code>🍌</code> ，因此它被打印出了。</p></p></details><hr><h6 id="147-输出什么？"><a href="#147-输出什么？" class="headerlink" title="147. 输出什么？"></a>147. 输出什么？</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Calc</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.count = <span class="number">0</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">increase</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.count ++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> calc = <span class="keyword">new</span> Calc()</span><br><span class="line"><span class="keyword">new</span> Calc().increase()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(calc.count)</span><br></pre></td></tr></table></figure><ul><li>A: <code>0</code></li><li>B: <code>1</code></li><li>C: <code>undefined</code></li><li>D: <code>ReferenceError</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-A-5"><a href="#答案-A-5" class="headerlink" title="答案: A"></a>答案: A</h4><p>我们设置 <code>calc</code> 变量为 <code>Calc</code> 类的一个新实例。 然后，我们初始化一个 <code>Calc</code> 的新实例，而且调用了这个实例的 <code>increase</code> 方法。因为count属性是在 <code>Calc</code> class的constructor内部的，所以count属性不会在 <code>Calc</code> 的原型链上共享出去。这就意味着calc实例的count值不会被更新，count仍然是 <code>0</code>。</p></p></details><hr><h6 id="148-输出什么"><a href="#148-输出什么" class="headerlink" title="148. 输出什么?"></a>148. 输出什么?</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> user = &#123;</span><br><span class="line">email: <span class="string">&quot;e@mail.com&quot;</span>,</span><br><span class="line">password: <span class="string">&quot;12345&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> updateUser = <span class="function">(<span class="params">&#123; email, password &#125;</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (email) &#123;</span><br><span class="line"><span class="built_in">Object</span>.assign(user, &#123; email &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (password) &#123;</span><br><span class="line">user.password = password</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> user</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> updatedUser = updateUser(&#123; <span class="attr">email</span>: <span class="string">&quot;new@email.com&quot;</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(updatedUser === user)</span><br></pre></td></tr></table></figure><ul><li>A: <code>false</code></li><li>B: <code>true</code></li><li>C: <code>TypeError</code></li><li>D: <code>ReferenceError</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-B-9"><a href="#答案-B-9" class="headerlink" title="答案: B"></a>答案: B</h4><p> <code>updateUser</code> 函数更新user的 <code>email</code> 和 <code>password</code> 属性的值， 如果它们的值传入函数， 函数返回的就是 <code>user</code> 对象。 <code>updateUser</code> 函数的返回值是 <code>user</code> 对象，意味着updatedUser的值与 <code>user</code> 指向的是同一个 <code>user</code> 对象。<code>updatedUser === user</code> 为 <code>true</code>.</p></p></details><hr><h6 id="149-输出什么"><a href="#149-输出什么" class="headerlink" title="149. 输出什么?"></a>149. 输出什么?</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fruit = [<span class="string">&#x27;🍌&#x27;</span>, <span class="string">&#x27;🍊&#x27;</span>, <span class="string">&#x27;🍎&#x27;</span>]</span><br><span class="line"></span><br><span class="line">fruit.slice(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">fruit.splice(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">fruit.unshift(<span class="string">&#x27;🍇&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(fruit)</span><br></pre></td></tr></table></figure><ul><li>A: <code>[&#39;🍌&#39;, &#39;🍊&#39;, &#39;🍎&#39;]</code></li><li>B: <code>[&#39;🍊&#39;, &#39;🍎&#39;]</code></li><li>C: <code>[&#39;🍇&#39;, &#39;🍊&#39;, &#39;🍎&#39;]</code></li><li>D: <code>[&#39;🍇&#39;, &#39;🍌&#39;, &#39;🍊&#39;, &#39;🍎&#39;]</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-C-14"><a href="#答案-C-14" class="headerlink" title="答案: C"></a>答案: C</h4><p>首先，我们在fruit数组上调用 <code>slice</code> 方法。 slice方法不会修改原始数组，但是会返回从数组切片下来的值：香蕉emoji。<br>其次，我们在fruit数组上调用 <code>splice</code> 方法。 splice方法会修改原始数组，也就意味着fruit数组此时为 <code>[&#39;🍊&#39;, &#39;🍎&#39;]</code>。<br>最后，我们在fruit数组上调用 <code>unshift</code> 方法，通过添加一个值的方式改变了原始数组，添加的是’🍇’，它成为了数组的第一个元素。现在fruit数组的组成为 <code>[&#39;🍇&#39;, &#39;🍊&#39;, &#39;🍎&#39;]</code>。</p></p></details><hr><h6 id="150-输出什么"><a href="#150-输出什么" class="headerlink" title="150. 输出什么?"></a>150. 输出什么?</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> animals = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> dog = &#123; <span class="attr">emoji</span>: <span class="string">&#x27;🐶&#x27;</span> &#125;</span><br><span class="line"><span class="keyword">let</span> cat = &#123; <span class="attr">emoji</span>: <span class="string">&#x27;🐈&#x27;</span> &#125;</span><br><span class="line"></span><br><span class="line">animals[dog] = &#123; ...dog, <span class="attr">name</span>: <span class="string">&quot;Mara&quot;</span> &#125;</span><br><span class="line">animals[cat] = &#123; ...cat, <span class="attr">name</span>: <span class="string">&quot;Sara&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(animals[dog])</span><br></pre></td></tr></table></figure><ul><li>A: <code>&#123; emoji: &quot;🐶&quot;, name: &quot;Mara&quot; &#125;</code></li><li>B: <code>&#123; emoji: &quot;🐈&quot;, name: &quot;Sara&quot; &#125;</code></li><li>C: <code>undefined</code></li><li>D: <code>ReferenceError</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-B-10"><a href="#答案-B-10" class="headerlink" title="答案: B"></a>答案: B</h4><p>对象的键会被转换为字符串。</p><p>因为  <code>dog</code> 的值是一个对象，   <code>animals[dog]</code> 实际上意味着我们创建了一个叫做 <code>&quot;object Object&quot;</code> 的属性来代表新的对象。  <code>animals[&quot;object Object&quot;]</code> 现在等于 <code>&#123; emoji: &quot;🐶&quot;, name: &quot;Mara&quot;&#125;</code>。</p><p><code>cat</code> 也是一个对象，<code>animals[cat]</code> 实际上意味着我们在用新的cat的属性覆盖  <code>animals[``&quot;``object Object``&quot;``]</code> 的值。</p><p>打印  <code>animals[dog]</code>，实际上是<code>animals[&quot;object Object&quot;]</code>，这是因为转化<code>dog</code>对象为一个字符串结果 <code>&quot;object Object&quot;</code> ，所以返回 <code>&#123; emoji: &quot;🐈&quot;, name: &quot;Sara&quot; &#125;</code>。</p></p></details><hr><h6 id="151-输出什么"><a href="#151-输出什么" class="headerlink" title="151. 输出什么?"></a>151. 输出什么?</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> user = &#123;</span><br><span class="line">email: <span class="string">&quot;my@email.com&quot;</span>,</span><br><span class="line">updateEmail: <span class="function"><span class="params">email</span> =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.email = email</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">user.updateEmail(<span class="string">&quot;new@email.com&quot;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(user.email)</span><br></pre></td></tr></table></figure><ul><li>A: <code>my@email.com</code></li><li>B: <code>new@email.com</code></li><li>C: <code>undefined</code></li><li>D: <code>ReferenceError</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-A-6"><a href="#答案-A-6" class="headerlink" title="答案: A"></a>答案: A</h4><p><code>updateEmail</code> 函数是一个箭头函数，它没有和 <code>user</code> 对象绑定。这就意味着 <code>this</code> 关键字不会引用到 <code>user</code> 对象，但是会引用到全局对象。 <code>user</code> 对象内部的 <code>email</code> 的值不会更新。当打印 <code>user.email</code> 的时候， 原始值 <code>my@email.com</code> 被返回。</p></p></details><hr><h6 id="152-输出什么"><a href="#152-输出什么" class="headerlink" title="152. 输出什么?"></a>152. 输出什么?</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;First&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> promise2 = <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;Second&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> promise3 = <span class="built_in">Promise</span>.reject(<span class="string">&#x27;Third&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> promise4 = <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;Fourth&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> runPromises = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line"><span class="keyword">const</span> res1 = <span class="keyword">await</span> <span class="built_in">Promise</span>.all([promise1, promise2])</span><br><span class="line"><span class="keyword">const</span> res2  = <span class="keyword">await</span> <span class="built_in">Promise</span>.all([promise3, promise4])</span><br><span class="line"><span class="keyword">return</span> [res1, res2]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">runPromises()</span><br><span class="line">.then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br><span class="line">.catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(err))</span><br></pre></td></tr></table></figure><ul><li>A: <code>[[&#39;First&#39;, &#39;Second&#39;], [&#39;Fourth&#39;]]</code></li><li>B: <code>[[&#39;First&#39;, &#39;Second&#39;], [&#39;Third&#39;, &#39;Fourth&#39;]]</code></li><li>C: <code>[[&#39;First&#39;, &#39;Second&#39;]]</code></li><li>D: <code>&#39;Third&#39;</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-D-9"><a href="#答案-D-9" class="headerlink" title="答案: D"></a>答案: D</h4><p> <code>Promise.all</code> 方法可以并行式运行promise。如果其中一个promise失败了，<code>Promise.all</code> 方法会带上被reject的promise的值_rejects_。在这个例子中， <code>promise3</code> 带着 <code>&quot;Third&quot;</code> 值reject。我们在调用 <code>runPromises</code> 时在 <code>runPromises</code> 函数内部的 <code>catch</code> 方法去捕获任意error从而捕获到被reject的值。因为 <code>promise3</code> 带着 <code>&quot;Third&quot;</code> 被reject，所以只有 <code>&quot;Third&quot;</code> 打印。</p></p></details><hr><h6 id="153-哪个作为method的值可以打印-name-quot-Lydia-quot-age-22"><a href="#153-哪个作为method的值可以打印-name-quot-Lydia-quot-age-22" class="headerlink" title="153. 哪个作为method的值可以打印{ name: &quot;Lydia&quot;, age: 22 }?"></a>153. 哪个作为<code>method</code>的值可以打印<code>&#123; name: &quot;Lydia&quot;, age: 22 &#125;</code>?</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> keys = [<span class="string">&quot;name&quot;</span>, <span class="string">&quot;age&quot;</span>]</span><br><span class="line"><span class="keyword">const</span> values = [<span class="string">&quot;Lydia&quot;</span>, <span class="number">22</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> method = <span class="comment">/* ?? */</span></span><br><span class="line"><span class="built_in">Object</span>[method](keys.map(<span class="function">(<span class="params">_, i</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> [keys[i], values[i]]</span><br><span class="line">&#125;)) <span class="comment">// &#123; name: &quot;Lydia&quot;, age: 22 &#125;</span></span><br></pre></td></tr></table></figure><ul><li>A: <code>entries</code></li><li>B: <code>values</code></li><li>C: <code>fromEntries</code></li><li>D: <code>forEach</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-C-15"><a href="#答案-C-15" class="headerlink" title="答案: C"></a>答案: C</h4><p> <code>fromEntries</code> 方法可以将二维数组转换为对象。在每个子数组的第一个元素是key，在每个子数组的第二个元素是value。在这个例子中，我们映射了 <code>keys</code> 数组，它返回了一个数组，数组的第一个元素为keys数组当前索引的值，第二个元素为values数组当前索引的值。</p><p>这样就创建了一个包含正确keys和values的子数组的数组，因此结果为<code>&#123; name: &quot;Lydia&quot;, age: 22 &#125;</code>。</p></p></details><hr><h6 id="154-输出什么"><a href="#154-输出什么" class="headerlink" title="154. 输出什么?"></a>154. 输出什么?</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> createMember = <span class="function">(<span class="params">&#123; email, address = &#123;&#125;&#125;</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">const</span> validEmail = <span class="regexp">/.+\@.+\..+/</span>.test(email)</span><br><span class="line"><span class="keyword">if</span> (!validEmail) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;Valid email pls&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">email,</span><br><span class="line">address: address ? address : <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> member = createMember(&#123; <span class="attr">email</span>: <span class="string">&quot;my@email.com&quot;</span> &#125;)</span><br><span class="line"><span class="built_in">console</span>.log(member)</span><br></pre></td></tr></table></figure><ul><li>A: <code>&#123; email: &quot;my@email.com&quot;, address: null &#125;</code></li><li>B: <code>&#123; email: &quot;my@email.com&quot; &#125;</code></li><li>C: <code>&#123; email: &quot;my@email.com&quot;, address: &#123;&#125; &#125;</code></li><li>D: <code>&#123; email: &quot;my@email.com&quot;, address: undefined &#125;</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-C-16"><a href="#答案-C-16" class="headerlink" title="答案: C"></a>答案: C</h4><p> <code>address</code> 的默认值是一个空对象 <code>&#123;&#125;</code>。当我们设置 <code>member</code> 变量为 <code>createMember</code> 函数返回的对象，我们没有为address参数传值，意味着address的值为默认的空对象 <code>&#123;&#125;</code>。一个空对象是一个truthy值，意味着 <code>address ? address : null</code> 条件会返回 <code>true</code>。address的值为空对象 <code>&#123;&#125;</code>。</p></p></details><hr><h6 id="155-输出什么"><a href="#155-输出什么" class="headerlink" title="155. 输出什么?"></a>155. 输出什么?</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> randomValue = &#123; <span class="attr">name</span>: <span class="string">&quot;Lydia&quot;</span> &#125;</span><br><span class="line">randomValue = <span class="number">23</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">typeof</span> randomValue === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;It&#x27;s not a string!&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;Yay it&#x27;s a string!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>A: <code>It&#39;s not a string!</code></li><li>B: <code>Yay it&#39;s a string!</code></li><li>C: <code>TypeError</code></li><li>D: <code>undefined</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-B-11"><a href="#答案-B-11" class="headerlink" title="答案: B"></a>答案: B</h4><p> <code>if</code> 语句的条件判断 <code>!typeof randomValue</code> 的值是否等于 <code>&quot;string&quot;</code>。 <code>!</code> 操作符将这个值转化为一个布尔值。如果值是truthy的话，返回值会是 <code>false</code>，如果值是falsy，返回值会是 <code>true</code>。在这里， <code>typeof randomValue</code> 的返回值是一个truthy值 <code>&quot;number&quot;</code>，意味着 <code>!typeof randomValue</code> 的值是一个布尔值 <code>false</code>。</p><p> <code>!typeof randomValue === &quot;string&quot;</code> 总是返回false，因为我们实际上是在执行 <code>false === &quot;string&quot;</code>。因为条件返回的是 <code>false</code>，所以 <code>else</code> 语句中的代码块会被运行，因此打印 <code>Yay it&#39;s a string!</code> 。</p></p></details>]]></content>
      
      
      <categories>
          
          <category> 写给女友 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「星辰大海」JS自测清单（一）</title>
      <link href="posts/20201127/"/>
      <url>posts/20201127/</url>
      
        <content type="html"><![CDATA[<h2 id="星辰大海」JS自测清单（一）"><a href="#星辰大海」JS自测清单（一）" class="headerlink" title="星辰大海」JS自测清单（一）"></a>星辰大海」JS自测清单（一）</h2><p>转载自 <a href="https://github.com/lydiahallie/javascript-questions">javascript-questions</a>（star支持一波）</p><blockquote><p>我们的征途是星辰大海~</p></blockquote><p>答案在问题下方的折叠部分，点击即可展开问题。祝你好运 :heart:</p><hr><h6 id="1-输出是什么？"><a href="#1-输出是什么？" class="headerlink" title="1. 输出是什么？"></a>1. 输出是什么？</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name)</span><br><span class="line">  <span class="built_in">console</span>.log(age)</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">&#x27;Lydia&#x27;</span></span><br><span class="line">  <span class="keyword">let</span> age = <span class="number">21</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sayHi()</span><br></pre></td></tr></table></figure><ul><li>A: <code>Lydia</code> 和 <code>undefined</code></li><li>B: <code>Lydia</code> 和 <code>ReferenceError</code></li><li>C: <code>ReferenceError</code> 和 <code>21</code></li><li>D: <code>undefined</code> 和 <code>ReferenceError</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-D"><a href="#答案-D" class="headerlink" title="答案: D"></a>答案: D</h4><p>在函数内部，我们首先通过 <code>var</code> 关键字声明了 <code>name</code> 变量。这意味着变量被提升了（内存空间在创建阶段就被设置好了），直到程序运行到定义变量位置之前默认值都是 <code>undefined</code>。因为当我们打印 <code>name</code> 变量时还没有执行到定义变量的位置，因此变量的值保持为 <code>undefined</code>。</p><p>通过 <code>let</code> 和 <code>const</code> 关键字声明的变量也会提升，但是和 <code>var</code> 不同，它们不会被<i>初始化</i>。在我们声明（初始化）之前是不能访问它们的。这个行为被称之为暂时性死区。当我们试图在声明之前访问它们时，JavaScript 将会抛出一个 <code>ReferenceError</code> 错误。</p></p></details><hr><h6 id="2-输出是什么？"><a href="#2-输出是什么？" class="headerlink" title="2. 输出是什么？"></a>2. 输出是什么？</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(i), <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(i), <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>A: <code>0 1 2</code> 和 <code>0 1 2</code></li><li>B: <code>0 1 2</code> 和 <code>3 3 3</code></li><li>C: <code>3 3 3</code> 和 <code>0 1 2</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-C"><a href="#答案-C" class="headerlink" title="答案: C"></a>答案: C</h4><p>由于 JavaScript 的事件循环，<code>setTimeout</code> 回调会在<em>遍历结束后</em>才执行。因为在第一个遍历中遍历 <code>i</code> 是通过 <code>var</code> 关键字声明的，所以这个值是全局作用域下的。在遍历过程中，我们通过一元操作符 <code>++</code> 来每次递增 <code>i</code> 的值。当 <code>setTimeout</code> 回调执行的时候，<code>i</code> 的值等于 3。</p><p>在第二个遍历中，遍历 <code>i</code> 是通过 <code>let</code> 关键字声明的：通过 <code>let</code> 和 <code>const</code> 关键字声明的变量是拥有块级作用域（指的是任何在 {} 中的内容）。在每次的遍历过程中，<code>i</code> 都有一个新值，并且每个值都在循环内的作用域中。</p></p></details><hr><h6 id="3-输出是什么？"><a href="#3-输出是什么？" class="headerlink" title="3. 输出是什么？"></a>3. 输出是什么？</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> shape = &#123;</span><br><span class="line">  radius: <span class="number">10</span>,</span><br><span class="line">  <span class="function"><span class="title">diameter</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.radius * <span class="number">2</span></span><br><span class="line">  &#125;,</span><br><span class="line">  perimeter: <span class="function">() =&gt;</span> <span class="number">2</span> * <span class="built_in">Math</span>.PI * <span class="built_in">this</span>.radius</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">shape.diameter()</span><br><span class="line">shape.perimeter()</span><br></pre></td></tr></table></figure><ul><li>A: <code>20</code> and <code>62.83185307179586</code></li><li>B: <code>20</code> and <code>NaN</code></li><li>C: <code>20</code> and <code>63</code></li><li>D: <code>NaN</code> and <code>63</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-B"><a href="#答案-B" class="headerlink" title="答案: B"></a>答案: B</h4><p>注意 <code>diameter</code> 的值是一个常规函数，但是 <code>perimeter</code> 的值是一个箭头函数。</p><p>对于箭头函数，<code>this</code> 关键字指向的是它当前周围作用域（简单来说是包含箭头函数的常规函数，如果没有常规函数的话就是全局对象），这个行为和常规函数不同。这意味着当我们调用 <code>perimeter</code> 时，<code>this</code> 不是指向 <code>shape</code> 对象，而是它的周围作用域（在例子中是 <code>window</code>）。</p><p>在 <code>window</code> 中没有 <code>radius</code> 这个属性，因此返回 <code>undefined</code>。</p></p></details><hr><h6 id="4-输出是什么？"><a href="#4-输出是什么？" class="headerlink" title="4. 输出是什么？"></a>4. 输出是什么？</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">+<span class="literal">true</span>;</span><br><span class="line">!<span class="string">&quot;Lydia&quot;</span>;</span><br></pre></td></tr></table></figure><ul><li>A: <code>1</code> and <code>false</code></li><li>B: <code>false</code> and <code>NaN</code></li><li>C: <code>false</code> and <code>false</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-A"><a href="#答案-A" class="headerlink" title="答案: A"></a>答案: A</h4><p>一元操作符加号尝试将 bool 转为 number。<code>true</code> 转换为 number 的话为 <code>1</code>，<code>false</code> 为 <code>0</code>。</p><p>字符串 <code>&#39;Lydia&#39;</code> 是一个真值，真值取反那么就返回 <code>false</code>。</p></p></details><hr><h6 id="5-哪一个是正确的？"><a href="#5-哪一个是正确的？" class="headerlink" title="5. 哪一个是正确的？"></a>5. 哪一个是正确的？</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> bird = &#123;</span><br><span class="line">  size: <span class="string">&#x27;small&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mouse = &#123;</span><br><span class="line">  name: <span class="string">&#x27;Mickey&#x27;</span>,</span><br><span class="line">  small: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>A: <code>mouse.bird.size</code>是无效的</li><li>B: <code>mouse[bird.size]</code>是无效的</li><li>C: <code>mouse[bird[&quot;size&quot;]]</code>是无效的</li><li>D: 以上三个选项都是有效的</li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-A-1"><a href="#答案-A-1" class="headerlink" title="答案: A"></a>答案: A</h4><p>在 JavaScript 中，所有对象的 keys 都是字符串（除非对象是 Symbol）。尽管我们可能不会定义它们为字符串，但它们在底层总会被转换为字符串。</p><p>当我们使用括号语法时（[]），JavaScript 会解释（或者 unboxes）语句。它首先看到第一个开始括号 <code>[</code> 并继续前进直到找到结束括号 <code>]</code>。只有这样，它才会计算语句的值。</p><p><code>mouse[bird.size]</code>：首先计算 <code>bird.size</code>，这会得到 <code>small</code>。<code>mouse[&quot;small&quot;]</code> 返回 <code>true</code>。</p><p>然后使用点语法的话，上面这一切都不会发生。<code>mouse</code> 没有 <code>bird</code> 这个 key，这也就意味着 <code>mouse.bird</code> 是 <code>undefined</code>。然后当我们使用点语法 <code>mouse.bird.size</code> 时，因为 <code>mouse.bird</code> 是 <code>undefined</code>，这也就变成了 <code>undefined.size</code>。这个行为是无效的，并且会抛出一个错误类似 <code>Cannot read property &quot;size&quot; of undefined</code>。</p></p></details><hr><h6 id="6-输出是什么？"><a href="#6-输出是什么？" class="headerlink" title="6. 输出是什么？"></a>6. 输出是什么？</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> c = &#123; <span class="attr">greeting</span>: <span class="string">&#x27;Hey!&#x27;</span> &#125;</span><br><span class="line"><span class="keyword">let</span> d</span><br><span class="line"></span><br><span class="line">d = c</span><br><span class="line">c.greeting = <span class="string">&#x27;Hello&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(d.greeting)</span><br></pre></td></tr></table></figure><ul><li>A: <code>Hello</code></li><li>B: <code>undefined</code></li><li>C: <code>ReferenceError</code></li><li>D: <code>TypeError</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-A-2"><a href="#答案-A-2" class="headerlink" title="答案: A"></a>答案: A</h4><p>在 JavaScript 中，当设置两个对象彼此相等时，它们会通过<em>引用</em>进行交互。</p><p>首先，变量 <code>c</code> 的值是一个对象。接下来，我们给 <code>d</code> 分配了一个和 <code>c</code> 对象相同的引用。</p><img src= "/img/loading.gif" data-lazy-src="https://i.imgur.com/ko5k0fs.png" width="200"><p>因此当我们改变其中一个对象时，其实是改变了所有的对象。</p></p></details><hr><h6 id="7-输出是什么？"><a href="#7-输出是什么？" class="headerlink" title="7. 输出是什么？"></a>7. 输出是什么？</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">3</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">3</span>)</span><br><span class="line"><span class="keyword">let</span> c = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a == b)</span><br><span class="line"><span class="built_in">console</span>.log(a === b)</span><br><span class="line"><span class="built_in">console</span>.log(b === c)</span><br></pre></td></tr></table></figure><ul><li>A: <code>true</code> <code>false</code> <code>true</code></li><li>B: <code>false</code> <code>false</code> <code>true</code></li><li>C: <code>true</code> <code>false</code> <code>false</code></li><li>D: <code>false</code> <code>true</code> <code>true</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-C-1"><a href="#答案-C-1" class="headerlink" title="答案: C"></a>答案: C</h4><p><code>new Number()</code> 是一个内建的函数构造器。虽然它看着像是一个 number，但它实际上并不是一个真实的 number：它有一堆额外的功能并且它是一个对象。</p><p>当我们使用 <code>==</code> 操作符时，它只会检查两者是否拥有相同的<em>值</em>。因为它们的值都是 <code>3</code>，因此返回 <code>true</code>。</p><p>然后，当我们使用 <code>===</code> 操作符时，两者的值以及<em>类型</em>都应该是相同的。<code>new Number()</code> 是一个对象而不是 number，因此返回 <code>false</code>。</p></p></details><hr><h6 id="8-输出是什么？"><a href="#8-输出是什么？" class="headerlink" title="8. 输出是什么？"></a>8. 输出是什么？</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chameleon</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">colorChange</span>(<span class="params">newColor</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.newColor = newColor</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.newColor</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">&#123; newColor = <span class="string">&#x27;green&#x27;</span> &#125; = &#123;&#125;</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.newColor = newColor</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> freddie = <span class="keyword">new</span> Chameleon(&#123; <span class="attr">newColor</span>: <span class="string">&#x27;purple&#x27;</span> &#125;)</span><br><span class="line">freddie.colorChange(<span class="string">&#x27;orange&#x27;</span>)</span><br></pre></td></tr></table></figure><ul><li>A: <code>orange</code></li><li>B: <code>purple</code></li><li>C: <code>green</code></li><li>D: <code>TypeError</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-D-1"><a href="#答案-D-1" class="headerlink" title="答案: D"></a>答案: D</h4><p><code>colorChange</code> 是一个静态方法。静态方法被设计为只能被创建它们的构造器使用（也就是 <code>Chameleon</code>），并且不能传递给实例。因为 <code>freddie</code> 是一个实例，静态方法不能被实例使用，因此抛出了 <code>TypeError</code> 错误。</p></p></details><hr><h6 id="9-输出是什么？"><a href="#9-输出是什么？" class="headerlink" title="9. 输出是什么？"></a>9. 输出是什么？</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> greeting</span><br><span class="line">greetign = &#123;&#125; <span class="comment">// Typo!</span></span><br><span class="line"><span class="built_in">console</span>.log(greetign)</span><br></pre></td></tr></table></figure><ul><li>A: <code>&#123;&#125;</code></li><li>B: <code>ReferenceError: greetign is not defined</code></li><li>C: <code>undefined</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-A-3"><a href="#答案-A-3" class="headerlink" title="答案: A"></a>答案: A</h4><p>代码打印出了一个对象，这是因为我们在全局对象上创建了一个空对象！当我们将 <code>greeting</code> 写错成 <code>greetign</code> 时，JS 解释器实际在上浏览器中将它视为 <code>global.greetign = &#123;&#125;</code> （或者 <code>window.greetign = &#123;&#125;</code>）。</p><p>为了避免这个为题，我们可以使用 `”use strict”。这能确保当你声明变量时必须赋值。</p></p></details><hr><h6 id="10-当我们这么做时，会发生什么？"><a href="#10-当我们这么做时，会发生什么？" class="headerlink" title="10. 当我们这么做时，会发生什么？"></a>10. 当我们这么做时，会发生什么？</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bark</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Woof!&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bark.animal = <span class="string">&#x27;dog&#x27;</span></span><br></pre></td></tr></table></figure><ul><li>A: 正常运行!</li><li>B: <code>SyntaxError</code>. 你不能通过这种方式给函数增加属性。</li><li>C: <code>undefined</code></li><li>D: <code>ReferenceError</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-A-4"><a href="#答案-A-4" class="headerlink" title="答案: A"></a>答案: A</h4><p>这在 JavaScript 中是可以的，因为函数是对象！（除了基本类型之外其他都是对象）</p><p>函数是一个特殊的对象。你写的这个代码其实不是一个实际的函数。函数是一个拥有属性的对象，并且属性也可被调用。</p></p></details><hr><h6 id="11-输出是什么？"><a href="#11-输出是什么？" class="headerlink" title="11. 输出是什么？"></a>11. 输出是什么？</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">firstName, lastName</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.firstName = firstName;</span><br><span class="line">  <span class="built_in">this</span>.lastName = lastName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> member = <span class="keyword">new</span> Person(<span class="string">&quot;Lydia&quot;</span>, <span class="string">&quot;Hallie&quot;</span>);</span><br><span class="line">Person.getFullName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.firstName&#125;</span> <span class="subst">$&#123;<span class="built_in">this</span>.lastName&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(member.getFullName());</span><br></pre></td></tr></table></figure><ul><li>A: <code>TypeError</code></li><li>B: <code>SyntaxError</code></li><li>C: <code>Lydia Hallie</code></li><li>D: <code>undefined</code> <code>undefined</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-A-5"><a href="#答案-A-5" class="headerlink" title="答案: A"></a>答案: A</h4><p>你不能像常规对象那样，给构造函数添加属性。如果你想一次性给所有实例添加特性，你应该使用原型。因此本例中，使用如下方式：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Person.prototype.getFullName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.firstName&#125;</span> <span class="subst">$&#123;<span class="built_in">this</span>.lastName&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这才会使 <code>member.getFullName()</code> 起作用。为什么这么做有益的？假设我们将这个方法添加到构造函数本身里。也许不是每个 <code>Person</code> 实例都需要这个方法。这将浪费大量内存空间，因为它们仍然具有该属性，这将占用每个实例的内存空间。相反，如果我们只将它添加到原型中，那么它只存在于内存中的一个位置，但是所有实例都可以访问它！</p></p></details><hr><h6 id="12-输出是什么？"><a href="#12-输出是什么？" class="headerlink" title="12. 输出是什么？"></a>12. 输出是什么？</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">firstName, lastName</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.firstName = firstName</span><br><span class="line">  <span class="built_in">this</span>.lastName = lastName</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> lydia = <span class="keyword">new</span> Person(<span class="string">&#x27;Lydia&#x27;</span>, <span class="string">&#x27;Hallie&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> sarah = Person(<span class="string">&#x27;Sarah&#x27;</span>, <span class="string">&#x27;Smith&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(lydia)</span><br><span class="line"><span class="built_in">console</span>.log(sarah)</span><br></pre></td></tr></table></figure><ul><li>A: <code>Person &#123;firstName: &quot;Lydia&quot;, lastName: &quot;Hallie&quot;&#125;</code> and <code>undefined</code></li><li>B: <code>Person &#123;firstName: &quot;Lydia&quot;, lastName: &quot;Hallie&quot;&#125;</code> and <code>Person &#123;firstName: &quot;Sarah&quot;, lastName: &quot;Smith&quot;&#125;</code></li><li>C: <code>Person &#123;firstName: &quot;Lydia&quot;, lastName: &quot;Hallie&quot;&#125;</code> and <code>&#123;&#125;</code></li><li>D:<code>Person &#123;firstName: &quot;Lydia&quot;, lastName: &quot;Hallie&quot;&#125;</code> and <code>ReferenceError</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-A-6"><a href="#答案-A-6" class="headerlink" title="答案: A"></a>答案: A</h4><p>对于 <code>sarah</code>，我们没有使用 <code>new</code> 关键字。当使用 <code>new</code> 时，<code>this</code> 引用我们创建的空对象。当未使用 <code>new</code> 时，<code>this</code> 引用的是<strong>全局对象</strong>（global object）。</p><p>我们说 <code>this.firstName</code> 等于 <code>&quot;Sarah&quot;</code>，并且 <code>this.lastName</code> 等于 <code>&quot;Smith&quot;</code>。实际上我们做的是，定义了 <code>global.firstName = &#39;Sarah&#39;</code> 和 <code>global.lastName = &#39;Smith&#39;</code>。而 <code>sarah</code> 本身是 <code>undefined</code>。</p></p></details><hr><h6 id="13-事件传播的三个阶段是什么？"><a href="#13-事件传播的三个阶段是什么？" class="headerlink" title="13. 事件传播的三个阶段是什么？"></a>13. 事件传播的三个阶段是什么？</h6><ul><li>A: Target &gt; Capturing &gt; Bubbling</li><li>B: Bubbling &gt; Target &gt; Capturing</li><li>C: Target &gt; Bubbling &gt; Capturing</li><li>D: Capturing &gt; Target &gt; Bubbling</li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-D-2"><a href="#答案-D-2" class="headerlink" title="答案: D"></a>答案: D</h4><p>在<strong>捕获</strong>（capturing）阶段中，事件从祖先元素向下传播到目标元素。当事件达到<strong>目标</strong>（target）元素后，<strong>冒泡</strong>（bubbling）才开始。</p><img src= "/img/loading.gif" data-lazy-src="https://i.imgur.com/N18oRgd.png" width="200"></p></details><hr><h6 id="14-所有对象都有原型。"><a href="#14-所有对象都有原型。" class="headerlink" title="14. 所有对象都有原型。"></a>14. 所有对象都有原型。</h6><ul><li>A: 对</li><li>B: 错</li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-B-1"><a href="#答案-B-1" class="headerlink" title="答案: B"></a>答案: B</h4><p>除了<strong>基本对象</strong>（base object），所有对象都有原型。基本对象可以访问一些方法和属性，比如 <code>.toString</code>。这就是为什么你可以使用内置的 JavaScript 方法！所有这些方法在原型上都是可用的。虽然 JavaScript 不能直接在对象上找到这些方法，但 JavaScript 会沿着原型链找到它们，以便于你使用。</p></p></details><hr><h6 id="15-输出是什么？"><a href="#15-输出是什么？" class="headerlink" title="15. 输出是什么？"></a>15. 输出是什么？</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum(<span class="number">1</span>, <span class="string">&#x27;2&#x27;</span>)</span><br></pre></td></tr></table></figure><ul><li>A: <code>NaN</code></li><li>B: <code>TypeError</code></li><li>C: <code>&quot;12&quot;</code></li><li>D: <code>3</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-C-2"><a href="#答案-C-2" class="headerlink" title="答案: C"></a>答案: C</h4><p>JavaScript 是一种<strong>动态类型语言</strong>：我们不指定某些变量的类型。值可以在你不知道的情况下自动转换成另一种类型，这种类型称为<strong>隐式类型转换</strong>（implicit type coercion）。<strong>Coercion</strong> 是指将一种类型转换为另一种类型。</p><p>在本例中，JavaScript 将数字 <code>1</code> 转换为字符串，以便函数有意义并返回一个值。在数字类型（<code>1</code>）和字符串类型（<code>&#39;2&#39;</code>）相加时，该数字被视为字符串。我们可以连接字符串，比如 <code>&quot;Hello&quot; + &quot;World&quot;</code>，这里发生的是 <code>&quot;1&quot; + &quot;2&quot;</code>，它返回 <code>&quot;12&quot;</code>。</p></p></details><hr><h6 id="16-输出是什么？"><a href="#16-输出是什么？" class="headerlink" title="16. 输出是什么？"></a>16. 输出是什么？</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> number = <span class="number">0</span></span><br><span class="line"><span class="built_in">console</span>.log(number++)</span><br><span class="line"><span class="built_in">console</span>.log(++number)</span><br><span class="line"><span class="built_in">console</span>.log(number)</span><br></pre></td></tr></table></figure><ul><li>A: <code>1</code> <code>1</code> <code>2</code></li><li>B: <code>1</code> <code>2</code> <code>2</code></li><li>C: <code>0</code> <code>2</code> <code>2</code></li><li>D: <code>0</code> <code>1</code> <code>2</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-C-3"><a href="#答案-C-3" class="headerlink" title="答案: C"></a>答案: C</h4><p>一元<strong>后自增</strong>运算符 <code>++</code>：</p><ol><li>返回值（返回 <code>0</code>）</li><li>值自增（number 现在是 <code>1</code>）</li></ol><p>一元<strong>前自增</strong>运算符 <code>++</code>：</p><ol><li>值自增（number 现在是 <code>2</code>）</li><li>返回值（返回 <code>2</code>）</li></ol><p>结果是 <code>0 2 2</code>.</p></p></details><hr><h6 id="17-输出是什么？"><a href="#17-输出是什么？" class="headerlink" title="17. 输出是什么？"></a>17. 输出是什么？</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPersonInfo</span>(<span class="params">one, two, three</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(one)</span><br><span class="line">  <span class="built_in">console</span>.log(two)</span><br><span class="line">  <span class="built_in">console</span>.log(three)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = <span class="string">&#x27;Lydia&#x27;</span></span><br><span class="line"><span class="keyword">const</span> age = <span class="number">21</span></span><br><span class="line"></span><br><span class="line">getPersonInfo<span class="string">`<span class="subst">$&#123;person&#125;</span> is <span class="subst">$&#123;age&#125;</span> years old`</span></span><br></pre></td></tr></table></figure><ul><li>A: <code>&quot;Lydia&quot;</code> <code>21</code> <code>[&quot;&quot;, &quot; is &quot;, &quot; years old&quot;]</code></li><li>B: <code>[&quot;&quot;, &quot; is &quot;, &quot; years old&quot;]</code> <code>&quot;Lydia&quot;</code> <code>21</code></li><li>C: <code>&quot;Lydia&quot;</code> <code>[&quot;&quot;, &quot; is &quot;, &quot; years old&quot;]</code> <code>21</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-B-2"><a href="#答案-B-2" class="headerlink" title="答案: B"></a>答案: B</h4><p>如果使用标记模板字面量，第一个参数的值总是包含字符串的数组。其余的参数获取的是传递的表达式的值！</p></p></details><hr><h6 id="18-输出是什么？"><a href="#18-输出是什么？" class="headerlink" title="18. 输出是什么？"></a>18. 输出是什么？</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkAge</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (data === &#123; <span class="attr">age</span>: <span class="number">18</span> &#125;) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;You are an adult!&#x27;</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data == &#123; <span class="attr">age</span>: <span class="number">18</span> &#125;) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;You are still an adult.&#x27;</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Hmm.. You don&#x27;t have an age I guess`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">checkAge(&#123; <span class="attr">age</span>: <span class="number">18</span> &#125;)</span><br></pre></td></tr></table></figure><ul><li>A: <code>You are an adult!</code></li><li>B: <code>You are still an adult.</code></li><li>C: <code>Hmm.. You don&#39;t have an age I guess</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-C-4"><a href="#答案-C-4" class="headerlink" title="答案: C"></a>答案: C</h4><p>在测试相等性时，基本类型通过它们的值（value）进行比较，而对象通过它们的引用（reference）进行比较。JavaScript 检查对象是否具有对内存中相同位置的引用。</p><p>题目中我们正在比较的两个对象不是同一个引用：作为参数传递的对象引用的内存位置，与用于判断相等的对象所引用的内存位置并不同。</p><p>这也是 <code>&#123; age: 18 &#125; === &#123; age: 18 &#125;</code> 和 <code>&#123; age: 18 &#125; == &#123; age: 18 &#125;</code> 都返回 <code>false</code> 的原因。</p></p></details><hr><h6 id="19-输出是什么？"><a href="#19-输出是什么？" class="headerlink" title="19. 输出是什么？"></a>19. 输出是什么？</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAge</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">typeof</span> args)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getAge(<span class="number">21</span>)</span><br></pre></td></tr></table></figure><ul><li>A: <code>&quot;number&quot;</code></li><li>B: <code>&quot;array&quot;</code></li><li>C: <code>&quot;object&quot;</code></li><li>D: <code>&quot;NaN&quot;</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-C-5"><a href="#答案-C-5" class="headerlink" title="答案: C"></a>答案: C</h4><p>扩展运算符（<code>...args</code>）会返回实参组成的数组。而数组是对象，因此 <code>typeof args</code> 返回 <code>&quot;object&quot;</code>。</p></p></details><hr><h6 id="20-输出是什么？"><a href="#20-输出是什么？" class="headerlink" title="20. 输出是什么？"></a>20. 输出是什么？</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAge</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  &#x27;use strict&#x27;</span></span><br><span class="line">  age = <span class="number">21</span></span><br><span class="line">  <span class="built_in">console</span>.log(age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getAge()</span><br></pre></td></tr></table></figure><ul><li>A: <code>21</code></li><li>B: <code>undefined</code></li><li>C: <code>ReferenceError</code></li><li>D: <code>TypeError</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-C-6"><a href="#答案-C-6" class="headerlink" title="答案: C"></a>答案: C</h4><p>使用 <code>&quot;use strict&quot;</code>，你可以确保不会意外地声明全局变量。我们从来没有声明变量 <code>age</code>，因为我们使用 <code>&quot;use strict&quot;</code>，它将抛出一个引用错误。如果我们不使用 <code>&quot;use strict&quot;</code>，它就会工作，因为属性 <code>age</code> 会被添加到全局对象中了。</p></p></details><hr><h6 id="21-输出是什么？"><a href="#21-输出是什么？" class="headerlink" title="21. 输出是什么？"></a>21. 输出是什么？</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sum = <span class="built_in">eval</span>(<span class="string">&#x27;10*10+5&#x27;</span>)</span><br></pre></td></tr></table></figure><ul><li>A: <code>105</code></li><li>B: <code>&quot;105&quot;</code></li><li>C: <code>TypeError</code></li><li>D: <code>&quot;10*10+5&quot;</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-A-7"><a href="#答案-A-7" class="headerlink" title="答案: A"></a>答案: A</h4><p>代码以字符串形式传递进来，<code>eval</code> 对其求值。如果它是一个表达式，就像本例中那样，它对表达式求值。表达式是 <code>10 * 10 + 5</code>。这将返回数字 <code>105</code>。</p></p></details><hr><h6 id="22-cool-secret-可访问多长时间？"><a href="#22-cool-secret-可访问多长时间？" class="headerlink" title="22. cool_secret 可访问多长时间？"></a>22. cool_secret 可访问多长时间？</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">sessionStorage.setItem(<span class="string">&#x27;cool_secret&#x27;</span>, <span class="number">123</span>)</span><br></pre></td></tr></table></figure><ul><li>A: 永远，数据不会丢失。</li><li>B: 当用户关掉标签页时。</li><li>C: 当用户关掉整个浏览器，而不只是关掉标签页。</li><li>D: 当用户关闭电脑时。</li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-B-3"><a href="#答案-B-3" class="headerlink" title="答案: B"></a>答案: B</h4><p>关闭 <strong>tab 标签页</strong> 后，<code>sessionStorage</code> 存储的数据才会删除。</p><p>如果使用 <code>localStorage</code>，那么数据将永远在那里，除非调用了 <code>localStorage.clear()</code>。</p></p></details><hr><h6 id="23-输出是什么？"><a href="#23-输出是什么？" class="headerlink" title="23. 输出是什么？"></a>23. 输出是什么？</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">8</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(num)</span><br></pre></td></tr></table></figure><ul><li>A: <code>8</code></li><li>B: <code>10</code></li><li>C: <code>SyntaxError</code></li><li>D: <code>ReferenceError</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-B-4"><a href="#答案-B-4" class="headerlink" title="答案: B"></a>答案: B</h4><p>使用 <code>var</code> 关键字，你可以用相同的名称声明多个变量。然后变量将保存最新的值。</p><p>你不能使用 <code>let</code> 或 <code>const</code> 来实现这一点，因为它们是块作用域的。</p></p></details><hr><h6 id="24-输出是什么？"><a href="#24-输出是什么？" class="headerlink" title="24. 输出是什么？"></a>24. 输出是什么？</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="number">1</span>: <span class="string">&#x27;a&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;b&#x27;</span>, <span class="number">3</span>: <span class="string">&#x27;c&#x27;</span> &#125;</span><br><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"></span><br><span class="line">obj.hasOwnProperty(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">obj.hasOwnProperty(<span class="number">1</span>)</span><br><span class="line">set.has(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">set.has(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><ul><li>A: <code>false</code> <code>true</code> <code>false</code> <code>true</code></li><li>B: <code>false</code> <code>true</code> <code>true</code> <code>true</code></li><li>C: <code>true</code> <code>true</code> <code>false</code> <code>true</code></li><li>D: <code>true</code> <code>true</code> <code>true</code> <code>true</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-C-7"><a href="#答案-C-7" class="headerlink" title="答案: C"></a>答案: C</h4><p>所有对象的键（不包括 Symbol）在底层都是字符串，即使你自己没有将其作为字符串输入。这就是为什么 <code>obj.hasOwnProperty(&#39;1&#39;)</code> 也返回 <code>true</code>。</p><p>对于集合，它不是这样工作的。在我们的集合中没有 <code>&#39;1&#39;</code>：<code>set.has(&#39;1&#39;)</code> 返回 <code>false</code>。它有数字类型为 <code>1</code>，<code>set.has(1)</code> 返回 <code>true</code>。</p></p></details><hr><h6 id="25-输出是什么？"><a href="#25-输出是什么？" class="headerlink" title="25. 输出是什么？"></a>25. 输出是什么？</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">a</span>: <span class="string">&#x27;one&#x27;</span>, <span class="attr">b</span>: <span class="string">&#x27;two&#x27;</span>, <span class="attr">a</span>: <span class="string">&#x27;three&#x27;</span> &#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj)</span><br></pre></td></tr></table></figure><ul><li>A: <code>&#123; a: &quot;one&quot;, b: &quot;two&quot; &#125;</code></li><li>B: <code>&#123; b: &quot;two&quot;, a: &quot;three&quot; &#125;</code></li><li>C: <code>&#123; a: &quot;three&quot;, b: &quot;two&quot; &#125;</code></li><li>D: <code>SyntaxError</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-C-8"><a href="#答案-C-8" class="headerlink" title="答案: C"></a>答案: C</h4><p>如果你有两个名称相同的键，则键会被替换掉。它仍然位于第一个键出现的位置，但是值是最后出现那个键的值。</p></p></details><hr><h6 id="26-JavaScript-全局执行上下文为你做了两件事：全局对象和-this-关键字。"><a href="#26-JavaScript-全局执行上下文为你做了两件事：全局对象和-this-关键字。" class="headerlink" title="26. JavaScript 全局执行上下文为你做了两件事：全局对象和 this 关键字。"></a>26. JavaScript 全局执行上下文为你做了两件事：全局对象和 this 关键字。</h6><ul><li>A: 对</li><li>B: 错</li><li>C: 看情况</li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-A-8"><a href="#答案-A-8" class="headerlink" title="答案: A"></a>答案: A</h4><p>基本执行上下文是全局执行上下文：它是代码中随处可访问的内容。</p></p></details><hr><h6 id="27-输出是什么？"><a href="#27-输出是什么？" class="headerlink" title="27. 输出是什么？"></a>27. 输出是什么？</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (i === <span class="number">3</span>) <span class="keyword">continue</span></span><br><span class="line">  <span class="built_in">console</span>.log(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>A: <code>1</code> <code>2</code></li><li>B: <code>1</code> <code>2</code> <code>3</code></li><li>C: <code>1</code> <code>2</code> <code>4</code></li><li>D: <code>1</code> <code>3</code> <code>4</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-C-9"><a href="#答案-C-9" class="headerlink" title="答案: C"></a>答案: C</h4><p>如果某个条件返回 <code>true</code>，则 <code>continue</code> 语句跳过本次迭代。</p></p></details><hr><h6 id="28-输出是什么？"><a href="#28-输出是什么？" class="headerlink" title="28. 输出是什么？"></a>28. 输出是什么？</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span>.prototype.giveLydiaPizza = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;Just give Lydia pizza already!&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;Lydia&#x27;</span></span><br><span class="line"></span><br><span class="line">name.giveLydiaPizza()</span><br></pre></td></tr></table></figure><ul><li>A: <code>&quot;Just give Lydia pizza already!&quot;</code></li><li>B: <code>TypeError: not a function</code></li><li>C: <code>SyntaxError</code></li><li>D: <code>undefined</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-A-9"><a href="#答案-A-9" class="headerlink" title="答案: A"></a>答案: A</h4><p><code>String</code> 是内置的构造函数，我们可以向它添加属性。我只是在它的原型中添加了一个方法。基本类型字符串被自动转换为字符串对象，由字符串原型函数生成。因此，所有 string(string 对象)都可以访问该方法！</p></p></details><hr><h6 id="29-输出是什么？"><a href="#29-输出是什么？" class="headerlink" title="29. 输出是什么？"></a>29. 输出是什么？</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> b = &#123; <span class="attr">key</span>: <span class="string">&#x27;b&#x27;</span> &#125;</span><br><span class="line"><span class="keyword">const</span> c = &#123; <span class="attr">key</span>: <span class="string">&#x27;c&#x27;</span> &#125;</span><br><span class="line"></span><br><span class="line">a[b] = <span class="number">123</span></span><br><span class="line">a[c] = <span class="number">456</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a[b])</span><br></pre></td></tr></table></figure><ul><li>A: <code>123</code></li><li>B: <code>456</code></li><li>C: <code>undefined</code></li><li>D: <code>ReferenceError</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-B-5"><a href="#答案-B-5" class="headerlink" title="答案: B"></a>答案: B</h4><p>对象的键被自动转换为字符串。我们试图将一个对象 <code>b</code> 设置为对象 <code>a</code> 的键，且相应的值为 <code>123</code>。</p><p>然而，当字符串化一个对象时，它会变成 <code>&quot;[object Object]&quot;</code>。因此这里说的是，<code>a[&quot;[object Object]&quot;] = 123</code>。然后，我们再一次做了同样的事情，<code>c</code> 是另外一个对象，这里也有隐式字符串化，于是，<code>a[&quot;[object Object]&quot;] = 456</code>。</p><p>然后，我们打印 <code>a[b]</code>，也就是 <code>a[&quot;[object Object]&quot;]</code>。之前刚设置为 <code>456</code>，因此返回的是 <code>456</code>。</p></p></details><hr><h6 id="30-输出是什么？"><a href="#30-输出是什么？" class="headerlink" title="30. 输出是什么？"></a>30. 输出是什么？</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;First&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> bar = <span class="function">() =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;Second&#x27;</span>))</span><br><span class="line"><span class="keyword">const</span> baz = <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;Third&#x27;</span>)</span><br><span class="line"></span><br><span class="line">bar()</span><br><span class="line">foo()</span><br><span class="line">baz()</span><br></pre></td></tr></table></figure><ul><li>A: <code>First</code> <code>Second</code> <code>Third</code></li><li>B: <code>First</code> <code>Third</code> <code>Second</code></li><li>C: <code>Second</code> <code>First</code> <code>Third</code></li><li>D: <code>Second</code> <code>Third</code> <code>First</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-B-6"><a href="#答案-B-6" class="headerlink" title="答案: B"></a>答案: B</h4><p>我们有一个 <code>setTimeout</code> 函数，并首先调用它。然而，它是最后打印日志的。</p><p>这是因为在浏览器中，我们不仅有运行时引擎，还有一个叫做 <code>WebAPI</code> 的东西。<code>WebAPI</code> 提供了 <code>setTimeout</code> 函数，也包含其他的，例如 DOM。</p><p>将 <em>callback</em> 推送到 WebAPI 后，<code>setTimeout</code> 函数本身(但不是回调！)将从栈中弹出。</p><img src= "/img/loading.gif" data-lazy-src="https://i.imgur.com/X5wsHOg.png" width="200"><p>现在，<code>foo</code> 被调用，打印 <code>&quot;First&quot;</code>。</p><img src= "/img/loading.gif" data-lazy-src="https://i.imgur.com/Pvc0dGq.png" width="200"><p><code>foo</code> 从栈中弹出，<code>baz</code> 被调用. 打印 <code>&quot;Third&quot;</code>。</p><img src= "/img/loading.gif" data-lazy-src="https://i.imgur.com/WhA2bCP.png" width="200"><p>WebAPI 不能随时向栈内添加内容。相反，它将回调函数推到名为 <em>queue</em> 的地方。</p><img src= "/img/loading.gif" data-lazy-src="https://i.imgur.com/NSnDZmU.png" width="200"><p>这就是事件循环开始工作的地方。一个<strong>事件循环</strong>查看栈和任务队列。如果栈是空的，它接受队列上的第一个元素并将其推入栈。</p><img src= "/img/loading.gif" data-lazy-src="https://i.imgur.com/uyiScAI.png" width="200"><p><code>bar</code> 被调用，打印 <code>&quot;Second&quot;</code>，然后它被栈弹出。</p></p></details><hr><h6 id="31-当点击按钮时，event-target是什么？"><a href="#31-当点击按钮时，event-target是什么？" class="headerlink" title="31. 当点击按钮时，event.target是什么？"></a>31. 当点击按钮时，event.target是什么？</h6><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onclick</span>=<span class="string">&quot;console.log(&#x27;first div&#x27;)&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">onclick</span>=<span class="string">&quot;console.log(&#x27;second div&#x27;)&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;console.log(&#x27;button&#x27;)&quot;</span>&gt;</span></span><br><span class="line">      Click!</span><br><span class="line">    <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>A: Outer <code>div</code></li><li>B: Inner <code>div</code></li><li>C: <code>button</code></li><li>D: 一个包含所有嵌套元素的数组。</li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-C-10"><a href="#答案-C-10" class="headerlink" title="答案: C"></a>答案: C</h4><p>导致事件的最深嵌套的元素是事件的 target。你可以通过 <code>event.stopPropagation</code> 来停止冒泡。</p></p></details><hr><h6 id="32-当您单击该段落时，日志输出是什么？"><a href="#32-当您单击该段落时，日志输出是什么？" class="headerlink" title="32. 当您单击该段落时，日志输出是什么？"></a>32. 当您单击该段落时，日志输出是什么？</h6><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onclick</span>=<span class="string">&quot;console.log(&#x27;div&#x27;)&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">onclick</span>=<span class="string">&quot;console.log(&#x27;p&#x27;)&quot;</span>&gt;</span></span><br><span class="line">    Click here!</span><br><span class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>A: <code>p</code> <code>div</code></li><li>B: <code>div</code> <code>p</code></li><li>C: <code>p</code></li><li>D: <code>div</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-A-10"><a href="#答案-A-10" class="headerlink" title="答案: A"></a>答案: A</h4><p>如果我们点击 <code>p</code>，我们会看到两个日志：<code>p</code> 和 <code>div</code>。在事件传播期间，有三个阶段：捕获、目标和冒泡。默认情况下，事件处理程序在冒泡阶段执行（除非将 <code>useCapture</code> 设置为 <code>true</code>）。它从嵌套最深的元素向外传播。</p></p></details><hr><h6 id="33-输出是什么？"><a href="#33-输出是什么？" class="headerlink" title="33. 输出是什么？"></a>33. 输出是什么？</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123; <span class="attr">name</span>: <span class="string">&#x27;Lydia&#x27;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span> is <span class="subst">$&#123;age&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sayHi.call(person, <span class="number">21</span>)</span><br><span class="line">sayHi.bind(person, <span class="number">21</span>)</span><br></pre></td></tr></table></figure><ul><li>A: <code>undefined is 21</code> <code>Lydia is 21</code></li><li>B: <code>function</code> <code>function</code></li><li>C: <code>Lydia is 21</code> <code>Lydia is 21</code></li><li>D: <code>Lydia is 21</code> <code>function</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-D-3"><a href="#答案-D-3" class="headerlink" title="答案: D"></a>答案: D</h4><p>使用这两种方法，我们都可以传递我们希望 <code>this</code> 关键字引用的对象。但是，<code>.call</code> 是<strong>立即执行</strong>的。</p><p><code>.bind</code> 返回函数的<strong>副本</strong>，但带有绑定上下文！它不是立即执行的。</p></p></details><hr><h6 id="34-输出是什么？"><a href="#34-输出是什么？" class="headerlink" title="34. 输出是什么？"></a>34. 输出是什么？</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="function">() =&gt;</span> <span class="number">0</span>)()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> sayHi()</span><br></pre></td></tr></table></figure><ul><li>A: <code>&quot;object&quot;</code></li><li>B: <code>&quot;number&quot;</code></li><li>C: <code>&quot;function&quot;</code></li><li>D: <code>&quot;undefined&quot;</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-B-7"><a href="#答案-B-7" class="headerlink" title="答案: B"></a>答案: B</h4><p><code>sayHi</code> 方法返回的是立即执行函数(IIFE)的返回值.此立即执行函数的返回值是 <code>0</code>， 类型是 <code>number</code></p><p>参考：只有7种内置类型：<code>null</code>，<code>undefined</code>，<code>boolean</code>，<code>number</code>，<code>string</code>，<code>object</code>, <code>symbol</code> 和 <code>bigint</code>。 <code>function</code> 不是一种类型，函数是对象，它的类型是<code>object</code>。</p></p></details><hr><h6 id="35-下面哪些值是-falsy"><a href="#35-下面哪些值是-falsy" class="headerlink" title="35. 下面哪些值是 falsy?"></a>35. 下面哪些值是 falsy?</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">0</span>)</span><br><span class="line">(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>)</span><br><span class="line"><span class="literal">undefined</span></span><br></pre></td></tr></table></figure><ul><li>A: <code>0</code>, <code>&#39;&#39;</code>, <code>undefined</code></li><li>B: <code>0</code>, <code>new Number(0)</code>, <code>&#39;&#39;</code>, <code>new Boolean(false)</code>, <code>undefined</code></li><li>C: <code>0</code>, <code>&#39;&#39;</code>, <code>new Boolean(false)</code>, <code>undefined</code></li><li>D: All of them are falsy</li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-A-11"><a href="#答案-A-11" class="headerlink" title="答案: A"></a>答案: A</h4><p>只有 6 种 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Falsy">falsy</a> 值:</p><ul><li><code>undefined</code></li><li><code>null</code></li><li><code>NaN</code></li><li><code>0</code></li><li><code>&#39;&#39;</code> (empty string)</li><li><code>false</code></li></ul><p><code>Function</code> 构造函数, 比如 <code>new Number</code> 和 <code>new Boolean</code>，是 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Truthy">truthy</a>。</p></p></details><hr><h6 id="36-输出是什么？"><a href="#36-输出是什么？" class="headerlink" title="36. 输出是什么？"></a>36. 输出是什么？</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="keyword">typeof</span> <span class="number">1</span>)</span><br></pre></td></tr></table></figure><ul><li>A: <code>&quot;number&quot;</code></li><li>B: <code>&quot;string&quot;</code></li><li>C: <code>&quot;object&quot;</code></li><li>D: <code>&quot;undefined&quot;</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-B-8"><a href="#答案-B-8" class="headerlink" title="答案: B"></a>答案: B</h4><p><code>typeof 1</code> 返回 <code>&quot;number&quot;</code>。<br><code>typeof &quot;number&quot;</code> 返回 <code>&quot;string&quot;</code>。</p></p></details><hr><h6 id="37-输出是什么？"><a href="#37-输出是什么？" class="headerlink" title="37. 输出是什么？"></a>37. 输出是什么？</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">numbers[<span class="number">10</span>] = <span class="number">11</span></span><br><span class="line"><span class="built_in">console</span>.log(numbers)</span><br></pre></td></tr></table></figure><ul><li>A: <code>[1, 2, 3, 7 x null, 11]</code></li><li>B: <code>[1, 2, 3, 11]</code></li><li>C: <code>[1, 2, 3, 7 x empty, 11]</code></li><li>D: <code>SyntaxError</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-C-11"><a href="#答案-C-11" class="headerlink" title="答案: C"></a>答案: C</h4><p>当你为数组设置超过数组长度的值的时候， JavaScript 会创建名为 “empty slots” 的东西。它们的值实际上是 <code>undefined</code>。你会看到以下场景：</p><p><code>[1, 2, 3, 7 x empty, 11]</code></p><p>这取决于你的运行环境（每个浏览器，以及 node 环境，都有可能不同）</p></p></details><hr><h6 id="38-输出是什么？"><a href="#38-输出是什么？" class="headerlink" title="38. 输出是什么？"></a>38. 输出是什么？</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> x, y</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>()</span><br><span class="line">  &#125; <span class="keyword">catch</span> (x) &#123;</span><br><span class="line">    (x = <span class="number">1</span>), (y = <span class="number">2</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(x)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(x)</span><br><span class="line">  <span class="built_in">console</span>.log(y)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><ul><li>A: <code>1</code> <code>undefined</code> <code>2</code></li><li>B: <code>undefined</code> <code>undefined</code> <code>undefined</code></li><li>C: <code>1</code> <code>1</code> <code>2</code></li><li>D: <code>1</code> <code>undefined</code> <code>undefined</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-A-12"><a href="#答案-A-12" class="headerlink" title="答案: A"></a>答案: A</h4><p><code>catch</code> 代码块接收参数 <code>x</code>。当我们传递参数时，这与之前定义的变量 <code>x</code> 不同 。这个 <code>x</code> 是属于 <code>catch</code> 块级作用域的。</p><p>然后，我们将块级作用域中的变量赋值为 <code>1</code>，同时也设置了变量 <code>y</code> 的值。现在，我们打印块级作用域中的变量 <code>x</code>，值为 <code>1</code>。</p><p><code>catch</code> 块之外的变量 <code>x</code> 的值仍为 <code>undefined</code>， <code>y</code> 的值为 <code>2</code>。当我们在 <code>catch</code> 块之外执行 <code>console.log(x)</code> 时，返回 <code>undefined</code>，<code>y</code> 返回 <code>2</code>。</p></p></details><hr><h6 id="39-JavaScript-中的一切都是？"><a href="#39-JavaScript-中的一切都是？" class="headerlink" title="39. JavaScript 中的一切都是？"></a>39. JavaScript 中的一切都是？</h6><ul><li>A: 基本类型与对象</li><li>B: 函数与对象</li><li>C: 只有对象</li><li>D: 数字与对象</li><li><details><summary><b>答案</b></summary><p></li></ul><h4 id="答案-A-13"><a href="#答案-A-13" class="headerlink" title="答案: A"></a>答案: A</h4><p>JavaScript 只有基本类型和对象。</p><p>基本类型包括 <code>boolean</code>, <code>null</code>, <code>undefined</code>, <code>bigint</code>, <code>number</code>, <code>string</code>, <code>symbol</code>。</p></p></details><hr><h6 id="40-输出是什么？"><a href="#40-输出是什么？" class="headerlink" title="40. 输出是什么？"></a>40. 输出是什么？</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">3</span>]].reduce(</span><br><span class="line">  (acc, cur) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> acc.concat(cur)</span><br><span class="line">  &#125;,</span><br><span class="line">  [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li>A: <code>[0, 1, 2, 3, 1, 2]</code></li><li>B: <code>[6, 1, 2]</code></li><li>C: <code>[1, 2, 0, 1, 2, 3]</code></li><li>D: <code>[1, 2, 6]</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-C-12"><a href="#答案-C-12" class="headerlink" title="答案: C"></a>答案: C</h4><p><code>[1, 2]</code>是初始值。初始值将会作为首次调用时第一个参数 <code>acc</code> 的值。在第一次执行时， <code>acc</code> 的值是 <code>[1, 2]</code>， <code>cur</code> 的值是 <code>[0, 1]</code>。合并它们，结果为 <code>[1, 2, 0, 1]</code>。<br>第二次执行， <code>acc</code> 的值是 <code>[1, 2, 0, 1]</code>， <code>cur</code> 的值是 <code>[2, 3]</code>。合并它们，最终结果为 <code>[1, 2, 0, 1, 2, 3]</code></p></p></details><hr><h6 id="41-输出是什么？"><a href="#41-输出是什么？" class="headerlink" title="41. 输出是什么？"></a>41. 输出是什么？</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">!!<span class="literal">null</span></span><br><span class="line">!!<span class="string">&#x27;&#x27;</span></span><br><span class="line">!!<span class="number">1</span></span><br></pre></td></tr></table></figure><ul><li>A: <code>false</code> <code>true</code> <code>false</code></li><li>B: <code>false</code> <code>false</code> <code>true</code></li><li>C: <code>false</code> <code>true</code> <code>true</code></li><li>D: <code>true</code> <code>true</code> <code>false</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-B-9"><a href="#答案-B-9" class="headerlink" title="答案: B"></a>答案: B</h4><p><code>null</code> 是 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Falsy">falsy</a>。 <code>!null</code> 的值是 <code>true</code>。 <code>!true</code> 的值是 <code>false</code>。</p><p><code>&quot;&quot;</code> 是 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Falsy">falsy</a>。 <code>!&quot;&quot;</code> 的值是 <code>true</code>。  <code>!true</code> 的值是 <code>false</code>。</p><p><code>1</code> 是 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Truthy">truthy</a>。 <code>!1</code> 的值是 <code>false</code>。 <code>!false</code> 的值是 <code>true</code>。</p></p></details><hr><h6 id="42-setInterval-方法的返回值是什么？"><a href="#42-setInterval-方法的返回值是什么？" class="headerlink" title="42. setInterval 方法的返回值是什么？"></a>42. <code>setInterval</code> 方法的返回值是什么？</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;Hi&#x27;</span>), <span class="number">1000</span>)</span><br></pre></td></tr></table></figure><ul><li>A: 一个唯一的id</li><li>B: 该方法指定的毫秒数</li><li>C: 传递的函数</li><li>D: <code>undefined</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-A-14"><a href="#答案-A-14" class="headerlink" title="答案: A"></a>答案: A</h4><p><code>setInterval</code> 返回一个唯一的 id。此 id 可被用于 <code>clearInterval</code> 函数来取消定时。</p></p></details><hr><h6 id="43-输出是什么？"><a href="#43-输出是什么？" class="headerlink" title="43. 输出是什么？"></a>43. 输出是什么？</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[...<span class="string">&#x27;Lydia&#x27;</span>]</span><br></pre></td></tr></table></figure><ul><li>A: <code>[&quot;L&quot;, &quot;y&quot;, &quot;d&quot;, &quot;i&quot;, &quot;a&quot;]</code></li><li>B: <code>[&quot;Lydia&quot;]</code></li><li>C: <code>[[], &quot;Lydia&quot;]</code></li><li>D: <code>[[&quot;L&quot;, &quot;y&quot;, &quot;d&quot;, &quot;i&quot;, &quot;a&quot;]]</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-A-15"><a href="#答案-A-15" class="headerlink" title="答案: A"></a>答案: A</h4><p>string 类型是可迭代的。扩展运算符将迭代的每个字符映射成一个元素。</p></p></details><hr><h6 id="44-输出是什么"><a href="#44-输出是什么" class="headerlink" title="44. 输出是什么?"></a>44. 输出是什么?</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generator</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> i;</span><br><span class="line">  <span class="keyword">yield</span> i * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> gen = generator(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(gen.next().value);</span><br><span class="line"><span class="built_in">console</span>.log(gen.next().value);</span><br></pre></td></tr></table></figure><ul><li>A: <code>[0, 10], [10, 20]</code></li><li>B: <code>20, 20</code></li><li>C: <code>10, 20</code></li><li>D: <code>0, 10 and 10, 20</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-C-13"><a href="#答案-C-13" class="headerlink" title="答案: C"></a>答案: C</h4><p>一般的函数在执行之后是不能中途停下的。但是，生成器函数却可以中途“停下”，之后可以再从停下的地方继续。当生成器遇到<code>yield</code>关键字的时候，会生成<code>yield</code>后面的值。注意，生成器在这种情况下不 <em>返回</em> (<em>return</em> )值，而是 <em>生成</em> (<em>yield</em>)值。</p><p>首先，我们用<code>10</code>作为参数<code>i</code>来初始化生成器函数。然后使用<code>next()</code>方法一步步执行生成器。第一次执行生成器的时候，<code>i</code>的值为<code>10</code>，遇到第一个<code>yield</code>关键字，它要生成<code>i</code>的值。此时，生成器“暂停”，生成了<code>10</code>。</p><p>然后，我们再执行<code>next()</code>方法。生成器会从刚才暂停的地方继续，这个时候<code>i</code>还是<code>10</code>。于是我们走到了第二个<code>yield</code>关键字处，这时候需要生成的值是<code>i*2</code>，<code>i</code>为<code>10</code>，那么此时生成的值便是<code>20</code>。所以这道题的最终结果是<code>10,20</code>。</p></p></details><h6 id="45-返回值是什么"><a href="#45-返回值是什么" class="headerlink" title="45. 返回值是什么?"></a>45. 返回值是什么?</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> firstPromise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">res, rej</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(res, <span class="number">500</span>, <span class="string">&quot;one&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> secondPromise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">res, rej</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(res, <span class="number">100</span>, <span class="string">&quot;two&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.race([firstPromise, secondPromise]).then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res));</span><br></pre></td></tr></table></figure><ul><li>A: <code>&quot;one&quot;</code></li><li>B: <code>&quot;two&quot;</code></li><li>C: <code>&quot;two&quot; &quot;one&quot;</code></li><li>D: <code>&quot;one&quot; &quot;two&quot;</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-B-10"><a href="#答案-B-10" class="headerlink" title="答案: B"></a>答案: B</h4><p>当我们向<code>Promise.race</code>方法中传入多个<code>Promise</code>时，会进行 <em>优先</em> 解析。在这个例子中，我们用<code>setTimeout</code>给<code>firstPromise</code>和<code>secondPromise</code>分别设定了500ms和100ms的定时器。这意味着<code>secondPromise</code>会首先解析出字符串<code>two</code>。那么此时<code>res</code>参数即为<code>two</code>，是为输出结果。</p></p></details><hr><h6 id="46-输出是什么"><a href="#46-输出是什么" class="headerlink" title="46. 输出是什么?"></a>46. 输出是什么?</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123; <span class="attr">name</span>: <span class="string">&quot;Lydia&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> members = [person];</span><br><span class="line">person = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(members);</span><br></pre></td></tr></table></figure><ul><li>A: <code>null</code></li><li>B: <code>[null]</code></li><li>C: <code>[&#123;&#125;]</code></li><li>D: <code>[&#123; name: &quot;Lydia&quot; &#125;]</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-D-4"><a href="#答案-D-4" class="headerlink" title="答案: D"></a>答案: D</h4><p>首先我们声明了一个拥有<code>name</code>属性的对象 <code>person</code>。</p><img src= "/img/loading.gif" data-lazy-src="https://i.imgur.com/TML1MbS.png" width="200"><p>然后我们又声明了一个变量<code>members</code>. 将首个元素赋值为变量<code>person</code>。 当设置两个对象彼此相等时，它们会通过 <em>引用</em> 进行交互。但是当你将引用从一个变量分配至另一个变量时，其实只是执行了一个 <em>复制</em> 操作。（注意一点，他们的引用 <em>并不相同</em>!）</p><img src= "/img/loading.gif" data-lazy-src="https://i.imgur.com/FSG5K3F.png" width="300"><p>接下来我们让<code>person</code>等于<code>null</code>。</p><img src= "/img/loading.gif" data-lazy-src="https://i.imgur.com/sYjcsMT.png" width="300"><p>我们没有修改数组第一个元素的值，而只是修改了变量<code>person</code>的值,因为元素（复制而来）的引用与<code>person</code>不同。<code>members</code>的第一个元素仍然保持着对原始对象的引用。当我们输出<code>members</code>数组时，第一个元素会将引用的对象打印出来。</p></p></details><hr><h6 id="47-输出是什么"><a href="#47-输出是什么" class="headerlink" title="47. 输出是什么?"></a>47. 输出是什么?</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  name: <span class="string">&quot;Lydia&quot;</span>,</span><br><span class="line">  age: <span class="number">21</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">in</span> person) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>A: <code>&#123; name: &quot;Lydia&quot; &#125;, &#123; age: 21 &#125;</code></li><li>B: <code>&quot;name&quot;, &quot;age&quot;</code></li><li>C: <code>&quot;Lydia&quot;, 21</code></li><li>D: <code>[&quot;name&quot;, &quot;Lydia&quot;], [&quot;age&quot;, 21]</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-B-11"><a href="#答案-B-11" class="headerlink" title="答案: B"></a>答案: B</h4><p>在<code>for-in</code>循环中,我们可以通过对象的key来进行迭代,也就是这里的<code>name</code>和<code>age</code>。在底层，对象的key都是字符串（如果他们不是Symbol的话）。在每次循环中，我们将<code>item</code>设定为当前遍历到的key.所以一开始，<code>item</code>是<code>name</code>，之后 <code>item</code>输出的则是<code>age</code>。</p></p></details><hr><h6 id="48-输出是什么"><a href="#48-输出是什么" class="headerlink" title="48. 输出是什么?"></a>48. 输出是什么?</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span> + <span class="number">4</span> + <span class="string">&quot;5&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li>A: <code>&quot;345&quot;</code></li><li>B: <code>&quot;75&quot;</code></li><li>C: <code>12</code></li><li>D: <code>&quot;12&quot;</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-B-12"><a href="#答案-B-12" class="headerlink" title="答案: B"></a>答案: B</h4><p>当所有运算符的 <em>优先级</em> 相同时，计算表达式需要确定运算符的结合顺序，即从右到左还是从左往右。在这个例子中，我们只有一类运算符<code>+</code>，对于加法来说，结合顺序就是从左到右。</p><p><code>3 + 4</code>首先计算，得到数字<code>7</code>.</p><p>由于类型的强制转换，<code>7 + &#39;5&#39;</code>的结果是<code>&quot;75&quot;</code>. JavaScript将<code>7</code>转换成了字符串，可以参考问题15.我们可以用<code>+</code>号把两个字符串连接起来。 <code>&quot;7&quot; + &quot;5&quot;</code> 就得到了<code>&quot;75&quot;</code>.</p></p></details><hr><h6 id="49-num的值是什么"><a href="#49-num的值是什么" class="headerlink" title="49. num的值是什么?"></a>49. <code>num</code>的值是什么?</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> num = <span class="built_in">parseInt</span>(<span class="string">&quot;7*6&quot;</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure><ul><li>A: <code>42</code></li><li>B: <code>&quot;42&quot;</code></li><li>C: <code>7</code></li><li>D: <code>NaN</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-C-14"><a href="#答案-C-14" class="headerlink" title="答案: C"></a>答案: C</h4><p>只返回了字符串中第一个字母. 设定了 <em>进制</em> 后 (也就是第二个参数，指定需要解析的数字是什么进制: 十进制、十六机制、八进制、二进制等等……),<code>parseInt</code> 检查字符串中的字符是否合法. 一旦遇到一个在指定进制中不合法的字符后，立即停止解析并且忽略后面所有的字符。</p><p><code>*</code>就是不合法的数字字符。所以只解析到<code>&quot;7&quot;</code>，并将其解析为十进制的<code>7</code>. <code>num</code>的值即为<code>7</code>.</p></p></details><hr><h6 id="50-输出是什么"><a href="#50-输出是什么" class="headerlink" title="50. 输出是什么?"></a>50. 输出是什么?</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map(<span class="function"><span class="params">num</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> num === <span class="string">&quot;number&quot;</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">return</span> num * <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>A: <code>[]</code></li><li>B: <code>[null, null, null]</code></li><li>C: <code>[undefined, undefined, undefined]</code></li><li>D: <code>[ 3 x empty ]</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-C-15"><a href="#答案-C-15" class="headerlink" title="答案: C"></a>答案: C</h4><p>对数组进行映射的时候,<code>num</code>就是当前循环到的元素. 在这个例子中，所有的映射都是number类型，所以if中的判断<code>typeof num === &quot;number&quot;</code>结果都是<code>true</code>.map函数创建了新数组并且将函数的返回值插入数组。</p><p>但是，没有任何值返回。当函数没有返回任何值时，即默认返回<code>undefined</code>.对数组中的每一个元素来说，函数块都得到了这个返回值，所以结果中每一个元素都是<code>undefined</code>.</p></p></details><hr><h6 id="51-输出的是什么"><a href="#51-输出的是什么" class="headerlink" title="51. 输出的是什么?"></a>51. 输出的是什么?</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getInfo</span>(<span class="params">member, year</span>) </span>&#123;</span><br><span class="line">  member.name = <span class="string">&quot;Lydia&quot;</span>;</span><br><span class="line">  year = <span class="string">&quot;1998&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = &#123; <span class="attr">name</span>: <span class="string">&quot;Sarah&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> birthYear = <span class="string">&quot;1997&quot;</span>;</span><br><span class="line"></span><br><span class="line">getInfo(person, birthYear);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person, birthYear);</span><br></pre></td></tr></table></figure><ul><li>A: <code>&#123; name: &quot;Lydia&quot; &#125;, &quot;1997&quot;</code></li><li>B: <code>&#123; name: &quot;Sarah&quot; &#125;, &quot;1998&quot;</code></li><li>C: <code>&#123; name: &quot;Lydia&quot; &#125;, &quot;1998&quot;</code></li><li>D: <code>&#123; name: &quot;Sarah&quot; &#125;, &quot;1997&quot;</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-A-16"><a href="#答案-A-16" class="headerlink" title="答案: A"></a>答案: A</h4><p>普通参数都是 <em>值</em> 传递的，而对象则不同，是 <em>引用</em> 传递。所以说，<code>birthYear</code>是值传递，因为他是个字符串而不是对象。当我们对参数进行值传递时，会创建一份该值的 <em>复制</em> 。（可以参考问题46）</p><p>变量<code>birthYear</code>有一个对<code>&quot;1997&quot;</code>的引用，而传入的参数也有一个对<code>&quot;1997&quot;</code>的引用，但二者的引用并不相同。当我们通过给 <code>year</code>赋值<code>&quot;1998&quot;</code>来更新<code>year</code>的值的时候我们只是更新了<code>year</code>（的引用）。此时<code>birthYear</code>仍然是<code>&quot;1997&quot;</code>.</p><p>而<code>person</code>是个对象。参数<code>member</code>引用与之 <em>相同的</em> 对象。当我们修改<code>member</code>所引用对象的属性时,<code>person</code>的相应属性也被修改了,因为他们引用了相同的对象. <code>person</code>的 <code>name</code>属性也变成了 <code>&quot;Lydia&quot;</code>.</p></p></details><hr><h6 id="52-输出是什么"><a href="#52-输出是什么" class="headerlink" title="52. 输出是什么?"></a>52. 输出是什么?</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greeting</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="string">&quot;Hello world!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> data = greeting();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;It worked!&quot;</span>, data);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Oh no an error:&quot;</span>, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sayHi();</span><br></pre></td></tr></table></figure><ul><li>A: <code>&quot;It worked! Hello world!&quot;</code></li><li>B: <code>&quot;Oh no an error: undefined</code></li><li>C: <code>SyntaxError: can only throw Error objects</code></li><li>D: <code>&quot;Oh no an error: Hello world!</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-D-5"><a href="#答案-D-5" class="headerlink" title="答案: D"></a>答案: D</h4><p>通过<code>throw</code>语句，我么可以创建自定义错误。 而通过它，我们可以抛出异常。异常可以是一个<b>字符串</b>, 一个 <b>数字</b>, 一个 <b>布尔类型</b> 或者是一个 <b>对象</b>。在本例中，我们的异常是字符串<code>&#39;Hello world&#39;</code>.</p><p>通过 <code>catch</code>语句，我们可以设定当<code>try</code>语句块中抛出异常后应该做什么处理。在本例中抛出的异常是字符串<code>&#39;Hello world&#39;</code>. <code>e</code>就是这个字符串，因此被输出。最终结果就是<code>&#39;Oh an error: Hello world&#39;</code>.</p></p></details><hr><h6 id="53-输出是什么"><a href="#53-输出是什么" class="headerlink" title="53. 输出是什么?"></a>53. 输出是什么?</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Car</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.make = <span class="string">&quot;Lamborghini&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">make</span>: <span class="string">&quot;Maserati&quot;</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myCar = <span class="keyword">new</span> Car();</span><br><span class="line"><span class="built_in">console</span>.log(myCar.make);</span><br></pre></td></tr></table></figure><ul><li>A: <code>&quot;Lamborghini&quot;</code></li><li>B: <code>&quot;Maserati&quot;</code></li><li>C: <code>ReferenceError</code></li><li>D: <code>TypeError</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-B-13"><a href="#答案-B-13" class="headerlink" title="答案: B"></a>答案: B</h4><p>返回属性的时候，属性的值等于 <em>返回的</em> 值，而不是构造函数中设定的值。我们返回了字符串 <code>&quot;Maserati&quot;</code>，所以 <code>myCar.make</code>等于<code>&quot;Maserati&quot;</code>.</p></p></details><hr><h6 id="54-输出是什么"><a href="#54-输出是什么" class="headerlink" title="54. 输出是什么?"></a>54. 输出是什么?</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> x = (y = <span class="number">10</span>);</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> x);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> y);</span><br></pre></td></tr></table></figure><ul><li>A: <code>&quot;undefined&quot;, &quot;number&quot;</code></li><li>B: <code>&quot;number&quot;, &quot;number&quot;</code></li><li>C: <code>&quot;object&quot;, &quot;number&quot;</code></li><li>D: <code>&quot;number&quot;, &quot;undefined&quot;</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-A-17"><a href="#答案-A-17" class="headerlink" title="答案: A"></a>答案: A</h4><p><code>let x = y = 10;</code> 是下面这个表达式的缩写:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">y = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> x = y;</span><br></pre></td></tr></table></figure><p>我们设定<code>y</code>等于<code>10</code>时,我们实际上增加了一个属性<code>y</code>给全局对象(浏览器里的<code>window</code>, Nodejs里的<code>global</code>)。在浏览器中， <code>window.y</code>等于<code>10</code>.</p><p>然后我们声明了变量<code>x</code>等于<code>y</code>,也是<code>10</code>.但变量是使用 <code>let</code>声明的，它只作用于 <em>块级作用域</em>, 仅在声明它的块中有效；就是案例中的立即调用表达式(IIFE)。使用<code>typeof</code>操作符时, 操作值 <code>x</code>没有被定义：因为我们在<code>x</code>声明块的外部，无法调用它。这就意味着<code>x</code>未定义。未分配或是未声明的变量类型为<code>&quot;undefined&quot;</code>. <code>console.log(typeof x)</code>返回<code>&quot;undefined&quot;</code>.</p><p>而我们创建了全局变量<code>y</code>，并且设定<code>y</code>等于<code>10</code>.这个值在我们的代码各处都访问的到。 <code>y</code>已经被定义了，而且有一个<code>&quot;number&quot;</code>类型的值。 <code>console.log(typeof y)</code>返回<code>&quot;number&quot;</code>.</p></p></details><hr><h6 id="55-输出是什么"><a href="#55-输出是什么" class="headerlink" title="55. 输出是什么?"></a><a name=20190629></a>55. 输出是什么?</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Dog.prototype.bark = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Woof I am <span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pet = <span class="keyword">new</span> Dog(<span class="string">&quot;Mara&quot;</span>);</span><br><span class="line"></span><br><span class="line">pet.bark();</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> Dog.prototype.bark;</span><br><span class="line"></span><br><span class="line">pet.bark();</span><br></pre></td></tr></table></figure><ul><li>A: <code>&quot;Woof I am Mara&quot;</code>, <code>TypeError</code></li><li>B: <code>&quot;Woof I am Mara&quot;</code>,<code>&quot;Woof I am Mara&quot;</code></li><li>C: <code>&quot;Woof I am Mara&quot;</code>, <code>undefined</code></li><li>D: <code>TypeError</code>, <code>TypeError</code></li></ul><details><summary><b>答案</b></summary><p><h4 id="答案-A-18"><a href="#答案-A-18" class="headerlink" title="答案: A"></a>答案: A</h4><p>我们可以用<code>delete</code>关键字删除对象的属性，对原型也是适用的。删除了原型的属性后，该属性在原型链上就不可用了。在本例中，函数<code>bark</code>在执行了<code>delete Dog.prototype.bark</code>后不可用, 然而后面的代码还在调用它。</p><p>当我们尝试调用一个不存在的函数时<code>TypeError</code>异常会被抛出。在本例中就是 <code>TypeError: pet.bark is not a function</code>，因为<code>pet.bark</code>是<code>undefined</code>.</p></p></details><hr>]]></content>
      
      
      <categories>
          
          <category> 写给女友 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端全家桶（面试题大整理）</title>
      <link href="posts/vue-family/"/>
      <url>posts/vue-family/</url>
      
        <content type="html"><![CDATA[<h2 id="面试准备——自我介绍"><a href="#面试准备——自我介绍" class="headerlink" title="面试准备——自我介绍"></a>面试准备——自我介绍</h2><h2 id="一面-二面"><a href="#一面-二面" class="headerlink" title="一面 / 二面"></a>一面 / 二面</h2><h3 id="面试技巧"><a href="#面试技巧" class="headerlink" title="面试技巧"></a>面试技巧</h3><ul><li>准备要充分</li><li>知识要系统</li><li>沟通要简洁</li><li>内心要诚实</li><li>态度要谦虚</li><li>回答要灵活</li></ul><h2 id="页面布局"><a href="#页面布局" class="headerlink" title="页面布局"></a>页面布局</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><strong>假设高度已知，请写出三栏布局，其中左、右栏宽度各为300px，中间自适应</strong></p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200402113527886.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><h3 id="五种解决方式代码"><a href="#五种解决方式代码" class="headerlink" title="五种解决方式代码"></a>五种解决方式代码</h3><ul><li>浮动解决方式</li><li>绝对定位解决方式</li><li>flexbox解决方式</li><li>表格布局</li><li>网格布局</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;en&quot;</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;Layout&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        html *&#123;</span><br><span class="line">            padding: <span class="number">0</span>;</span><br><span class="line">            margin: <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        .layout&#123;</span><br><span class="line">            margin-top: 20px;</span><br><span class="line">        &#125;</span><br><span class="line">        .layout article div&#123;</span><br><span class="line">            min-height: 100px;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;!-- 浮动解决方式 --&gt;</span><br><span class="line">    &lt;section <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;layout float&quot;</span>&gt;</span><br><span class="line">        &lt;style&gt;</span><br><span class="line">            .layout.float .left&#123;</span><br><span class="line">                float: left;</span><br><span class="line">                width: 300px;</span><br><span class="line">                background: red;</span><br><span class="line">            &#125;</span><br><span class="line">            .layout.float .right&#123;</span><br><span class="line">                float: right;</span><br><span class="line">                width: 300px;</span><br><span class="line">                background: blue;</span><br><span class="line">            &#125;</span><br><span class="line">            .layout.float .center&#123;</span><br><span class="line">                background: yellow;</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;/style&gt;</span><br><span class="line">        &lt;article <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;left-right-center&quot;</span>&gt;</span><br><span class="line">            &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;left&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">            &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;right&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">            &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;center&quot;</span>&gt;</span><br><span class="line">                &lt;h1&gt;浮动解决方式&lt;/h1&gt;</span><br><span class="line">                <span class="number">1.</span>这是三栏布局的正中间部分</span><br><span class="line">                <span class="number">2.</span>这是三栏布局的正中间部分</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/article&gt;</span><br><span class="line">    &lt;/section&gt;</span><br><span class="line">    &lt;!-- 绝对定位解决方式 --&gt;</span><br><span class="line">    &lt;section <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;layout absolute&quot;</span>&gt;</span><br><span class="line">        &lt;style&gt;</span><br><span class="line">            .layout.absolute .left-center-right&gt;div&#123;</span><br><span class="line">                position: absolute;</span><br><span class="line">            &#125;</span><br><span class="line">            .layout.absolute .left&#123;</span><br><span class="line">                left: <span class="number">0</span>;</span><br><span class="line">                width: 300px;</span><br><span class="line">                background: red;</span><br><span class="line">            &#125;</span><br><span class="line">            .layout.absolute .center&#123;</span><br><span class="line">                left: 300px;</span><br><span class="line">                right: 300px;</span><br><span class="line">                background: yellow;</span><br><span class="line">            &#125;</span><br><span class="line">            .layout.absolute .right&#123;</span><br><span class="line">                right: <span class="number">0</span>;</span><br><span class="line">                width: 300px;</span><br><span class="line">                background: blue;</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;/style&gt;</span><br><span class="line">        &lt;article <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;left-center-right&quot;</span>&gt;</span><br><span class="line">            &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;left&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">            &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;center&quot;</span>&gt;</span><br><span class="line">                &lt;h1&gt;绝对定位解决方式&lt;/h1&gt;</span><br><span class="line">                <span class="number">1.</span>这是三栏布局的正中间部分</span><br><span class="line">                <span class="number">2.</span>这是三栏布局的正中间部分</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;right&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">        &lt;/article&gt;</span><br><span class="line">    &lt;/section&gt;</span><br><span class="line">    &lt;!-- flexbox解决方式 --&gt;</span><br><span class="line">    &lt;section <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;layout flexbox&quot;</span>&gt;</span><br><span class="line">        &lt;style&gt;</span><br><span class="line">            .layout.flexbox&#123;</span><br><span class="line">                margin-top: 140px;</span><br><span class="line">            &#125;</span><br><span class="line">            .layout.flexbox .left-center-right&#123;</span><br><span class="line">                display: flex;</span><br><span class="line">            &#125;</span><br><span class="line">            .layout.flexbox .left&#123;</span><br><span class="line">                width: 300px;</span><br><span class="line">                background: red;</span><br><span class="line">            &#125;</span><br><span class="line">            .layout.flexbox .center&#123;</span><br><span class="line">                flex: <span class="number">1</span>;</span><br><span class="line">                background: yellow;</span><br><span class="line">            &#125;</span><br><span class="line">            .layout.flexbox .right&#123;</span><br><span class="line">                width: 300px;</span><br><span class="line">                background: blue;</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;/style&gt;</span><br><span class="line">        &lt;article <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;left-center-right&quot;</span>&gt;</span><br><span class="line">            &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;left&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">            &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;center&quot;</span>&gt;</span><br><span class="line">                &lt;h1&gt;flexbox解决方式&lt;/h1&gt;</span><br><span class="line">                <span class="number">1.</span>这是三栏布局的正中间部分</span><br><span class="line">                <span class="number">2.</span>这是三栏布局的正中间部分</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;right&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">        &lt;/article&gt;</span><br><span class="line">    &lt;/section&gt;</span><br><span class="line">    &lt;!-- 表格布局 --&gt;</span><br><span class="line">    &lt;section <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;layout table&quot;</span>&gt;</span><br><span class="line">        &lt;style&gt;</span><br><span class="line">            .layout.table .left-center-right&#123;</span><br><span class="line">                width: <span class="number">100</span>%;</span><br><span class="line">                display: table;</span><br><span class="line">                height: 100px;</span><br><span class="line">            &#125;</span><br><span class="line">            .layout.table .left-center-right&gt;div&#123;</span><br><span class="line">                display: table-cell;</span><br><span class="line">            &#125;</span><br><span class="line">            .layout.table .left&#123;</span><br><span class="line">                width: 300px;</span><br><span class="line">                background: red;</span><br><span class="line">            &#125;</span><br><span class="line">            .layout.table .center&#123;</span><br><span class="line">                background: yellow;</span><br><span class="line">            &#125;</span><br><span class="line">            .layout.table .right&#123;</span><br><span class="line">                width: 300px;</span><br><span class="line">                background: blue;</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;/style&gt;</span><br><span class="line">        &lt;article <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;left-center-right&quot;</span>&gt;</span><br><span class="line">            &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;left&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">            &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;center&quot;</span>&gt;</span><br><span class="line">                &lt;h1&gt;表格解决方式&lt;/h1&gt;</span><br><span class="line">                <span class="number">1.</span>这是三栏布局的正中间部分</span><br><span class="line">                <span class="number">2.</span>这是三栏布局的正中间部分</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;right&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">        &lt;/article&gt;</span><br><span class="line">    &lt;/section&gt;</span><br><span class="line">    &lt;!-- 网格布局 --&gt;</span><br><span class="line">    &lt;section <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;layout grid&quot;</span>&gt;</span><br><span class="line">        &lt;style&gt;</span><br><span class="line">            .layout.grid .left-center-right&#123;</span><br><span class="line">                display: grid;</span><br><span class="line">                width: <span class="number">100</span>%;</span><br><span class="line">                grid-template-rows: 100px;</span><br><span class="line">                grid-template-columns: 300px auto 300px;</span><br><span class="line">            &#125;</span><br><span class="line">            .layout.grid .left&#123;</span><br><span class="line">                background: red;</span><br><span class="line">            &#125;</span><br><span class="line">            .layout.grid .center&#123;</span><br><span class="line">                background: yellow;</span><br><span class="line">            &#125;</span><br><span class="line">            .layout.grid .right&#123;</span><br><span class="line">                background: blue;</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;/style&gt;</span><br><span class="line">        &lt;article <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;left-center-right&quot;</span>&gt;</span><br><span class="line">            &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;left&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">            &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;center&quot;</span>&gt;</span><br><span class="line">                &lt;h1&gt;网格解决方式&lt;/h1&gt;</span><br><span class="line">                <span class="number">1.</span>这是三栏布局的正中间部分</span><br><span class="line">                <span class="number">2.</span>这是三栏布局的正中间部分</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;right&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">        &lt;/article&gt;</span><br><span class="line">    &lt;/section&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h3 id="展示效果"><a href="#展示效果" class="headerlink" title="展示效果"></a>展示效果</h3><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200402134031526.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><h3 id="知识拓展"><a href="#知识拓展" class="headerlink" title="知识拓展"></a>知识拓展</h3><p>上述5中解决方式是比较常见的，但是我们<code>不能只局限于为了问答而问答，我们应该从此基础上升华一下问题。</code></p><p>答完了这5种常见方式，并不代表我们页面布局这一话题就结束了，面试官可能还会延伸我们的问题，比如：</p><ul><li>这5种布局方式各自有什么优点和缺点？</li><li>如果<code>高度已知</code>条件去掉，考虑纵向，那么对于中间内容过多，导致中间格子撑开，此时需要左右跟着撑开，以上5种方式哪几种还能使用？</li><li>这5中方式的兼容性如何？如果让你选择一种最优的去应用于业务，你会选择哪种方式？</li></ul><p>那么，接下来就来围绕这三个问题来讲解：</p><h3 id="1、各自的优缺点"><a href="#1、各自的优缺点" class="headerlink" title="1、各自的优缺点"></a>1、各自的优缺点</h3><p><strong>① 对于浮动：</strong></p><p><strong>优点</strong></p><p>兼容性比较好，把清除浮动和其它浮动周边元素的关系处理好的话，那么它的兼容性是挺不错的。</p><p><strong>缺点</strong></p><p>设置浮动之后，脱离了文档流，处理不好的话，会带来很多问题，这是它本身的局限性。</p><p><strong>② 对于绝对定位：</strong></p><p><strong>优点</strong></p><p>快捷，不容易出问题</p><p><strong>缺点</strong></p><p>本身脱离了文档流，就会导致子元素跟着脱离文档流。因此，导致绝对定位的<code>有效性</code>、<code>可使用性</code>比较差。</p><p><strong>③ 对于flexbox</strong></p><p>css3中推出的flex布局，就是为了解决上述两种方式不足而出现的，算是比较完美的一种方式，尤其是对于移动端</p><p><strong>④ 对于表格布局</strong></p><p><strong>优点</strong></p><p>尽管多数人吐槽表格布局，但其实，表格布局在很多场景都适用的。比如上文写的三栏布局设计当中，表格布局是不是很轻松就实现了呢？</p><p>同时，表格布局的兼容性是非常好的，当用<code>flex</code>解决不了问题的时候，对于PC端  <code>IE8</code>是不支持<code>flex</code>的，此时就可以尝试表格布局</p><p><strong>缺点</strong></p><p>除开历史上一些诟病外，还有一个：</p><p>比如我们把三栏理解成为三个小单元格，那么当其中某一个单元格高度超出的时候，其余两侧也会跟着调整，于是对于有些场景是不合适的。因此，对于不同场景，我们可以在<code>flex</code>和<code>表格</code>布局进行选优操作</p><p><strong>⑤ 对于网格布局</strong></p><p>这一块的话，算是新热点，也是经历了一段时间的演变，从上文代码来看的话，通过网格布局我们能让代码更加简单、方便实现逻辑。在面试的时候提到也可以说明你比较关注新的事物，主动学习能力不错。</p><hr/><p>当然，以上表述有部分个人思考，也有现常说的优缺点，读者可以根据研究布局方式进行深入思考，学习更多的使用场景以及优缺点，其次，欢迎提出新的解决方案及相关知识点，后续进行补充。</p><h3 id="2、去掉高度，有哪几种布局可以使用？"><a href="#2、去掉高度，有哪几种布局可以使用？" class="headerlink" title="2、去掉高度，有哪几种布局可以使用？"></a>2、去掉高度，有哪几种布局可以使用？</h3><p>这里，我们就采用增加高度方式来看看，还有哪些布局能使用。（中间区域增加几个p标签）</p><p><strong>源代码</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;en&quot;</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;Layout&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        html *&#123;</span><br><span class="line">            padding: <span class="number">0</span>;</span><br><span class="line">            margin: <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        .layout&#123;</span><br><span class="line">            margin-top: 20px;</span><br><span class="line">        &#125;</span><br><span class="line">        .layout article div&#123;</span><br><span class="line">            min-height: 100px;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;!-- 浮动解决方式 --&gt;</span><br><span class="line">    &lt;section <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;layout float&quot;</span>&gt;</span><br><span class="line">        &lt;style&gt;</span><br><span class="line">            .layout.float .left&#123;</span><br><span class="line">                float: left;</span><br><span class="line">                width: 300px;</span><br><span class="line">                background: red;</span><br><span class="line">            &#125;</span><br><span class="line">            .layout.float .right&#123;</span><br><span class="line">                float: right;</span><br><span class="line">                width: 300px;</span><br><span class="line">                background: blue;</span><br><span class="line">            &#125;</span><br><span class="line">            .layout.float .center&#123;</span><br><span class="line">                background: yellow;</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;/style&gt;</span><br><span class="line">        &lt;article <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;left-right-center&quot;</span>&gt;</span><br><span class="line">            &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;left&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">            &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;right&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">            &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;center&quot;</span>&gt;</span><br><span class="line">                &lt;h1&gt;浮动解决方式&lt;/h1&gt;</span><br><span class="line">                <span class="number">1.</span>这是三栏布局的正中间部分</span><br><span class="line">                <span class="number">2.</span>这是三栏布局的正中间部分</span><br><span class="line">                &lt;p&gt;增加高度&lt;/p&gt;</span><br><span class="line">                &lt;p&gt;增加高度&lt;/p&gt;</span><br><span class="line">                &lt;p&gt;增加高度&lt;/p&gt;</span><br><span class="line">                &lt;p&gt;增加高度&lt;/p&gt;</span><br><span class="line">                &lt;p&gt;增加高度&lt;/p&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/article&gt;</span><br><span class="line">    &lt;/section&gt;</span><br><span class="line">    &lt;!-- 绝对定位解决方式 --&gt;</span><br><span class="line">    &lt;section <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;layout absolute&quot;</span>&gt;</span><br><span class="line">        &lt;style&gt;</span><br><span class="line">            .layout.absolute .left-center-right&gt;div&#123;</span><br><span class="line">                position: absolute;</span><br><span class="line">            &#125;</span><br><span class="line">            .layout.absolute .left&#123;</span><br><span class="line">                left: <span class="number">0</span>;</span><br><span class="line">                width: 300px;</span><br><span class="line">                background: red;</span><br><span class="line">            &#125;</span><br><span class="line">            .layout.absolute .center&#123;</span><br><span class="line">                left: 300px;</span><br><span class="line">                right: 300px;</span><br><span class="line">                background: yellow;</span><br><span class="line">            &#125;</span><br><span class="line">            .layout.absolute .right&#123;</span><br><span class="line">                right: <span class="number">0</span>;</span><br><span class="line">                width: 300px;</span><br><span class="line">                background: blue;</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;/style&gt;</span><br><span class="line">        &lt;article <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;left-center-right&quot;</span>&gt;</span><br><span class="line">            &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;left&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">            &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;center&quot;</span>&gt;</span><br><span class="line">                &lt;h1&gt;绝对定位解决方式&lt;/h1&gt;</span><br><span class="line">                <span class="number">1.</span>这是三栏布局的正中间部分</span><br><span class="line">                <span class="number">2.</span>这是三栏布局的正中间部分</span><br><span class="line">                &lt;p&gt;增加高度&lt;/p&gt;</span><br><span class="line">                &lt;p&gt;增加高度&lt;/p&gt;</span><br><span class="line">                &lt;p&gt;增加高度&lt;/p&gt;</span><br><span class="line">                &lt;p&gt;增加高度&lt;/p&gt;</span><br><span class="line">                &lt;p&gt;增加高度&lt;/p&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;right&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">        &lt;/article&gt;</span><br><span class="line">    &lt;/section&gt;</span><br><span class="line">    &lt;!-- flexbox解决方式 --&gt;</span><br><span class="line">    &lt;section <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;layout flexbox&quot;</span>&gt;</span><br><span class="line">        &lt;style&gt;</span><br><span class="line">            .layout.flexbox&#123;</span><br><span class="line">                margin-top: 140px;</span><br><span class="line">            &#125;</span><br><span class="line">            .layout.flexbox .left-center-right&#123;</span><br><span class="line">                display: flex;</span><br><span class="line">            &#125;</span><br><span class="line">            .layout.flexbox .left&#123;</span><br><span class="line">                width: 300px;</span><br><span class="line">                background: red;</span><br><span class="line">            &#125;</span><br><span class="line">            .layout.flexbox .center&#123;</span><br><span class="line">                flex: <span class="number">1</span>;</span><br><span class="line">                background: yellow;</span><br><span class="line">            &#125;</span><br><span class="line">            .layout.flexbox .right&#123;</span><br><span class="line">                width: 300px;</span><br><span class="line">                background: blue;</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;/style&gt;</span><br><span class="line">        &lt;article <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;left-center-right&quot;</span>&gt;</span><br><span class="line">            &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;left&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">            &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;center&quot;</span>&gt;</span><br><span class="line">                &lt;h1&gt;flexbox解决方式&lt;/h1&gt;</span><br><span class="line">                <span class="number">1.</span>这是三栏布局的正中间部分</span><br><span class="line">                <span class="number">2.</span>这是三栏布局的正中间部分</span><br><span class="line">                &lt;p&gt;增加高度&lt;/p&gt;</span><br><span class="line">                &lt;p&gt;增加高度&lt;/p&gt;</span><br><span class="line">                &lt;p&gt;增加高度&lt;/p&gt;</span><br><span class="line">                &lt;p&gt;增加高度&lt;/p&gt;</span><br><span class="line">                &lt;p&gt;增加高度&lt;/p&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;right&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">        &lt;/article&gt;</span><br><span class="line">    &lt;/section&gt;</span><br><span class="line">    &lt;!-- 表格布局 --&gt;</span><br><span class="line">    &lt;section <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;layout table&quot;</span>&gt;</span><br><span class="line">        &lt;style&gt;</span><br><span class="line">            .layout.table .left-center-right&#123;</span><br><span class="line">                width: <span class="number">100</span>%;</span><br><span class="line">                display: table;</span><br><span class="line">                height: 100px;</span><br><span class="line">            &#125;</span><br><span class="line">            .layout.table .left-center-right&gt;div&#123;</span><br><span class="line">                display: table-cell;</span><br><span class="line">            &#125;</span><br><span class="line">            .layout.table .left&#123;</span><br><span class="line">                width: 300px;</span><br><span class="line">                background: red;</span><br><span class="line">            &#125;</span><br><span class="line">            .layout.table .center&#123;</span><br><span class="line">                background: yellow;</span><br><span class="line">            &#125;</span><br><span class="line">            .layout.table .right&#123;</span><br><span class="line">                width: 300px;</span><br><span class="line">                background: blue;</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;/style&gt;</span><br><span class="line">        &lt;article <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;left-center-right&quot;</span>&gt;</span><br><span class="line">            &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;left&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">            &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;center&quot;</span>&gt;</span><br><span class="line">                &lt;h1&gt;表格解决方式&lt;/h1&gt;</span><br><span class="line">                <span class="number">1.</span>这是三栏布局的正中间部分</span><br><span class="line">                <span class="number">2.</span>这是三栏布局的正中间部分</span><br><span class="line">                &lt;p&gt;增加高度&lt;/p&gt;</span><br><span class="line">                &lt;p&gt;增加高度&lt;/p&gt;</span><br><span class="line">                &lt;p&gt;增加高度&lt;/p&gt;</span><br><span class="line">                &lt;p&gt;增加高度&lt;/p&gt;</span><br><span class="line">                &lt;p&gt;增加高度&lt;/p&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;right&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">        &lt;/article&gt;</span><br><span class="line">    &lt;/section&gt;</span><br><span class="line">    &lt;!-- 网格布局 --&gt;</span><br><span class="line">    &lt;section <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;layout grid&quot;</span>&gt;</span><br><span class="line">        &lt;style&gt;</span><br><span class="line">            .layout.grid .left-center-right&#123;</span><br><span class="line">                display: grid;</span><br><span class="line">                width: <span class="number">100</span>%;</span><br><span class="line">                grid-template-rows: 100px;</span><br><span class="line">                grid-template-columns: 300px auto 300px;</span><br><span class="line">            &#125;</span><br><span class="line">            .layout.grid .left&#123;</span><br><span class="line">                background: red;</span><br><span class="line">            &#125;</span><br><span class="line">            .layout.grid .center&#123;</span><br><span class="line">                background: yellow;</span><br><span class="line">            &#125;</span><br><span class="line">            .layout.grid .right&#123;</span><br><span class="line">                background: blue;</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;/style&gt;</span><br><span class="line">        &lt;article <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;left-center-right&quot;</span>&gt;</span><br><span class="line">            &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;left&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">            &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;center&quot;</span>&gt;</span><br><span class="line">                &lt;h1&gt;网格解决方式&lt;/h1&gt;</span><br><span class="line">                <span class="number">1.</span>这是三栏布局的正中间部分</span><br><span class="line">                <span class="number">2.</span>这是三栏布局的正中间部分</span><br><span class="line">                &lt;p&gt;增加高度&lt;/p&gt;</span><br><span class="line">                &lt;p&gt;增加高度&lt;/p&gt;</span><br><span class="line">                &lt;p&gt;增加高度&lt;/p&gt;</span><br><span class="line">                &lt;p&gt;增加高度&lt;/p&gt;</span><br><span class="line">                &lt;p&gt;增加高度&lt;/p&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;right&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">        &lt;/article&gt;</span><br><span class="line">    &lt;/section&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><strong>展示效果</strong></p><p>这里，图片可能不是特别清楚，读者可以跑一遍上述代码，在浏览器打开使用会更好一点嗷~</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200402153629282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><p><strong>总结</strong></p><p>从上述显示效果来看的话，改变了高度，用<code>flex</code>和<code>表格</code>布局还能继续使用。</p><p>对于第一块，也就是浮动布局那一块，我们还可以进行知识拓展：</p><ul><li><p>为什么会有两段文字跑到最左边去了呢？</p><p>  答：因为向左浮动的原因，上面文字被左边红色部分挡住了，当内容超过高度后，就会往左边移动了。</p></li><li><p>那你怎么将多余的两段文字接着上述文字显示，而不是向左移动？</p><p>  答：这就扯到了BFC的问题，清楚浮动等等，这里就不再进行拓展了，不然这篇文章没法完结啦。。。</p></li></ul><h3 id="页面布局模块——总结"><a href="#页面布局模块——总结" class="headerlink" title="页面布局模块——总结"></a>页面布局模块——总结</h3><ul><li>语义化掌握到位</li><li>页面布局深刻理解</li><li>CSS基础扎实</li><li>思维灵活且积极上进</li><li>代码书写规范</li></ul><h3 id="页面布局的变通"><a href="#页面布局的变通" class="headerlink" title="页面布局的变通"></a>页面布局的变通</h3><p><strong>三栏布局</strong></p><ul><li>左右宽度固定，中间自适应</li><li>上下高度固定，中间自适应</li></ul><p><strong>两栏布局</strong></p><ul><li>左宽度固定，右自适应</li><li>右宽度固定，左自适应</li><li>上宽度固定，下自适应</li><li>下宽度固定，上自适应</li></ul><h2 id="CSS盒模型"><a href="#CSS盒模型" class="headerlink" title="CSS盒模型"></a>CSS盒模型</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p><strong>谈谈你对CSS盒模型的认识</strong></p><ul><li><p>基本概念：标准模型+IE模型</p></li><li><p>标准模型和IE模型的区别</p></li><li><p>CSS如何设置这两种盒模型</p></li><li><p>JS如何设置获取盒模型对应的宽和高</p></li><li><p>实例题（根据盒模型解释边距重叠）</p></li><li><p>BFC（边距重叠解决方案）</p></li></ul><hr/><p>以上内容知识点由浅入深，知识点理论从CSS-&gt;JS-&gt;CSS</p><p><a href="https://blog.csdn.net/weixin_42429718/article/details/104448450">推荐阅读：这一次，彻底看懂 CSS 盒模型（图文并茂）</a></p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>标准盒模型、怪异盒模型（IE盒模型）和flex弹性伸缩盒模型以及多列布局</p><ul><li>标准盒模型（box-sizing content-box）</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200222185449952.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><ul><li>IE盒模型（box-sizing border-box）</li></ul><p>content = width+padding+border</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200222185613912.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><p><strong><font color=red>附完美回答方式：</font></strong></p><p>标准盒子模型，即box-sizing content-box，浏览器默认模型，我们所写的width和height并不是最终盒子的宽高，而是content的，盒子的宽高由我们的content+padding+border来组成的，但是这样在做项目时可能会遇到小问题，假如我想构建一个100x100的盒子大小，但是我发现我写的是width和height是100，于是我需要加上padding及border，但是加上去之后，盒子也会相应变大，这就造成改动麻烦。</p><p>后面css3中提供了IE盒子模型，能够直接控制盒子的大小。于是项目中大多数用上了IE盒子模型，以及我看过bootstrap以及element-ui源码中大部分也是用的IE盒子模型</p><blockquote><div>以上回答方式，请读者可以好好体会一下，挖掘其中的亮点！</div></blockquote><ul><li>FLEX盒模型</li></ul><p>关于这里可以参考阮一峰老师的文章</p><p><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html">参考：Flex 布局教程：语法篇</a></p><ul><li>多列布局（基本上不用）</li></ul><p>读者可以适当了解一下，这里就不加以说明了</p><h3 id="JS如何获取盒模型对应的宽和高"><a href="#JS如何获取盒模型对应的宽和高" class="headerlink" title="JS如何获取盒模型对应的宽和高"></a>JS如何获取盒模型对应的宽和高</h3><p>①<code>dom.style.width / height</code></p><p>这种方法，有一定局限性，只能取内联样式的宽高。</p><p>②<code>dom.currentStyle.width / height</code></p><p>这种方法，也是有一定局限性，不过我们三种常用css样式都能获取。但是只支持<code>IE</code>，其它浏览器不支持</p><p>③ <code>window.getComputedStyle(dom).width / height</code></p><p>支持所有浏览器，兼容性好</p><p>④ <code>dom.getBoundingClientRect().width / height</code></p><p>这种方法，一般用于计算元素的绝对位置，根据视窗左上角的点来算的。可以拿到四个元素值：<code>left</code>、<code>top</code>、<code>width</code>、<code>height</code></p><h3 id="实例题（根据盒模型解释边距重叠）"><a href="#实例题（根据盒模型解释边距重叠）" class="headerlink" title="实例题（根据盒模型解释边距重叠）"></a>实例题（根据盒模型解释边距重叠）</h3><p>如下图，有两个盒子，深色的定为父元素，浅色的定位子元素，子元素的高度为<code>100px</code>，与父元素的上边距为<code>10px</code>，请问父元素实际高度是多少？<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200402165051784.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><p>结合这个标题的情况，你可能会说是100px，但你也可能就是直接相加，觉得是110px，但都不是面试官觉得满意的回答，因为要看父元素的盒模型是如何设置的，下面来探讨这个问题：</p><p>我们在界面里来写一个父子元素的盒子</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;en&quot;</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;CSS盒模型&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        html *&#123;</span><br><span class="line">            padding: <span class="number">0</span>%;</span><br><span class="line">            margin: <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;section id=<span class="string">&quot;sec&quot;</span>&gt;</span><br><span class="line">        &lt;style&gt;</span><br><span class="line">            #sec&#123;</span><br><span class="line">                background: #f00;</span><br><span class="line">            &#125;</span><br><span class="line">            .children&#123;</span><br><span class="line">                height: 100px;</span><br><span class="line">                margin-top: 10px;</span><br><span class="line">                background: yellow;</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;/style&gt;</span><br><span class="line">        &lt;article <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;children&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">        &lt;/article&gt;</span><br><span class="line">    &lt;/section&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>打开浏览器，出现如下界面：<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200402190607634.png" alt=""></p><p> 我们父级元素貌似没看到，打开开发者工具（按下<code>F12</code>）</p><p>此时，我们看一下计算属性 <code>Computed</code></p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200402192214142.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""><br>发现，此时高度是<code>100px</code>。</p><p>同时，我们也看一下子元素的高度，如下，也是<code>100px</code>。<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200402192306678.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><p>那是不是就是<code>100px</code>呢？在回答之前，接着来如下操作，我们修改一个地方：</p><p>在父元素样式里设置 <code>overflow: hidden;</code><br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/2020040219294052.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""><br>此时，我们再次查看content，变成了<code>110px</code>。<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200402201211584.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""><br>此时，就有疑问了，为什么之前是<code>100px</code>，而当我们加了<code>overflow: hidden;</code>之后变成了<code>110px</code>了呢？</p><p><strong>补充知识点：</strong></p><p>我们常见的边距重叠，有两种情况：</p><ul><li>父子元素重叠（如上文所述）</li><li>兄弟之间重叠：比如两个格子，第一个格子下边距30px，第二个上边距5px，会取一个最大值30px作为边距。另外，特殊一点的就是空元素了，会取<code>margin-top</code>和<code>margin-bottom</code><br>的最大值</li></ul><p>补充完后，接着回答上一个问题，为什么加了<code>overflow: hidden;</code>之后变成了<code>110px</code>了呢？</p><p>其实，是给父级元素创建了一个<code>BFC</code>，这里我们在下文继续讨论。</p><h3 id="BFC（边距重叠解决方案）"><a href="#BFC（边距重叠解决方案）" class="headerlink" title="BFC（边距重叠解决方案）"></a>BFC（边距重叠解决方案）</h3><p><strong>BFC基本概念</strong>：块级格式化上下文</p><p>与之并列的一个是IFC（内联格式化上下文）这个不常考，就提一下。</p><p><strong>BFC的原理（渲染规则）</strong></p><p>① 在BFC这个元素的<code>垂直方向</code>边距会发生重叠</p><p>② BFC的区域不会与浮动元素的box重叠，可用来<code>清除</code>浮动布局</p><p>③ BFC是一个<code>独立</code>的容器，外面的元素不会影响里面的元素，同时，里面的元素不会影响外面的元素。</p><p>④ 计算BFC元素高度的时候，<code>浮动元素也会参与计算</code></p><p><strong>怎么创建BFC？</strong></p><p>① <code>float</code>值不为none，因为CSS默认为none，只要设置了浮动，当前元素就设置了BFC</p><p>② static：静态定位。它是<code>position</code>的默认值，一般不设置position属性时，元素会按照正常的文档流进行排列。那么，只要position不为默认值static也是设置了BFC</p><p>③ <code>display</code>属性，table、table-cell等table相关的，都是设置了BFC</p><p>④ <code>overflow</code>: auto / hidden</p><p><strong>BFC使用场景</strong></p><h3 id="垂直方向边距重叠问题"><a href="#垂直方向边距重叠问题" class="headerlink" title="垂直方向边距重叠问题"></a>垂直方向边距重叠问题</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;en&quot;</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;CSS盒模型&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        html *&#123;</span><br><span class="line">            padding: <span class="number">0</span>%;</span><br><span class="line">            margin: <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;section id=<span class="string">&quot;sec&quot;</span>&gt;</span><br><span class="line">        &lt;style&gt;</span><br><span class="line">            #sec&#123;</span><br><span class="line">                background: #f00;</span><br><span class="line">            &#125;</span><br><span class="line">            .children&#123;</span><br><span class="line">                height: 100px;</span><br><span class="line">                margin-top: 10px;</span><br><span class="line">                background: yellow;</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;/style&gt;</span><br><span class="line">        &lt;article <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;children&quot;</span>&gt;</span><br><span class="line">            </span><br><span class="line">        &lt;/article&gt;</span><br><span class="line">    &lt;/section&gt;</span><br><span class="line">    &lt;!-- BFC垂直方向边距重叠 --&gt;</span><br><span class="line">    &lt;section id=<span class="string">&quot;margin&quot;</span>&gt;</span><br><span class="line">        &lt;style&gt;</span><br><span class="line">            #margin&#123;</span><br><span class="line">                background: pink;</span><br><span class="line">                overflow: hidden;</span><br><span class="line">            &#125;</span><br><span class="line">            #margin&gt;p&#123;</span><br><span class="line">                margin: 5px auto 25px;</span><br><span class="line">                background: red;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &lt;/style&gt;</span><br><span class="line">        &lt;p&gt;a&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;b&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;c&lt;/p&gt;</span><br><span class="line">    &lt;/section&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>如下图所示，a的顶部只有5px，而b的顶部用到了a的底部25px，因此就造成了边距重叠问题<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200402204846508.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""><br>如何消除上述情况？</p><p>给子元素创建父元素，让父元素设置BFC</p><p>如下图所示，仅需加一个div，然后设置<code>overflow: hidden</code>即可</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200402211309341.png" alt=""></p><p><strong>效果</strong></p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200402211300463.png" alt=""></p><p>接下来，来一个左边固定，右边自适应的例子。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!-- BFC不予float重叠 --&gt;</span><br><span class="line">&lt;section id=<span class="string">&quot;layout&quot;</span>&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        #layout&#123;</span><br><span class="line">            margin-top: 10px;</span><br><span class="line">            background: red;</span><br><span class="line">        &#125;</span><br><span class="line">        #layout .left&#123;</span><br><span class="line">            float: left;</span><br><span class="line">            width: 100px;</span><br><span class="line">            height: 100px;</span><br><span class="line">            background: pink;</span><br><span class="line">        &#125;</span><br><span class="line">        #layout .right&#123;</span><br><span class="line">            height: 110px;</span><br><span class="line">            background: #ccc;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;left&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;right&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;/section&gt;</span><br></pre></td></tr></table></figure><p><strong>效果</strong><br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200402212208404.png" alt=""><br>从上图可以看到，右边因为宽度设置的高一点，经过浮动重叠到了左边一部分，此时，我们仅需一行代码即可<code>overflow: auto;</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#layout .right&#123;</span><br><span class="line">height: 110px;</span><br><span class="line">background: #ccc;</span><br><span class="line">overflow: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>效果</strong><br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200402212438518.png" alt=""></p><p><strong>计算BFC元素高度的时候，浮动元素也会参与计算</strong></p><p>怎么理解这个概念呢？比如下面代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!-- BFC子元素即使是float也会参与高度计算 --&gt;</span><br><span class="line">&lt;section id=<span class="string">&quot;float&quot;</span>&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        #float&#123;</span><br><span class="line">            background: green;</span><br><span class="line">        &#125;</span><br><span class="line">        #float .float&#123;</span><br><span class="line">            float: left;</span><br><span class="line">            font-size: 30px;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;float&quot;</span>&gt;I am 浮动元素&lt;/div&gt;</span><br><span class="line">&lt;/section&gt;</span><br></pre></td></tr></table></figure><p><strong>效果</strong><br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200402223151584.png" alt=""><br>我们从上面图片发现，没有父级元素，于是检查一下，发现父级高度为0，因为子元素设置了浮动，高度没有算进去<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200402223510992.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><p>解决办法，父级元素设置清除浮动，于是形成了一个BFC，然后就会加上子级元素的高度</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#float&#123;</span><br><span class="line">background: green;</span><br><span class="line">overflow: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从门再次打开开发者工具（F12），可以看到，父级元素已经有了高度</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200402223829514.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><h2 id="DOM-事件类"><a href="#DOM-事件类" class="headerlink" title="DOM 事件类"></a>DOM 事件类</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><ul><li><p>基本概念：DOM事件的级别</p></li><li><p>DOM事件模型</p></li><li><p>DOM事件流</p></li><li><p>描述DOM事件捕获的具体流程</p></li><li><p>Event对象的常见应用</p></li><li><p>自定义事件</p></li></ul><h3 id="基本概念：DOM事件的级别"><a href="#基本概念：DOM事件的级别" class="headerlink" title="基本概念：DOM事件的级别"></a>基本概念：DOM事件的级别</h3><table><thead><tr><th align="center">DMO事件类</th><th align="center">事件级别</th></tr></thead><tbody><tr><td align="center">DOM0</td><td align="center">element.onclick=function(){}</td></tr><tr><td align="center">DOM2</td><td align="center">element.addEventListener(‘click’, function(){} , false)</td></tr><tr><td align="center">DOM3</td><td align="center">element.addEventListener(‘keyup’, function(){} , false)</td></tr></tbody></table><p>为啥没有DOM1呢？</p><p>答：因为DOM1制定的时候，没有设计与事件相关的东西，但不代表DOM1标准不存在</p><p>DOM3也是一种事件定义方式，相对来说事件类型增加了，比如鼠标键盘事件等</p><p>最后一个<code>boolean</code>值表示事件模型是捕获还是冒泡，默认为<code>false</code>冒泡，为<code>true</code>表示捕获。</p><h3 id="DOM事件模型"><a href="#DOM事件模型" class="headerlink" title="DOM事件模型"></a>DOM事件模型</h3><p>分为捕获（从上到下）和冒泡（从目标元素往上）</p><h3 id="DOM事件流"><a href="#DOM事件流" class="headerlink" title="DOM事件流"></a>DOM事件流</h3><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200403093615164.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""><br>如上图所示，这就是一个事件流，一个<code>完整的事件流</code>分为三个阶段：</p><ul><li>第一阶段是捕获</li><li>第二阶段是目标阶段，比如说点按钮就是目标阶段，或者说是事件通过捕获到达目标元素</li><li>第三阶段是从目标元素上传到window对象，也就是冒泡的过程</li></ul><h3 id="描述DOM事件捕获的具体流程"><a href="#描述DOM事件捕获的具体流程" class="headerlink" title="描述DOM事件捕获的具体流程"></a>描述DOM事件捕获的具体流程</h3><p>（冒泡方向与之相反）<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/2020040309413230.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><h3 id="Event对象的常见应用"><a href="#Event对象的常见应用" class="headerlink" title="Event对象的常见应用"></a>Event对象的常见应用</h3><ul><li><code>event.preventDefault()</code>        （阻止默认，例如链接等）</li><li><code>event.stopPropagation()</code>    （阻止冒泡）</li><li><code>event.stopImmediateProgation()</code>         （事件响应优先级，例如给一个按钮添加两个事件A和B，你想要只执行A，不执行B，就在A的响应函数里添加这个方法，就会阻止B事件的执行）</li><li><code>event.currentTarget</code>        （表示当前所绑定的事件，如下面所述，指向的就是父级元素）</li><li><code>event.target</code>    （与事件委托相关，把子元素的事件全都转到父级元素上，进行优化，只需绑定一次事件，然而作响应的时候，需要区别是哪个子元素被点击，该方法就可以绑定当前被点击的元素）</li></ul><h3 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> eve = <span class="keyword">new</span> Event(<span class="string">&#x27;custome&#x27;</span>);</span><br><span class="line">ev.addEventListener(<span class="string">&#x27;custome&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;custome&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">ev.dispatchEvent(eve);</span><br></pre></td></tr></table></figure><p><code>CustomEvent</code>是为了解决Event事件不能传数据的问题</p><h3 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h3><p>上文讲述了相关知识点，下面我们通过代码来简单实现，让抽象的知识更加具体化</p><p><strong>DOM事件捕获的具体流程实例</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;en&quot;</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=<span class="string">&quot;ev&quot;</span>&gt;</span><br><span class="line">        &lt;style&gt;</span><br><span class="line">            #ev&#123;</span><br><span class="line">                width: 300px;</span><br><span class="line">                height: 100px;</span><br><span class="line">                color: #fff;</span><br><span class="line">                text-align: center;</span><br><span class="line">                line-height: 100px;</span><br><span class="line">                background: red;</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;/style&gt;</span><br><span class="line">        目标元素</span><br><span class="line">        &lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">            <span class="keyword">var</span> ev=<span class="built_in">document</span>.getElementById(<span class="string">&#x27;ev&#x27;</span>);</span><br><span class="line">            <span class="comment">//DOM2中定义事件 window</span></span><br><span class="line">            <span class="built_in">window</span>.addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&#x27;window capture&#x27;</span>)</span><br><span class="line">            &#125;,<span class="literal">true</span>)</span><br><span class="line">            <span class="comment">//document</span></span><br><span class="line">            <span class="built_in">document</span>.addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&#x27;document capture&#x27;</span>)</span><br><span class="line">            &#125;,<span class="literal">true</span>)</span><br><span class="line">            <span class="comment">//html</span></span><br><span class="line">            <span class="built_in">document</span>.documentElement.addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&#x27;html capture&#x27;</span>)</span><br><span class="line">            &#125;,<span class="literal">true</span>)</span><br><span class="line">            <span class="comment">//body</span></span><br><span class="line">            <span class="built_in">document</span>.body.addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&#x27;body capture&#x27;</span>)</span><br><span class="line">            &#125;,<span class="literal">true</span>)</span><br><span class="line">            <span class="comment">//目标元素</span></span><br><span class="line">            ev.addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&#x27;ev capture&#x27;</span>)</span><br><span class="line">            &#125;,<span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 自定义事件 */</span></span><br><span class="line">            <span class="keyword">var</span> eve = <span class="keyword">new</span> Event(<span class="string">&#x27;test&#x27;</span>);</span><br><span class="line">            ev.addEventListener(<span class="string">&#x27;test&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&#x27;test dispatch&#x27;</span>)</span><br><span class="line">            &#125;,<span class="literal">true</span>)</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                ev.dispatchEvent(eve);</span><br><span class="line">            &#125;,<span class="number">2000</span>)</span><br><span class="line"></span><br><span class="line">        &lt;/script&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><strong>效果</strong><br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/2020040311370377.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><h2 id="HTTP-协议类"><a href="#HTTP-协议类" class="headerlink" title="HTTP 协议类"></a>HTTP 协议类</h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><ul><li><p>HTTP协议的主要特点</p></li><li><p>HTTP报文的组成部分</p></li><li><p>HTTP方法</p></li><li><p>POST和GET的区别</p></li><li><p>HTTP状态码</p></li><li><p>什么是持久连接</p></li><li><p>什么是管线化</p></li></ul><h3 id="HTTP协议的主要特点"><a href="#HTTP协议的主要特点" class="headerlink" title="HTTP协议的主要特点"></a>HTTP协议的主要特点</h3><ul><li>简单快速    （每个资源URL是固定的，一个图片或页面地址，统一资源符，只需输入URL即可访问）</li><li>灵活    （在HTTP协议头部head部分有一个数据类型，通过http协议可以完成不同数据类型的传输）</li><li>无连接    （连接一次会断掉，不会保持连接）</li><li>无状态    （客户端和服务端连接两次，不能区分两次连接者身份）</li></ul><h3 id="HTTP报文的组成部分"><a href="#HTTP报文的组成部分" class="headerlink" title="HTTP报文的组成部分"></a>HTTP报文的组成部分</h3><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200403132018916.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><ul><li>请求行：包含方法、页面地址、HTTP协议版本</li><li>请求头：key-value值，告诉服务端需要什么内容，要注意什么类型</li><li>空行：告诉服务端请求头结束，接下来是请求体部分了</li><li>请求体：数据部分</li></ul><p>同理，响应报文</p><p><strong>请求示例</strong><br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200403135448592.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""><br>以上第一行就是请求行，包含<code>GET</code>方法 / 表示首页  <code>HTTP/1.1</code> 表示HTTP协议版本</p><p>后面内容都是请求头，都是<code>key-value</code>键值对</p><p>空行在这里没有显示出来，然后对于请求体就是一些数据部分了。</p><p><strong>响应示例</strong><br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200403135749252.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><p>第一行是状态行，包含HTTP协议版本，协议状态码200</p><p>下面就是响应头了，也是键值对的形式</p><p>下面会有一个空行，类似下面这种效果（下面这条分割横线）</p><hr/><h3 id="HTTP方法"><a href="#HTTP方法" class="headerlink" title="HTTP方法"></a>HTTP方法</h3><table><thead><tr><th align="center">方法</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">GET</td><td align="center">获取资源</td></tr><tr><td align="center">POST</td><td align="center">传输资源</td></tr><tr><td align="center">PUT</td><td align="center">更新资源</td></tr><tr><td align="center">DELETE</td><td align="center">删除资源</td></tr><tr><td align="center">HEAD</td><td align="center">获取报文首部</td></tr></tbody></table><h3 id="POST和GET的区别（重点前5条）"><a href="#POST和GET的区别（重点前5条）" class="headerlink" title="POST和GET的区别（重点前5条）"></a>POST和GET的区别（重点前5条）</h3><ul><li><p>get在浏览器回退时是无害的，而post会再次提交请求</p></li><li><p>get请求会被浏览器主动缓存，而post不会，除非手动设置</p></li><li><p>get请求参数会被完整保留在浏览器历史记录里，而post中的参数不会被保留</p></li><li><p>get请求在URL中传送的参数是有长度限制的，而POST没有限制</p></li><li><p>get参数通过URL传递，post放在Request body中</p></li><li><p>get请求只能进行url编码，而post支持多种编码方式</p></li><li><p>对参数的数据类型，get只接受ASCALL字符，而post没有限制</p></li><li><p>get比post更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息</p></li><li><p>get产生的URL地址可以被收藏，而post不可以</p></li></ul><h3 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h3><ul><li>1xx：指示信息——表示请求已接收，继续处理</li><li>2xx：成功——表示请求已经被成功接收</li><li>3xx：重定向——要完成请求必须进行更进一步的操作</li><li>4xx：客户端错误——请求有语法错误或请求无法实现</li><li>5xx：服务器错误——服务器未能实现合法的请求</li></ul><p>一般答完上述基本ok了，如果问的详细一点的话，就多加一点知识上去：</p><ul><li><code>200 OK</code>：客户端请求成功</li><li><code>206 Partial Content</code>：客户发送了一个带有Range（范围）头的GET请求，服务器完成了它（比如客户端请求0-1w字节，服务器就会返回206,常见播放视频和音频地址，文件过大时一般返回206）</li></ul><hr/><ul><li><code>301 Moved Permanently</code>：所请求的页面已经转移至新的URL</li><li><code>302 Found</code>：所请求的页面已经<code>临时</code>转移至新的URL</li><li><code>304 Not  Modified</code>：客户端有<code>缓冲</code>的文档并发出一个条件性的请求，服务器告诉客户，原来缓冲的文档还可以继续使用</li></ul><hr/><ul><li><code>400 Bad Request</code>：客户端请求有语法错误，不能被服务器所理解</li><li><code>401 Unauthorized</code>：请求未经授权，这个状态码必须和<code>WWW-Authenticate</code>报头域一起使用</li><li><code>403 Forbidden</code>：请求访问的页面被禁止（比如页面只能通过服务端去访问）</li><li><code>404 Not Found</code>：请求资源不存在</li></ul><hr/><ul><li><code>500 Internal Server Error</code>：服务器发生不可预料的错误但原来缓冲的文档还可以继续使用</li><li><code>503 Server Unavailable</code>：请求未完成，服务器临时过载或当机，一段时候后可能恢复正常</li></ul><h3 id="什么是持久连接"><a href="#什么是持久连接" class="headerlink" title="什么是持久连接"></a>什么是持久连接</h3><p>HTTP协议采用“请求-应答”模式，当使用普通模式，即<code>非 Keep-Alive</code> 模式时，每个请求 / 应答客户和服务器都要新建一个连接，完成之后立即断开连接（HTTP协议为无连接的协议）</p><p>当使用 <code>Keep-Alive</code>模式（又称持久连接、连接重用）时，<code>Keep-Alive</code> 功能使客户端到服务端的连接持续有效，当出现对服务器的后续请求时，<code>Keep-Alive</code> 功能避免了建立或者重新建立连接</p><p>PS：只有HTTP 1.1 版本才支持持久连接，1.0不支持。</p><h3 id="什么是管线化（加分点）"><a href="#什么是管线化（加分点）" class="headerlink" title="什么是管线化（加分点）"></a>什么是管线化（加分点）</h3><p>在使用持久连接的情况下，某个连接上消息的传递类似于</p><p>请求1-&gt;响应1-&gt;请求2-&gt;响应2-&gt;请求3-&gt;响应3</p><p>某个连接上的消息类似变成了这样：</p><p>请求1-&gt;请求2-&gt;请求3-&gt;响应1-&gt;响应2-&gt;响应3</p><p>（将请求打包一起发送，然后服务器一起打包回来响应）</p><p><strong>拓展知识：</strong></p><ul><li>管线化机制通过持久连接完成，仅 <code>HTTP / 1.1</code> 支持此技术（重点）</li><li>只有<code>get</code>和<code>head</code>请求可以进行管线化，而 <code>post</code> 有所限制（重点）</li><li>初次创建连接时不应启动管线机制，因为对方（服务器）不一定支持 <code>HTTP /1.1</code>版本的协议（重点）</li><li>管线化不会影响响应到来的顺序，如上面的例子所示，响应返回的顺序并未改变</li><li><code>HTTP / 1.1</code>要求服务器端支持管线化，但并不要求服务器端也对响应进行管线化处理，只是要求对于管线化的请求不失败即可</li><li>由于上面提到的服务器端的问题，开启管线化很可能并不会带来大幅度的性能提升，而且很多服务器端和代理程序对管线化的支持并不好，因此现代浏览器如 <code>Chrome</code> 和 <code>Firefox</code> 默认并未开启管线化支持</li></ul><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><h3 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h3><ul><li>创建对象有几种方法</li><li>原型、构造函数、实例、原型链</li><li>instanceof的原理</li><li>new运算符</li></ul><h3 id="创建对象有几种方法"><a href="#创建对象有几种方法" class="headerlink" title="创建对象有几种方法"></a>创建对象有几种方法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o1 = &#123;<span class="attr">name</span>:<span class="string">&#x27;o1&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> o11 = <span class="keyword">new</span> <span class="built_in">Object</span>(&#123;<span class="attr">name</span>:<span class="string">&#x27;o11&#x27;</span>&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> M = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">this</span>.name=<span class="string">&#x27;o2&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> o2 = <span class="keyword">new</span> M();</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> P = &#123;<span class="attr">name</span>:<span class="string">&#x27;o3&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> o3 = <span class="built_in">Object</span>.create(P);</span><br></pre></td></tr></table></figure><h3 id="原型、构造函数、实例、原型链"><a href="#原型、构造函数、实例、原型链" class="headerlink" title="原型、构造函数、实例、原型链"></a>原型、构造函数、实例、原型链</h3><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200404091811124.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> M = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;<span class="built_in">this</span>.name=name&#125;;    <span class="comment">//构造函数</span></span><br><span class="line"><span class="keyword">var</span> o2 = <span class="keyword">new</span> M(<span class="string">&#x27;o2&#x27;</span>);   <span class="comment">//实例</span></span><br></pre></td></tr></table></figure><p>构造函数和原型对象的关系<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200404092424139.png" alt=""></p><p>实例和构造函数的关系</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200404092715485.png" alt=""></p><p>原型链：通过原型链的方式，找到原型对象，原型对象的方法是被不同实例所共有的。例如Object上有toString()方法，因此其它所有的实例都共有这个方法。</p><h3 id="instanceof的原理"><a href="#instanceof的原理" class="headerlink" title="instanceof的原理"></a>instanceof的原理</h3><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200404093505976.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""><br><code>instanceof</code>原理就是判断当前实例是不是当前构造函数的实例对象，判断依据就是实例对象的<code>__proto__</code>和构造函数的<code>prototype</code>是否指向相同的引用，只要在一条原型链上，<code>instanceof</code>就会返回<code>true</code>。</p><p>很抽象是吧，下面我们还是举上文的例子：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> M = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;<span class="built_in">this</span>.name=name&#125;;</span><br><span class="line"><span class="keyword">var</span> o2 = <span class="keyword">new</span> M(<span class="string">&#x27;o2&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200404094108600.png" alt=""></p><p>因此，<code>instanceof</code>判断不严谨，比如m继承了a、b、c，我怎么判断是继承了哪一个呢？用<code>instanceof</code>判断都返回<code>true</code>。</p><p>下面就来，介绍<code>constructor</code>判断方式</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200404094632985.png" alt=""></p><h3 id="new运算符"><a href="#new运算符" class="headerlink" title="new运算符"></a>new运算符</h3><ul><li><p>一个新对象被创建。它继承自<code>foo.prototype</code></p></li><li><p>构造函数foo被执行。执行的时候，相应的参数会被传入，同时上下文（this）会被指定为这个新实例。<code>new foo</code> 等同于 <code>new foo()</code>，只能用在不传递任何参数的情况</p></li><li><p>如果构造函数返回一个“对象”，那么这个对象会取代整个new出来的结果。如果构造函数没有返回对象，那么new出来的结果为步骤1创建的对象</p></li></ul><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h3><p><strong>类与实例</strong></p><ul><li>类的声明</li><li>生成实例</li></ul><p><strong>类与继承</strong></p><ul><li>如何实现继承</li><li>继承的几种方式</li></ul><h3 id="类与实例"><a href="#类与实例" class="headerlink" title="类与实例"></a>类与实例</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        <span class="comment">/* 类的声明 */</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.name=<span class="string">&#x27;aaa&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* ES6中的class的声明 */</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Animal2</span></span>&#123;</span><br><span class="line">            <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="built_in">this</span>.name = <span class="string">&#x27;bbb&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 实例化一个类 */</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">new</span> Animal(),<span class="keyword">new</span> Animal2());</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><p><strong>效果</strong><br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200404101354316.png" alt=""></p><h3 id="类与继承"><a href="#类与继承" class="headerlink" title="类与继承"></a>类与继承</h3><p><strong>方法一：借助构造函数来实现继承</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 借助构造函数来实现继承 */</span></span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">fruit</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">          <span class="built_in">this</span>.name = <span class="string">&#x27;fruit&#x27;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">apple</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">          fruit.call(<span class="built_in">this</span>);</span><br><span class="line">          <span class="built_in">this</span>.type=<span class="string">&#x27;apple&#x27;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">new</span> apple);</span><br></pre></td></tr></table></figure><p>上述这种方式，是通过改变<code>fruit</code>构造函数运行时this指向，指向了<code>apple</code>上，但是<code>fruit</code>原型链上的东西并没有被继承。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 借助构造函数来实现继承 */</span></span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">fruit</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">          <span class="built_in">this</span>.name = <span class="string">&#x27;fruit&#x27;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      fruit.prototype.eat = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">&#x27;吃水果啦！&#x27;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">apple</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">          fruit.call(<span class="built_in">this</span>);</span><br><span class="line">          <span class="built_in">this</span>.type=<span class="string">&#x27;apple&#x27;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">new</span> apple().eat());</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200404105822522.png" alt=""><br>因此，通过构造函数来实现的继承，只能继承父类构造函数的属性，如果原型<code>prototype</code>上面还有方法甚至原型链上的方法，不会继承。</p><p><strong>方法二：借助原型链实现继承</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 借助原型链实现继承 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fruit</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = <span class="string">&#x27;fruit&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">apple</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.type=<span class="string">&#x27;apple&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">apple.prototype = <span class="keyword">new</span> fruit();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> apple());</span><br></pre></td></tr></table></figure><p>掌握之前原型链相关的知识，下面的等式应该就比较容易理解了<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/2020040411063490.png" alt=""><br>但这种继承方式也是有缺点的，下文来探讨这个问题：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 借助原型链实现继承 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fruit</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&#x27;fruit&#x27;</span>;</span><br><span class="line">    <span class="built_in">this</span>.arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">apple</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.type=<span class="string">&#x27;apple&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">apple.prototype = <span class="keyword">new</span> fruit();</span><br><span class="line"><span class="keyword">var</span> app1 = <span class="keyword">new</span> apple();</span><br><span class="line"><span class="keyword">var</span> app2 = <span class="keyword">new</span> apple();</span><br><span class="line">app1.arr.push(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(app1,app2);</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200404110957499.png" alt=""></p><p>从上述结果来看，当我们修改某一个对象时，该函数的所有新出的实例对象都会跟着改变，这就造成了<code>污染</code>问题，肯定不是我们面向对象思想所想要的。（因为它们引用的是同一个父类实例对象）</p><p><strong>方式三：组合方式实现继承</strong></p><p>这种方式就是结合前两种的优点，弥补它们的缺点。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;en&quot;</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;面向对象&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        <span class="comment">/* 关于继承的几种方式</span></span><br><span class="line"><span class="comment">        **使用方法：</span></span><br><span class="line"><span class="comment">        **读者按需将对应模块注释取消掉即可 </span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 借助原型链实现继承 */</span></span><br><span class="line">        <span class="comment">/*function fruit()&#123;</span></span><br><span class="line"><span class="comment">            this.name = &#x27;fruit&#x27;;</span></span><br><span class="line"><span class="comment">            this.arr = [1,2,3];</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        function apple()&#123;</span></span><br><span class="line"><span class="comment">            this.type=&#x27;apple&#x27;;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        apple.prototype = new fruit();</span></span><br><span class="line"><span class="comment">        var app1 = new apple();</span></span><br><span class="line"><span class="comment">        var app2 = new apple();</span></span><br><span class="line"><span class="comment">        app1.arr.push(4);</span></span><br><span class="line"><span class="comment">        console.log(app1,app2);*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 组合方式实现继承 */</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        *此方法的缺点：new fruit() 父类构造函数执行了两次，可以但没必要</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">fruit</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.name = <span class="string">&#x27;fruit&#x27;</span>;</span><br><span class="line">            <span class="built_in">this</span>.arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">apple</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            fruit.call(<span class="built_in">this</span>);</span><br><span class="line">            <span class="built_in">this</span>.type=<span class="string">&#x27;apple&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        apple.prototype = <span class="keyword">new</span> fruit();  <span class="comment">//这里拿的是父类的实例，没有自己的constructor</span></span><br><span class="line">        <span class="keyword">var</span> app1 = <span class="keyword">new</span> apple();</span><br><span class="line">        <span class="keyword">var</span> app2 = <span class="keyword">new</span> apple();</span><br><span class="line">        app1.arr.push(<span class="number">4</span>);</span><br><span class="line">        <span class="comment">//console.log(app1,app2);</span></span><br><span class="line">        <span class="comment">//console.log(app1.constructor,app2.constructor)   </span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 组合方式实现继承优化1 */</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">fruit1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.name = <span class="string">&#x27;fruit&#x27;</span>;</span><br><span class="line">            <span class="built_in">this</span>.arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">apple1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            fruit.call(<span class="built_in">this</span>);</span><br><span class="line">            <span class="built_in">this</span>.type=<span class="string">&#x27;apple&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        apple1.prototype = fruit1.prototype;  <span class="comment">//这里拿的是父类的原型对象，但依旧没有自己的constructor</span></span><br><span class="line">        <span class="keyword">var</span> app3 = <span class="keyword">new</span> apple1();</span><br><span class="line">        <span class="keyword">var</span> app4 = <span class="keyword">new</span> apple1();</span><br><span class="line">        app3.arr.push(<span class="number">4</span>);</span><br><span class="line">        <span class="comment">//console.log(app3,app4);</span></span><br><span class="line">        <span class="comment">//判断实例</span></span><br><span class="line">        <span class="comment">//console.log(app3 instanceof apple1);</span></span><br><span class="line">        <span class="comment">//console.log(app3 instanceof fruit1); //这里无法判断当前对象是由父类产生的实例对象还是由子类产生的实例对象</span></span><br><span class="line">        <span class="comment">//判断构造函数</span></span><br><span class="line">        <span class="comment">//console.log(app3.constructor);      </span></span><br><span class="line">        <span class="comment">//console.log(app4.constructor);       //因为和父类的原型对象是一个对象，导致constructor也是指向的父类的constructor，无法判断自己</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 组合方式实现继承优化2 */</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">fruit2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.name = <span class="string">&#x27;fruit&#x27;</span>;</span><br><span class="line">            <span class="built_in">this</span>.arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">apple2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            fruit.call(<span class="built_in">this</span>);</span><br><span class="line">            <span class="built_in">this</span>.type=<span class="string">&#x27;apple&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        apple2.prototype = <span class="built_in">Object</span>.create(fruit2.prototype);  <span class="comment">//这里使用Object.create()方法，和之前直接用fruit2.prototype来说，它创建了一个中间对象，和父类不是指向同一个区域了</span></span><br><span class="line">        <span class="comment">//这样就能区分父类和子类的原型对象了，达到父类和子类原型对象的隔离效果</span></span><br><span class="line">        apple2.prototype.constructor = apple2;  <span class="comment">//由于隔离了父类子类的原型对象，我们就可以指定子类自己的constructor</span></span><br><span class="line">        <span class="keyword">var</span> app5 = <span class="keyword">new</span> apple2();</span><br><span class="line">        <span class="keyword">var</span> app6 = <span class="keyword">new</span> apple2();</span><br><span class="line">        app5.arr.push(<span class="number">4</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(app5,app6);</span><br><span class="line">         <span class="comment">//判断实例</span></span><br><span class="line">        <span class="built_in">console</span>.log(app5 <span class="keyword">instanceof</span> apple2);</span><br><span class="line">        <span class="built_in">console</span>.log(app5 <span class="keyword">instanceof</span> fruit2); <span class="comment">//因此，这里可以判断当前对象是由父类产生的实例对象还是由子类产生的实例对象</span></span><br><span class="line">        <span class="comment">//判断构造函数</span></span><br><span class="line">        <span class="built_in">console</span>.log(app5.constructor);       <span class="comment">//指向的是自己的constructor</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;/script&gt;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><hr><h2 id="通信类"><a href="#通信类" class="headerlink" title="通信类"></a>通信类</h2><h3 id="题目-6"><a href="#题目-6" class="headerlink" title="题目"></a>题目</h3><ul><li>什么是同源策略及限制</li><li>前后端如何通信</li><li>如何创建Ajax</li><li>跨域通信的几种方式（重点）</li></ul><h3 id="什么是同源策略及限制"><a href="#什么是同源策略及限制" class="headerlink" title="什么是同源策略及限制"></a>什么是同源策略及限制</h3><p>同源策略限制从一个源加载的文档或脚本如何与来自另一个源的资源进行交互。<br>这是一个用于隔离潜在恶意文件的关键的安全机制。</p><p> 源包括协议、域名、端口</p><ul><li>Cookie、LocalStorage和IndexDB无法读取</li><li>DOM无法获得</li><li>AJAX请求不能发送</li></ul><h3 id="前后端如何通信"><a href="#前后端如何通信" class="headerlink" title="前后端如何通信"></a>前后端如何通信</h3><ul><li>Ajax（同源下的通信）</li><li>WebSocket（不限制，不受同源策略的限制）</li><li>CORS（支持同源通信，也支持跨域通信，新型）</li></ul><h3 id="如何创建Ajax"><a href="#如何创建Ajax" class="headerlink" title="如何创建Ajax"></a>如何创建Ajax</h3><ul><li>XMLHttpRequest（高级浏览器才支持）对象的工作流程</li><li>兼容性处理</li><li>事件的触发条件</li><li>事件的触发顺序</li></ul><h3 id="跨域通信的几种方式（重点）"><a href="#跨域通信的几种方式（重点）" class="headerlink" title="跨域通信的几种方式（重点）"></a>跨域通信的几种方式（重点）</h3><ul><li>JSONP</li><li>Hash（改变页面不刷新，search改变会刷新，因此search不可以）</li><li>postMessage（H5中出现的标准，实现跨域通信）</li><li>WebSocket</li><li>CORS（可以理解为支持跨域通信的Ajax，在请求头上加了Origin）</li></ul><p><strong>JSONP实现原理：</strong></p><p>根据script标签异步加载而来</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200404135628568.png" alt=""></p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/2020040413390361.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""><br>将<code>html</code>加入<code>script</code>标签，即把请求发送出去<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200404135715278.png" alt=""></p><p>很关键一点是会向服务端发送一个<code>callbackName</code>，然后服务器就会响应如下内容（下面那个script里的内容）利用<code>callbackName</code>作为函数名来返回，而且本地必须有这个函数名的函数。<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200404133842188.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""><br><strong>Hash与postMessage实现原理</strong><br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200404135948962.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""><br><strong>WebSocket实现原理</strong><br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/2020040414064464.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><p><strong>CORS实现原理</strong><br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200404141010376.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""><br>PS：CORS为什么支持跨域通信？</p><p>浏览器回拦截<code>Ajax</code>请求，如果觉得是跨域的，就会在请求头上加上<code>origin</code>。</p><h2 id="安全类"><a href="#安全类" class="headerlink" title="安全类"></a>安全类</h2><h3 id="题目-7"><a href="#题目-7" class="headerlink" title="题目"></a>题目</h3><ul><li><p>CSRF</p><p>  基本概念和缩写<br>  攻击原理<br>  防御措施</p></li><li><p>XSS</p></li></ul><h3 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h3><p><strong>基本概念和缩写</strong></p><p>CSRF，通常称为跨站请求伪造，英文名（Cross-site request forgery）缩写CSRF</p><p><strong>CSRF攻击原理</strong></p><ul><li>用户必须在网站登录过</li><li>网站中某个接口存在漏洞<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200404141759423.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></li></ul><p><strong>CSRF防御措施</strong></p><ul><li>Token验证</li><li>Referer验证（页面来源验证）</li><li>隐藏令牌（类似Token，隐藏在http的head头中，不放在链接上）</li></ul><h3 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h3><p><strong>基本概念和缩写</strong></p><p>跨域脚本攻击（cross-site scripting）</p><p><strong>攻击原理</strong></p><p>比如可以在你的提交区里面写上script标签，即用一些渠道向你的页面注入js脚本</p><p><strong>防御措施</strong></p><p>让插入的js不可执行</p><h3 id="CSRF与XSS区别"><a href="#CSRF与XSS区别" class="headerlink" title="CSRF与XSS区别"></a>CSRF与XSS区别</h3><p>CSRF是利用本身的漏洞自动执行接口，依赖于用户登录网站</p><p>XSS是向页面注入js，js函数体里面做想做的事</p><h2 id="算法类"><a href="#算法类" class="headerlink" title="算法类"></a>算法类</h2><h3 id="题目-8"><a href="#题目-8" class="headerlink" title="题目"></a>题目</h3><ul><li>排序</li><li>堆栈、队列、链表</li><li>递归</li><li>波兰式和逆波兰式</li><li>…</li></ul><p>PS：由于文章篇幅所限，并且算法这一块需要的是自己平时的积累，这里就不作长文加载了，关于算法这一块我会在github里有相应专栏，记录题库。因此，在这里就给大家分享一些比较好的文章提供学习。</p><hr/><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><ul><li>快速排序：<a href="https://segmentfault.com/a/1190000009426421">传送门</a></li><li>选择排序：<a href="https://segmentfault.com/a/1190000009366805">传送门</a></li><li>希尔排序：<a href="https://segmentfault.com/a/1190000009461832">传送门</a></li></ul><p><a href="https://chocolate.blog.csdn.net/article/details/105218288">推荐：【再也不怕面试官要你手写排序算法】一文详细解读前后端之各种排序算法及知识拓展（附图示） JS / C / C++</a></p><h3 id="堆栈、队列、链表"><a href="#堆栈、队列、链表" class="headerlink" title="堆栈、队列、链表"></a>堆栈、队列、链表</h3><p><a href="https://juejin.im/entry/58759e79128fe1006b48cdfd">参考：JS中的数据结构与算法</a></p><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p><a href="https://segmentfault.com/a/1190000009857470">参考：JS中的递归</a></p><h3 id="波兰式和逆波兰式"><a href="#波兰式和逆波兰式" class="headerlink" title="波兰式和逆波兰式"></a>波兰式和逆波兰式</h3><p><a href="https://www.cnblogs.com/chenying99/p/3675876.html">参考：波兰式、逆波兰式与表达式求值</a></p><p><a href="https://github.com/Tairraos/rpn.js">参考：源码</a></p><h3 id="关于算法的心得"><a href="#关于算法的心得" class="headerlink" title="关于算法的心得"></a>关于算法的心得</h3><p>首先，对于前端来说，算法要求没有后端那么严格，考察的一般不会很刁专，一般就是看下你的思考能力。如果一开始就考察算法题，如果你回答不了的话，也很正常，或许这不是一个关于前端的部门…可能招的是算法工程师，算法这一块问的话，多半是中间时间段。算法这一块的话，在于平时积累，如果时间充裕的话，可以深入了解一点，这也是面试加分点，如果时间紧迫的话，把上文提到的部分专题弄懂已经不错了。</p><hr/><h2 id="二面-三面"><a href="#二面-三面" class="headerlink" title="二面 / 三面"></a>二面 / 三面</h2><h3 id="面试技巧-1"><a href="#面试技巧-1" class="headerlink" title="面试技巧"></a>面试技巧</h3><ul><li>知识面要广</li><li>理解要深刻</li><li>内心要诚实</li><li>态度要谦虚</li><li>回答要灵活</li><li>要学会赞美</li></ul><h2 id="渲染机制"><a href="#渲染机制" class="headerlink" title="渲染机制"></a>渲染机制</h2><h3 id="题目-9"><a href="#题目-9" class="headerlink" title="题目"></a>题目</h3><ul><li>什么是DOCTYPE及作用</li><li>浏览器渲染过程</li><li>重排Reflow</li><li>重绘Repaint</li><li>布局Layout</li></ul><h3 id="什么是DOCTYPE及作用"><a href="#什么是DOCTYPE及作用" class="headerlink" title="什么是DOCTYPE及作用"></a>什么是DOCTYPE及作用</h3><ul><li>DTD（document type ，文档类型定义）是一系列的语法规则，用来定义XML或（X）HTML的文件类型。浏览器会使用它来判断文件类型，决定使用何种协议来解析，以及切换浏览器模式</li><li>DOCTYPE是用来声明文档类型和DTD规范的，一个主要的用途便是文件的合法性验证。如果文件代码不合法，那么浏览器就会出现一些解析错误。（简单来说，就是告诉浏览器我用了哪一个DTD）</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200404161808788.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""><br>PS：这里要记住html5该如何声明，以及4.0版本有严格模式和传统模式，具体区别如上图下划线所示</p><h3 id="浏览器渲染过程"><a href="#浏览器渲染过程" class="headerlink" title="浏览器渲染过程"></a>浏览器渲染过程</h3><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200404162046639.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><p><strong>简单快速回答：</strong></p><p>第一步，HTML经过HTML解析器解析成为DOM Tree</p><p>第二步，CSS通过CSS解析器形成样式规则</p><p>第三步，将两个DOM结合形成Render Tree，这里就类似于告诉浏览器渲染树结构基本出来了，此时有一个平行操作，Layout，经过这个，就能知道元素具体应该显示在屏幕在哪个位置（宽、高、颜色等）</p><p>最后一步，浏览器通过GUI画图，呈现页面内容，最后Display显示页面</p><hr/><p>下面通过几个比较好理解的图形来将抽象具体化：</p><p><strong>DOM Tree</strong><br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200404163122362.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""><br><strong>CSSOM Tree</strong><br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200404163149664.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""><br><strong>Render Tree</strong><br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200404163230751.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""><br><strong>Layout</strong><br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200404163324722.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><h3 id="重排Reflow"><a href="#重排Reflow" class="headerlink" title="重排Reflow"></a>重排Reflow</h3><p><strong>定义</strong></p><p>DOM结构中的各个元素都有自己的盒子（模型），这些都需要浏览器根据各种样式来计算并根据计算结果将元素放到它该出现的位置，这个过程称之为reflow</p><p><strong>触发Reflow</strong></p><ul><li>当你增加、删除、修改<code>DOM</code>结点时，会导致 <code>Reflow</code> 或 <code>Repaint</code></li><li>当你移动<code>DOM</code>的位置，或是搞个动画的时候</li><li>当你修改<code>CSS</code>样式的时候</li><li>当你 <code>Resize</code> 窗口的时候（移动端没有这个问题），或是滚动的时候</li><li>当你修改网页的默认字体时候（影响比较大，性能问题）</li></ul><h3 id="重绘Repaint"><a href="#重绘Repaint" class="headerlink" title="重绘Repaint"></a>重绘Repaint</h3><p><strong>定义</strong></p><p>当各种盒子的位置、大小以及其他属性，例如颜色、字体大小等确定下来后，浏览器于是便把这些元素都按照各自的特性绘制了一遍，于是页面的内容出现了，这个过程称之为<code>repaint</code>。即页面需要呈现的内容，一起画到屏幕上。</p><p><strong>触发Repaint</strong></p><ul><li>DOM改动</li><li>CSS改动</li></ul><p><strong>（重点）如何尽量减小Repaint？</strong></p><p>比如页面有一个计算器，用户在输入框输入一些计算表达式，最后显示计算结果，然后把输入给隐藏掉。这里就有两个交互，先是用户输入，将输入隐藏掉，然后将结果显示出来。这两个交互呈现内容不一样，当然就需要Repaint，那怎么做少画点东西？</p><p>好像是有一个documentFrame这个东西，把n个节点创建成一个片段，向浏览器一次添加这个片段。</p><p>（这里我的朋友考察过，遗留一下这个问题，可以帮助我完善这个问题，谢谢！）</p><h2 id="js运行机制"><a href="#js运行机制" class="headerlink" title="js运行机制"></a>js运行机制</h2><p>关于这一专题，我之前的文章也是写的挺多的了。</p><p><a href="https://blog.csdn.net/weixin_42429718/article/details/104907304">推荐阅读：【金三银四】一个问题就知道你会不会JS了 阿里、头条真题解析</a></p><p><a href="https://blog.csdn.net/weixin_42429718/article/details/104990407">推荐阅读：【金三银四】 一文弄懂 js 数据类型、堆栈内存、作用域（链）、闭包知识拓展 （一）</a></p><p>下面就例举几个经典题，读者可以好好体会一下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;en&quot;</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;js运行机制&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">        &#125;,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">   <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(i);</span><br><span class="line">   &#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目-10"><a href="#题目-10" class="headerlink" title="题目"></a>题目</h3><ul><li>如何理解JS的单线程</li><li>什么是任务队列</li><li>什么是Event Loop</li></ul><p>以上三个问题的详细表述：</p><p><a href="https://blog.csdn.net/weixin_42429718/article/details/104990407">推荐阅读：【金三银四】 一文弄懂 js 数据类型、堆栈内存、作用域（链）、闭包知识拓展 （一）</a></p><h3 id="如何理解JS的单线程"><a href="#如何理解JS的单线程" class="headerlink" title="如何理解JS的单线程"></a>如何理解JS的单线程</h3><p>学过JS，不对，听过JS的同学应该都知道，JS是单线程的，而浏览器是多线程的，分配的时间内js只能干一件事情</p><h3 id="什么是任务队列"><a href="#什么是任务队列" class="headerlink" title="什么是任务队列"></a>什么是任务队列</h3><p>分同步任务和异步任务</p><h3 id="什么是Event-Loop"><a href="#什么是Event-Loop" class="headerlink" title="什么是Event Loop"></a>什么是Event Loop</h3><p>为了解决同步和异步问题，浏览器提供了一个事件队列 Event Queue，根据特征不同，分为微任务和宏任务队列</p><p>执行顺序是：主线程代码 &gt; 微任务 &gt; 宏任务</p><p><strong>宏任务：</strong></p><p>定时器例如setTimeout（异步）、事件绑定</p><p><strong>微任务：</strong></p><p>await（异步，执行x函数并等待返回结果，有结果再执行下面代码）</p><p>resolve() / reject() 执行的时候把 then / catch 中的代码执行</p><p>promise、async</p><p><strong>特殊情况：</strong></p><p>new Promise（同步）会立即执行</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>理解Js的单线程的概念</li><li>理解任务队列</li><li>理解 Event Loop</li><li>理解哪些语句会放入异步任务队列</li><li>理解语句放入异步任务队列的时机</li></ul><h2 id="页面性能"><a href="#页面性能" class="headerlink" title="页面性能"></a>页面性能</h2><h3 id="题目-11"><a href="#题目-11" class="headerlink" title="题目"></a>题目</h3><p>提升页面性能的方法有哪些？</p><ul><li>1、资源压缩合并，减少HTTP请求</li><li>2、非核心代码异步加载——异步加载的方式——异步加载的区别</li><li>3、利用浏览器缓存——缓存的分类——缓存的原理</li><li>4、使用CDN</li><li>5、预解析DNS</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;meta http-equiv=<span class="string">&quot;x-dns-prefetch-control&quot;</span> content=<span class="string">&quot;on&quot;</span>&gt; <span class="comment">//打开a标签dns预解析</span></span><br><span class="line"><span class="comment">//有些https默认关了dns预解析，使用上述可以打开（加分点）</span></span><br><span class="line">&lt;link rel=<span class="string">&quot;dns-prefetch&quot;</span> href=<span class="string">&quot;//host_name_to_prefetch.com&quot;</span>&gt;</span><br></pre></td></tr></table></figure><h3 id="异步加载"><a href="#异步加载" class="headerlink" title="异步加载"></a>异步加载</h3><p>1、异步加载的方式</p><ul><li>动态脚本加载（用过js添加到document中，比如加入到body或head中）</li><li>defer</li><li>async</li></ul><p>2、异步加载的区别</p><p>（1）<code>defer</code>是在HTML解析完之后才会执行，如果是多个，按照加载的顺序依次执行<br>（2）<code>async</code>是在加载完之后立即执行，如果是多个，执行顺序和加载顺序无关</p><h3 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h3><p><strong>1、缓存的分类</strong></p><ul><li><p>① <strong>强缓存</strong>（不用任何请求，拿过来就用，如果两个都下发，以第二个<code>Cache</code>为准）</p><p>  <strong>Expires（过期时间-服务器绝对时间）</strong> Expires:Thu,21 Jan 2017 23:39:02 GMT<br>  （会导致客户端时间和服务器时间之间时间差问题）<br>  <strong>Cache-Control（客户端相对时间，单位秒）</strong> Cache-Control:max-age=3600</p></li></ul><ul><li><p>② <strong>协商缓存</strong>（浏览器发现本地有这个副本，但是不确定用不用它，于是得向服务器问一下，这个副本要不要用）</p><p>  <strong>Last-Modified</strong>（拿到某个资源文件时，通过这个字段服务器下发一个时间）  <strong>If-Modified-Since</strong> （当下次请求这个资源是否发生变化时，是用这个<code>key</code>值，对比两个时间）</p><p>  Last-Modified: Web,26 Jan 2017 00:35:11 GMT</p><p>  （上述方式会存在问题，例如我可能时间上修改了，但是内容并没有修改）</p><p>  <strong>Etage</strong>（解决上述问题，服务器给Etage值，当过了强缓存时间，浏览器请求是否可用副本时，会在http请求头中用 <strong>If-None-Match</strong> 当做key值，加上<code>value</code>，此value就是Etage的值）</p></li></ul><p><strong>PS：（面试真题-鹅厂）你知道浏览器与缓存相关的http头有哪些？</strong></p><p>答案就是上述<strong>加粗字体</strong></p><h2 id="错误监控"><a href="#错误监控" class="headerlink" title="错误监控"></a>错误监控</h2><p><strong>问法：如何检测JS错误，如何保证你的产品质量？</strong></p><h3 id="题目-12"><a href="#题目-12" class="headerlink" title="题目"></a>题目</h3><ul><li>前端错误的分类</li><li>错误的捕获方式</li><li>上报错误的基本原理</li></ul><h3 id="前端错误的分类"><a href="#前端错误的分类" class="headerlink" title="前端错误的分类"></a>前端错误的分类</h3><p>即时运行错误：代码错误<br>资源加载错误</p><h3 id="错误的捕获方式"><a href="#错误的捕获方式" class="headerlink" title="错误的捕获方式"></a>错误的捕获方式</h3><p><strong>即时运行错误</strong>的捕获方式</p><p>（1） try…catch<br>（2）window.onerror（无法捕获资源加载错误，理由如下）</p><p><strong>资源加载错误</strong>（上述原因：因为资源加载错误不会冒泡）</p><p>（1）<code>object.onerror</code>（节点上绑定<code>onerror</code>事件）</p><p>（2）<code>performance.getEntries()</code> （获得目前已加载的资源，例如图片，然后用document.getElementsByTagName(‘img’)来获取需要加载的图片，然后用总的去减已加载的，就能知道未加载的有多少了）</p><p>（3）<code>Error</code>事件捕获（之前说不能冒泡，但可以捕获）</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200404205139389.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""><br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200404205209691.png" alt=""></p><p><strong>延伸：跨域的js运行错误可以捕获吗，错误提示什么，应该怎么处理？</strong></p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/2020040420481855.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""><br><strong>处理</strong></p><ul><li>在script标签增加 <code>crossorigin</code> 属性</li><li>设置js资源响应头 `Access-Control-Allow-Origin:*（可以指定域名）</li></ul><h3 id="上报错误的基本原理"><a href="#上报错误的基本原理" class="headerlink" title="上报错误的基本原理"></a>上报错误的基本原理</h3><p>1、采用Ajax通信的方式上报<br>2、利用Image对象上报（重点，加分点）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;en&quot;</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;利用Image对象上报&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        (<span class="keyword">new</span> Image()).src=<span class="string">&#x27;http://baidu.com/test?name=123&#x27;</span>;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>此时，我们查看<code>Nerwork</code>，可以发现，我们的请求已经发出去了（比Ajax简单，不用借用任何第三方库）<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200404205701538.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><h2 id="三面-四面"><a href="#三面-四面" class="headerlink" title="三面 / 四面"></a>三面 / 四面</h2><h3 id="面试技巧-2"><a href="#面试技巧-2" class="headerlink" title="面试技巧"></a>面试技巧</h3><ul><li>准备要充分</li><li>描述要熟练</li><li>引导找时机</li><li>优势要发挥</li><li>回答要灵活</li></ul><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p><font color="Tomato"><strong>如若本文有瑕疵需修改的地方，请提出来，谢谢您的贡献！</strong></font></p><p><font color=chocolate>欢迎关注微信公众号：小狮子前端Vue</font></p><p>谢谢您的支持！✿✿ヽ(°▽°)ノ✿</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">学如逆水行舟，不进则退</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「阿里智能事业群-达摩院-机器智能技术部」秋招面试复盘总结</title>
      <link href="posts/20209022/"/>
      <url>posts/20209022/</url>
      
        <content type="html"><![CDATA[<h2 id="阿里智能事业群-达摩院-机器智能技术部"><a href="#阿里智能事业群-达摩院-机器智能技术部" class="headerlink" title="阿里智能事业群-达摩院-机器智能技术部"></a>阿里智能事业群-达摩院-机器智能技术部</h2><h3 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h3><h3 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h3><h3 id="聊实习经历"><a href="#聊实习经历" class="headerlink" title="聊实习经历"></a>聊实习经历</h3><blockquote><p>主要工作内容，比如申请前端小组组长，与项目负责人沟通，完成模块发布工具前端框架。每日完成工作进度汇报，前端工作主要是表格页面渲染，比如树形表格，分组表格结合等，实现基本的增删改查功能…</p></blockquote><h3 id="项目中有用到SSR，说说对SSR的理解，目前为什么要用SSR？"><a href="#项目中有用到SSR，说说对SSR的理解，目前为什么要用SSR？" class="headerlink" title="项目中有用到SSR，说说对SSR的理解，目前为什么要用SSR？"></a>项目中有用到SSR，说说对SSR的理解，目前为什么要用SSR？</h3><h4 id="页面的渲染流程"><a href="#页面的渲染流程" class="headerlink" title="页面的渲染流程"></a>页面的渲染流程</h4><ul><li>浏览器通过请求得到一个HTML文本</li><li>渲染进程解析HTML文本，构建DOM树</li><li>解析HTML的同时，如果遇到内联样式或者样式脚本，则下载并构建样式规则（stytle rules），若遇到JavaScript脚本，则会下载执行脚本。</li><li>DOM树和样式规则构建完成之后，渲染进程将两者合并成渲染树（render tree）</li><li>渲染进程开始对渲染树进行布局，生成布局树（layout tree）</li><li>渲染进程对布局树进行绘制，生成绘制记录</li><li>渲染进程的对布局树进行分层，分别栅格化每一层，并得到合成帧</li><li>渲染进程将合成帧信息发送给GPU进程显示到页面中</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200830094446563.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70#pic_center" alt=""></p><p>可以看到，页面的渲染其实就是<strong>浏览器将HTML文本转化为页面帧</strong>的过程。而如今我们大部分WEB应用都是使用 JavaScript 框架（Vue、React、Angular）进行页面渲染的，也就是说，在执行 JavaScript 脚本的时候，<strong>HTML页面已经开始解析并且构建DOM树</strong>了，JavaScript 脚本只是动态的改变 DOM 树的结构，使得页面成为希望成为的样子，这种渲染方式叫动态渲染，也可以叫<code>客户端渲染（client side rende）</code>。</p><p>那么什么是服务端渲染（server side render）？顾名思义，服务端渲染就是在浏览器请求页面URL的时候，服务端<strong>将我们需要的HTML文本组装好</strong>，并返回给浏览器，这个HTML文本被浏览器解析之后，<strong>不需要经过 JavaScript 脚本</strong>的执行，即可直接构建出希望的 DOM 树并展示到页面中。这个服务端组装HTML的过程，叫做<code>服务端渲染</code>。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200830094831458.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70#pic_center" alt=""></p><h4 id="服务端渲染的由来"><a href="#服务端渲染的由来" class="headerlink" title="服务端渲染的由来"></a>服务端渲染的由来</h4><p> <strong>Web1.0</strong></p><p>在没有AJAX的时候，也就是web1.0时代，几乎所有应用都是服务端渲染（此时服务器渲染非现在的服务器渲染），那个时候的页面渲染大概是这样的，浏览器请求页面URL，然后服务器接收到请求之后，到数据库查询数据，将<strong>数据丢到后端的组件模板（php、asp、jsp等）中，并渲染成HTML片段</strong>，接着服务器在组装这些HTML片段，组成一个完整的HTML，最后返回给浏览器，这个时候，浏览器已经拿到了一个完整的被服务器动态组装出来的HTML文本，然后将HTML渲染到页面中，过程没有任何JavaScript代码的参与。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200830095923257.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70#pic_center" alt=""><br><strong>客户端渲染</strong></p><p>在WEB1.0时代，服务端渲染看起来是一个当时的最好的渲染方式，但是随着业务的日益复杂和后续AJAX的出现，也渐渐开始暴露出了WEB1.0服务器渲染的缺点。</p><ul><li>每次更新页面的一小的模块，都需要重新请求一次页面，重新查一次数据库，重新组装一次HTML</li><li>前端JavaScript代码和后端（jsp、php、jsp）代码混杂在一起，使得日益复杂的WEB应用难以维护</li></ul><p>而且那个时候，根本就没有前端工程师这一职位，前端js的活一般都由后端同学 jQuery 一把梭。但是随着前端页面渐渐地复杂了之后，后端开始发现js好麻烦，虽然很简单，但是坑太多了，于是让公司招聘了一些专门写js的人，也就是前端，这个时候，前后端的鄙视链就出现了，后端鄙视前端，因为后端觉得js太简单，无非就是写写页面的特效（JS），切切图（CSS），根本算不上是真正的程序员。</p><p>随之 nodejs 的出现，前端看到了翻身的契机，为了摆脱后端的指指点点，前端开启了一场前后端分离的运动，希望可以脱离后端独立发展。前后端分离，表面上看上去是代码分离，实际上是为了前后端人员分离，也就是前后端分家，前端不再归属于后端团队。</p><p>前后端分离之后，网页开始被当成了独立的应用程序（SPA，Single Page Application），前端团队接管了所有页面渲染的事，后端团队只负责提供所有数据查询与处理的API，大体流程是这样的：首先浏览器请求URL，前端服务器直接返回一个空的静态HTML文件（不需要任何查数据库和模板组装），这个HTML文件中加载了很多渲染页面需要的 JavaScript 脚本和 CSS 样式表，浏览器拿到 HTML 文件后开始加载脚本和样式表，并且执行脚本，这个时候脚本请求后端服务提供的API，获取数据，获取完成后将数据通过JavaScript脚本动态的将数据渲染到页面中，完成页面显示。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/2020083010005345.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70#pic_center" alt=""><br>这一个前后端分离的渲染模式，也就是<code>客户端渲染（CSR）</code>。</p><p><strong>服务端渲染</strong></p><p>随着单页应用（SPA）的发展，程序员们渐渐发现<code>SEO（Search Engine Optimazition，即搜索引擎优化）</code>出了问题，而且随着应用的复杂化，JavaScript 脚本也不断的臃肿起来，使得<strong>首屏渲染</strong>相比于 Web1.0时候的服务端渲染，也慢了不少。</p><p>自己选的路，跪着也要走下去。于是前端团队选择了使用 nodejs 在服务器进行页面的渲染，进而再次出现了服务端渲染。大体流程与客户端渲染有些相似，首先是浏览器请求<code>URL</code>，前端服务器接收到URL请求之后，根据不同的URL，前端服务器向后端服务器请求数据，请求完成后，前端服务器会组装一个携带了具体数据的HTML文本，并且返回给浏览器，浏览器得到HTML之后开始渲染页面，同时，<strong>浏览器加载并执行 JavaScript 脚本，给页面上的元素绑定事件，让页面变得可交互</strong>，当用户与浏览器页面进行交互，如跳转到下一个页面时，浏览器会执行 JavaScript 脚本，向后端服务器请求数据，获取完数据之后再次执行 JavaScript 代码动态渲染页面。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200830100428984.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70#pic_center" alt=""><br><a href="https://juejin.im/post/6856321751115431944">参考：【万字长文警告】从头到尾彻底理解服务端渲染SSR原理</a></p><p><a href="https://www.zhihu.com/question/59578433/answer/326694511">参考：为什么现在又流行服务端渲染html？</a></p><p><a href="https://ssr.vuejs.org/zh/#%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E6%B8%B2%E6%9F%93-ssr-%EF%BC%9F">Vue.js 服务器端渲染指南</a></p><h4 id="服务端渲染的利弊"><a href="#服务端渲染的利弊" class="headerlink" title="服务端渲染的利弊"></a>服务端渲染的利弊</h4><p> <strong>利于SEO</strong></p><p>有利于SEO，其实就是有利于爬虫来爬你的页面，然后在别人使用搜索引擎搜索相关的内容时，你的网页排行能靠得更前，这样你的流量就有越高。那为什么服务端渲染更利于爬虫爬你的页面呢？其实，爬虫也分低级爬虫和高级爬虫。</p><ul><li>低级爬虫：只请求URL，URL返回的HTML是什么内容就爬什么内容。</li><li>高级爬虫：请求URL，加载并执行JavaScript脚本渲染页面，<strong>爬JavaScript渲染后的内容</strong>。</li></ul><p>也就是说，低级爬虫对客户端渲染的页面来说，简直无能为力，因为返回的HTML是一个空壳，它需要执行 JavaScript 脚本之后才会渲染真正的页面。而目前像百度、谷歌、微软等公司，有一部分年代老旧的爬虫还属于低级爬虫，使用服务端渲染，对这些低级爬虫更加友好一些。</p><p><strong>白屏时间更短</strong></p><p>相对于客户端渲染，服务端渲染在浏览器请求URL之后已经得到了一个带有数据的HTML文本，浏览器只需要解析HTML，直接构建DOM树就可以。而客户端渲染，需要先得到一个空的HTML页面，这个时候页面已经进入白屏，之后还需要经过加载并执行 JavaScript、请求后端服务器获取数据、JavaScript 渲染页面几个过程才可以看到最后的页面。特别是在复杂应用中，由于需要加载 JavaScript 脚本，<strong>越是复杂的应用，需要加载的 JavaScript 脚本就越多、越大，这会导致应用的首屏加载时间非常长，进而降低了体验感。</strong></p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/2020083010053151.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70#pic_center" alt=""></p><h4 id="服务端渲染缺点"><a href="#服务端渲染缺点" class="headerlink" title="服务端渲染缺点"></a>服务端渲染缺点</h4><p>并不是所有的WEB应用都必须使用SSR，这需要开发者自己来权衡，因为服务端渲染会带来以下问题：</p><ul><li><strong>代码复杂度增加</strong>。为了实现服务端渲染，应用代码中需要兼容服务端和客户端两种运行情况，而一部分依赖的外部扩展库却只能在客户端运行，需要对其进行特殊处理，才能在服务器渲染应用程序中运行。</li><li><strong>需要更多的服务器负载均衡</strong>。由于服务器增加了渲染HTML的需求，使得原本只需要输出静态资源文件的nodejs服务，新增了数据获取的IO和渲染HTML的CPU占用，如果流量突然暴增，有可能导致服务器down机，因此需要使用响应的缓存策略和准备相应的服务器负载。</li><li>涉<strong>及构建设置和部署的更多要求</strong>。与可以部署在任何静态文件服务器上的完全静态单页面应用程序 (SPA) 不同，服务器渲染应用程序，需要处于 Node.js server 运行环境。</li></ul><p>所以在使用服务端渲染SSR之前，需要开发者考虑投入产出比，比如大部分应用系统都不需要SEO，而且首屏时间并没有非常的慢，如果使用SSR反而小题大做了。</p><h4 id="同构"><a href="#同构" class="headerlink" title="同构"></a>同构</h4><p>在服务端渲染中，有两种页面渲染的方式：</p><ul><li>前端服务器通过请求后端服务器获取数据并组装HTML返回给浏览器，浏览器直接解析HTML后渲染页面</li><li>浏览器在交互过程中，请求新的数据并动态更新渲染页面</li></ul><p>这两种渲染方式有一个不同点就是，一个是在服务端中组装<code>html</code>的，一个是在客户端中组装<code>html</code>的，运行环境是不一样的。所谓<strong>同构</strong>，就是让一份代码，<strong>既可以在服务端中执行，也可以在客户端中执行，并且执行的效果都是一样的</strong>，都是完成这个html的组装，正确的显示页面。也就是说，一份代码，既可以客户端渲染，也可以服务端渲染。</p><p><strong>同构的条件</strong></p><p>为了实现同构，我们需要满足什么条件呢？</p><p>首先，我们思考一个应用中一个页面的组成，假如我们使用的是<code>Vue.js</code>，当我们打开一个页面时，首先是打开这个页面的<code>URL</code>，这个<code>URL</code>，可以通过应用的路由匹配，找到具体的页面，不同的页面有不同的视图，那么，视图是什么？从应用的角度来看，<strong>视图 = 模板 + 数据</strong>，那么在 Vue.js 中， 模板可以理解成<code>组件</code>，数据可以理解为<code>数据模型</code>，即<code>响应式数据</code>。所以，对于同构应用来说，我们<strong>必须实现客户端与服务端的路由、模型组件、数据模型的共享</strong>。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200830101713996.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70#pic_center" alt=""></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><strong>浏览器渲染</strong></p><p>单页应用用的基本都是浏览器渲染。优点很明确，后端只提供数据，前端做视图和交互逻辑，<strong>分工明确</strong>。服务器只提供接口，路由以及渲染都丢给前端，服务器计算压力变轻了。但是弱点就是<strong>用户等待时间变长</strong>了，尤其在请求数多而且有一定先后顺序的时候。</p><p><code>客户端渲染路线</code>：1. 请求一个html -&gt; 2. 服务端返回一个html -&gt; 3. 浏览器下载html里面的js/css文件 -&gt; 4. 等待js文件下载完成 -&gt; 5. 等待js加载并初始化完成 -&gt; 6. js代码终于可以运行，由js代码向后端请求数据( ajax/fetch ) -&gt; 7. 等待后端数据返回 -&gt; 8. 客户端从无到完整地，把数据渲染为响应页面</p><p><strong>服务器渲染</strong></p><p>服务器接到用户请求之后，计算出用户需要的数据，然后将数据更新成视图（也就是一串dom字符）发给客户端，客户端直接将这串字符塞进页面即可。这样做的好处是<strong>响应很快，用户体验会比较好</strong>，另外对于搜索引擎来说也是友好的，<strong>有SEO优化</strong>。nodejs层的服务器渲染，还有一个明显的好处就是<strong>前端性能优化更顺手了，可操作的空间大</strong>了。但是缺点也很明显，如果不是增加一个node层的话，前后<code>端责任分工不明，不能很好的并行开发</code>。另外也<code>增加了服务器计算压力</code>（虽然可以做渲染缓存，但毕竟是多做了计算）。</p><p><code>服务端渲染路线</code>：2. 请求一个html -&gt; 2. 服务端请求数据( 内网请求快 ) -&gt; 3. 服务器初始渲染（服务端性能好，较快） -&gt; 4. 服务端返回已经有正确内容的页面 -&gt; 5. 客户端请求js/css文件 -&gt; 6. 等待js文件下载完成 -&gt; 7. 等待js加载并初始化完成 -&gt; 8. 客户端把剩下一部分渲染完成( 内容小，渲染快 )</p><h3 id="对CDN的理解"><a href="#对CDN的理解" class="headerlink" title="对CDN的理解"></a>对CDN的理解</h3><blockquote><p>github 里面有做cdn仓库，于是扯到了cdn，之后挂钩上http缓存，浏览器缓存相关，回源那一块。</p></blockquote><h3 id="说一个最近刷的印象比较深刻的-leetcode-题目，讲讲思路"><a href="#说一个最近刷的印象比较深刻的-leetcode-题目，讲讲思路" class="headerlink" title="说一个最近刷的印象比较深刻的 leetcode 题目，讲讲思路"></a>说一个最近刷的印象比较深刻的 leetcode 题目，讲讲思路</h3><blockquote><p>leetcode 200 岛屿问题 讲了怎么dfs 沉岛</p></blockquote><h3 id="大学里面学的一些课程哪门最熟悉？"><a href="#大学里面学的一些课程哪门最熟悉？" class="headerlink" title="大学里面学的一些课程哪门最熟悉？"></a>大学里面学的一些课程哪门最熟悉？</h3><blockquote><p>算法、数据结构、计算机网络、操作系统</p></blockquote><p>选了计算机网络，毕竟是班主任教的（orz）</p><h3 id="说说五层、七层-计算机网络模型"><a href="#说说五层、七层-计算机网络模型" class="headerlink" title="说说五层、七层 计算机网络模型"></a>说说五层、七层 计算机网络模型</h3><p><a href="https://juejin.im/post/6861131647056805902">参考：详解 四层、五层、七层 计算机网络模型</a></p><h3 id="举例传输层和应用层"><a href="#举例传输层和应用层" class="headerlink" title="举例传输层和应用层"></a>举例传输层和应用层</h3><p>传输层：TCP / UDP<br>应用层：HTTP / HTTPS 、FTP、SMTP等</p><h3 id="HTTP1-0-和-HTTP2-0区别有了解吗？"><a href="#HTTP1-0-和-HTTP2-0区别有了解吗？" class="headerlink" title="HTTP1.0 和 HTTP2.0区别有了解吗？"></a>HTTP1.0 和 HTTP2.0区别有了解吗？</h3><h4 id="简要概括一下-HTTP-的特点？HTTP-有哪些缺点？"><a href="#简要概括一下-HTTP-的特点？HTTP-有哪些缺点？" class="headerlink" title="简要概括一下 HTTP 的特点？HTTP 有哪些缺点？"></a>简要概括一下 HTTP 的特点？HTTP 有哪些缺点？</h4><p><strong>HTTP 特点</strong></p><ul><li><p>灵活可扩展<br>主要体现在两个方面。一个是语义上的自由，只规定了基本格式，比如空格分隔单词，换行分隔字段，其他的各个部分都没有严格的语法限制。另一个是传输形式的多样性，不仅仅可以传输文本，还能传输图片、视频等任意数据，非常方便。</p></li><li><p>可靠传输<br>HTTP 基于 TCP/IP，因此把这一特性继承了下来。</p></li><li><p>请求-应答<br>也就是<code>一发一收、有来有回</code>， 当然这个请求方和应答方不单单指客户端和服务器之间，如果某台服务器作为代理来连接后端的服务端，那么这台服务器也会扮演请求方的角色。</p></li><li><p>无状态<br>这里的状态是指<strong>通信过程的上下文信息</strong>，而每次 http 请求都是独立、无关的，默认不需要保留状态信息。</p></li></ul><p><strong>HTTP 缺点</strong></p><ul><li>无状态</li></ul><p>所谓的优点和缺点还是要分场景来看的，对于 HTTP 而言，最具争议的地方在于它的<strong>无状态</strong>。</p><p>在<strong>需要长连接</strong>的场景中，需要保存大量的上下文信息，以免传输大量重复的信息，那么这时候无状态就是 http 的缺点了。</p><p>但与此同时，另外一些应用仅仅只是为了获取一些数据，不需要保存连接上下文信息，无状态反而<code>减少了网络开销</code>，成为了 http 的优点。</p><ul><li>明文传输</li></ul><p>即协议里的报文(主要指的是<strong>头部</strong>)不使用二进制数据，而是<strong>文本形式</strong>。<br>这当然对于调试提供了便利，但同时也让 HTTP 的报文信息暴露给了外界，给攻击者也提供了便利。<code>WIFI陷阱</code>就是利用 HTTP 明文传输的缺点，诱导你连上热点，然后疯狂抓你所有的流量，从而拿到你的敏感信息。</p><ul><li>队头阻塞问题</li></ul><p>当 http 开启长连接时，共用一个 TCP 连接，同一时刻只能处理一个请求，那么当前请求耗时过长的情况下，其它的请求只能处于阻塞状态，也就是著名的<strong>队头阻塞</strong>问题。</p><p><a href="https://juejin.im/post/6844904100035821575">参考：三元大佬（建议精读）HTTP灵魂之问，巩固你的 HTTP 知识体系</a></p><h4 id="HTTP1-1-如何解决-HTTP-的队头阻塞问题？"><a href="#HTTP1-1-如何解决-HTTP-的队头阻塞问题？" class="headerlink" title="HTTP1.1 如何解决 HTTP 的队头阻塞问题？"></a>HTTP1.1 如何解决 HTTP 的队头阻塞问题？</h4><p><strong>什么是 HTTP 队头阻塞？</strong></p><p>HTTP 传输是基于<code>请求-应答</code>的模式进行的，报文必须是一发一收，但值得注意的是，里面的任务被放在一个任务队列中串行执行，一旦队首的请求处理太慢，就会阻塞后面请求的处理。这就是著名的<code>HTTP队头阻塞</code>问题。</p><ul><li>并发连接</li></ul><p>对于一个域名允许分配多个长连接，那么相当于增加了任务队列，不至于一个队伍的任务阻塞其它所有任务。在RFC2616规定过客户端最多并发 2 个连接，不过事实上在现在的浏览器标准中，这个上限要多很多，<strong>Chrome 中是 6 个</strong>。</p><p>但其实，即使是提高了并发连接，还是不能满足人们对性能的需求。</p><ul><li>域名分片</li></ul><p>一个域名不是可以并发 6 个长连接吗？那我就多分几个域名。</p><p>比如 content1.sanyuan.com 、content2.sanyuan.com。</p><p>这样一个sanyuan.com域名下可以分出非常多的二级域名，而它们都指向同样的一台服务器，能够并发的长连接数更多了，事实上也更好地解决了队头阻塞的问题。</p><h4 id="HTTP-2-有哪些改进？"><a href="#HTTP-2-有哪些改进？" class="headerlink" title="HTTP/2 有哪些改进？"></a>HTTP/2 有哪些改进？</h4><p>由于 HTTPS 在安全方面已经做的非常好了，HTTP 改进的关注点放在了性能方面。对于 HTTP/2 而言，它对于性能的提升主要在于两点:</p><ul><li>头部压缩</li><li>多路复用</li></ul><p>当然还有一些颠覆性的功能实现:</p><ul><li>设置请求优先级</li><li>服务器推送</li></ul><p>这些重大的提升本质上也是为了解决 HTTP 本身的问题而产生的。接下来我们来看看 HTTP/2 解决了哪些问题，以及解决方式具体是如何的。</p><p><strong>头部压缩</strong></p><p>在 HTTP/1.1 及之前的时代，<strong>请求体</strong>一般会有响应的压缩编码过程，通过<code>Content-Encoding</code>头部字段来指定，但你有没有想过头部字段本身的压缩呢？当请求字段非常复杂的时候，尤其对于 GET 请求，请求报文几乎全是请求头，这个时候还是存在非常大的优化空间的。HTTP/2 针对头部字段，也采用了对应的压缩算法——HPACK，对请求头进行压缩。</p><p>HPACK 算法是专门为 HTTP/2 服务的，它主要的亮点有两个：</p><ul><li>首先是在服务器和客户端之间建立哈希表，将用到的字段存放在这张表中，那么在传输的时候对于之前出现过的值，只需要把<strong>索引</strong>(比如0，1，2，…)传给对方即可，对方拿到索引查表就行了。这种<strong>传索引</strong>的方式，可以说让请求头字段得到极大程度的精简和复用。</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200829193029877.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70#pic_center" alt=""></p><blockquote><p>HTTP/2 当中废除了起始行的概念，将起始行中的请求方法、URI、状态码转换成了头字段，不过这些字段都有一个”:”前缀，用来和其它请求头区分开。</p></blockquote><ul><li>其次是对于整数和字符串进行<strong>哈夫曼编码</strong>，哈夫曼编码的原理就是先将所有出现的字符建立一张索引表，然后让出现次数多的字符对应的索引尽可能短，传输的时候也是传输这样的<strong>索引序列</strong>，可以达到非常高的压缩率。</li></ul><p><strong>多路复用</strong></p><p>我们之前讨论了 HTTP 队头阻塞的问题，其根本原因在于HTTP 基于<code>请求-响应</code>的模型，在同一个 TCP 长连接中，前面的请求没有得到响应，后面的请求就会被阻塞。</p><p>后面我们又讨论到用<strong>并发连接</strong>和<strong>域名分片</strong>的方式来解决这个问题，但这并没有真正从 HTTP 本身的层面解决问题，只是增加了 TCP 连接，分摊风险而已。而且这么做也有弊端，多条 TCP 连接会竞争<strong>有限的带宽</strong>，让真正优先级高的请求不能优先处理。</p><p>而 HTTP/2 便从 HTTP 协议本身解决了<code>队头阻塞</code>问题。注意，这里并不是指的<code>TCP队头阻塞</code>，而是<code>HTTP队头阻塞</code>，两者并不是一回事。TCP 的队头阻塞是在<code>数据包</code>层面，单位是<code>数据包</code>，前一个报文没有收到便不会将后面收到的报文上传给 HTTP，而HTTP 的队头阻塞是在 <code>HTTP 请求-响应</code>层面，前一个请求没处理完，后面的请求就要阻塞住。两者所在的层次不一样。</p><p>那么 HTTP/2 如何来解决所谓的队头阻塞呢？</p><p><strong>二进制分帧</strong></p><p>首先，HTTP/2 认为<strong>明文传输对机器而言太麻烦</strong>了，不方便计算机的解析，因为对于文本而言会有多义性的字符，比如回车换行到底是内容还是分隔符，在内部需要用到状态机去识别，效率比较低。于是 HTTP/2 干脆把报文全部换成二进制格式，全部传输<code>01</code>串，方便了机器的解析。</p><p>原来<code>Headers + Body</code>的报文格式如今被拆分成了一个个二进制的帧，用<strong>Headers帧</strong>存放头部字段，<strong>Data帧</strong>存放请求体数据。分帧之后，服务器看到的不再是一个个完整的 HTTP 请求报文，而是一堆<strong>乱序的二进制帧</strong>。这些二进制帧不存在先后关系，因此也就<code>不会排队等待，也就没有了 HTTP 的队头阻塞问题</code>。</p><p>通信双方都可以给对方发送二进制帧，这种二进制帧的<strong>双向传输的序列</strong>，也叫做<code>流(Stream)</code>。HTTP/2 用<code>流</code>来在<strong>一个 TCP 连接上来进行多个数据帧的通信</strong>，这就是多路复用的概念。</p><blockquote><p>可能你会有一个疑问，既然是乱序首发，那最后如何来处理这些乱序的数据帧呢？</p></blockquote><p>首先要声明的是，所谓的乱序，指的是不同 ID 的 Stream 是乱序的，但同一个 Stream ID 的帧一定是按顺序传输的。二进制帧到达后对方会将 Stream ID 相同的二进制帧组装成完整的<code>请求报文</code>和<code>响应报文</code>。当然，在二进制帧当中还有其他的一些字段，实现了优先级和流量控制等功能，我们放到下一节再来介绍。</p><p><strong>服务器推送</strong></p><p>另外值得一说的是 HTTP/2 的服务器推送(Server Push)。在 HTTP/2 当中，服务器已经不再是完全被动地接收请求，响应请求，它<strong>也能新建 stream 来给客户端发送消息</strong>，当 TCP 连接建立之后，比如浏览器请求一个 HTML 文件，服务器就可以在返回 HTML 的基础上，将 HTML 中引用到的其他资源文件一起返回给客户端，<code>减少客户端的等待</code>。</p><p><strong>总结</strong></p><p>当然，HTTP/2 新增那么多的特性，是不是 HTTP 的语法要重新学呢？不需要，HTTP/2 完全兼容之前 HTTP 的语法和语义，如<strong>请求头、URI、状态码、头部字段</strong>都没有改变，完全不用担心。同时，在安全方面，HTTP 也支持 TLS，并且现在主流的浏览器都公开只支持加密的 HTTP/2, 因此你现在能看到的 HTTP/2 也基本上都是跑在<code>TLS</code> 上面的了。最后放一张分层图给大家参考:</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200829194312962.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70#pic_center" alt=""></p><h4 id="HTTP-2-中的二进制帧是如何设计的？"><a href="#HTTP-2-中的二进制帧是如何设计的？" class="headerlink" title="HTTP/2 中的二进制帧是如何设计的？"></a>HTTP/2 中的二进制帧是如何设计的？</h4><p><strong>帧结构</strong></p><p>HTTP/2 中传输的帧结构如下图所示:<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200829194349165.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70#pic_center" alt=""><br>每个帧分为<strong>帧头</strong>和<strong>帧体</strong>。先是三个字节的帧长度，这个长度表示的是<code>帧体</code>的长度。</p><p>然后是帧类型，大概可以分为<strong>数据帧</strong>和<strong>控制帧</strong>两种。数据帧用来存放 HTTP 报文，控制帧用来管理<code>流</code>的传输。</p><p>接下来的一个字节是<strong>帧标志</strong>，里面一共有 8 个标志位，常用的有 <strong>END_HEADERS</strong>表示头数据结束，<strong>END_STREAM</strong>表示单方向数据发送结束。</p><p>后 4 个字节是<code>Stream ID</code>, 也就是<code>流标识符</code>，有了它，接收方就能从乱序的二进制帧中选择出 ID 相同的帧，按顺序组装成请求/响应报文。</p><p><strong>流的状态变化</strong></p><p>从前面可以知道，在 HTTP/2 中，所谓的<code>流</code>，其实就是二进制帧的<strong>双向传输的序列</strong>。那么在 HTTP/2 请求和响应的过程中，流的状态是如何变化的呢？<br>HTTP/2 其实也是借鉴了 TCP 状态变化的思想，根据帧的标志位来实现具体的状态改变。这里我们以一个普通的<code>请求-响应过程</code>为例来说明：</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200829194937124.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70#pic_center" alt=""><br>最开始两者都是空闲状态，当客户端发送<code>Headers帧</code>后，开始分配<code>Stream ID</code>, 此时<strong>客户端的流打开</strong>, <strong>服务端接收之后服务端的流也打开</strong>，两端的流都打开之后，就可以互相传递数据帧和控制帧了。</p><p>当客户端要关闭时，向服务端发送<code>END_STREAM帧</code>，进入<strong>半关闭状态</strong>, 这个时候客户端<code>只能接收数据，而不能发送数据</code>。</p><p>服务端收到这个<code>END_STREAM帧</code>后也进入半关闭状态，不过此时服务端的情况是<strong>只能发送数据，而不能接收数据</strong>。随后服务端也向客户端发送<code>END_STREAM帧</code>，表示<strong>数据发送完毕，双方进入关闭状态</strong>。</p><p>如果下次要开启新的流，流 ID 需要自增，直到上限为止，到达上限后开一个新的 TCP 连接重头开始计数。由于流 ID 字段长度为 4 个字节，最高位又被保留，因此范围是 <code>0 ~ 2的 31 次方</code>，大约 21 亿个。</p><p><strong>流的特性</strong></p><p>刚刚谈到了流的状态变化过程，这里顺便就来总结一下流传输的特性:</p><ul><li>并发性。一个 HTTP/2 连接上可以同时发多个帧，这一点和 HTTP/1 不同。这也是实现<strong>多路复用</strong>的基础。</li><li>自增性。流 ID 是不可重用的，而是会按顺序递增，达到上限之后又新开 TCP 连接从头开始。</li><li>双向性。客户端和服务端都可以创建流，互不干扰，双方都可以作为<code>发送方</code>或者<code>接收方</code>。</li><li>可设置优先级。可以设置数据帧的优先级，让服务端先处理重要资源，优化用户体验。</li></ul><h3 id="自己搭的博客目的是什么？主要写的内容是？"><a href="#自己搭的博客目的是什么？主要写的内容是？" class="headerlink" title="自己搭的博客目的是什么？主要写的内容是？"></a>自己搭的博客目的是什么？主要写的内容是？</h3><blockquote><p>爱折腾，搭建了一个美化版的博客，主要整合前端相关知识点</p></blockquote><h3 id="询问了大学里面图像处理课程"><a href="#询问了大学里面图像处理课程" class="headerlink" title="询问了大学里面图像处理课程"></a>询问了大学里面图像处理课程</h3><blockquote><p>博客专栏里面有图像处理相关博文，问到了这个点</p></blockquote><h3 id="如何学习前端（或者说是如何学习计算机领域知识）"><a href="#如何学习前端（或者说是如何学习计算机领域知识）" class="headerlink" title="如何学习前端（或者说是如何学习计算机领域知识）"></a>如何学习前端（或者说是如何学习计算机领域知识）</h3><blockquote><p>先学好本科基础知识，锻炼思维，然后经常逛一些博客网站，例如掘金，学习优秀的人是怎样学习的，看一些书籍，比如js红宝书。另外，常逛一些b站学习一些老师教授的课程。</p></blockquote><h3 id="对未来的职业规划"><a href="#对未来的职业规划" class="headerlink" title="对未来的职业规划"></a>对未来的职业规划</h3><blockquote><p>热爱前端，干到退休（苦笑）往架构方向发展，然后面试官提到了是否未来会参与算法、人工智能相关领域。我非常赞同，也提了nodejs目前比较火热，后续也会继续学习 koa、egg框架，总之，懂的越多，不懂得更多，一直学习~</p></blockquote><h3 id="有什么问题可以询问"><a href="#有什么问题可以询问" class="headerlink" title="有什么问题可以询问"></a>有什么问题可以询问</h3><p>了解部门主要业务工作，了解部门规模</p><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><blockquote><p>感受：问题能想起来的暂时这么多，一面体验还是不错的，又增加了一些知识，还能和面试官交流一下大学学习课程，挺好的。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 面试整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 秋招 </tag>
            
            <tag> 阿里巴巴 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「腾讯-QQ音乐」秋招面试复盘总结</title>
      <link href="posts/20209021/"/>
      <url>posts/20209021/</url>
      
        <content type="html"><![CDATA[<h2 id="腾讯-QQ音乐-面经"><a href="#腾讯-QQ音乐-面经" class="headerlink" title="腾讯 QQ音乐 面经"></a>腾讯 QQ音乐 面经</h2><h3 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h3><h3 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h3><h3 id="了解ajax跨域嘛？"><a href="#了解ajax跨域嘛？" class="headerlink" title="了解ajax跨域嘛？"></a>了解ajax跨域嘛？</h3><h4 id="什么是跨域"><a href="#什么是跨域" class="headerlink" title="什么是跨域"></a>什么是跨域</h4><p>回顾一下 URI 的组成:</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200828151935234.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70#pic_center" alt=""></p><p>浏览器遵循<strong>同源政策</strong>(<code>scheme(协议)</code>、<code>host(主机)</code> 和 <code>port(端口)</code> 都相同则为同源)。非同源站点有这样一些限制:</p><ul><li>不能读取和修改对方的 DOM</li><li>不读访问对方的 Cookie、IndexDB 和 LocalStorage</li><li>限制 XMLHttpRequest 请求。(后面的话题着重围绕这个)</li></ul><p>当浏览器向目标 URI 发 Ajax 请求时，只要当前 URL 和目标 URL 不同源，则产生跨域，被称为 <code>跨域请求。</code></p><p>跨域请求的响应一般会被浏览器所拦截，注意，是被<strong>浏览器</strong>拦截，响应其实是成功到达客户端了。那这个拦截是如何发生呢？</p><p>首先要知道的是，浏览器是多进程的，以 <code>Chrome</code> 为例，进程组成如下：</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/2020082817450440.png#pic_center" alt=""><br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200828152201813.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70#pic_center" alt=""><br><strong>WebKit 渲染引擎</strong> 和 <strong>V8 引擎</strong>都在渲染进程当中。</p><p>当 <code>xhr.send</code> 被调用，即 <code>Ajax</code> 请求准备发送的时候，其实还只是在<strong>渲染进程</strong>的处理。为了防止黑客通过脚本触碰到系统资源，浏览器将每一个渲染进程装进了沙箱，并且为了防止 CPU 芯片一直存在的Spectre 和 Meltdown漏洞，采取了站点隔离的手段，给每一个不同的站点(一级域名不同)分配了沙箱，互不干扰。具体见<a href="https://www.youtube.com/watch?v=dBuykrdhK-A&feature=emb_logo">YouTube上Chromium安全团队的演讲视频</a>。</p><p>在沙箱当中的渲染进程是没有办法发送网络请求的，那怎么办？只能通过网络进程来发送。那这样就涉及到<strong>进程间通信</strong>(IPC，Inter Process Communication)了。</p><blockquote><p>总的来说就是利用<code>Unix Domain Socket</code>套接字，配合事件驱动的高性能网络并发库<code>libevent</code>完成进程的 IPC 过程。</p></blockquote><p>好，现在数据传递给了<strong>浏览器主进程</strong>，主进程接收到后，才真正地发出相应的网络请求。<br>在服务端处理完数据后，将响应返回，主进程检查到跨域，且没有<code>cors</code>(后面会详细说)响应头，将响应体全部丢掉，并不会发送给渲染进程。这就达到了拦截数据的目的。</p><h3 id="cors跨域怎么做？"><a href="#cors跨域怎么做？" class="headerlink" title="cors跨域怎么做？"></a>cors跨域怎么做？</h3><p>CORS 其实是 W3C 的一个标准，全称是 <code>跨域资源共享</code> 。它需要浏览器和服务器的共同支持，具体来说，非 IE 和 IE10 以上支持CORS，服务器需要附加特定的响应头，后面具体拆解。不过在弄清楚 CORS 的原理之前，我们需要清楚两个概念: <strong>简单请求</strong>和<strong>非简单请求</strong>。</p><p>浏览器根据请求方法和请求头的特定字段，将请求做了一下分类，具体来说规则是这样，凡是满足下面条件的属于<strong>简单请求</strong>:</p><ul><li>请求方法为 GET、POST 或者 HEAD</li><li>请求头的取值范围: Accept、Accept-Language、Content-Language、Content-Type(只限于三个值<code>application/x-www-form-urlencoded</code> 、<code>multipart/form-data</code> 、<code>text/plain</code>)</li></ul><p>浏览器画了这样一个圈，在这个圈里面的就是<strong>简单请求</strong>, 圈外面的就是<strong>非简单请求</strong>，然后针对这两种不同的请求进行不同的处理。</p><h4 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h4><p>请求发出去之前，浏览器做了什么？</p><p>它会自动在请求头当中，添加一个<code>Origin</code>字段，用来说明请求来自哪个<code>源</code>。服务器拿到请求之后，在回应时对应地添加<code>Access-Control-Allow-Origin</code>字段，如果<code>Origin</code>不在这个字段的范围中，那么浏览器就会将响应拦截。</p><p>因此，<code>Access-Control-Allow-Origin</code>字段是服务器用来决定浏览器是否拦截这个响应，这是必需的字段。与此同时，其它一些可选的功能性的字段，用来描述如果不会拦截，这些字段将会发挥各自的作用。</p><p><strong>Access-Control-Allow-Credentials</strong>。这个字段是一个布尔值，表示是否允许发送 Cookie，对于跨域请求，浏览器对这个字段<strong>默认值</strong>设为 <code>false</code>，而如果需要拿到浏览器的 Cookie，需要添加这个响应头并设为<code>true</code>, 并且在前端也需要设置<code>withCredentials</code>属性:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.withCredentials = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p><strong>Access-Control-Expose-Headers</strong>。这个字段是给 XMLHttpRequest 对象赋能，让它不仅可以拿到基本的 6 个响应头字段（包括<code>Cache-Control、Content-Language、Content-Type、Expires、Last-Modified 和 Pragma</code>）, 还能拿到这个字段声明的响应头字段。比如这样设置:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Access-Control-Expose-Headers: aaa</span><br></pre></td></tr></table></figure><p>那么在前端可以通过 <code>XMLHttpRequest.getResponseHeader(&#39;aaa&#39;)</code>拿到 <code>aaa</code> 这个字段的值。</p><h4 id="非简单请求"><a href="#非简单请求" class="headerlink" title="非简单请求"></a>非简单请求</h4><p>非简单请求相对而言会有些不同，体现在两个方面: <strong>预检请求</strong>和<strong>响应字段</strong>。</p><p>我们以 PUT 方法为例。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="string">&#x27;http://xxx.com&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.open(<span class="string">&#x27;PUT&#x27;</span>, url, <span class="literal">true</span>);</span><br><span class="line">xhr.setRequestHeader(<span class="string">&#x27;X-Custom-Header&#x27;</span>, <span class="string">&#x27;xxx&#x27;</span>);</span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure><p>当这段代码执行后，首先会发送<strong>预检请求</strong>。这个预检请求的请求行和请求体是下面这个格式:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">OPTIONS / HTTP/<span class="number">1.1</span></span><br><span class="line">Origin: 当前地址</span><br><span class="line">Host: xxx.com</span><br><span class="line">Access-Control-Request-Method: PUT</span><br><span class="line">Access-Control-Request-Headers: X-Custom-Header</span><br></pre></td></tr></table></figure><p>预检请求的方法是 <code>OPTIONS</code>，同时会加上<code>Origin</code>源地址和<code>Host</code>目标地址，这很简单。同时也会加上两个关键的字段:</p><ul><li>Access-Control-Request-Method, 列出 CORS 请求用到哪个HTTP方法</li><li>Access-Control-Request-Headers，指定 CORS 请求将要加上什么请求头</li></ul><p>这是<code>预检请求</code>。接下来是<strong>响应字段</strong>，响应字段也分为两部分，一部分是对于<strong>预检请求</strong>的响应，一部分是对于 <strong>CORS 请求</strong>的响应。</p><p><strong>预检请求的响应</strong>。如下面的格式:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</span><br><span class="line">Access-Control-Allow-Origin: *</span><br><span class="line">Access-Control-Allow-Methods: GET, POST, PUT</span><br><span class="line">Access-Control-Allow-Headers: X-Custom-Header</span><br><span class="line">Access-Control-Allow-Credentials: <span class="literal">true</span></span><br><span class="line">Access-Control-Max-Age: <span class="number">1728000</span></span><br><span class="line">Content-Type: text/html; charset=utf-<span class="number">8</span></span><br><span class="line">Content-Encoding: gzip</span><br><span class="line">Content-Length: <span class="number">0</span></span><br></pre></td></tr></table></figure><p>其中有这样几个关键的<strong>响应头字段</strong>:</p><ul><li>Access-Control-Allow-Origin: 表示可以允许请求的源，可以填具体的源名，也可以填*表示允许任意源请求。</li><li>Access-Control-Allow-Methods: 表示允许的请求方法列表。</li><li>Access-Control-Allow-Credentials: 简单请求中已经介绍。</li><li>Access-Control-Allow-Headers: 表示允许发送的请求头字段</li><li>Access-Control-Max-Age: 预检请求的有效期，在此期间，不用发出另外一条预检请求。</li></ul><p>在预检请求的响应返回后，如果请求不满足响应头的条件，则触发<code>XMLHttpRequest</code>的<code>onerror</code>方法，当然后面真正的<strong>CORS</strong>请求也不会发出去了。</p><p><strong>CORS 请求的响应</strong>。绕了这么一大转，到了真正的 CORS 请求就容易多了，现在它和<strong>简单请求</strong>的情况是一样的。浏览器自动加上<code>Origin</code>字段，服务端响应头返回<strong>Access-Control-Allow-Origin</strong>。可以参考以上简单请求部分的内容。</p><h3 id="说说jsonp原理"><a href="#说说jsonp原理" class="headerlink" title="说说jsonp原理"></a>说说jsonp原理</h3><p>虽然<code>XMLHttpRequest</code>对象遵循同源政策，但是<code>script</code>标签不一样，它可以通过 src 填上目标地址从而发出 GET 请求，实现跨域请求并拿到响应。这也就是 JSONP 的原理，接下来我们就来封装一个 JSONP:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 自定义封装jsonp */</span></span><br><span class="line"><span class="keyword">let</span> jsonp = <span class="function">(<span class="params">&#123; url, params, callbackName &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> generateUrl = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> dataStr = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> params) &#123;</span><br><span class="line">      dataStr += <span class="string">`<span class="subst">$&#123;key&#125;</span>=<span class="subst">$&#123;params[key]&#125;</span>`</span></span><br><span class="line">    &#125;</span><br><span class="line">    dataStr += <span class="string">`callback=<span class="subst">$&#123;callbackName&#125;</span>`</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;url&#125;</span>?<span class="subst">$&#123;dataStr&#125;</span>`</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 创建 script 元素并加入到当前文档中</span></span><br><span class="line">    <span class="keyword">let</span> scriptEle = <span class="built_in">document</span>.createElemet(<span class="string">&#x27;script&#x27;</span>)</span><br><span class="line">    script.src = generateUrl</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(scriptEle)</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      resolve(data)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      reject(e)</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// script 执行完了，成为无用元素，需要清除</span></span><br><span class="line">      <span class="built_in">document</span>.body.removeChild(scriptEle)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然在服务端也会有响应的操作, 以 <strong>express</strong> 为例:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 服务端相关操作，以express为例 */</span></span><br><span class="line"><span class="keyword">let</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> app = express()</span><br><span class="line"><span class="keyword">const</span> port = <span class="string">&#x27;3000&#x27;</span></span><br><span class="line">app.get(<span class="string">&#x27;/&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> &#123;a,b,callback&#125; = req.query</span><br><span class="line">  <span class="built_in">console</span>.log(a)</span><br><span class="line">  <span class="built_in">console</span>.log(b)</span><br><span class="line">  <span class="comment">// 注意，返回给script标签，浏览器直接把这部分字符串执行</span></span><br><span class="line">  res.send(<span class="string">`<span class="subst">$&#123;callback&#125;</span>(&#x27;数据包&#x27;)`</span>)</span><br><span class="line">&#125;)</span><br><span class="line">app;listen(port)</span><br></pre></td></tr></table></figure><p>前端这样简单地调用一下就好了:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 前端调用 */</span></span><br><span class="line">jsonp(&#123;</span><br><span class="line">  url: <span class="string">&#x27;http://localhost:3000&#x27;</span>,</span><br><span class="line">  params: &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    b: <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;).then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data) <span class="comment">//该数据包</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>和<code>CORS</code>相比，JSONP 最大的优势在于兼容性好，IE 低版本不能使用 CORS 但可以使用 JSONP，缺点也很明显，请求方法单一，只支持 GET 请求。</p><h4 id="拓展：Nginx"><a href="#拓展：Nginx" class="headerlink" title="拓展：Nginx"></a>拓展：Nginx</h4><p><code>Nginx</code> 是一种高性能的 <code>反向代理</code> 服务器，可以用来轻松解决跨域问题。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200828165451492.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70#pic_center" alt=""></p><p>正向代理帮助客户端<strong>访问</strong>客户端自己访问不到的服务器，然后将结果返回给客户端。</p><p>反向代理拿到客户端的请求，将请求转发给其他的服务器，主要的场景是维持服务器集群的<strong>负载均衡</strong>，换句话说，反向代理帮<strong>其它的服务器</strong>拿到请求，然后<strong>选择一个合适</strong>的服务器，将请求转交给它。</p><p>因此，两者的区别就很明显了，正向代理服务器是帮<strong>客户端</strong>做事情，而反向代理服务器是帮其它的<strong>服务器</strong>做事情。</p><p>好了，那 <code>Nginx</code> 是如何来解决跨域的呢？</p><p>比如说现在客户端的域名为 <code>client.com</code>，服务器的域名为 <code>server.com</code>，客户端向服务器发送 <code>Ajax</code> 请求，当然会跨域了，那这个时候让 <code>Nginx</code> 登场了，通过下面这个配置:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen  <span class="number">80</span>;</span><br><span class="line">  server_name  client.com;</span><br><span class="line">  location /api &#123;</span><br><span class="line">    proxy_pass server.com;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Nginx 相当于起了一个跳板机，这个跳板机的域名也是 <code>client.com</code>，让客户端首先访问 <code>client.com/api</code>，这当然没有跨域，然后 Nginx 服务器作为反向代理，将请求转发给 <code>server.com</code>，当响应返回时又将响应给到客户端，这就完成整个跨域请求的过程。</p><blockquote><p>还有一些不太常用的方式，了解即可，比如postMessage，当然WebSocket也是一种方式，但是已经不属于 HTTP 的范畴。</p></blockquote><h3 id="如果是用node来做跨域的话，你会怎么做？"><a href="#如果是用node来做跨域的话，你会怎么做？" class="headerlink" title="如果是用node来做跨域的话，你会怎么做？"></a>如果是用node来做跨域的话，你会怎么做？</h3><blockquote><p>(1) 浏览器会自动进行 CORS 通信，实现 CORS 通信的关键是后端。只要后端实现了<br>CORS，就实现了跨域。<br>(2) 服务端设置 Access-Control-Allow-Origin 就可以开启 CORS。 该属性表示哪些域名可以访<br>问资源，如果设置通配符(*)则表示所有网站都可以访问资源。<br>(3)设置 CORS 和前端没什么关系，但是通过这种方式解决跨域问题的话，会在发送请求时出现两种情况，分<br>别为简单请求和复杂请求。（上文已经提到）</p></blockquote><h4 id="先以-express-为例"><a href="#先以-express-为例" class="headerlink" title="先以 express 为例"></a>先以 <code>express</code> 为例</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//allow custom header and CORS</span></span><br><span class="line">app.all(<span class="string">&#x27;*&#x27;</span>,<span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  res.header(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">  res.header(<span class="string">&#x27;Access-Control-Allow-Headers&#x27;</span>, <span class="string">&#x27;Content-Type, Content-Length, Authorization, Accept, X-Requested-With , yourHeaderFeild&#x27;</span>);</span><br><span class="line">  res.header(<span class="string">&#x27;Access-Control-Allow-Methods&#x27;</span>, <span class="string">&#x27;PUT, POST, GET, DELETE, OPTIONS&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (req.method == <span class="string">&#x27;OPTIONS&#x27;</span>) &#123;</span><br><span class="line">    res.send(<span class="number">200</span>); <span class="regexp">/让options请求快速返回/</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    next();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>介绍一个 <code>cors</code> 模块,引入就可以解决了。代码如下:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* express引入cors模块 */</span></span><br><span class="line"><span class="keyword">let</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> cors = <span class="built_in">require</span>(<span class="string">&#x27;cors&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> app = express()</span><br><span class="line"></span><br><span class="line">app.use(cors())</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">&#x27;/products/:id&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  res.json(&#123; <span class="attr">msg</span>: <span class="string">&#x27;This is CORS-enabled for all origins!&#x27;</span> &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">80</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;CORS-enabled web server listening on port 80&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="然后，我们再以-koa-为例"><a href="#然后，我们再以-koa-为例" class="headerlink" title="然后，我们再以 koa 为例"></a>然后，我们再以 <code>koa</code> 为例</h4><p><strong>服务端: 3001端口</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Koa = <span class="built_in">require</span>(<span class="string">&#x27;koa&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> Router = <span class="built_in">require</span>(<span class="string">&#x27;koa-router&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> bodyParser = <span class="built_in">require</span>(<span class="string">&#x27;koa-bodyparser&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"><span class="keyword">var</span> router = <span class="keyword">new</span> Router();</span><br><span class="line"></span><br><span class="line">app.use(bodyParser()); <span class="comment">// 解析body数据</span></span><br><span class="line">router.options(<span class="string">&#x27;/test&#x27;</span>,<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  ctx.set(<span class="string">&quot;Access-Control-Allow-Origin&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">  ctx.set(<span class="string">&quot;Access-Control-Allow-Headers&quot;</span>, <span class="string">&quot;Content-Type&quot;</span>);</span><br><span class="line">  ctx.set(<span class="string">&quot;Access-Control-Allow-Methods&quot;</span>,<span class="string">&quot;PUT,POST,GET,DELETE,OPTIONS&quot;</span>);</span><br><span class="line">  ctx.set(<span class="string">&#x27;Access-Control-Allow-Credentials&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line">  ctx.set(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json;charset=utf-8&quot;</span>);</span><br><span class="line">  ctx.status = <span class="number">204</span>;</span><br><span class="line">&#125;);</span><br><span class="line">router.post(<span class="string">&#x27;/test&#x27;</span>,<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="comment">// ctx.router available</span></span><br><span class="line">  ctx.set(<span class="string">&quot;Access-Control-Allow-Origin&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">  ctx.set(<span class="string">&quot;Access-Control-Allow-Headers&quot;</span>, <span class="string">&quot;Content-Type&quot;</span>);</span><br><span class="line">  ctx.set(<span class="string">&quot;Access-Control-Allow-Methods&quot;</span>,<span class="string">&quot;PUT,POST,GET,DELETE,OPTIONS&quot;</span>);</span><br><span class="line">  ctx.set(<span class="string">&#x27;Access-Control-Allow-Credentials&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line">  ctx.set(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json;charset=utf-8&quot;</span>);</span><br><span class="line">  ctx.body = &#123;</span><br><span class="line">    status: <span class="string">&#x27;success&#x27;</span>,</span><br><span class="line">    result: ctx.request.body</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app</span><br><span class="line">  .use(router.routes())</span><br><span class="line">  .use(router.allowedMethods());</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3001</span>);</span><br></pre></td></tr></table></figure><p><strong>客户端:</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;en&quot;</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">  &lt;meta name=<span class="string">&quot;viewport&quot;</span> content=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br><span class="line">  &lt;meta http-equiv=<span class="string">&quot;X-UA-Compatible&quot;</span> content=<span class="string">&quot;ie=edge&quot;</span>&gt;</span><br><span class="line">  &lt;title&gt;测试&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    fetch(<span class="string">&#x27;http://localhost:3001/test&#x27;</span>, &#123;</span><br><span class="line">      method: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">      headers: &#123;</span><br><span class="line">        <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json;charset=utf-8&#x27;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      body: <span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">        data: <span class="string">&#x27;Test&#x27;</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(data);</span><br><span class="line">    &#125;)</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><code>koa</code> 也有个 <code>cors</code> 模块.代码如下:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* koa引入cors模块 */</span></span><br><span class="line"><span class="keyword">var</span> koa = <span class="built_in">require</span>(<span class="string">&#x27;koa&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> route = <span class="built_in">require</span>(<span class="string">&#x27;koa-route&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> cors = <span class="built_in">require</span>(<span class="string">&#x27;koa-cors&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> app = koa()</span><br><span class="line"></span><br><span class="line">app.use(cors())</span><br><span class="line"></span><br><span class="line">app.use(</span><br><span class="line">  route.get(<span class="string">&#x27;/&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.body = &#123; <span class="attr">msg</span>: <span class="string">&#x27;Hello World!&#x27;</span> &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">)</span><br><span class="line">app.listen(<span class="number">3000</span>)</span><br></pre></td></tr></table></figure><h3 id="怎样给一个新增的dom节点绑定事件？（询问事件代理的作用）"><a href="#怎样给一个新增的dom节点绑定事件？（询问事件代理的作用）" class="headerlink" title="怎样给一个新增的dom节点绑定事件？（询问事件代理的作用）"></a>怎样给一个新增的dom节点绑定事件？（询问事件代理的作用）</h3><h4 id="事件委托-事件代理-的作用"><a href="#事件委托-事件代理-的作用" class="headerlink" title="事件委托(事件代理)的作用?"></a>事件委托(事件代理)的作用?</h4><ul><li>支持为同一个DOM元素注册多个同类型事件</li><li>可将事件分成事件捕获和事件冒泡机制</li></ul><p><strong>注册多个事件</strong></p><blockquote><p>用以往注册事件的方法,如果存在多个事件,后注册的事件会覆盖先注册的事件</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//index.html</span></span><br><span class="line">&lt;div id=<span class="string">&quot;div1&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> div1 = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;div1&#x27;</span>);</span><br><span class="line">    div1.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;打印第一次&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    div1.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;打印第二次&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200828191356247.png#pic_center" alt=""></p><blockquote><p>可以看到第二个点击注册事件覆盖了第一个注册事件,只执行了console.log(‘打印第二次’);</p></blockquote><p>用 <code>addEventListener(type,listener,useCapture)</code>实现</p><ul><li>type: 必须,String类型,事件类型</li><li>listener: 必须,函数体或者JS方法</li><li>useCapture: 可选,boolean类型。指定事件是否发生在捕获阶段。<strong>默认</strong>为false,事件发生在<strong>冒泡</strong>阶段</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;div1&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> div1 = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;div1&#x27;</span>);</span><br><span class="line">    div1.addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;打印第一次&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    div1.addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;打印第二次&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200828191501273.png#pic_center" alt=""></p><blockquote><p>可以看到两个注册事件都成功触发了。 useCapture是事件委托的关键,我们后面详解</p></blockquote><p><strong>事件捕获和事件冒泡机制</strong></p><p>事件捕获</p><p>当一个事件触发后,从Window对象触发,不断<strong>经过下级节点,直到目标节点</strong>。在事件到达目标节点之前的过程就是捕获阶段。<code>所有经过的节点,都会触发对应的事件</code></p><p>事件冒泡</p><p>当事件到达目标节点后，会<strong>沿着捕获阶段的路线原路返回</strong>。同样，<code>所有经过的节点,都会触发对应的事件</code></p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200828191703820.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70#pic_center" alt=""><br>通过例子理解两个事件机制:<br>例子：假设有body和body节点下的div1均有绑定了一个注册事件.<br>效果：</p><ul><li>当为事件捕获(useCapture:true)时,先执行body的事件,再执行div的事件<ul><li>当为事件冒泡(useCapture:false)时,先执行div的事件,再执行body的事件</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当useCapture为默认false时,为事件冒泡</span></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=<span class="string">&quot;div1&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> body = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;body&#x27;</span>);</span><br><span class="line">    <span class="keyword">let</span> div1 = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;div1&#x27;</span>);</span><br><span class="line">    body.addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;打印body&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    div1.addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;打印div1&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果:打印div1  打印body</span></span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200828191807616.png#pic_center" alt=""></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当useCapture为true时,为事件捕获</span></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=<span class="string">&quot;div1&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> body = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;body&#x27;</span>);</span><br><span class="line">    <span class="keyword">let</span> div1 = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;div1&#x27;</span>);</span><br><span class="line">    body.addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;打印body&#x27;</span>)</span><br><span class="line">    &#125;,<span class="literal">true</span>)</span><br><span class="line">    div1.addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;打印div1&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果:打印body   打印div1</span></span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200828191818232.png#pic_center" alt=""></p><h4 id="事件委托和新增节点绑定事件的关系？"><a href="#事件委托和新增节点绑定事件的关系？" class="headerlink" title="事件委托和新增节点绑定事件的关系？"></a>事件委托和新增节点绑定事件的关系？</h4><p>事件委托的优点:</p><ul><li><strong>提高性能</strong>: 每一个函数都会占用内存空间，只需添加一个事件处理程序代理所有事件,所占用的内存空间更少。</li><li><strong>动态监听</strong>: 使用事件委托可以<strong>自动绑定动态添加的元素</strong>,即新增的节点不需要主动添加也可以一样具有和其他元素一样的事件。</li></ul><p>例子解析:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> div = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">        </span><br><span class="line">        div.addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(e.target)</span><br><span class="line">        &#125;)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> div3 = <span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">        div3.setAttribute(<span class="string">&#x27;class&#x27;</span>,<span class="string">&#x27;div3&#x27;</span>)</span><br><span class="line">        div3.innerHTML = <span class="string">&#x27;div3&#x27;</span>;</span><br><span class="line">        div.appendChild(div3)</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=<span class="string">&quot;div&quot;</span>&gt;</span><br><span class="line">        &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;div1&quot;</span>&gt;div1&lt;/div&gt;</span><br><span class="line">        &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;div2&quot;</span>&gt;div2&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><blockquote><p>虽然没有给div1和div2添加点击事件,但是无论是点击div1还是div2,都会打印当前节点。因为其父级绑定了点击事件,点击div1后冒泡上去的时候,执行父级的事件。</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200828192241244.png#pic_center" alt=""></p><blockquote><p>这样无论后代新增了多少个节点,一样具有这个点击事件的功能。</p></blockquote><h3 id="了解浏览器缓存吗？（强缓存、协商缓存）你怎样更新强缓存呢？"><a href="#了解浏览器缓存吗？（强缓存、协商缓存）你怎样更新强缓存呢？" class="headerlink" title="了解浏览器缓存吗？（强缓存、协商缓存）你怎样更新强缓存呢？"></a>了解浏览器缓存吗？（强缓存、协商缓存）你怎样更新强缓存呢？</h3><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200829085756205.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70#pic_center" alt=""></p><h4 id="1-强缓存"><a href="#1-强缓存" class="headerlink" title="1.强缓存"></a>1.强缓存</h4><p>强缓存是指直接通过本地缓存获取资源，不用经过服务器</p><p>常用字段：</p><ul><li>expires<br>值为一个绝对时间的 GMT 格式的时间字符串，如果发送请求的时间在 expires 之前，那么本地缓存有效，否则就会发送请求到服务器来获取资源。</li></ul><p>缺点：无法保证客户端按照标准时间设定</p><ul><li>Cache-Control(常用值如下)：</li></ul><p>max-age：允许的最大缓存秒数<br>no-store：不允许使用缓存，<strong>每次都要向服务器获取</strong><br>no-cache：不允许使用本地缓存，<strong>每次都要向服务器进行协商缓存</strong><br>public：允许被<strong>所有</strong>中间代理和终端浏览器缓存<br>private：只允许被终端浏览器缓存<br>Cache-Control 比 expires 优先级高</p><h4 id="2-协商缓存"><a href="#2-协商缓存" class="headerlink" title="2.协商缓存"></a>2.协商缓存</h4><p>协商缓存是指客户端<strong>向服务端确认资源是否用</strong></p><p>常用字段：</p><ul><li>Last-Modified / If-Modified-Since：</li></ul><p>值是 GMT 格式的时间字符串，具体流程如下：</p><p>浏览器第一次请求资源，服务端返回 <code>Last-Modified</code>，表示资源在服务端的最后修改时间。<br>浏览器第二次请求的时候会在请求头上携带<code>If-Modified-Since</code>，值为上次返回的 <code>Last-Modified</code><br>服务端收到请求后，比较保存的 <code>Last-Modified</code> 和 请求报文中的 <code>If-Modified-Since</code>，如果一致就返回 304 状态码，不一致就返回新资源，同时更新 <code>Last-Modified</code> 值</p><ul><li>ETag / If-None-Match</li></ul><p>值是服务器生成的资源标识符，当资源修改后这个值会被改变，</p><p>具体流程与 <code>Last-Modified、If-Modified-Since</code> 相似，但与 <code>Last-Modified</code> 不一样的是，当服务器返回304的响应时，由于 ETag 重新生成过，<code>response header</code>中还会把这个 ETag 返回，即使这个 ETag 跟之前的没有变化。</p><h4 id="既生-Last-Modified-何生-Etag"><a href="#既生-Last-Modified-何生-Etag" class="headerlink" title="既生 Last-Modified 何生 Etag"></a>既生 Last-Modified 何生 Etag</h4><ul><li><p>一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，我们就可以使用 <code>Etag</code> 来做</p></li><li><p>某些文件修改非常频繁，比如在<strong>秒以下的时间内</strong>进行修改，(比方说1s内修改了N次)，<code>If-Modified-Since</code> 能检查到的粒度是s级的，这种修改无法判断</p></li></ul><h4 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h4><blockquote><p>缓存的意义就在于<code>减少请求</code>，更多地使用本地的资源，给用户更好的体验的同时，也减轻服务器压力。所以，最佳实践，就应该是尽可能命中强缓存，同时，能在更新版本的时候让客户端的缓存失效。</p></blockquote><p>在更新版本之后，如何让用户第一时间使用最新的资源文件呢？机智的前端们想出了一个方法，在更新版本的时候，顺便<strong>把静态资源的路径</strong>改了，这样，就相当于第一次访问这些资源，就不会存在缓存的问题了。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200829085935300.png#pic_center" alt=""><br>伟大的<strong>webpack</strong>可以让我们在打包的时候，在文件的命名上带上 <code>hash</code> 值</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">entry:&#123;</span><br><span class="line">    main: path.join(__dirname,<span class="string">&#x27;./main.js&#x27;</span>),</span><br><span class="line">    vendor: [<span class="string">&#x27;react&#x27;</span>, <span class="string">&#x27;antd&#x27;</span>]</span><br><span class="line">&#125;,</span><br><span class="line">output:&#123;</span><br><span class="line">    path:path.join(__dirname,<span class="string">&#x27;./dist&#x27;</span>),</span><br><span class="line">    publicPath: <span class="string">&#x27;/dist/&#x27;</span>,</span><br><span class="line">    filname: <span class="string">&#x27;bundle.[chunkhash].js&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>综上所述，我们可以得出一个较为合理的缓存方案：</p><ul><li>HTML：使用协商缓存。</li><li>CSS&amp;JS&amp;图片：使用强缓存，文件命名带上hash值。</li></ul><h4 id="哈希值计算方式"><a href="#哈希值计算方式" class="headerlink" title="哈希值计算方式"></a>哈希值计算方式</h4><p>webpack给我们提供了三种哈希值计算方式，分别是 <code>hash</code> 、<code>chunkhash</code> 和 <code>contenthash</code>。那么这三者有什么区别呢？</p><ul><li>hash：跟整个项目的构建相关，构建生成的文件hash值都是一样的，只要项目里有文件更改，整个项目构建的hash值都会更改。</li><li>chunkhash：根据不同的入口文件(Entry)进行依赖文件解析、构建对应的chunk，生成对应的hash值。</li><li>contenthash：由文件内容产生的hash值，内容不同产生的contenthash值也不一样。</li></ul><blockquote><p>显然，我们是不会使用第一种的。改了一个文件，打包之后，其他文件的hash都变了，缓存自然都失效了。这不是我们想要的。</p></blockquote><p>那<code>chunkhash</code> 和 <code>contenthash</code> 的主要应用场景是什么呢？在实际在项目中，我们一般会把项目中的<code>css</code>都抽离出对应的<strong>css文件</strong>来加以引用。如果我们使用chunkhash，当我们改了css代码之后，会发现css文件hash值改变的同时，js文件的hash值也会改变。这时候，contenthash就派上用场了。</p><h4 id="补充：后端需要怎么设置"><a href="#补充：后端需要怎么设置" class="headerlink" title="补充：后端需要怎么设置"></a>补充：后端需要怎么设置</h4><p>上文主要说的是前端如何进行打包，那后端怎么做呢？ 我们知道，浏览器是根据响应头的相关字段来决定缓存的方案的。所以，后端的关键就在于，根据不同的请求返回对应的缓存字段。 以<code>nodejs</code>为例，如果<strong>需要浏览器强缓存</strong>，我们可以这样设置：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">res.setHeader(<span class="string">&#x27;Cache-Control&#x27;</span>, <span class="string">&#x27;public, max-age=xxx&#x27;</span>);</span><br></pre></td></tr></table></figure><p>如果需要协商缓存，则可以这样设置：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">res.setHeader(<span class="string">&#x27;Cache-Control&#x27;</span>, <span class="string">&#x27;public, max-age=0&#x27;</span>);</span><br><span class="line">res.setHeader(<span class="string">&#x27;Last-Modified&#x27;</span>, xxx);</span><br><span class="line">res.setHeader(<span class="string">&#x27;ETag&#x27;</span>, xxx);</span><br></pre></td></tr></table></figure><blockquote><p>在做前端缓存时，我们尽可能设置长时间的强缓存，通过文件名加hash的方式来做版本更新。在代码分包的时候，应该将一些不常变的公共库独立打包出来，使其能够更持久的缓存。</p></blockquote><h4 id="HTTP缓存"><a href="#HTTP缓存" class="headerlink" title="HTTP缓存"></a>HTTP缓存</h4><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/2020082909125616.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70#pic_center" alt=""></p><h4 id="缓存配置"><a href="#缓存配置" class="headerlink" title="缓存配置"></a>缓存配置</h4><p>方案如下：</p><ul><li>方案1：cache-control: no-store：不缓存，每次访问都从服务下载所有资源。</li><li>方案2：cache-control: no-cache或cache-control: max-age=0：对比缓存，缓存当前资源，但每次访问都需要跟服务器对比，检查资源是否被修改。（等同于expires = 过去的时间或无效时间，缓存但立即过期）</li><li>方案3：cache-control: max-age=seconds //seconds &gt; 0：强缓存，缓存当前资源，在一定时期内，再次请求资源直接读取本地缓存。</li></ul><blockquote><p>注：强缓存下资源也并非不可更新，例如chrome的<code>ctrl + f5</code>等同于直接触发方案1，f5或者webview的刷新键会直接触发方案2，但都是基于客户端操作，不建议纳入实际项目考虑。</p></blockquote><blockquote><p>实际项目中，方案1的应用基本上看不到，对比方案2和方案3，方案1没有任何优势。在方案2和方案3的选择中，我们会对资源作区分。</p></blockquote><ul><li><p>对于<code>img，css，js，fonts</code>等非html资源，我们可以直接考虑方案3，并且max-age配置的时间可以尽可能久，类似于缓存规则案例中，<code>cache-control: max-age=31535000</code> 配置365天的缓存，需要注意的是，这样配置并不代表这些资源就一定一年不变，其根本原因在于目前前端构建工具在静态资源中都会加入戳的概念（例如，webpack中的[hash]，gulp中的gulp-rev），<strong>每次修改均会改变文件名或增加query参数，本质上改变了请求的地址</strong>，也就不存在缓存更新的问题。</p></li><li><p>对于<code>html</code>资源，我们建议根据项目的更新频度来确定采用哪套方案。html作为前端资源的入口文件，一旦被强缓存，那么相关的js，css，img等均无法更新。对于<strong>高频维护的业务类</strong>项目，建议采用方案2，或是方案3但max-age设置一个较小值，例如3600，一小时过期。对于一些活动项目，上线后<strong>不会进行较大改动，建议采用方案3</strong>，不过max-age也不要设置过大，否则一旦出现bug或是未知问题，用户无法及时更新。</p></li></ul><blockquote><p>除了以上考虑，有时候其他因素也会影响缓存的配置，例如<code>QQ红包除夕活动</code>，高并发大流量很容易给服务器带来极大挑战，这时我们作为前端开发，就可以采用方案3来避免用户多次进入带来的流量压力。</p></blockquote><blockquote><p>对于http缓存的配置，我们始终要做到两点，一是清楚明白http缓存的原理与规则，二是明确<code>缓存的配置不是一次性的</code>，根据不同的情况配置不同的规则，才能够更好的发挥http缓存的价值。</p></blockquote><h4 id="cdn缓存"><a href="#cdn缓存" class="headerlink" title="cdn缓存"></a>cdn缓存</h4><blockquote><p>cdn缓存是一种服务端缓存，CDN服务商将源站的资源缓存到遍布全国的高性能加速节点上，当用户访问相应的业务资源时，用户会被调度至最接近的节点最近的节点ip返回给用户，在web性能优化中，它主要起到了，缓解源站压力，优化不同用户的访问速度与体验的作用。</p></blockquote><h4 id="缓存规则"><a href="#缓存规则" class="headerlink" title="缓存规则"></a>缓存规则</h4><p>与http缓存规则不同的是，这个规则并不是规范性的，而是由cdn服务商来制定，我们以腾讯云举例，打开cdn加速服务配置，面板如下。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200829093146111.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70#pic_center" alt=""><br>可以看到，提供给我们的配置项只有文件类型（或文件目录）和刷新时间，意义也很简单，针对不同文件类型，在cdn节点上缓存对应的时间。</p><h4 id="cdn运作流程"><a href="#cdn运作流程" class="headerlink" title="cdn运作流程"></a>cdn运作流程</h4><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200829093208366.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70#pic_center" alt=""><br>由图我们可以看出，cdn缓存的配置主要作用在缓存处理阶段，虽然配置项只有文件类型和缓存时间，但流程却并不简单，我们先来明确一个概念——<strong>回源</strong>，回源的意思就是<strong>返回源站，何为源站，就是我们自己的服务器</strong>，很多人误解接入cdn就是把资源放在了cdn上，其实不然，如图中所示，接入cdn后，我们的服务器就是源站，源站一般情况下只会在cdn节点没有资源或cdn资源失效时接收到cdn节点的请求，其他时间，源站并不会接收请求（当然，如果我们知道源站的地址，我们可以直接访问源站）。明确了回源的概念后，cdn的流程就显得不那么复杂了，简单的理解就是， <strong>没有资源就去源站读取，有资源就直接发送给用户。</strong> 与http缓存不同的是，cdn中没有no-cache（max-age=0）的情况，当我们设置缓存时间为0的时候，该类型文件就被认定为不缓存文件，就是所有请求直接转发源站，<strong>只有当缓存时间大于0且缓存过期的时候，才会与源站对比缓存是否被修改。</strong></p><h4 id="缓存配置-1"><a href="#缓存配置-1" class="headerlink" title="缓存配置"></a>缓存配置</h4><blockquote><p>各个cdn服务商并不完全一致，以腾讯云为例，在缓存配置的文档中特别有以下说明。</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200829093344364.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70#pic_center" alt=""><br>这会对我们有什么影响呢？</p><ul><li><p>如果我们http缓存设置cache-control: max-age=600，即缓存10分钟，但cdn缓存配置中设置文件缓存时间为1小时，那么就会出现如下情况，文件被访问后第12分钟修改并上传到服务器，用户重新访问资源，响应码会是304，对比缓存未修改，资源依然是旧的，一个小时后再次访问才能更新为最新资源</p></li><li><p>如果不设置cache-control呢，在http缓存中我们说过，如果不设置cache-control，那么会有默认的缓存时间，但在这里，cdn服务商明确会在没有cache-control字段时主动帮我们添加cache-control: max-age=600。</p></li></ul><p>注：针对问题1，也并非没有办法，当我们必须要在缓存期内修改文件，并且不想影响用户体验，那么我们可以<strong>使用cdn服务商提供的强制更新缓存功能</strong>，主要注意的是，这里的强制更新是更新服务端缓存，<strong>http缓存</strong>依然按照http头部规则进行自己的缓存处理，并<strong>不会受到影响</strong>。</p><h4 id="http缓存与cdn缓存的结合"><a href="#http缓存与cdn缓存的结合" class="headerlink" title="http缓存与cdn缓存的结合"></a>http缓存与cdn缓存的结合</h4><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200829093529114.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70#pic_center" alt=""><br>当用户访问我们的业务服务器时，首先进行的就是http缓存处理，如果http缓存通过校验，则直接响应给用户，如果<strong>未通过校验，则继续进行cdn缓存</strong>的处理，cdn缓存处理完成后返回给客户端，由客户端进行http缓存规则存储并响应给用户。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><strong>CDN的原理</strong></p><p>首先，浏览器会先请求CDN域名，CDN域名服务器会给浏览器返回指定域名的CNAME，浏览器在对这些CNAME进行解析，得到CDN缓存服务器的IP地址，浏览器在去请求缓存服务器，CDN缓存服务器根据内部专用的DNS解析得到实际IP，然后缓存服务器会向实际IP地址请求资源，缓存服务器得到资源后进行本地保存和返回给浏览器客户端。</p><h3 id="如何检测JS错误，如何保证你的产品质量？（错误监控）（仅仅答了window-onerror）跨域的js运行错误可以捕获吗，错误提示什么，应该怎么处理？"><a href="#如何检测JS错误，如何保证你的产品质量？（错误监控）（仅仅答了window-onerror）跨域的js运行错误可以捕获吗，错误提示什么，应该怎么处理？" class="headerlink" title="如何检测JS错误，如何保证你的产品质量？（错误监控）（仅仅答了window.onerror）跨域的js运行错误可以捕获吗，错误提示什么，应该怎么处理？"></a>如何检测JS错误，如何保证你的产品质量？（错误监控）（仅仅答了window.onerror）跨域的js运行错误可以捕获吗，错误提示什么，应该怎么处理？</h3><h4 id="script-error-由来"><a href="#script-error-由来" class="headerlink" title="script error 由来"></a>script error 由来</h4><p>我们的页面往往将静态资源（ js、css、image ）存放到第三方 CDN，或者依赖于外部的静态资源。当从<strong>第三方加载的 javascript 执行出错</strong>时，由于同源策略，为了<code>保证用户信息不被泄露，不会返回详细的错误信息</code>，取之返回 script error。</p><p>webkit 源码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">bool ScriptExecutionContext::<span class="function"><span class="title">sanitizeScriptError</span>(<span class="params"><span class="built_in">String</span>&amp; errorMessage, int&amp; lineNumber, <span class="built_in">String</span>&amp; sourceURL</span>)</span> &#123;</span><br><span class="line">  KURL targetURL = completeURL(sourceURL);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (securityOrigin()-&gt;canRequest(targetURL)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">// 非同源，将相关的错误信息设置成默认，错误信息置为 Script error，行号置成0</span></span><br><span class="line">  errorMessage = <span class="string">&quot;Script error.&quot;</span>;</span><br><span class="line">  sourceURL = <span class="built_in">String</span>();</span><br><span class="line">  ineNumber = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool ScriptExecutionContext::<span class="function"><span class="title">dispatchErrorEvent</span>(<span class="params"><span class="keyword">const</span> <span class="built_in">String</span>&amp; errorMessage, int lineNumber, <span class="keyword">const</span> <span class="built_in">String</span>&amp; sourceURL</span>)</span> &#123;</span><br><span class="line">  EventTarget* target = errorEventTarget();</span><br><span class="line">  <span class="keyword">if</span> (!target) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="built_in">String</span> message = errorMessage;</span><br><span class="line">  int line = lineNumber;</span><br><span class="line">  <span class="built_in">String</span> sourceName = sourceURL;</span><br><span class="line">  sanitizeScriptError(message, line, sourceName);</span><br><span class="line">  ASSERT(!m_inDispatchErrorEvent);</span><br><span class="line">  m_inDispatchErrorEvent = <span class="literal">true</span>;</span><br><span class="line">  RefPtr&lt;ErrorEvent&gt; errorEvent = ErrorEvent::create(message, sourceName, line);</span><br><span class="line">  target-&gt;dispatchEvent(errorEvent);</span><br><span class="line">  m_inDispatchErrorEvent = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> errorEvent-&gt;defaultPrevented();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="常见的解决方案"><a href="#常见的解决方案" class="headerlink" title="常见的解决方案"></a>常见的解决方案</h4><ul><li>开启 CORS 跨域资源共享</li></ul><p>a) 添加 crossorigin=”anonymous” 属性：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;http://domain/path/*.js&quot;</span> crossorigin=<span class="string">&quot;anonymous&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>当有 crossorigin=”anonymous”，浏览器以匿名的方式获取目标脚本，请求脚本时不会向服务器发送用户信息（ cookie、http 证书等）。</p><p>b) 此时静态服务器需要添加跨域协议头：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Access-Control-Allow-Origin: *</span><br></pre></td></tr></table></figure><p>完成这两步后 <code>window.onerror</code> 就能够捕获对应跨域脚本发生错误时的详细错误信息了。</p><ul><li>try catch</li></ul><blockquote><p>crossorigin=”anonymous” 确实可以完美解决 badjs 上报 script error 问题，但是需要服务端进行跨域头支持，而往往在大型企业，域名多的令人发指，导致跨域规则配置非常复杂，所以很难全部都配置上，而且依赖的一些外部资源也不能确保支持，所以我们在<code>调用外部资源方法以及一些不确认是否配置跨域头的资源方法时采用 try catch 包装，并在 catch 到问题时上报对应的错误</code>。</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">invoke</span>(<span class="params">obj, method, args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> obj[method].apply(<span class="built_in">this</span>, args);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    reportBadjs(e); <span class="comment">// report the error</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://juejin.im/post/6844904024441880589#heading-1">参考：前端 JavaScript 错误分析实践</a></p><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p>一面凉经，继续努力。</p>]]></content>
      
      
      <categories>
          
          <category> 面试整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 腾讯 </tag>
            
            <tag> 秋招 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「网易互娱-CC直播事业群」秋招面试复盘总结【已走完流程】</title>
      <link href="posts/2020923/"/>
      <url>posts/2020923/</url>
      
        <content type="html"><![CDATA[<h2 id="网易互娱-CC直播事业群面经"><a href="#网易互娱-CC直播事业群面经" class="headerlink" title="网易互娱-CC直播事业群面经"></a>网易互娱-CC直播事业群面经</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>9月11日晚7点进行了笔试，当时感觉难度有点大，共4道题，仅A了一道题，最后一题0%，另外两道过了一点样例。好在还是收到了面试邀请，9月23日下午5点开始了网易互娱一面。</p><h3 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h3><p>9月23日（周三）下午5点 时间大约26分钟左右</p><h4 id="面经"><a href="#面经" class="headerlink" title="面经"></a>面经</h4><p>1、自我介绍（提及了自己恒生实习经历和写博客习惯）<br>2、几乎全是聊实习经历，可能参考价值不大，但是分享一下相关项目经验的问题<br>3、你在实习角色是什么？有遇到什么问题吗？怎么解决的？<br>4、你说了跨域，那你知道复杂请求怎么处理的吗？</p><p><a href="https://blog.wskfz.com/index.php/archives/103/">参考：处理简单请求和复杂请求之完美跨域CORS</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS">参考MDN：跨源资源共享（CORS）</a></p><p>5、刚刚你说了预校验，那么怎么可以取消它呢？<br>6、你说了深拷贝，你是怎么做的？可以自己手动实现一个吗？对数组怎么做？<code>JSON.parse(...)</code>这种方式有什么不好的地方，说一说？</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* JSON.parse(JSON.stringify()) 可以拷贝数据吗？ */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  arr: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">  name: <span class="string">&#x27;Chocolate&#x27;</span>,</span><br><span class="line">  age: <span class="number">21</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> res = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj));</span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// 可以 &#123; arr: [ 1, 2, 3 ], name: &#x27;Chocolate&#x27;, age: 21 &#125;</span></span><br></pre></td></tr></table></figure><p>7、项目中说使用了 <code>Vuex+SessionStorage</code>？为什么要这么做？（原本只是保存定了的数据字典）后续问我如果是动态的怎么存？<br>8、说说 <code>Cookie</code>、<code>SessionStorage</code>、<code>LocalStorage</code>的区别？<br>9、前端发 <code>ajax</code>请求，你是怎么封装的？（答了 <code>axios</code>）<br>10、那你知道请求那里的请求拦截吗？你知道怎么实现吗？<br><a href="https://www.jianshu.com/p/646ed4edf51f">参考：axios拦截器接口配置与使用</a></p><p>11、前端发起请求，如果请求失败了你怎么做呢？<br>12、你还有什么想问我的吗？</p><h4 id="感受"><a href="#感受" class="headerlink" title="感受"></a>感受</h4><p>问了部门是CC直播事业群，由于时间关系本次一面就26分钟左右，然后还问了校招流程是2轮技术面+1轮HR面。不过一面全程聊实习经历，感觉有些含含糊糊的，答的不是特别好。</p><h3 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h3><p>10月13日（周二）上午11点 时间大约30分钟左右</p><h4 id="面经-1"><a href="#面经-1" class="headerlink" title="面经"></a>面经</h4><blockquote><p>二面大体上参考价值不是很大，基本上与个人经历相关，但还是列出来。与一面不同的是，二面有两个面试官，左边一个，右边一个…</p></blockquote><p>1、自我介绍（提及了自己恒生实习经历和写博客习惯）<br>2、个人博客得到面试官夸赞<br>3、询问我是否读过Vue源码（必须有）<br>4、询问虚拟 dom 实现原理<br>5、diff 算法原理有了解吗？<br>6、虚拟dom更新时间，为啥使用虚拟dom能够优化？（从 <code>diff</code> 算法扯到 <code>React fiber</code>）<br>7、业务设计题：关于商品抢购，后端返回一个倒计时时间，前端你该如何设计，倒计时结束后才能购买（promise里面放一个定时器来回调）<br>8、接上一题，定时器时间是固定那个时间之后就回调嘛？（当然不是，然后提出了可以用 <code>rAF</code> 以系统帧来做）<br>9、下一个面试官到来<br>10、询问我如何学习前端的<br>11、询问了ACM相关经历，用了什么语言打比赛<br>12、给了两个算法场景，询问涉及到什么算法（一个是博弈，当时忘记名字了，就说了<code>Alice</code> 和 <code>Bob</code>，好在面试官也懂我意思，另一个就是并查集，例举了朋友的朋友也是朋友，然后问多少圈朋友 ）<br>13、询问平常在学校干啥（学习…）怎么规划时间的<br>14、你还有什么想问的吗？<br>15、询问面试官学习方法（面试官说我的学习方法就挺好）、询问在网易里业务和技术的重要性</p><h4 id="感受-1"><a href="#感受-1" class="headerlink" title="感受"></a>感受</h4><p>第一次体验两个面试官循环问，不过面试体验还不错，面试官比较耐心听我的表述，过了两天后，通过了二面，收到了HR面</p><h3 id="HR面"><a href="#HR面" class="headerlink" title="HR面"></a>HR面</h3><p>1、询问选前端的理由<br>2、询问简历上项目<br>3、询问怎么学习前端的，这个项目是否个人独立完成<br>4、询问实习经历（主要做了些啥，实习带给你怎样的感受）<br>5、有收到转正意向吗（收到了）那你对其它工作机会怎么看的<br>6、有其它 offer 吗 （没有，如实回答）<br>7、你觉得找工作你比较看重的三个点是哪些（团队、薪资、地点）<br>8、你期望怎样的薪资<br>9、有女朋友吗<br>10、除开网易，你还有面其它公司嘛（当然，腾讯字节都有面）<br>11、你还有什么想问我的吗？<br>12、对校招生培养计划、学习方面的了解<br>13、是否可以提前来实习<br>14、发意向还是会发带薪offer（11月份发放带薪 offer）<br>15、询问工作时间（995 双休）</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>基本上整个秋招就结束了，赶上了末班车，等待11月份网易正式offer，马上也要成为猪厂中一个小猪仔了哇~</p>]]></content>
      
      
      <categories>
          
          <category> 面试整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 秋招 </tag>
            
            <tag> 网易互娱 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「滴滴-橙心优选」秋招面试复盘总结</title>
      <link href="posts/2020906/"/>
      <url>posts/2020906/</url>
      
        <content type="html"><![CDATA[<h2 id="滴滴-橙心优选-面经"><a href="#滴滴-橙心优选-面经" class="headerlink" title="滴滴-橙心优选 面经"></a>滴滴-橙心优选 面经</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>先说一下最终结果吧，第三面凉了。9月5号下午1点开始，一直到下午4点20样子，持续三轮面试，最终倒在了第三轮。感受与总结我就放在最后吧。总体来说问的比较基础，没有深度挖掘知识点。另外，已经过了一天了，还是三面一起来的，可能会有问题遗漏掉，一般来说遗漏掉的都是比较简单，能轻松说出来的那种。</p><h3 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h3><h4 id="面经"><a href="#面经" class="headerlink" title="面经"></a>面经</h4><p>1、自我介绍<br>2、JS基本数据类型（怎么判断基本数据类型）<br>3、说说你对原型和原型链的理解<br>4、水平垂直居中的几种方式，说一说<br>5、说说你对深浅拷贝的理解（要求手撕深拷贝）<br>6、输入一个URL到渲染页面的整个过程<br>7、浏览器缓存有了解过嘛？说说看<br>8、说一个你熟悉的排序算法，然后手写一下（简单写了一个冒泡）</p><h4 id="感受"><a href="#感受" class="headerlink" title="感受"></a>感受</h4><p>一面问的比较基础，也是比较顺利收到了二面通知</p><h3 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h3><h4 id="面经-1"><a href="#面经-1" class="headerlink" title="面经"></a>面经</h4><p>1、自我介绍<br>2、CSS选择器优先级的理解<br>3、CSS定位的几种方式<br>4、CSS怎么清除浮动<br>5、display几种属性说一说<br>6、水平垂直居中的几种方式<br>7、父容器已知宽高，子容器宽高未知，怎样让子容器水平垂直居中<br>8、css modules你有了解过吗<br>9、如果组件css命名冲突，你怎么解决<br>10、设计模式你有了解过吗？说说单例模式<br>11、call、apply、bind的区别<br>12、普通函数和箭头函数的区别<br>13、项目中有用到 <code>debounce</code>，那你写一下防抖吧<br>14、实现如下效果：当点击 <code>aaa</code> 时输出 0 ，当点击 <code>bbb</code> 输出 1，当点击<code>ccc</code> 输出 2</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">&lt;li&gt;aaa&lt;/li&gt;</span><br><span class="line">&lt;li&gt;bbb&lt;/li&gt;</span><br><span class="line">&lt;li&gt;ccc&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure><p>15、for 遍历时，如果用 <code>var</code> 来声明变量 <code>i</code> 会有什么问题，怎么解决这个问题？<br>16、浏览器缓存你了解多少，说说看<br>17、谈谈你对 <code>cookie</code> 的理解，<code>cookie</code> 有哪些字段，说说看<br>18、<code>cookie</code> 和 <code>session</code> 的区别</p><h4 id="感受-1"><a href="#感受-1" class="headerlink" title="感受"></a>感受</h4><p>感觉有些问题，答的不是很好，但过了二面，手撕那块没啥问题。</p><h3 id="三面"><a href="#三面" class="headerlink" title="三面"></a>三面</h3><h4 id="面经-2"><a href="#面经-2" class="headerlink" title="面经"></a>面经</h4><p>1、自我介绍<br>2、聊大学经历<br>3、你觉得学的最好的一门课</p><blockquote><p>因为网络这块知识准备的比较充足，就选了计算机网络，其它的与前端不太挂钩，也不太好扯。</p></blockquote><p>4、面试官对网络这门课教学方式很感兴趣，于是扯了挺久，扯到了网络建设项目（校运动会举行），扯到了最后排名，与第一名的差距在哪<br>5、如果要你给一个非科班的人，讲网络这门课，你会怎么讲？<br>6、网络里面你认为的最熟悉的章节（说了HTTP、TCP这块）<br>7、那你说一下对称加密和非对称加密。为什么非对称加密更好，现在还是有用对称加密，你能说出原因吗？最好举一下生活中的例子<br>8、你算法和数据结构咋样，做一道题吧</p><blockquote><p>上来就来了一道动态规划的题，想了一下，没啥思路，面试官就换了一道题</p></blockquote><p>9、算法题：求两个数组的交集</p><h4 id="感受-2"><a href="#感受-2" class="headerlink" title="感受"></a>感受</h4><p>10分钟后收到了感谢信，这效率是真高啊。原以为秋招以收到滴滴意向书结束，但没想到还是倒在了三面这最后一步了。收到后不甘心是当然的，但是面试后的复盘是很重要的，接下来写一下对本次面试的总结吧</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>我很强，但是我很傲。</code> 从下午1点开始面，一直面到下午4点20左右，也是我第一次经历。面试完后，都感觉脑袋空荡荡的，啥也记不起来了。开头这句话，是我收到面试结果后想到的一句话。<code>我很强</code>：这或许就是面试失败后对自己的安慰吧，我很强，不要因为这个丢失了信心。</p><p><code>但是我很傲</code>：连面的过程是挺兴奋的，我从春招从未收到二面开始，到现在居然到了三面，就感觉离成功就差那么一步了。三面面完后，休息时间段期间，我甚至比较自信自己快要拿到滴滴意向书了。与实习公司同事还聊了一会，他们说自己也是聊天，聊着聊着就凉了。我还是对自己比较有信心，还例举了自己问了哪些问题。</p><p>世界就是这样，永远不要笑别人，因为保不准那天你就成了故事里的主人公，成为了被笑的那个。</p><p>没错，我也终究成为了那一个，甚至怀疑是不是弄错了，但过了一天后，复盘过后，发现确实有些地方没有到位。</p><p>至于这个 <code>傲</code>，我还去查了查狮子座男生性格特点：</p><blockquote><p>在十二星座中，狮子座是最具有权威感与支配能力的星座。通常有一种贵族气息或是王者风范。受人尊重，做事相当独立，知道如何运用能力和权术以达到目的。本质是阳刚、钻制、具有太阳般的生气、宽宏大量、乐观、海派、光明磊落、不拘小节、心胸开阔。不过也会有顽固、傲慢、独裁的一面。同时，他们天生怀抱着崇高的理想，能够全力以赴、发挥旺盛的生命力为周遭的人、为弱者或正义而战。对弱者有慈悲心及同情心，对自己很有自信，擅长组织事务，喜欢有秩序;能够发挥创造的才华，使成果具有建设性、原创性，是个行动派。</p></blockquote><p>在过去，可能对星座这一块不太了解，也不会相信所说的性格特点啥的，但是现在回过头来看，这些性格特点真差不了太多。</p><p>其实，这或许就是大家常在嘴边说起的年轻人吧，那种傲气，能力不够，简单事又不愿意做。</p><p>尽管这次面试依旧凉了，但还是继续努力，在这里整理一下9月份规划：</p><ul><li>适当慢下来，整理复盘一下8月份面试出现的问题，及时查漏补缺</li><li>亡羊补牢，将基础知识学的更扎实一点</li><li>算法那一块也要坚持下去，保证让自己9月份刷完一轮专题路线</li></ul><p>至于对于面试其它感受，在此就不继续书写了，因为看到的文章并不一定能体会到我的过程。就好像读者看到的是一张风景照片，但可能没法体验到沿途的风景的那段过程。</p><blockquote><p>2020.9.6晚有感而发，希望9月对自己更温柔一点。加油！</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 面试整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 秋招 </tag>
            
            <tag> 滴滴 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「快手-效率工程」秋招面试复盘总结</title>
      <link href="posts/2020910/"/>
      <url>posts/2020910/</url>
      
        <content type="html"><![CDATA[<h2 id="快手-效率工程面经"><a href="#快手-效率工程面经" class="headerlink" title="快手-效率工程面经"></a>快手-效率工程面经</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>8月25日（周二）投递，在9月8日上午收到 HR 电话，告知简历通过了，约9月10日上午11点面试，整个面试时间1个小时左右。</p><h3 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h3><h4 id="面经"><a href="#面经" class="headerlink" title="面经"></a>面经</h4><p>1、自我介绍<br>2、你刚刚提到了项目中防抖 <code>debounce</code> ，你知道实现原理是什么吗？说一说</p><blockquote><p>这个问题是项目中用到过，然后自我介绍提了一下，就说了一下原理，面试官居然不要我手撕…</p></blockquote><p>3、你家乡在哪？面试岗位在北京，有没有城市要求吗？</p><blockquote><p>回答：反正在湖南，去哪都是很远…</p></blockquote><p>4、实现一个函数，以字符串形式（要求字母小写）返回参数类型 </p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// null =&gt; &#x27;null&#x27; undefined=&gt;&#x27;undefined&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getArgType</span>(<span class="params">arg</span>)</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 编程题：以字符串形式返回参数类型  */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getArgType</span>(<span class="params">arg</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> str = <span class="built_in">Object</span>.prototype.toString.call(arg).slice(<span class="number">8</span>,-<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">let</span> res = str[<span class="number">0</span>].toLowerCase() + str.substr(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(getArgType(<span class="literal">null</span>))</span><br><span class="line"><span class="built_in">console</span>.log(getArgType(<span class="literal">undefined</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">console</span>.log(a === b)</span><br><span class="line"><span class="built_in">console</span>.log(getArgType(a))</span><br><span class="line"><span class="built_in">console</span>.log(getArgType(b))</span><br><span class="line"><span class="built_in">console</span>.log(getArgType(<span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2020</span>,<span class="number">9</span>,<span class="number">10</span>)))</span><br><span class="line"><span class="built_in">console</span>.log(getArgType(<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/^\s+|\s$/g</span>)))</span><br></pre></td></tr></table></figure><p>后面终点问了 <code>1</code> 和 <code>new Number(1)</code> 有什么区别，这里没答上来。</p><blockquote><p>对象Number、String、Boolean分别对应数字、字符串、布尔值，可以通过这三个对象把原始类型的值变成（包装成）对象</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> v1 = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">123</span>);</span><br><span class="line"><span class="keyword">var</span> v2 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&#x27;abc&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> v3 = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> v1;<span class="comment">// &quot;object&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> v2;<span class="comment">// &quot;object&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> v3;<span class="comment">// &quot;object&quot;</span></span><br><span class="line"></span><br><span class="line">v1 === <span class="number">123</span>; <span class="comment">// false</span></span><br><span class="line">v1 == <span class="number">123</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>但是要注意 <code>new Boolean</code> 的用法，只有当 <code>new Boolean</code> 的参数值为 <code>null</code> 或者 <code>undefined</code> 时，求值转换的原始的值才是 <code>false</code> ，其他情况都是 <code>true</code></p><p>5、给你一个数组 <code>[1,3,2,5]</code> 你有多少种方法，求得最大值，说一说</p><blockquote><p>一下没 get 到面试官的点，我想着除了遍历比较或排序还能怎么做。但后面不断引导后发现可以用各种数组 <code>api</code> ，然后就答了 <code>sort</code>，<code>map</code>，<code>reduce</code>，<code>for循环</code> ，<code>shift</code>，<code>pop</code>，<code>forEach</code>，<code>Math.max(...arr)</code></p></blockquote><p>后面面试官说了用 <code>apply</code>，没使用过，补充一下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">6</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">11</span>, <span class="number">23</span>];</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, arr))</span><br></pre></td></tr></table></figure><p>6、实现如下效果：当你点击 <code>ul</code> 下面某个 <code>li</code>后（多个 <code>ui</code>），打印对应索引值（可以为 <code>0</code> 或 <code>1</code>）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;ul&gt;<span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span>........&lt;/ul&gt;</span><br><span class="line">&lt;ul&gt;<span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span>........&lt;/ul&gt;</span><br><span class="line">&lt;ul&gt;<span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span>........&lt;/ul&gt;</span><br></pre></td></tr></table></figure><p>最终实现如下，一开始我是直接 <code>querySelectorAll</code>所有的 <code>li</code>，但是会给所有 <code>li</code>绑定事件，于是面试官说考虑使用事件代理，然后提示 <code>e.target</code>（当时没写出来，现在补充一下）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;en&quot;</span>&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span><br><span class="line">    &lt;meta name=<span class="string">&quot;viewport&quot;</span> content=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span><br><span class="line">    &lt;title&gt;编程题：ul底下li索引值（多个ul）&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &lt;li&gt;<span class="number">1</span>&lt;/li&gt;</span><br><span class="line">      &lt;li&gt;<span class="number">2</span>&lt;/li&gt;</span><br><span class="line">      &lt;li&gt;<span class="number">3</span>&lt;/li&gt;</span><br><span class="line">      &lt;li&gt;<span class="number">4</span>&lt;/li&gt;</span><br><span class="line">      &lt;li&gt;<span class="number">5</span>&lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &lt;li&gt;<span class="number">1</span>&lt;/li&gt;</span><br><span class="line">      &lt;li&gt;<span class="number">2</span>&lt;/li&gt;</span><br><span class="line">      &lt;li&gt;<span class="number">3</span>&lt;/li&gt;</span><br><span class="line">      &lt;li&gt;<span class="number">4</span>&lt;/li&gt;</span><br><span class="line">      &lt;li&gt;<span class="number">5</span>&lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">      <span class="keyword">let</span> list = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;ul&#x27;</span>)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; list.length; i++) &#123;</span><br><span class="line">        list[i].addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> target = e.target</span><br><span class="line">          <span class="comment">// console.log(target)</span></span><br><span class="line">          <span class="keyword">if</span> (target.tagName.toLowerCase() === <span class="string">&#x27;li&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> liList = list[i].getElementsByTagName(<span class="string">&#x27;li&#x27;</span>)</span><br><span class="line">            <span class="comment">// console.log(liList)</span></span><br><span class="line">            <span class="comment">// getElementsByTagName方法获取到的元素列表不是数组，</span></span><br><span class="line">            <span class="comment">// 和函数的arguments一样是一种类数组类型，不可以直接使用数组的方法。</span></span><br><span class="line">            <span class="keyword">let</span> idx = <span class="built_in">Array</span>.prototype.indexOf.call(liList, target)</span><br><span class="line">            <span class="comment">/* 或者采用如下方式，将类数组转换成数组，然后使用indexOf方法 */</span></span><br><span class="line">            <span class="comment">// let idx = Array.from(liList).indexOf(target)</span></span><br><span class="line">            <span class="built_in">console</span>.log(liList)</span><br><span class="line">            <span class="built_in">console</span>.log(idx)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>7、使用 <code>vue</code> 封装一个组件，实现倒计时的功能</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">倒计时（一个 button 按钮，有下述三种状态）</span><br><span class="line">（开始-》暂停-》继续）</span><br><span class="line"></span><br><span class="line">&#123;count&#125;</span><br><span class="line">按钮</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/qq_42778001/article/details/104683996">参考：vue封装倒计时组件</a></p><p>8、你还有什么想问我的吗？</p><h4 id="感受"><a href="#感受" class="headerlink" title="感受"></a>感受</h4><p>问了部门是效率工程，然后主要业务是做公司内部系统，比如各种流程处理，请假那些，然后还提到了公司封装内部聊天工具，类似于企业微信那种。然后还问了技术栈，主要用 <code>React + Ts</code> ，然后面试官说了技术栈都不是太大问题，主要还是 <code>js</code> 能力</p><p>最后，问了一下多久会有面试结果，面试官说一天之内给结果。</p><h3 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h3><blockquote><p>待更新</p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><p>待更新</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 面试整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 秋招 </tag>
            
            <tag> 快手 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「字节跳动-飞书」秋招面试复盘总结</title>
      <link href="posts/20209029/"/>
      <url>posts/20209029/</url>
      
        <content type="html"><![CDATA[<h2 id="字节跳动-飞书面经"><a href="#字节跳动-飞书面经" class="headerlink" title="字节跳动-飞书面经"></a>字节跳动-飞书面经</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>9月20日晚7点进行了笔试，有3道单选题，2道多选题，然后3道编程题，3道编程题全A了，自然收到了面试邀请，约了9月29日下午5点一面。</p><h3 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h3><h4 id="面经"><a href="#面经" class="headerlink" title="面经"></a>面经</h4><p>1、自我介绍（提及了自己恒生实习经历和写博客习惯）<br>2、说一下你的个人经历（详细讲了实习这一块做了什么）<br>3、实习中表格渲染具体怎么做的，说一说<br>4、Vuex实现原理</p><blockquote><p>这里答的不是很好，面试官跳过了。</p></blockquote><p>5、Vue组件通信有哪些？说一说</p><blockquote><p>只答了父子组件，兄弟组件，自定义事件，还有一些忘记了。</p></blockquote><p>6、实习项目登录你是怎么做的？token怎么存，如果要让登录状态在新的tab页面保持，你怎么做？</p><blockquote><p>cookie</p></blockquote><p>7、如果避免用户通过JS脚本获取cookie</p><p>8、普通函数和箭头函数的区别</p><blockquote><p>答的不是很好，面试官跳过了</p></blockquote><p>9、箭头函数可以作为构造函数吗</p><blockquote><p>回答了不可以，但是可能答的不是特别好</p></blockquote><p>10、说一下你对原型和原型链的理解？</p><p>11、说说你对TCP的理解，说说三次握手</p><p>12、考察Event Loop（事件循环）机制，写出输出结果：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;begin&#x27;</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout 1&#x27;</span>)</span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise 1&#x27;</span>)</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout2 between promise1&amp;2&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise 2&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;end&#x27;</span>)</span><br></pre></td></tr></table></figure><p>跑一下，输出结果如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">begin</span><br><span class="line">end</span><br><span class="line"><span class="built_in">setTimeout</span> <span class="number">1</span></span><br><span class="line">promise <span class="number">1</span></span><br><span class="line">promise <span class="number">2</span></span><br><span class="line">setTimeout2 between promise1&amp;<span class="number">2</span></span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200929214202499.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70#pic_center" alt=""></p><p>13、首屏加载慢你会怎么考察？</p><blockquote><p>这里面试官又改了一下，让我去说前端性能优化</p></blockquote><ul><li>减少http请求</li><li>引用CDN</li><li>异步加载</li><li>服务端渲染</li><li>浏览器缓存优化</li></ul><p>14、说说你对异步加载的理解（说了 defer 和 async）</p><p>15、说说你对浏览器缓存的理解（强缓存、协商缓存），后续问了缓存的优先级</p><p>16、手撕：实现 deepClone </p><blockquote><p>其中还问了 undefined.toString() 会是什么结果，这个在博客JS知识梳理里面整理过，直接回答了会报错</p></blockquote><p>还问了如下代码输出结果：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])); <span class="comment">// [object Array]</span></span><br></pre></td></tr></table></figure><p>17、算法题：合并两个有序数组  mergeSortedArray([0,3,5], [1,2,4])   // [0,1,2,3,4,5]</p><p>18、还有什么想问我的吗？</p><h4 id="感受"><a href="#感受" class="headerlink" title="感受"></a>感受</h4><p>字节面试依旧是体验很好，面试官单独在一个休息室面的，没有任何外界干扰。最后问了面试官关于飞书，然后请教了一下对于前端学习方法。应该还有下一面，面试官说了后面会有同事来沟通。</p><h3 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h3><blockquote><p>待更新</p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><p>待更新</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 面试整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 秋招 </tag>
            
            <tag> 字节跳动 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「字节跳动-广告系统」秋招面试复盘总结</title>
      <link href="posts/20209023/"/>
      <url>posts/20209023/</url>
      
        <content type="html"><![CDATA[<h2 id="字节跳动广告系统-面经"><a href="#字节跳动广告系统-面经" class="headerlink" title="字节跳动广告系统 面经"></a>字节跳动广告系统 面经</h2><h3 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h3><h3 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h3><h3 id="手撕防抖（如果滚动条判断一个div是否存在会用什么来做？节流）"><a href="#手撕防抖（如果滚动条判断一个div是否存在会用什么来做？节流）" class="headerlink" title="手撕防抖（如果滚动条判断一个div是否存在会用什么来做？节流）"></a>手撕防抖（如果滚动条判断一个div是否存在会用什么来做？节流）</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>实现防抖<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">      <span class="selector-class">.container</span> &#123;</span></span><br><span class="line">        width: 200px;</span><br><span class="line">        height: 200px;</span><br><span class="line">        background-color: aqua;</span><br><span class="line">        font-size: 30px;</span><br><span class="line">        line-height: 200px;</span><br><span class="line">        text-align: center;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementsByClassName(<span class="string">&#x27;container&#x27;</span>)[<span class="number">0</span>]</span></span><br><span class="line"><span class="javascript">      <span class="comment">// let cnt = 0</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// let timeId = null</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// btn.onmouseover = () =&gt; &#123;</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">//   clearTimeout(timeId)</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">//   timeId = setTimeout(() =&gt; &#123;</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">//     btn.innerHTML = ++cnt</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">//   &#125;, 2000)</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// &#125;</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> cnt = <span class="number">0</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> doSomething = <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line">        btn.innerHTML = ++cnt</span><br><span class="line">      &#125;</span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> debounce = <span class="function">(<span class="params">fn,time,triggerNow</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> timeId = <span class="literal">null</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> debounced = <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">if</span>(timeId)&#123;</span></span><br><span class="line"><span class="javascript">              <span class="built_in">clearTimeout</span>(timeId)</span></span><br><span class="line">            &#125;</span><br><span class="line"><span class="javascript">          <span class="keyword">if</span>(triggerNow)&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">let</span> exec = !timeId</span></span><br><span class="line"><span class="javascript">            timeId =<span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span></span><br><span class="line"><span class="javascript">              timeId = <span class="literal">null</span></span></span><br><span class="line">            &#125;,time)</span><br><span class="line"><span class="javascript">            <span class="keyword">if</span>(exec)&#123;</span></span><br><span class="line"><span class="javascript">              fn.apply(<span class="built_in">this</span>,args)</span></span><br><span class="line">            &#125;</span><br><span class="line"><span class="javascript">          &#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="javascript">            timeId = <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span></span><br><span class="line"><span class="javascript">              fn.apply(<span class="built_in">this</span>,args)</span></span><br><span class="line">            &#125;,time)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="javascript">        debounced.remove = <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">          <span class="built_in">clearTimeout</span>(timeId)</span></span><br><span class="line"><span class="javascript">          timeId = <span class="literal">null</span></span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> debounced</span></span><br><span class="line">      &#125;</span><br><span class="line"><span class="javascript">      btn.onmouseover = debounce(doSomething,<span class="number">2000</span>,<span class="literal">false</span>)</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="CSS实现三角形"><a href="#CSS实现三角形" class="headerlink" title="CSS实现三角形"></a>CSS实现三角形</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>画三角形<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.triggle</span>&#123;</span></span><br><span class="line">            width: 0px;</span><br><span class="line">            height: 0px;</span><br><span class="line">            border-top: 40px solid transparent;</span><br><span class="line">            border-left: 40px solid transparent;</span><br><span class="line">            border-bottom: 40px solid red;</span><br><span class="line">            border-right: 40px solid transparent;</span><br><span class="line">            margin: 40px;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;triggle&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="了解伪元素和伪类吗？"><a href="#了解伪元素和伪类吗？" class="headerlink" title="了解伪元素和伪类吗？"></a>了解伪元素和伪类吗？</h3><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/2020083019232475.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70#pic_center" alt=""><br><a href="https://www.bilibili.com/video/BV1h7411P7Pz">参考：CSS伪类和伪元素的区别 - Web前端工程师面试题讲解</a></p><h3 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span>: </span><br><span class="line">width=100px;</span><br><span class="line"><span class="selector-tag">border</span>: 10<span class="selector-tag">px</span>;</span><br><span class="line"><span class="selector-tag">padding</span>: 15<span class="selector-tag">px</span>;</span><br><span class="line"><span class="selector-tag">margin</span>: 10<span class="selector-tag">px</span>;</span><br><span class="line">height=100px;</span><br><span class="line"></span><br><span class="line">content-box =&gt; 100px</span><br><span class="line"></span><br><span class="line">border-box =&gt; 150px</span><br></pre></td></tr></table></figure><h4 id="Vue双向绑定实现-Object-defineProperty-它有哪些不足点？"><a href="#Vue双向绑定实现-Object-defineProperty-它有哪些不足点？" class="headerlink" title="Vue双向绑定实现 Object.defineProperty()  它有哪些不足点？"></a>Vue双向绑定实现 Object.defineProperty()  它有哪些不足点？</h4><ul><li>只能监听某个属性，不能对全对象进行监听</li><li>需要 for in遍历找对象中的属性</li><li>不能监听数组，需要单独的对数组进行特异性操作</li><li>会污染原对象</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">data : &#123;</span><br><span class="line">name; <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line">age: <span class="number">23</span>,</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.name = <span class="string">&#x27;brown&#x27;</span>;</span><br><span class="line"><span class="built_in">this</span>.gender = <span class="string">&#x27;男&#x27;</span>;</span><br></pre></td></tr></table></figure><p>如何让 gender 改变也会让视图变化（面试官意思是如何用Vue动态新增对象属性,触发dom渲染）</p><blockquote><p>背景：项目中因为一些需求需要在JSON中新增一个属性,也能console出来,但是就是不能在页面渲染,即不能触发视图更新 </p></blockquote><p>其实在vue 中新增属性应该用 <code>$set</code> 这个方法的</p><h4 id="1-添加单个属性"><a href="#1-添加单个属性" class="headerlink" title="1. 添加单个属性"></a>1. 添加单个属性</h4><p>用 <code>$set()</code>方法，既可以新增属性,又可以触发视图更新。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.$set(<span class="built_in">this</span>.data,”key”,value)</span><br></pre></td></tr></table></figure><h4 id="2-添加多个属性"><a href="#2-添加多个属性" class="headerlink" title="2.添加多个属性"></a>2.添加多个属性</h4><p>使用 <code>Object.assign()</code>用原对象与要混合进去的对象的属性一起创建一个新的对象。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.obj = <span class="built_in">Object</span>.assign(&#123;&#125;, <span class="built_in">this</span>.obj, &#123;</span><br><span class="line">  age: <span class="number">18</span>,</span><br><span class="line">  name: <span class="string">&#x27;Chocolate&#x27;</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="询问输出结果"><a href="#询问输出结果" class="headerlink" title="询问输出结果"></a>询问输出结果</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; alert (<span class="number">1</span>); &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">Foo.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; alert (<span class="number">2</span>);&#125;;</span><br><span class="line">Foo.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; alert (<span class="number">3</span>);&#125;;</span><br><span class="line"><span class="keyword">var</span> getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; alert (<span class="number">4</span>);&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123; alert (<span class="number">5</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//请写出以下输出结果：</span></span><br><span class="line">Foo.getName();</span><br><span class="line">getName();</span><br><span class="line">Foo().getName();</span><br><span class="line">getName();</span><br><span class="line"><span class="keyword">new</span> Foo.getName();</span><br><span class="line"><span class="keyword">new</span> Foo().getName();</span><br><span class="line"><span class="keyword">new</span> <span class="keyword">new</span> Foo().getName();</span><br></pre></td></tr></table></figure><p><a href="https://www.cnblogs.com/xxcanghai/p/5189353.html">参考：一道常被人轻视的前端JS面试题</a></p><h4 id="第一问"><a href="#第一问" class="headerlink" title="第一问"></a>第一问</h4><p>先看此题的上半部分做了什么，首先定义了一个叫<strong>Foo的函数</strong>，之后为Foo创建了一个叫<code>getName</code>的<strong>静态属性</strong>存储了一个匿名函数，之后为Foo的<strong>原型对象</strong>新创建了一个叫<code>getName</code>的匿名函数。之后又通过<strong>函数变量表达式</strong>创建了一个getName的函数，最后再声明一个叫<code>getName</code>函数。</p><p>第一问的<code>Foo.getName</code> 自然是访问Foo函数上存储的<strong>静态属性</strong>，自然是2，没什么可说的。</p><h4 id="第二问"><a href="#第二问" class="headerlink" title="第二问"></a>第二问</h4><p>第二问，直接调用 <code>getName</code> 函数。既然是直接调用那么就是访问<strong>当前上文作用域内</strong>的叫<code>getName</code>的函数，所以跟1 2 3都没什么关系。此题有无数面试者回答为5。此处有两个坑，<strong>一是变量声明提升，二是函数表达式。</strong></p><p><strong>变量声明提升</strong></p><p>即<code>所有声明变量或声明函数</code>都会被提升到当前函数的顶部。<br>例如下代码:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;x&#x27;</span> <span class="keyword">in</span> <span class="built_in">window</span>);<span class="comment">//true</span></span><br><span class="line"><span class="keyword">var</span> x;</span><br><span class="line">x = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>代码执行时js引擎会将声明语句提升至代码最上方，变为：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;x&#x27;</span> <span class="keyword">in</span> <span class="built_in">window</span>);<span class="comment">//true</span></span><br><span class="line">x = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p><strong>函数表达式</strong></p><p><code>var getName</code>与 <code>function getName</code> 都是声明语句，区别在于<code>var getName</code> 是<strong>函数表达式</strong>，而<code>function getName</code>是<strong>函数声明</strong>。关于JS中的各种函数创建方式可以看 <a href="https://www.cnblogs.com/xxcanghai/p/4991870.html">大部分人都会做错的经典JS闭包面试题 </a>这篇文章有详细说明。</p><p>函数表达式最大的问题，在于js会将此代码拆分为两行代码分别执行。<br>例如下代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(x);<span class="comment">//输出：function x()&#123;&#125;</span></span><br><span class="line"><span class="keyword">var</span> x=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">x</span>(<span class="params"></span>)</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>实际执行的代码为，先将 <code>var x=1</code>拆分为<code>var x;</code> 和 <code>x = 1;</code>两行，再将 <code>var x;</code> 和<code>function x()&#123;&#125;</code>两行提升至最上方变成：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">x</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(x);</span><br><span class="line">x=<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>所以最终函数声明的x覆盖了变量声明的x，log输出为x函数。<br>同理，原题中代码最终执行时的是：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; alert (<span class="number">1</span>); &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> getName;<span class="comment">//只提升变量声明</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123; alert (<span class="number">5</span>);&#125;<span class="comment">//提升函数声明，覆盖var的声明</span></span><br><span class="line"></span><br><span class="line">Foo.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; alert (<span class="number">2</span>);&#125;;</span><br><span class="line">Foo.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; alert (<span class="number">3</span>);&#125;;</span><br><span class="line">getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; alert (<span class="number">4</span>);&#125;;<span class="comment">//最终的赋值再次覆盖function getName声明</span></span><br><span class="line"></span><br><span class="line">getName();<span class="comment">//最终输出4</span></span><br></pre></td></tr></table></figure><h4 id="第三问"><a href="#第三问" class="headerlink" title="第三问"></a>第三问</h4><p>第三问的<code>Foo().getName();</code> 先执行了Foo函数，然后调用Foo函数的返回值对象的getName属性函数。</p><p>Foo函数的第一句  <code>getName = function () &#123; alert (1); &#125;;</code> 是一句函数赋值语句，注意它没有<code>var</code>声明，所以先向当前Foo函数作用域内寻找<code>getName</code>变量，没有。再向当前函数作用域上层，即外层作用域内寻找是否含有<code>getName变量</code>，找到了，也就是第二问中的<code>alert(4)</code>函数，将此变量的值赋值为 <code>function()&#123;alert(1)&#125;</code>。 </p><p><strong>此处实际上是将外层作用域内的getName函数修改了。</strong></p><blockquote><p>注意：此处若依然没有找到会一直向上查找到window对象，若window对象中也没有getName属性，就在window对象中创建一个getName变量。</p></blockquote><p>简单的讲，<strong>this的指向是由所在函数的调用方式决定的</strong>。而此处的直接调用方式，this指向<code>window对象</code>。</p><p>遂Foo函数返回的是window对象，相当于执行 <code>window.getName()</code> ，而window中的getName已经被修改为<code>alert(1)</code>，所以最终会输出<code>1</code></p><p>此处考察了两个知识点，一个是<strong>变量作用域问题</strong>，一个是<strong>this指向问题</strong>。</p><h4 id="第四问"><a href="#第四问" class="headerlink" title="第四问"></a>第四问</h4><p>直接调用getName函数，相当于 <code>window.getName()</code> ，因为这个变量已经被<code>Foo</code>函数执行时修改了，遂结果与第三问相同，为<code>1</code></p><h4 id="第五问"><a href="#第五问" class="headerlink" title="第五问"></a>第五问</h4><p><code>new Foo.getName();</code> ,此处考察的是js的运算符优先级问题。</p><p>js运算符优先级:<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200830161709359.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70#pic_center" alt=""><br>通过查上表可以得知点<code>（.）</code>的优先级高于<code>new</code>操作，遂相当于是:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> (Foo.getName)();</span><br></pre></td></tr></table></figure><p>所以实际上将<code>getName</code>函数作为了构造函数来执行，遂弹出<code>2</code>。</p><h4 id="第六问"><a href="#第六问" class="headerlink" title="第六问"></a>第六问</h4><p>第六问 <code>new Foo().getName()</code>，首先看运算符优先级<strong>括号高于new</strong>，并且带参数的new操作符是优先级最高的，实际执行为</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">new</span> Foo()).getName()</span><br></pre></td></tr></table></figure><p>遂先执行Foo函数，而Foo此时作为构造函数却有返回值，所以这里需要说明下js中的<strong>构造函数返回值问题</strong>。</p><p>原题中，返回的是<code>this</code>，而this在构造函数中本来就代表当前实例化对象，遂最终Foo函数<strong>返回实例化对象</strong>。之后调用实例化对象的getName函数，因为在<strong>Foo构造函数中没有为实例化对象添加任何属性</strong>，遂到当前对象的<code>原型对象（prototype）</code>中寻找getName，找到了。</p><p>遂最终输出3。</p><h4 id="第七问"><a href="#第七问" class="headerlink" title="第七问"></a>第七问</h4><p>最终实际执行为：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> ((<span class="keyword">new</span> Foo()).getName)();</span><br></pre></td></tr></table></figure><p>先初始化Foo的实例化对象，然后将其原型上的getName函数作为构造函数再次new。</p><p>遂最终结果为3</p><h4 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; alert (<span class="number">1</span>); &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">Foo.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; alert (<span class="number">2</span>);&#125;;</span><br><span class="line">Foo.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; alert (<span class="number">3</span>);&#125;;</span><br><span class="line"><span class="keyword">var</span> getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; alert (<span class="number">4</span>);&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123; alert (<span class="number">5</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//答案：</span></span><br><span class="line">Foo.getName();<span class="comment">//2</span></span><br><span class="line">getName();<span class="comment">//4</span></span><br><span class="line">Foo().getName();<span class="comment">//1</span></span><br><span class="line">getName();<span class="comment">//1</span></span><br><span class="line"><span class="keyword">new</span> Foo.getName();<span class="comment">//2</span></span><br><span class="line"><span class="keyword">new</span> Foo().getName();<span class="comment">//3</span></span><br><span class="line"><span class="keyword">new</span> <span class="keyword">new</span> Foo().getName();<span class="comment">//3</span></span><br></pre></td></tr></table></figure><h3 id="promise相关，下面代码输出结果"><a href="#promise相关，下面代码输出结果" class="headerlink" title="promise相关，下面代码输出结果"></a>promise相关，下面代码输出结果</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.reject(<span class="number">2</span>).catch(<span class="function"><span class="params">e</span> =&gt;</span> e).then(<span class="function"><span class="params">d</span> =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(d);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 输出2</span></span><br></pre></td></tr></table></figure><p>一般总是建议，Promise 对象后面要跟catch方法，这样可以处理 Promise 内部发生的错误。<strong>catch方法返回的还是一个 Promise 对象，因此后面还可以接着调用then方法。</strong></p><p><a href="https://juejin.im/post/6844903604009041928#heading-0">参考：你真的完全掌握了promise么？</a></p><p><a href="https://zhuanlan.zhihu.com/p/30797777">Promise 必知必会（十道题）</a></p><p><a href="https://juejin.im/post/6844904023988895757">关于 Promise 的 9 个面试题</a></p><h3 id="cookie-和-session-区别（session-存放哪）"><a href="#cookie-和-session-区别（session-存放哪）" class="headerlink" title="cookie 和 session 区别（session 存放哪）"></a>cookie 和 session 区别（session 存放哪）</h3><h4 id="http是一个无状态协议"><a href="#http是一个无状态协议" class="headerlink" title="http是一个无状态协议"></a>http是一个无状态协议</h4><p>什么是无状态呢？就是说这一次请求和上一次请求是没有任何关系的，互不认识的，没有关联的。这种无状态的的好处是快速。坏处是假如我们想要把<code>www.zhihu.com/login.html</code> 和 <code>www.zhihu.com/index.html</code>关联起来，必须使用某些手段和工具</p><h4 id="cookie和session"><a href="#cookie和session" class="headerlink" title="cookie和session"></a>cookie和session</h4><p>由于http的无状态性，为了使某个域名下的所有网页能够共享某些数据，session和cookie出现了。客户端访问服务器的流程如下：</p><ul><li>首先，客户端会发送一个http请求到服务器端。</li><li>服务器端接受客户端请求后，建立一个session，并发送一个http响应到客户端，这个响应头，其中就包含Set-Cookie头部。该头部包含了sessionId。Set-Cookie格式如下：<br><code>Set-Cookie: value[; expires=date][; domain=domain][; path=path][; secure]</code></li><li>在客户端发起的第二次请求，假如服务器给了set-Cookie，浏览器会自动在请求头中添加cookie</li><li>服务器接收请求，分解cookie，验证信息，核对成功后返回response给客户端</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200829103822995.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70#pic_center" alt=""><br><strong>注意</strong></p><ul><li>cookie只是实现session的其中一种方案。虽然是最常用的，但并不是唯一的方法。禁用cookie后还有其他方法存储，比如放在url中</li><li><strong>现在大多都是Session + Cookie</strong>，但是只用session不用cookie，或是只用cookie，不用session在理论上都可以保持会话状态。可是实际中因为多种原因，一般不会单独使用</li><li>用session只需要在客户端保存一个id，实际上<strong>大量数据都是保存在服务端</strong>。如果全部用cookie，数据量大的时候客户端是没有那么多空间的。</li><li>如果只用cookie不用session，那么账户信息全部保存在客户端，一旦被劫持，全部信息都会泄露。并且客户端数据量变大，网络传输的数据量也会变大</li></ul><h4 id="拓展：token"><a href="#拓展：token" class="headerlink" title="拓展：token"></a>拓展：token</h4><p>token 也称作令牌，由uid+time+sign[+固定参数]<br>token 的认证方式类似于<strong>临时的证书签名</strong>, 并且是一种服务端无状态的认证方式, 非常适合于 <code>REST API</code>（表现层状态转换） 的场景. 所谓无状态就是服务端并不会保存身份认证相关的数据。</p><p><strong>组成</strong></p><ul><li>uid: 用户唯一身份标识</li><li>time: 当前时间的时间戳</li><li>sign: 签名, 使用 <code>hash/encrypt</code> 压缩成定长的十六进制字符串，以防止第三方恶意拼接<br>固定参数(可选): 将一些常用的固定参数加入到 token 中是为了避免重复查库</li></ul><p><strong>存放</strong></p><p>token在客户端一般存放于<code>localStorage，cookie，或sessionStorage</code>中。在服务器一般存于<code>数据库</code>中</p><h4 id="token认证流程"><a href="#token认证流程" class="headerlink" title="token认证流程"></a>token认证流程</h4><p>token 的认证流程与cookie很相似</p><ul><li>用户登录，成功后服务器返回Token给客户端。</li><li>客户端收到数据后保存在客户端</li><li>客户端再次访问服务器，将token放入<code>headers</code>中</li><li>服务器端<strong>采用filter过滤器校验</strong>。校验成功则返回请求数据，校验失败则返回错误码</li></ul><h4 id="token可以抵抗csrf，cookie-session不行"><a href="#token可以抵抗csrf，cookie-session不行" class="headerlink" title="token可以抵抗csrf，cookie+session不行"></a>token可以抵抗csrf，cookie+session不行</h4><p>假如用户正在登陆银行网页，同时登陆了攻击者的网页，并且银行网页未对csrf攻击进行防护。攻击者就可以在网页放一个表单，该表单提交src为<code>http://www.bank.com/api/transfer</code>，body为<code>count=1000&amp;to=Tom</code>。倘若是session+cookie，用户打开网页的时候就已经转给Tom1000元了.因为<strong>form 发起的 POST 请求并不受到浏览器同源策略的限制</strong>，因此可以任意地使用其他域的 Cookie 向其他域发送 POST 请求，形成 CSRF 攻击。在post请求的瞬间，cookie会被浏览器自动添加到请求头中。但token不同，token是开发者<strong>为了防范csrf而特别设计的令牌</strong>，浏览器<code>不会自动添加到headers里</code>，攻击者也无法访问用户的token，所以提交的表单<strong>无法通过服务器过滤</strong>，也就无法形成攻击。</p><h4 id="分布式情况下的session和token"><a href="#分布式情况下的session和token" class="headerlink" title="分布式情况下的session和token"></a>分布式情况下的session和token</h4><p>负载均衡多服务器的情况，不好确认当前用户是否登录，因为多服务器不共享session。该解决方案是 <code>session 数据持久化</code>，<strong>写入数据库或别的持久层</strong>。各种服务收到请求后，都向持久层请求数据。这种方案的优点是架构清晰，缺点是<code>工程量比较大</code>。另外，持久层万一挂了，就会单点失败。</p><p>而token是无状态的，<code>token</code>字符串里就<strong>保存了所有的用户信息</strong></p><p>客户端登陆传递信息给服务端，服务端收到后把用户信息加密（token）传给客户端，客户端将token存放于localStroage等容器中。客户端每次访问都传递token，服务端解密token，就知道这个用户是谁了。通过cpu加解密，服务端就不需要存储session占用存储空间，就很好的解决负载均衡多服务器的问题了。这个方法叫做<code>JWT(Json Web Token)</code></p><blockquote><p>Json web token (JWT), 是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准（(RFC 7519).该token被设计为紧凑且安全的，特别适用于<code>分布式站点的单点登录（SSO）场景</code>。JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该token也可直接被用于认证，也可被加密。</p></blockquote><p><a href="http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html">参考：阮一峰 JSON Web Token 入门教程</a></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>session存储于服务器，可以理解为一个状态列表，拥有一个唯一识别符号sessionId，通常存放于cookie中。服务器收到cookie后解析出sessionId，再去session列表中查找，才能找到相应session所依赖cookie</li><li>cookie类似一个令牌，装有sessionId，存储在客户端，浏览器通常会自动添加。</li><li>token也类似一个令牌，无状态，用户信息都被加密到token中，服务器收到token后解密就可知道是哪个用户。需要开发者手动添加。</li><li>jwt只是一个跨域认证的方案</li></ul><h3 id="如何保护cookie"><a href="#如何保护cookie" class="headerlink" title="如何保护cookie"></a>如何保护cookie</h3><h4 id="Secure和HttpOnly"><a href="#Secure和HttpOnly" class="headerlink" title="Secure和HttpOnly"></a>Secure和HttpOnly</h4><p><code>Secure</code>属性意味着把cookie通信限制在加密传输中，指示浏览器只能通过安全/加密连接使用cookie。然而如果一个web服务器在非安全连接中给cookie设置了一个secure属性，这个cookie在发送给用户时仍然可以通过<strong>中间人攻击</strong>拦截到。因此，为了安全<strong>必须通过安全连接</strong>设置cookie的Secure属性。</p><p><code>HttpOnly</code>属性指示浏览器除了HTTP/HTTPS请求之外不要显示cookie。这意味着这种cookie不能在客户端通过脚本获取，因此也不会轻易的被跨站脚本窃取。</p><h4 id="浏览器设置"><a href="#浏览器设置" class="headerlink" title="浏览器设置"></a>浏览器设置</h4><p>大部分浏览器都支持cookie，并且允许用户禁止掉他们。下面是一些常用的选项：</p><ul><li>完全允许或者禁止cookie，以便浏览器总是接受或者总是阻止cookie</li><li>通过cookie管理器查看或者删除cookie</li><li>彻底清除所有的隐私数据，包括cookie</li></ul><h3 id="HTTPS中-TLS握手过程简述"><a href="#HTTPS中-TLS握手过程简述" class="headerlink" title="HTTPS中 TLS握手过程简述"></a>HTTPS中 TLS握手过程简述</h3><p><a href="http://47.98.159.95/my_blog/browser-security/003.html">参考：三元博客 (传统RSA版本)HTTPS为什么让数据传输更安全？</a></p><p><a href="https://juejin.im/post/6844904100035821575#heading-74">参考：TLS1.2 握手的过程是怎样的？</a></p><h3 id="Koa-中间件-passport"><a href="#Koa-中间件-passport" class="headerlink" title="Koa 中间件 passport"></a>Koa 中间件 passport</h3><h3 id="仿美团项目登录怎么实现的"><a href="#仿美团项目登录怎么实现的" class="headerlink" title="仿美团项目登录怎么实现的"></a>仿美团项目登录怎么实现的</h3><h3 id="浏览器缓存-强缓存-和-协商缓存-状态码"><a href="#浏览器缓存-强缓存-和-协商缓存-状态码" class="headerlink" title="浏览器缓存 强缓存 和 协商缓存 状态码"></a>浏览器缓存 强缓存 和 协商缓存 状态码</h3><blockquote><p>（见后文）</p></blockquote><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p>一面通过</p><h2 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h2><h3 id="面经"><a href="#面经" class="headerlink" title="面经"></a>面经</h3><blockquote><p>开篇没有自我介绍，面试官直接说一面问的比较简单，我来考察一下。</p></blockquote><p>1、考你一点操作系统知识，你知道进程和线程吗？它们有什么区别联系？</p><p>2、进程间通信有了解过吗？linux文件系统说一说？</p><p>3、说说网络吧，你知道子网掩码这个概念吗？这个出错了会怎么办？是访问不了内网还是外网还是怎么？</p><p>4、刚刚说了ABC类地址，你知道这个是怎么区分的吗？</p><p>5、你怎么学习前端的？</p><p>6、那你有了解过 BOM 和 DOM吗？</p><p>7、有了解过 map 吗？那你知道 Map和 WeakMap的区别吗？</p><p>8、你刚刚讲到了垃圾回收，那你知道v8垃圾回收机制吗？说说</p><p>9、你了解class吗？你能模拟实现它的私有属性吗？让他具有 private 功能</p><p>10、ES5中的继承实现方式</p><p>11、提供类似框架，实现时间过滤器</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DateHelper</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将 UNIX timestamp 时间标签转换成 formatter 格式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param <span class="type">&#123;Number&#125;</span> </span>时间标签 e.g. 1463368789</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param <span class="type">&#123;String&#125;</span> </span>格式 e.g. &#x27;yyyy-mm-dd hh:MM&#x27;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@returns <span class="type">&#123;String&#125;</span> </span>e.g. &#x27;2016-05-16 18:17&#x27;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    timestampConverter (timestamp: number, <span class="attr">formatter</span>: string): string &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>12、算法题</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">给定一个整数数组nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</span><br><span class="line"></span><br><span class="line">示例: 输入: [-<span class="number">2</span>,<span class="number">1</span>,-<span class="number">3</span>,<span class="number">4</span>,-<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,-<span class="number">5</span>,<span class="number">4</span>], 输出: <span class="number">6</span></span><br></pre></td></tr></table></figure><blockquote><p>这道题卡了一小会，但最后还是以O(n)时间做出来了</p></blockquote><p>13、设计题</p><p>微信扫描二维码登录网页是什么原理，前后两个事件是如何联系的？</p><blockquote><p>场景是一台手机（已经登录了微信），PC端服务器，微信服务器，网页二维码。你怎么处理这四者的关系，不牵扯到网络，中间人攻击层面来讲。</p></blockquote><blockquote><p>这题想了挺久，不断尝试去套面试官的话，不过后面面试官说我还是猜到了一点点。</p></blockquote><p>14、你还有什么要问我的吗？</p><blockquote><p>请教了一下最后那个设计题的简单思路，我是最后结束了才明白场景居然是那样，不过面试官那边确实有点吵，一些点也没抓住。</p></blockquote><p><a href="https://www.zhihu.com/question/20368066">参考知乎：微信扫描二维码登录网页是什么原理，前后两个事件是如何联系的？</a></p>]]></content>
      
      
      <categories>
          
          <category> 面试整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 秋招 </tag>
            
            <tag> 字节跳动 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「美团-两轮车部门」秋招面试复盘总结</title>
      <link href="posts/20201023/"/>
      <url>posts/20201023/</url>
      
        <content type="html"><![CDATA[<h3 id="美团-两轮车部门"><a href="#美团-两轮车部门" class="headerlink" title="美团-两轮车部门"></a>美团-两轮车部门</h3><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20201023210708312.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70#pic_center" alt=""></p><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>10月19日晚上收到了HR电话邀约，约了10月23日面试，当天晚上就收到了两个面试邀请，下午3点和 晚上6点，当时以为是发错了，没想到的当天两连面，下面分享一下面试过程。</p><h3 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h3><p>10月23日（周五）下午3点 时间大约56分钟左右。</p><h4 id="面经"><a href="#面经" class="headerlink" title="面经"></a>面经</h4><p>1、自我介绍<br>2、询问实习经历<br>3、看下述代码意思：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">ul</span><span class="selector-class">.content</span>&gt;<span class="selector-class">.a</span><span class="selector-pseudo">:nth-child(2)</span><span class="selector-pseudo">:not(</span><span class="selector-pseudo">:disabled)</span></span><br></pre></td></tr></table></figure><p>4、<code>head</code> 头部 <code>meta</code> 了解多少？<br>5、<code>opacity: 0</code>、<code>visibility: hidden</code>、<code>display:none</code> 的区别？<br>6、<code>js</code> 的引入方式有哪些？<br>7、<code>import</code>、<code>require</code> 方式有什么区别？<br>8、不定宽不定高的元素垂直水平居中？<br>9、<code>defer</code>、<code>async</code>区别？<br>10、<code>http</code> 缓存策略？<br>11、浏览器的本地存储方式有哪些？<br>12、<code>httpOnly</code> 的理解，怎么获取<code>cookie</code>？<br>13、<code>localStorage</code> 和 <code>vuex</code> 的理解？<br>14、有些什么方式可以改变函数 <code>this</code> 指针？<br>15、截止目前 <code>js</code> 里有些什么数据类型？<br>16、<code>event loop</code> 的理解？<br>17、<code>ES6 class</code> 与 <code>ES5</code> 的构造函数？<br>18、<code>v-show</code> 和 <code>v-if</code> 的区别？<br>19、<code>template</code> 是否能用 <code>v-show</code>？<br>20、<code>Vue</code> 中 <code>$set</code> 理解<br>21、<code>Vue</code> 中 <code>&amp;nextTick</code> 的理解<br>22、手撕代码：<code>console.log(&#39;hello&#39;.repeatify(3))</code>，输出<code>hellohellohello</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span>.prototype.repeatify = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line"><span class="keyword">let</span> res = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="keyword">while</span>(n--)&#123;</span><br><span class="line">res+=<span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;hello&#x27;</span>.repeatify(<span class="number">3</span>));</span><br></pre></td></tr></table></figure><p>23、对前端的看法，个人职业规划<br>24、你还有什么想问我的吗？</p><h4 id="感受"><a href="#感受" class="headerlink" title="感受"></a>感受</h4><p>问了部门是两轮车部门，体验还不错，面试官会有引导，然后问了一下主要技术栈和小组规模，了解到主要做美团单车那一块，PC端那些等，一面的话就没有问很多。</p><h3 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h3><p>10月23日（周五）下午6点 时间大约30分钟左右</p><h4 id="面经-1"><a href="#面经-1" class="headerlink" title="面经"></a>面经</h4><p>1、得到面试官反馈说一面面评还不错，夸赞博客<br>2、介绍实习经历，<code>star</code> 法则<br>3、项目前后端交互那块<br>4、作为前端实习的小组长，做了些啥<br>5、聊项目架构<br>6、聊未来职业发展、期待的工作环境<br>7、对于前端这个领域的了解</p><h4 id="感受-1"><a href="#感受-1" class="headerlink" title="感受"></a>感受</h4><p>二面感觉回答的挺自然地，把自己对于未来规划理清楚讲了一遍给面试官，后面面试官说后面会有HR面通知。</p><h3 id="HR面"><a href="#HR面" class="headerlink" title="HR面"></a>HR面</h3><p>10月28日 电话面 </p><p>首先，上午来了一个电话，了解一下基本情况，然后下午谈了薪资，介绍相关信息，发放 offer</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>选择去美团，接受offer</p>]]></content>
      
      
      <categories>
          
          <category> 面试整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 秋招 </tag>
            
            <tag> 美团 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>腾讯云 CODING 2021  【校招&amp;社招】春招内推开启，大家快来投递～</title>
      <link href="posts/20210324/"/>
      <url>posts/20210324/</url>
      
        <content type="html"><![CDATA[<p>CODING 2021 内推活动开始啦！</p><p>前端、后端、测试、运维？ - 在招！</p><p>产品、设计、售前、项目？ - 在招！</p><p>社招、校招？ - 都在招！</p><p>CODING 代码托管、持续集成、持续部署、制品库、项目协同，应有尽有！</p><p>公司官网：<a href="https://coding.net/join/">https://coding.net/join/</a></p><p>公司简介：深圳市腾云扣钉科技有限公司（CODING）成立于 2014 年 2 月，系<strong>腾讯旗下全资子公司</strong>。旗下一站式软件研发管理平台 – CODING（coding.net）上线稳定运行 6 年，目前已累积超过 200 万开发者用户，5 万家企业团队，服务涵盖互联网、金融、政企、教育等不同行业客户。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20210324111759857.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><p>下面内推的是校招内推，如果是社招的可以私信我，或者评论区留言告知一下。  小狮子前端交流群：666151691  欢迎大家来讨论交流～</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/img_convert/c96a94bb0fdf9341a60f9c0f2a4e93ea.png" alt=""></p><p><strong>欢迎大家投递，由于在工作日，有工作需要，回复可能不是很及时，还请各位投递简历之后，在评论区回复【已投递】，让我确认一下，然后与 HR 姐姐们联系尽早安排后续环节～</strong></p><p>可能大家比较关心工作时间哈，这里我说明一下，基本上没有加班， CODING 本身就是为了让开发者提升效率，<a href="https://coding.net/">https://coding.net/</a> 大家可以看一看公司官网哈，公司的产品也是比较简约美观哈。工作时间9:00-9:30 弹性打卡时间，下班不用打卡，标准965！</p><p>我目前在公司是做前端，相信也会有前端小伙伴来投递简历，在这里说一说入职感受：</p><p>技术栈很新，如果大家对技术感兴趣的话，来 CODING 是不错的选择，最近我有接触过微前端项目，99%项目都是以 React 技术为主，目前没有学习 React 的也没关系，基础知识扎实很快上手哈～（目前我就在学 React)</p><p>另外，后端也是特别特别新的技术，Docker，DevOps CI/CD概念，Kubernetes等等</p><p>最后，由于本人是前端，在此给大家提供一些我的复习资料哈（我都这么为你准备了，还不来投递简历么？）</p><p><a href="https://yangchaoyi.vip/">https://yangchaoyi.vip/</a>  访问超逸的博客，为你面试保驾护航～</p><p><strong>腾讯云 CODING 期待你的加入！云端开发，由你定义！</strong></p><p>已投递的同学，请在评论区回复【已投递】哈，小伙伴们也可以加小狮子前端交流群：666151691 或者私信询问公司更多福利哈～</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内推 </tag>
            
            <tag> CODING </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Vue全家桶+SSR+Koa2全栈开发】项目搭建过程  整合  学习目录（持续更新中）</title>
      <link href="posts/35725/"/>
      <url>posts/35725/</url>
      
        <content type="html"><![CDATA[<h2 id="写在开头"><a href="#写在开头" class="headerlink" title="写在开头"></a>写在开头</h2><blockquote><div>大家好，这里是<font color=chocolate>lionLoveVue</font>，基础知识决定了编程思维，学如逆水行舟，不进则退。金三银四，为了面试也还在慢慢积累知识，Github上面可以直接查看所有前端知识点梳理，<a href="https://github.com/Chocolate1999/Front-end-learning-to-organize-notes">github传送门</a>，觉得不错，点个Star★，好运连连，Offer终究鼠于你，持续更新中。另外，也可以关注微信公众号：<font color=chocolate>小狮子前端Vue</font>，源码以及资料今后都会放在里面。</div></blockquote><h2 id="Vue基础"><a href="#Vue基础" class="headerlink" title="Vue基础"></a>Vue基础</h2><hr/><p>全局安装<code>vue/cli</code>脚手架</p><p>管理员身份运行cmd，执行如下代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install -g @vue/cli</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">yarn <span class="built_in">global</span> add @vue/cli</span><br></pre></td></tr></table></figure><p>命令行输入<code>vue ui</code> 打开可视化界面</p><p>使用默认<code>default</code>配置</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200405213511680.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><p>用vscode打开项目，执行如下命令</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm/cnpm run serve</span><br></pre></td></tr></table></figure><p>访问：<a href="http://localhost:8080/">http://localhost:8080/</a> 查看是否配置成功</p><h3 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h3><p><a href="https://cn.vuejs.org/v2/guide/custom-directive.html">推荐阅读：官方文档-自定义指令</a></p><p>除了核心功能默认内置的指令 (<code>v-model</code> 和 <code>v-show</code>)，Vue 也允许注册自定义指令。注意，在 Vue2.0 中，代码复用和抽象的主要形式是组件。然而，有的情况下，你仍然需要对普通 DOM 元素进行底层操作，这时候就会用到自定义指令。</p><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><p><strong>父子组件的通信方式</strong></p><p>父组件传子组件，是在子组件使用<code>props</code>，然后再父组件，通过<code>:=</code>绑定变量</p><p>子组件传父组件，是在子组件使用自定义事件，例如：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//子组件配置</span></span><br><span class="line">@click=<span class="string">&quot;$emit(&#x27;patch(xxx)&#x27;)&quot;</span></span><br><span class="line"><span class="comment">//父组件配置</span></span><br><span class="line">@patch=<span class="string">&quot;func&quot;</span></span><br></pre></td></tr></table></figure><p>如果是跨组件，不是父子组件关系，就使用 <code>Vuex</code>。</p><p><strong>slot</strong></p><p>插槽在组件抽象设计中的应用：</p><p>原本组件不能嵌入html内容，但通过父子组件传递插槽即可实现</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//父组件</span></span><br><span class="line">slot=<span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="comment">//子组件</span></span><br><span class="line">&lt;slot name=<span class="string">&quot;a&quot;</span>&gt;&lt;/slot&gt;</span><br></pre></td></tr></table></figure><h2 id="Vuex基础"><a href="#Vuex基础" class="headerlink" title="Vuex基础"></a>Vuex基础</h2><hr/><p>Vuex简单来说就是多个组件共享数据，但是组件是不能直接操纵数据的，如下图所示，我们的数据放在紫色部分<code>state</code>里面（没有放在<code>data</code>里），操作数据源由红色部分<code>Mutations</code>完成，什么时候操控数据有黄色部分<code>Actions</code>来控制，这里就是由用户来操纵组件来触发 <code>Actions</code> ，最后，由 <code>Actons</code> 提交 <code>Commit</code> 通知改变数据源，来完成组件视图的更新渲染。<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200406210920118.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><p><strong>安装Vuex</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm/cnpm i vuex</span><br></pre></td></tr></table></figure><h2 id="Koa2基础"><a href="#Koa2基础" class="headerlink" title="Koa2基础"></a>Koa2基础</h2><hr/><h3 id="koa-generator"><a href="#koa-generator" class="headerlink" title="koa-generator"></a>koa-generator</h3><p>管理员身份打开cmd，运行如下代码，全局安装</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install -g koa-generator</span><br></pre></td></tr></table></figure><p>使用<code>git bash</code>，在文件夹内创建项目</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">koa2 -e project_name</span><br></pre></td></tr></table></figure><p>-e 表示使用<code>ejs</code>，不加和 <code>node</code> 一样</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200407104615983.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""><br>接下来，执行安装命令</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">cd koa2_learn</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure><p>安装&amp;更新 <code>fsevents</code> 包</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install --update-binary</span><br></pre></td></tr></table></figure><p>run app命令：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">DEBUG=koa2_learn:* npm start</span><br></pre></td></tr></table></figure><p>执行后输出 <code>node bin/www</code> 说明服务端已经跑起来了</p><p>访问 <a href="http://localhost:3000/">http://localhost:3000/</a> 查看页面效果</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/2020040710530544.png" alt=""><br>我们查看 <code>package.json</code> ，发现启动脚本是通过 <code>npm scripts</code> ，如果你想要自启动的话，执行如下命令：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200407105417668.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""><br>对于上述执行指令，<code>dev</code> 和 <code>prd</code> 必须使用 <code>npm run xxx</code></p><p>与此同时，我们在 <code>index.js</code> 全局打印一下，加入如下代码：<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200407105756505.png" alt=""></p><p>在 <code>git bash</code> 中执行如下命令</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure><p>说明我们改变服务端脚本，服务能够自启动了<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200407105837914.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><h2 id="Koa2中间件"><a href="#Koa2中间件" class="headerlink" title="Koa2中间件"></a>Koa2中间件</h2><hr/><p>图片来自Koa2官方，大致意思就是服务端接受客户端的 <code>Request</code>，经过服务端一些流程，然后 <code>Response</code> 返回给浏览器，其中每一个环，都是一个中间件。进来的时候会经过某个中间件，出去的时候也会经过，<strong>这样的机制就可以让中间件引用顺序和代码执行顺序不一致。</strong><br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200407112345912.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><h2 id="mongoose基础"><a href="#mongoose基础" class="headerlink" title="mongoose基础"></a>mongoose基础</h2><hr/><h3 id="mongodb概念-amp-安装"><a href="#mongodb概念-amp-安装" class="headerlink" title="mongodb概念&amp;安装"></a>mongodb概念&amp;安装</h3><p>mongodb属于<code>非关系型</code>数据库，与<code>mysql</code>相对的（mysql是关系型数据库）</p><p>mongodb里面没有 <code>table</code>表，只有 <code>Collections</code></p><p>原本mysql一行叫做 <code>row</code>，而在mongodb中叫做 <code>document</code>，原本一列叫做 <code>cloumn</code>，而现在叫做 <code>fields</code></p><p>windows 10 安装教程：</p><p><a href="https://www.runoob.com/mongodb/mongodb-window-install.html">推荐阅读：Windows 平台安装 MongoDB</a></p><p><strong>注意</strong></p><p>安装<code>Install MongoDB Compass</code> 不勾选，否则可能要很长时间都一直在执行安装，MongoDB Compass是一个图形界面管理工具，后面会去下载一个图形界面管理工具<code>Robo3T</code>。</p><p>其它选项就默认选择 <code>next</code> 即可</p><p>找到下面位置下的两个 <code>.exe</code> 都点击运行一下好了…  （启动服务应该是下面那一个）<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200407135608794.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><p><strong>检测是否安装成功</strong></p><p>访问：<a href="http://127.0.0.1:27017/">http://127.0.0.1:27017/</a> 是否出现如下界面：</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200407135531155.png" alt=""></p><h3 id="图形界面管理工具-Robo3T-安装与使用"><a href="#图形界面管理工具-Robo3T-安装与使用" class="headerlink" title="图形界面管理工具 Robo3T 安装与使用"></a>图形界面管理工具 <code>Robo3T</code> 安装与使用</h3><p><a href="https://robomongo.org/">官网地址</a></p><p><a href="https://studio3t.com/download/">Studio windows下载地址</a></p><p><a href="https://robomongo.org/download">Robo 3T下载</a></p><p>进入安装页面后选择 <code>easy</code> 版本 ，然后选择你喜欢的主题风格，是明亮还是黑暗风格</p><p>进入图形化界面后，新建一个 <code>connection</code>，选择默认端口 <code>27017</code>，保存</p><h3 id="mongoose-中文文档"><a href="#mongoose-中文文档" class="headerlink" title="mongoose 中文文档"></a>mongoose 中文文档</h3><p><a href="https://xiaoxiami.gitbook.io/mongoose/">参考：mongoose 4.5中文文档</a></p><p>在之前配置好的 Koa2 文件夹内（我的是koa2_learn文件夹） 打开 <code>bash</code> 界面，输入如下命令，安装 <code>mongoose</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm i mongoose</span><br></pre></td></tr></table></figure><h3 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h3><p><strong>接下来就是配置相关了</strong></p><p>在项目根目录下创建 名为 <code>dbs</code> 的文件夹</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/2020040714493081.png" alt=""><br>新建一个 <code>config.js</code> 文件，配置如下代码</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    dbs: <span class="string">&#x27;mongodb://127.0.0.1:27017/dbs&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>dbs</code> 目录下创建 名为 <code>models</code> 的文件夹<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200407145636457.png" alt=""><br>新建一个 <code>person.js</code> 文件，配置如下代码（此时的文件名对应着之后我们的“表名”，也就是 <code>Collections</code>）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mongoose = <span class="built_in">require</span>(<span class="string">&#x27;mongoose&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建模式 </span></span><br><span class="line"><span class="keyword">let</span> personSchema = <span class="keyword">new</span> mongoose.Schema(&#123;</span><br><span class="line">    name: <span class="built_in">String</span>,</span><br><span class="line">    age: <span class="built_in">Number</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建模型</span></span><br><span class="line"><span class="built_in">module</span>.exports = mongoose.model(<span class="string">&#x27;Person&#x27;</span>,personSchema)</span><br></pre></td></tr></table></figure><p>然后在 <code>app.js</code> 中进行导入</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mongoose = <span class="built_in">require</span>(<span class="string">&#x27;mongoose&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> dbConfig = <span class="built_in">require</span>(<span class="string">&#x27;./dbs/config&#x27;</span>)</span><br></pre></td></tr></table></figure><p>在 <code>app.js</code> 默认注释 <code>routes</code> 后面，添加第三行连接代码</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// routes</span></span><br><span class="line">app.use(index.routes(), index.allowedMethods())</span><br><span class="line">app.use(users.routes(), users.allowedMethods())</span><br><span class="line">mongoose.connect(dbConfig.dbs,&#123;</span><br><span class="line">  useNewUrlParser:<span class="literal">true</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>基本配置就结束了，现在最好是重启一下koa服务，<code>ctrl+c</code> 退出，然后输入如下命令：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure><p>出现如下界面，说明配置是没有问题的，连接成功！<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200407151732459.png" alt=""><br>接下来就是尝试写一个api试试，在 <code>users.js</code> 文件内配置如下代码</p><p>头部导入模型</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//导入模型</span></span><br><span class="line"><span class="keyword">const</span> Person = <span class="built_in">require</span>(<span class="string">&#x27;../dbs/models/person&#x27;</span>)</span><br></pre></td></tr></table></figure><p>自定义api接口</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">router.post(<span class="string">&#x27;/addPerson&#x27;</span>,<span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params">ctx</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//新建一个模型的实例</span></span><br><span class="line">  <span class="keyword">const</span> person = <span class="keyword">new</span> Person(&#123;</span><br><span class="line">    name: ctx.request.body.name,</span><br><span class="line">    age: ctx.request.body.age</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">let</span> code</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> person.save()</span><br><span class="line">    code=<span class="number">0</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    code=-<span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  ctx.body=&#123;</span><br><span class="line">    code</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>调用接口。 <code>curl</code> 是一个shell 命令，  <code>-d</code>命令表示是 <code>post</code> 请求 ，接下来是数据项，最后是api接口地址</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">curl -d <span class="string">&#x27;name=chocolate&amp;age=20&#x27;</span> http:<span class="comment">//localhost:3000/users/addPerson</span></span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200407162123495.png" alt=""><br>此时，打开Robo 3T，刷新一下我们的数据库，就能发现多了一个 <code>dbs</code><br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200407162222285.png" alt=""><br>查看一下，是否有对应写入数据：<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/2020040716231684.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""><br>上述过程，基本上把我们的后端服务和数据库进行了打通，后续我们只需要套着之前的例子来就好了，接下来再展示写一个api，因为上文是增加操作，也就是写操作，下文我们再来个读操作吧。</p><p>依旧是在 <code>users.js</code> 中加入如下代码</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数据库读取api</span></span><br><span class="line">router.post(<span class="string">&#x27;/getPerson&#x27;</span>,<span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params">ctx</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">await</span> Person.findOne(&#123;<span class="attr">name</span>:ctx.request.body.name&#125;)</span><br><span class="line">  <span class="keyword">const</span> results = <span class="keyword">await</span> Person.find(&#123;<span class="attr">name</span>:ctx.request.body.name&#125;)</span><br><span class="line">  ctx.body = &#123;</span><br><span class="line">    code: <span class="number">0</span>,</span><br><span class="line">    result,</span><br><span class="line">    results</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>打开 <code>bash</code> ，执行如下命令：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">curl -d <span class="string">&#x27;name=chocolate&#x27;</span> http:<span class="comment">//localhost:3000/users/getPerson</span></span><br></pre></td></tr></table></figure><p>发现，会返回给我们json数据包，证明api接口实现<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200407171844176.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""><br>最后，附上更新和删除api，亲测有效嗷</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//更新api</span></span><br><span class="line">router.post(<span class="string">&#x27;/updatePerson&#x27;</span>,<span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params">ctx</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">await</span> Person.where(&#123;</span><br><span class="line">    name:ctx.request.body.name</span><br><span class="line">  &#125;).update(&#123;</span><br><span class="line">    age: ctx.request.body.age</span><br><span class="line">  &#125;)</span><br><span class="line">  ctx.body = &#123;</span><br><span class="line">    code: <span class="number">0</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//删除api</span></span><br><span class="line">router.post(<span class="string">&#x27;/removePerson&#x27;</span>,<span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params">ctx</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">await</span> Person.where(&#123;</span><br><span class="line">    name:ctx.request.body.name</span><br><span class="line">  &#125;).remove()</span><br><span class="line"></span><br><span class="line">  ctx.body = &#123;</span><br><span class="line">    code: <span class="number">0</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><a href="https://xiaoxiami.gitbook.io/mongoose/">更多知识点请参考：mongoose 4.5中文文档</a></p><h2 id="Redis基础"><a href="#Redis基础" class="headerlink" title="Redis基础"></a>Redis基础</h2><hr/><h3 id="cookie-和-session-引入"><a href="#cookie-和-session-引入" class="headerlink" title="cookie 和 session 引入"></a>cookie 和 session 引入</h3><p>这里就要扯到 <code>cookie</code> 和 <code>session</code>的相关知识点了，划重点啦！ </p><p>服务端的程序如何去识别客户端的状态，大家知道，http是无状态的，<a href="https://blog.csdn.net/weixin_42429718/article/details/105264747">推荐阅读：如何学好前端，白嫖知识</a> </p><p>比如现在有个用户A，它访问了服务器程序，那服务器程序如何知道下一次再访问的时候还是A呢？</p><p>因此，对于这一块就要用到非常重要的概念，<code>session</code>，当然，这个<code>session</code>可不是浏览器的，<strong>而是服务器的</strong>，它是用来存储用户的信息的。</p><p>那么，服务器的 <code>session</code>是如何保持在客户端呢？</p><p>这个时候呢，又要引出另一个非常重要的概念，浏览器中的 <code>cookie</code> 。</p><p>综上所述，<code>cookie</code> 和 <code>session</code> 的关系是：服务端用 <code>session</code> 来保存用户的状态，然后客户端用 <code>cookie</code> 来保存 <code>session</code> ，服务器端把 <code>session</code> 种植到 <code>cookie</code> 中，然后下次访问时，<code>cookie</code> 会携带着 <code>session</code> ，进而<strong>达到一个身份认证的效果</strong>。</p><h3 id="redis概念-amp-安装"><a href="#redis概念-amp-安装" class="headerlink" title="redis概念&amp;安装"></a>redis概念&amp;安装</h3><p>上文我们知道了cookie 和 session 在浏览器和服务器端的作用，那么与我们<code>redis</code> 有什么关系呢？</p><p>想一想，既然是认证的功能，那我们服务端的<code>session</code> 应该存在哪呢，也许你会想着放入服务器端存储，放入内存当中，这确实是一种方式，没有问题，但当应用程序很大的时候，<code>session</code> 容量特别大的时候呢？例如某宝这样的呢？此时内存肯定不够用了，这个时候就需要一个容器来存储大容量的 <code>session</code> 了，此时存储数据库 <code>redis</code>就发挥了它的作用了！</p><p>关于数据库的话，上文也提到了<code>mongodb</code>，我们是不是也可以用这个呢？</p><p>这个的话，虽然也是一种方式，但我们要考虑<strong>读写性能问题</strong>，因为 <code>redis</code>是<strong>快速读写类型的数据库</strong>，使用灵活方便，是 <code>key-value</code> 型的</p><hr/><p>为了更加了解<code>redis</code>，这里我就引用官方介绍了：</p><ul><li><p>REmote DIctionary Server(Redis) 是一个由Salvatore Sanfilippo写的key-value存储系统。</p></li><li><p>Redis是一个开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。</p></li><li><p>它通常被称为数据结构服务器，因为值（value）可以是 字符串(String), 哈希(Hash), 列表(list), 集合(sets) 和 有序集合(sorted sets)等类型。</p></li></ul><p><strong>安装教程</strong></p><p><a href="https://www.runoob.com/redis/redis-install.html">参考：redis安装教程</a></p><p><a href="https://blog.csdn.net/u012343297/article/details/78839063?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3&utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3">参考：windows下Redis的安装和配置–图文教程</a></p><p>在 <code>koa</code> 的 <code>bash</code>界面，执行如下命令，完成 <code>koa</code> 与 <code>redis</code> 的连接</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm i koa-generic-session koa-redis</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">redis-server.exe redis.windows.conf</span><br></pre></td></tr></table></figure><h3 id="启动-redis-服务"><a href="#启动-redis-服务" class="headerlink" title="启动 redis 服务"></a>启动 redis 服务</h3><p>一、[9980] 21 Apr 02:57:05.611 # Creating Server TCP listening socket 127.0.0.1:6379: bind: No error</p><p>解决方法：在命令行中运行</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">redis-cli.exe</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt;shutdown</span><br></pre></td></tr></table></figure><p>二、Redis (error) NOAUTH Authentication required.解决方法</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt;auth <span class="string">&quot;123456&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt;shutdown</span><br><span class="line">not connected&gt;exit</span><br></pre></td></tr></table></figure><p>然后重新运行 <code>redis-server.exe redis.windows.conf</code> ，启动成功！</p><p><a href="https://blog.csdn.net/sweetgirl520/article/details/79001056#commentBox">参考：Redis启动报错：Creating Server TCP listening socket 127.0.0.1:6379: bind: No error</a></p><h2 id="Nuxt-js基础"><a href="#Nuxt-js基础" class="headerlink" title="Nuxt.js基础"></a>Nuxt.js基础</h2><hr/><p>Nuxt.js 是一个基于Vue.js的通用应用框架，预设了利用Vue.js开发服务端渲染的应用所需要的各种配置。</p><p>基于Vue 2做的，包括Vue-Router，支持Vuex、Vue Server Render、vue-meta</p><p><img src= "/img/loading.gif" data-lazy-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy82NTUwMDk2LTc4NDVmMjgxYzg1NjVlNTAucG5n?x-oss-process=image/format,png#pic_center" alt=""></p><h3 id="Nuxt-js工作流"><a href="#Nuxt-js工作流" class="headerlink" title="Nuxt.js工作流"></a>Nuxt.js工作流</h3><p>下图源自Nuxt官网，简单介绍一下它的工作流程</p><p><a href="https://nuxtjs.org/api">更多内容，请参考：nuxtjs 英文官方文档</a></p><p><a href="https://zh.nuxtjs.org/guide">参考：nuxtjs 中文文档</a><br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200407200805943.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""><br>从浏览器发出一个请求，到最终服务端渲染完成，关于Nuxt的生命周期如下：</p><ul><li><code>Incoming Request</code> 浏览器发送一个请求</li><li>服务端检查是否有 <code>nuxtServerInit</code> 配置项，有的话就会执行这个函数，其中包含一个标注： <code>Store action</code> 用来操作 <code>vuex</code></li><li>下一个环节就是中间件 <code>middleware</code> ，与路由相关，做任何你想要的功能</li><li>预验证 <code>validate()</code> 可以配合高级动态路由，做一些验证，比如是否允许跳转某个页面</li><li><code>asyncData() &amp; fetch()</code> 获取数据，前一个是用来渲染<code>vue component</code>，即 vue组件的，后一个通常用来修改 <code>vuex</code>，即 <code>Store</code>的</li><li>有了数据，模板后，最后一步就是 <code>Render</code> 渲染了，方式是 <code>SSR</code></li></ul><h3 id="Nuxt-js-安装"><a href="#Nuxt-js-安装" class="headerlink" title="Nuxt.js 安装"></a>Nuxt.js 安装</h3><p>如果没有安装vue cli的话，先全局安装一下</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm/cnpm install -g @vue/cli-init</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">vue init nuxt-community/koa-template nuxt_learn（这里填入你自己的文件名）</span><br></pre></td></tr></table></figure><p>安装完成后，依次执行如下命令</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">cd nuxt_learn</span><br><span class="line">npm install # Or yarn</span><br><span class="line">npm install --update-binary</span><br><span class="line">npm install ajv@^<span class="number">6</span>（可选项，如果有报warn，就装一下）</span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure><p>如果安装过程网络有问题，报错了，可以试试用 <code>cnpm</code>或者</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">nrm use cnpm</span><br></pre></td></tr></table></figure><p><strong>eslint版本问题：</strong> 需要更新eslint版本<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200407212332515.png" alt=""><br>解决：执行如下代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install eslint-plugin-html@^<span class="number">3</span></span><br></pre></td></tr></table></figure><p>执行完如下步骤后，最后一步，打开服务：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure><p><strong>babel编译版本有问题：</strong> 解决办法是升级<code>backpack-core@0.3.0</code>到<code>backpack-core@0.7.0</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install backpack-core@<span class="number">0.7</span><span class="number">.0</span> --save-dev</span><br></pre></td></tr></table></figure><p>解决上述问题后，编译能成功，但是客户端依旧运行报错</p><p>解决办法是：在<code>nuxt.config.js</code>里找到<code>eslint-loader</code>将<code>ctx.isClient</code>改成<code>ctx.Client</code>就可以运行了</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200408075951708.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><p><a href="https://www.cnblogs.com/ITtt/p/10515456.html">参考：解决vue init nuxt-community/koa-template项目，安装报错问题</a></p><p>解决完上述问题后，执行如下指令：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200408082532970.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200408082553312.png" alt=""><br>访问：<a href="http://localhost:3000/">http://localhost:3000/</a>  出现如下界面，代表配置成功 ✿✿ヽ(°▽°)ノ✿</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200408082558408.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""><br>附：微信公众号：【小狮子前端】 回复【nuxt-learn】即可获取本节源码</p><h3 id="知识拓展"><a href="#知识拓展" class="headerlink" title="知识拓展"></a>知识拓展</h3><p>当使用 <code>SSR</code> 时， <code>mounted</code> 只在浏览器端渲染，而<strong>在服务器端不会渲染</strong> ：浏览器通过axios请求的数据，只有 <code>created</code> 在开启SSR时会执行。</p><p>SSR原理：① 服务器端将编译好的内容（模板）下发（包括样式、内容、数据）  ② 把异步获取的数据响应给浏览器端（把交互交给浏览器来完成）</p><p><strong>SSR原理深入</strong></p><p>我们打开页面源代码，查看一下：<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200408105343967.png" alt=""><br>服务器端渲染完页面后给浏览器端的html分了几个部分，第一个是样式 <code>style</code> ，第二个是模板内容，例如上图中圈中的<font color=blue>蓝色</font>部分，第三个是服务端拿到的数据结果，例如上图中圈中的<font color=red>红色</font>部分，为什么服务端拿到的数据给到浏览器端呢？<br>这里我们得思考一个<font color=red><strong>SSR的工作原理</strong></font> 了</p><p>如果不给数据的话，就是一个静态html模板，一个<strong>静态的内容</strong>，没有任何交互，那交互是在哪完成的呢？</p><p>交互是在浏览器端完成的，也就是说浏览器端会有一个入口，进行预编译，但不会再渲染页面了，因为服务器端已经在页面渲染过一次了。<strong>它要做的是创建一个虚拟的编译结果（可以理解为虚拟dom），</strong> 和服务器端传过来的结果进行对比，如果有区别，它会重新请求数据。在nuxt项目中都是一套文件，没有特别指定是在浏览器端运行还是服务端运行，也就是SSR常说的<strong>同构</strong>，浏览器端编译虚拟dom，也依赖于 <code>vue</code> 文件，因此模板是有的，而编译这个dom，需要的是额外的数据，此数据是服务器端渲染之前请求而来的数据，如果数据不同步在浏览器端，<strong>编译出来的结果必然和服务器端编译结果不一致</strong>。 </p><p>综上，<strong>服务器端异步获取的数据会同步在浏览器端</strong>，作对比，如果对比一致的话，浏览器端就会对对应的dom结点注册事件，达到交互作用。</p><p><a href="https://nuxtjs.org/api">更多内容，请参考：nuxtjs 英文官方文档</a></p><p><a href="https://zh.nuxtjs.org/guide">参考：nuxtjs 中文文档</a></p><p><font color=chocolate>以上，就是我们项目搭建所需的基础知识啦，已经整理完结啦，当然还有许多地方没有提及，读者可以去查阅一些官方文档来补充更多知识，下文我们将逐步深入全栈开发过程记录，制作不易，点赞收藏评论，一键三连一波~</font></p><h2 id="项目搭建开始"><a href="#项目搭建开始" class="headerlink" title="项目搭建开始"></a>项目搭建开始</h2><hr/><h2 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h2><ul><li>node</li><li>vue</li><li>npm</li><li>webpack</li><li>nuxt</li></ul><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install -g npx</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npx create-nuxt-app loveVueApp</span><br></pre></td></tr></table></figure><p>使用 <code>npx</code> 可以帮助我们更快速的搭建项目环境，在你需要创建项目文件夹的地方 <code>shift+鼠标右键</code> 打开 <code>powershell</code> 窗口，执行上述命令，然后按照下列图片选择对应的模块：</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200408131621565.png" alt=""><br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200408131631954.png" alt=""><br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200408131650677.png" alt=""></p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200408131703632.png" alt=""><br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/2020040813172024.png" alt=""></p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200408131730286.png" alt=""><br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200408131810561.png" alt=""><br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200408131823305.png" alt=""><br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200408131845331.png" alt=""><br>安装完成后，会提示你执行如下命令：</p><p>这里我们就执行开发环境的指令就好了</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">cd loveVueApp</span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure><p>另附上，生产环境的指令：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">cd loveVueApp</span><br><span class="line">npm run build</span><br><span class="line">npm run start</span><br></pre></td></tr></table></figure><p>访问：<a href="http://localhost:3000/">http://localhost:3000/</a> 会有一个nuxtjs的图标出现，代表环境搭配成功 ✿✿ヽ(°▽°)ノ✿</p><p>此时，再 <code>ctrl+c</code> 退出当前服务</p><p>执行如下命令，重新安装一下，防止版本问题等</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install  --update-binary</span><br></pre></td></tr></table></figure><p>重装之后，再跑一次服务，看能不能打开界面</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure><h3 id="增加-babel-node-处理（使用ES6的import指令问题）"><a href="#增加-babel-node-处理（使用ES6的import指令问题）" class="headerlink" title="增加 babel-node 处理（使用ES6的import指令问题）"></a>增加 babel-node 处理（使用ES6的import指令问题）</h3><p>创建好我们的基本项目后，我们还需要对我们所需要的模块进行更改。</p><p>例如，对应目标文件的第一行代码：<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200408154705542.png" alt=""><br>改为如下代码</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Koa  <span class="keyword">from</span> <span class="string">&#x27;koa&#x27;</span></span><br></pre></td></tr></table></figure><p>于是，就会出现报错，无法识别<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200408154830122.png" alt=""></p><p>在上文讲解 <code>nuxtjs</code>基础 我们是可以直接用 <code>import</code> 操作的，但当我们使用官方脚手架时，是没有处理这个 <code>bug</code> 的。下面来解释一下为什么会出现这个问题：</p><p>当我们使用命令 <code>npm run dev</code> 的时候，其实是用了 <code>npm</code> 的 <code>script</code> 的方法，如下图所示：</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200408155247326.png" alt=""></p><p>可见使用了 <code>node</code>，并且不支持 <code>import</code> 操作，上文是因为使用了 <code>babel</code> 进行了处理，在这里官方脚手架时使用 <code>node</code> 来启动服务，没有经过 <code>babel</code> 处理，因此就不会识别 <code>import</code> 指令了。</p><p><strong>解决上述问题</strong></p><p>上文提到了是因为没有 <code>babel</code>处理，执行服务程序，那就自己加上去咯，具体如下：</p><p>在 <code>dev</code> 和 <code>start</code> 后面添加 <code>--exec babel-node</code></p><p>或者直接使用下面代码覆盖你的 <code>scripts</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;dev&quot;</span>: <span class="string">&quot;cross-env NODE_ENV=development nodemon server/index.js --watch server --exec babel-node&quot;</span>,</span><br><span class="line">    <span class="string">&quot;build&quot;</span>: <span class="string">&quot;nuxt build&quot;</span>,</span><br><span class="line">    <span class="string">&quot;start&quot;</span>: <span class="string">&quot;cross-env NODE_ENV=production node server/index.js --exec babel-node&quot;</span>,</span><br><span class="line">    <span class="string">&quot;generate&quot;</span>: <span class="string">&quot;nuxt generate&quot;</span></span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><p>然后，在根目录下创建一个 <code>.babelrc</code> 的配置文件，然后给它指定一个指令集</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;presets&quot;</span>:[<span class="string">&quot;es2015&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了代码还不行，还要再安装插件，执行如下命令</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install babel-preset-es2015</span><br><span class="line">npm install babel-cli -S</span><br></pre></td></tr></table></figure><p>好了，有了 <code>babel-node</code> 后我们就能启动服务程序了，改成了我们常用的 <code>ES6</code>语法了</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure><p>访问：<a href="http://localhost:3000/">http://localhost:3000/</a> 会有一个nuxtjs的图标出现，代表环境搭配成功 ✿✿ヽ(°▽°)ノ✿</p><h3 id="解决-sass-导致编译出错问题"><a href="#解决-sass-导致编译出错问题" class="headerlink" title="解决 sass 导致编译出错问题"></a>解决 sass 导致编译出错问题</h3><p>这个问题也依旧是脚手架带来的问题，解决方式就是安装几个插件，执行命令如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install sass-loader node-sass</span><br></pre></td></tr></table></figure><p>PS：可能会有下述 <code>warn</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install eslint@^(版本号)  <span class="comment">//（注意，这里是当你出现对应warn才执行）</span></span><br></pre></td></tr></table></figure><p>我的是这种警告，因此依葫芦画瓢，执行下述命令<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200408162852228.png" alt=""></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install sass@^<span class="number">1.3</span><span class="number">.0</span> fibers@&gt;= <span class="number">3.1</span><span class="number">.0</span></span><br></pre></td></tr></table></figure><h3 id="辅助工具安装"><a href="#辅助工具安装" class="headerlink" title="辅助工具安装"></a>辅助工具安装</h3><ul><li>MongoDB</li><li>redis</li><li>Robo 3T</li></ul><p>（上文基础部分有介绍安装教程，可以往回看一看对应模块 ↑）</p><h2 id="远程仓库常用指令（整理）"><a href="#远程仓库常用指令（整理）" class="headerlink" title="远程仓库常用指令（整理）"></a>远程仓库常用指令（整理）</h2><ul><li><p>查看分支：<code>git branch</code></p></li><li><p>查看项目的分支们(包括本地和远程) <code>git branch -a</code></p></li><li><p>创建分支：<code>git branch &lt;name&gt;</code></p></li><li><p>切换分支：<code>git checkout &lt;name&gt;</code></p></li><li><p>创建+切换分支：<code>git checkout -b &lt;name&gt;</code></p></li><li><p>合并某分支到当前分支：<code>git merge &lt;name&gt;</code></p></li><li><p>提交 git commit -m ‘简介’</p></li><li><p>git push -u origin master</p></li></ul><h2 id="首页开发"><a href="#首页开发" class="headerlink" title="首页开发"></a>首页开发</h2><h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><ul><li>模板设计（解决复用问题）</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/2020040817250239.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><ul><li>组件设计（如何拆分组件）</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200408174830905.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""><br><strong>如何节省网络请求？</strong></p><p>上述流程图共进行了两次请求，另外，异步获取数据时，还会有<code>闪一下</code>，影响用户体验，同时浪费一次网络请求。解决办法就是当浏览器去请求服务器的时候，当浏览器去请求文档的时候，服务端 <code>ip</code>已经知道了，那个时候就可以拿到对应的城市，立即返回数据给浏览器。做法就是通过 <code>vuex</code> 来同步状态，然后通过 <code>SSR</code> 异步请求就能得到数据。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/2020040818365254.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""><br>类似于上文流程图，也是可以通过 <code>vuex</code> 来做<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200408183829795.png" alt=""><br>属于静态模块，不需要我们异步获取数据，直接用 <code>SSR</code> 下发一下就ok。</p><ul><li>数据结构设计（依赖于数据和组件）</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200409171816616.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""><br><code>pois表</code>  <strong>城市推荐数据库</strong><br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200409171908774.png" alt=""></p><ul><li>接口设计（与数据结构相对应）</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200409172047435.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><h3 id="首页开发Header-城市定位服务设计"><a href="#首页开发Header-城市定位服务设计" class="headerlink" title="首页开发Header-城市定位服务设计"></a>首页开发Header-城市定位服务设计</h3><p>根据 <code>Header</code> 布局情况来看的话，我们在<code>components</code>文件夹下创建如下几个文件夹和文件（水印遮住的是 <code>README</code>）</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200408192534453.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><p>导入css，然后打开 <code>nuxt.config.js</code> 进行配置<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200408191205311.png" alt=""></p><h2 id="项目开发可能遇到问题"><a href="#项目开发可能遇到问题" class="headerlink" title="项目开发可能遇到问题"></a>项目开发可能遇到问题</h2><hr/><p><strong><font color=red>重要提醒！</font></strong></p><p>本篇文章能详细概述的地方有限，所以下文将会以讲重点部分为主，其余部分请参考本参考源码，已经开放，开发过程中按照分支进行开发，然后合并到 <code>master</code> 分支</p><p><a href="https://github.com/Chocolate1999/Vue-family-bucket-SSR-Koa2-full-stack-development-from-Meituan">仓库の传送门（戳一戳）</a></p><p>收藏 <code>star</code> 一波，✿✿ヽ(°▽°)ノ✿</p><h3 id="关于项目中SMTP服务功能配置问题"><a href="#关于项目中SMTP服务功能配置问题" class="headerlink" title="关于项目中SMTP服务功能配置问题"></a>关于项目中SMTP服务功能配置问题</h3><p>如下图，所示，我们首先登陆自己的QQ，打开邮箱，然后去打开下面两项服务<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200409181256509.png" alt=""><br>在  <code>server/dbs/config.js</code> 文件内更改为你自己的授权密钥和邮箱即可<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200409182212470.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><p><strong>引入 mongoose</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install mongoose</span><br></pre></td></tr></table></figure><p>配置 <code>users</code> 接口</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install koa-router koa-redis nodemailer</span><br></pre></td></tr></table></figure><p>配置 <code>axios</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install axios</span><br></pre></td></tr></table></figure><p>配置 <code>passport</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install koa-passport passport-local</span><br></pre></td></tr></table></figure><h3 id="关于项目中登录注册接口问题"><a href="#关于项目中登录注册接口问题" class="headerlink" title="关于项目中登录注册接口问题"></a>关于项目中登录注册接口问题</h3><p><code>passport</code> 包内有 <code>isAuthenticated()</code>方法，因此在文档源码中没有定义过。</p><p><code>passport</code>会把用户的信息对象放到 <code>session</code> 对象里面去，也就是 <code>passport</code> 会存储在 <code>session</code> 中，例如如下，如果是登录状态的话，那么session会有 <code>passport</code>，而 <code>passport</code> 会有 <code>user</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//判断是否是登录状态</span></span><br><span class="line"><span class="keyword">if</span> (ctx.isAuthenticated()) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;username, email&#125; = ctx.session.passport.user</span><br><span class="line">  ctx.body=&#123;</span><br><span class="line">    user:username,</span><br><span class="line">    email</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>users.js</li></ul><h3 id="server文件夹-index-js文件中-加载相关包"><a href="#server文件夹-index-js文件中-加载相关包" class="headerlink" title="server文件夹 index.js文件中 加载相关包"></a>server文件夹 index.js文件中 加载相关包</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> mongoose <span class="keyword">from</span> <span class="string">&#x27;mongoose&#x27;</span></span><br><span class="line"><span class="keyword">import</span> bodyParser <span class="keyword">from</span> <span class="string">&#x27;koa-bodyparser&#x27;</span></span><br><span class="line"><span class="keyword">import</span> session <span class="keyword">from</span> <span class="string">&#x27;koa-generic-session&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Redis <span class="keyword">from</span> <span class="string">&#x27;koa-redis&#x27;</span></span><br><span class="line"><span class="keyword">import</span> json <span class="keyword">from</span> <span class="string">&#x27;koa-json&#x27;</span></span><br><span class="line"><span class="keyword">import</span> dbConfig <span class="keyword">from</span> <span class="string">&#x27;./dbs/config&#x27;</span></span><br><span class="line"><span class="keyword">import</span> passport <span class="keyword">from</span> <span class="string">&#x27;./interface/utils/passport&#x27;</span></span><br><span class="line"><span class="keyword">import</span> users <span class="keyword">from</span> <span class="string">&#x27;./interface/users&#x27;</span></span><br><span class="line"><span class="keyword">import</span> geo <span class="keyword">from</span> <span class="string">&#x27;./interface/geo&#x27;</span></span><br><span class="line"><span class="keyword">import</span> search <span class="keyword">from</span> <span class="string">&#x27;./interface/search&#x27;</span></span><br><span class="line"><span class="keyword">import</span> categroy <span class="keyword">from</span> <span class="string">&#x27;./interface/categroy&#x27;</span></span><br><span class="line"><span class="keyword">import</span> cart <span class="keyword">from</span> <span class="string">&#x27;./interface/cart&#x27;</span></span><br></pre></td></tr></table></figure><p>加载指令：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install mongoose koa-bodyparser koa-generic-session koa-redis koa-json</span><br></pre></td></tr></table></figure><h3 id="Cannot-read-property-‘post’-of-undefined-问题解决"><a href="#Cannot-read-property-‘post’-of-undefined-问题解决" class="headerlink" title="Cannot read property ‘post’ of undefined 问题解决"></a>Cannot read property ‘post’ of undefined 问题解决</h3><p>注册那一个模块那里，我一点发送验证码，然后就报了这个错误，一开始以为接口写错了，还测试了一下，原来是因为 <code>axios</code> 没有在 <code>nuxt</code> 脚手架中配置</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Cannot read property <span class="string">&#x27;name&#x27;</span> <span class="keyword">of</span> <span class="literal">undefined</span></span><br></pre></td></tr></table></figure><p><code>nuxt.config.js</code> 文件中配置如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  modules: [</span><br><span class="line">    <span class="string">&#x27;@nuxtjs/axios&#x27;</span>,</span><br><span class="line">  ],</span><br><span class="line"></span><br><span class="line">  axios: &#123;</span><br><span class="line">    <span class="comment">// proxyHeaders: false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决之后，发送验证码，如下结果，有邮件发送过来 ✿✿ヽ(°▽°)ノ✿<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200410101314585.png" alt=""></p><h3 id="关于-win10-redis-报错-Permission-denied"><a href="#关于-win10-redis-报错-Permission-denied" class="headerlink" title="关于 win10 redis 报错 Permission denied"></a>关于 win10 redis 报错 Permission denied</h3><p>同样也是注册页面，当我们注册后，点击同意协议并注册，发现无法跳转到登录界面，而提示 <code>已注册</code> ，看了半天，提示服务错误，于是一开打redis命令窗，报了这个错误，原来是默认设置了<strong>只可读不可写</strong>，按如下方式增加权限，解决了问题 ✿✿ヽ(°▽°)ノ✿</p><p>解决：去Redis的rdb文件查看文件属性，增加写入权限<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200410111551414.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""><br><a href="https://blog.csdn.net/u010049198/article/details/89715009">参考：Redis在Windows下的坑</a></p><h3 id="关于win10-mongodb-导入-bat文件问题"><a href="#关于win10-mongodb-导入-bat文件问题" class="headerlink" title="关于win10 mongodb 导入.bat文件问题"></a>关于win10 mongodb 导入.bat文件问题</h3><p>网上说用如下指令，但是我还是没有导入成功，说是不存在这指令，但之前数据库都导入了 <code>users</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">mongoimport -d student -c areas areas.dat</span><br></pre></td></tr></table></figure><p>于是，我就打开了 <code>Studio 3T</code> 来试着导入，还算是成功了吧</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200410115105370.png" alt=""><br>我的做法是直接在左边那个 <code>Collections</code> 文件夹直接右键 选择 <code>Add</code> 操作，然后导入 <code>.dat</code>文件，不过导完之后会有后缀出现，于是我就重命名了一下。虽然看起来有点傻傻的做法，但也算是解决了吧 ✿✿ヽ(°▽°)ノ✿<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200410115134385.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><h3 id="关于-geo服务-接口签名"><a href="#关于-geo服务-接口签名" class="headerlink" title="关于 geo服务 接口签名"></a>关于 geo服务 接口签名</h3><p><a href="http://cp-tools.cn/sign">http://cp-tools.cn/sign</a></p><h3 id="关于定位服务及切换城市-geo-bug解决"><a href="#关于定位服务及切换城市-geo-bug解决" class="headerlink" title="关于定位服务及切换城市 geo bug解决"></a>关于定位服务及切换城市 geo bug解决</h3><p>在城市定位  <code>geo</code> 分支那里，报了如下两个错误，可让我焦头烂额啊，终于，找到了解决办法，特来写此模块，记录一下 ✿✿ヽ(°▽°)ノ✿</p><p><font color=red>① 报错Classic mode for store/ is deprecated and will be removed in Nuxt 3.</font></p><p><font color=red>② Error occurred when calling nuxtServerInit:  socket hang up</font></p><p>对<strong>第一个问题</strong>出现这种错误的原因是：nuxt3版本中已经移除了对原始vuex这种编程，出现这种错误的代码如下：</p><p>解决的办法如下： store 目录下的每个 .js 文件会被转换成为状态树指定命名的子模块 （当然，index 是根模块）。</p><p>（以下代码亲测有效，直接覆盖你的代码即可）</p><p>首先是目录结构修改，最新版的已经不需要另外加一个 <code>models</code> 文件夹了。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200410192219410.png" alt=""></p><p><code>index.js</code> 文件：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> actions = &#123;</span><br><span class="line">  <span class="keyword">async</span> nuxtServerInit(&#123;</span><br><span class="line">    commit</span><br><span class="line">  &#125;,&#123;req,app&#125;) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;status,<span class="attr">data</span>: &#123;province,city&#125;&#125; = <span class="keyword">await</span> app.$axios.get(<span class="string">&#x27;/geo/getPosition&#x27;</span>)</span><br><span class="line">    commit(<span class="string">&#x27;geo/setPosition&#x27;</span>,status===<span class="number">200</span>?&#123;city,province&#125;:&#123;<span class="attr">city</span>:<span class="string">&#x27;&#x27;</span>,<span class="attr">province</span>:<span class="string">&#x27;&#x27;</span>&#125;)      </span><br><span class="line">    <span class="keyword">const</span> &#123;<span class="attr">status</span>:status2, <span class="attr">data</span>: &#123;menu&#125;&#125; = <span class="keyword">await</span> app.$axios.get(<span class="string">&#x27;/geo/menu&#x27;</span>)</span><br><span class="line">    commit(<span class="string">&#x27;home/setMenu&#x27;</span>,status2===<span class="number">200</span>?menu:[])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>geo.js</code> 文件无需修改</p><p>对<strong>第二个问题</strong>，多半是因为你写好的 <code>geo</code> 相关接口没有在<code>serve/index.js</code>中进行导入和配置使用（我就是因为这个）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> geo <span class="keyword">from</span> <span class="string">&#x27;./utils/geo&#x27;</span></span><br><span class="line">app.use(geo.routes()).use(geo.allowedMethods())</span><br></pre></td></tr></table></figure><p>具体导入位置如下：</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200410192529985.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200410192546969.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><p><a href="https://blog.csdn.net/Umbrella_Um/article/details/99711310">参考：美团项目 — 定位服务及切换城市5</a></p><p><a href="https://blog.csdn.net/weixin_44638823/article/details/103546428?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2&utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2">参考：nuxtjs中使用SSR开发关于前端vuex请求后台的问题</a></p><h3 id="关于搜索框请求次数问题"><a href="#关于搜索框请求次数问题" class="headerlink" title="关于搜索框请求次数问题"></a>关于搜索框请求次数问题</h3><p>我们当然不能没输入一个字符，就请求一次接口，因此我们需要弄一个延时函数</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install lodash</span><br></pre></td></tr></table></figure><p>引入库</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> _ <span class="keyword">from</span> <span class="string">&#x27;lodash&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="关于切换城市模块优化与实现"><a href="#关于切换城市模块优化与实现" class="headerlink" title="关于切换城市模块优化与实现"></a>关于切换城市模块优化与实现</h3><p>首先明确一载入切换城市界面，哪个是要进行请求的，那就是省份（第一级），此时可以使用ssr进行服务端渲染，页面载入后也跟着进行载入，但这里就直接使用vue中的Mouted生命函数完成这里的axios请求 ↓</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">mounted: <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> self = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">let</span> &#123;</span><br><span class="line">      status,</span><br><span class="line">      data: &#123; province &#125;</span><br><span class="line">    &#125; = <span class="keyword">await</span> self.$axios.get(<span class="string">&quot;/geo/province&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (status === <span class="number">200</span>) &#123;</span><br><span class="line">      self.province = province.map(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">          value: item.id,</span><br><span class="line">          label: item.name</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>联动逻辑，使用watch监听用户选择了什么省份</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//监听pvalue值，当省份发生改变的时候，可选城市也要跟着改变（联动）</span></span><br><span class="line">watch:&#123;</span><br><span class="line">  pvalue:<span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params">newPvalue</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> self=<span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">let</span> &#123;status,<span class="attr">data</span>:&#123;city&#125;&#125;=<span class="keyword">await</span> self.$axios.get(<span class="string">`/geo/province/<span class="subst">$&#123;newPvalue&#125;</span>`</span>)</span><br><span class="line">    <span class="keyword">if</span>(status===<span class="number">200</span>)&#123;</span><br><span class="line">      self.city=city.map(<span class="function"><span class="params">item</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">          value:item.id,</span><br><span class="line">          label:item.name</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">      self.cvalue=<span class="string">&#x27;&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>注意select下拉框的设计，如果你不设置 <code>label</code> 显示的还是 <code>value</code> 的值，但是如果你设置了 <code>label</code> 那输入框显示的就是 <code>label</code> 的值，但是你 <code>v-model</code> 拿的还是你 <code>value</code> 的值，所以在省份中复制也是将 <code>id</code> 赋值给 <code>value</code> 的，所以参数正确！<br>会二级联动，三级联动还会难吗？毕竟现在你只需要重点思考逻辑上的代码，而 <code>DOM</code> 结构E-UI已经随随便便完成了，只剩下你关联他们的代码而已</p><p><a href="https://blog.csdn.net/Umbrella_Um/article/details/100191306">参考：美团项目 — 切换城市 7</a></p><h2 id="通过项目挖掘知识点（整理）"><a href="#通过项目挖掘知识点（整理）" class="headerlink" title="通过项目挖掘知识点（整理）"></a>通过项目挖掘知识点（整理）</h2><h3 id="koa2中的ctx是什么？"><a href="#koa2中的ctx是什么？" class="headerlink" title="koa2中的ctx是什么？"></a>koa2中的ctx是什么？</h3><p>为了试图搞明白，用console.log将它输出</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">&#123; request:</span><br><span class="line">   &#123; method: <span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">     url: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">     header:</span><br><span class="line">      &#123; host: <span class="string">&#x27;localhost:3000&#x27;</span>,</span><br><span class="line">        connection: <span class="string">&#x27;keep-alive&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;cache-control&#x27;</span>: <span class="string">&#x27;max-age=0&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;upgrade-insecure-requests&#x27;</span>: <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;user-agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36&#x27;</span>,</span><br><span class="line">        accept: <span class="string">&#x27;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;accept-encoding&#x27;</span>: <span class="string">&#x27;gzip, deflate, sdch, br&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;accept-language&#x27;</span>: <span class="string">&#x27;zh-CN,zh;q=0.8&#x27;</span> &#125; &#125;,</span><br><span class="line">  response:</span><br><span class="line">   &#123; status: <span class="number">200</span>,</span><br><span class="line">     message: <span class="string">&#x27;OK&#x27;</span>,</span><br><span class="line">     header:</span><br><span class="line">      &#123; <span class="string">&#x27;content-type&#x27;</span>: <span class="string">&#x27;text/plain; charset=utf-8&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;content-length&#x27;</span>: <span class="string">&#x27;25&#x27;</span> &#125; &#125;,</span><br><span class="line">  app: &#123; subdomainOffset: <span class="number">2</span>, proxy: <span class="literal">false</span>, env: <span class="string">&#x27;development&#x27;</span> &#125;,</span><br><span class="line">  originalUrl: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">  req: <span class="string">&#x27;&lt;original node req&gt;&#x27;</span>,</span><br><span class="line">  res: <span class="string">&#x27;&lt;original node res&gt;&#x27;</span>,</span><br><span class="line">  socket: <span class="string">&#x27;&lt;original node socket&gt;&#x27;</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见它主要包括 <code>request</code> 和  <code>response</code> 两部分。</p><blockquote><div>ctx是context的缩写中文一般叫成上下文，这个在所有语言里都有的名词，可以理解为上(request)下(response)沟通的环境，所以koa中把他们两都封装进了ctx对象，koa官方文档里的解释是为了调用方便，ctx.req=ctx.request,ctx.res=ctx.response，类似linux系统中的软连接？最终执行还是request和response对象</blockquote><blockquote><div>body是http协议中的响应体，header是指响应头ctx.body = ctx.res.body = ctx.response.body</div></blockquote><p>Koa 提供一个 Context 对象，表示一次对话的上下文（包括 HTTP 请求和 HTTP 回复）。通过加工这个对象，就可以控制返回给用户的内容。</p><p><code>Context.response.body</code> 属性就是发送给用户的内容。</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = require(<span class="string">&#x27;koa&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> app = new Koa();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> main = ctx =&gt; &#123;</span><br><span class="line">  ctx.response.body = <span class="string">&#x27;Hello World&#x27;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">app.use(main);</span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p>上面代码中，main函数用来设置 <code>ctx.response.body</code> 。然后，使用 <code>app.use</code> 方法加载main函数。</p><p>你可能已经猜到了，ctx.response代表 HTTP Response。同样地，ctx.request代表 HTTP Request。</p><p>运行这个 demo，访问 <a href=" http://127.0.0.1:3000">http://127.0.0.1:3000 </a>，现在就可以看到”Hello World”了。</p><p><a href="https://www.cnblogs.com/lfri/p/11936231.html">参考：koa2中的ctx是什么？</a></p><h3 id="koa2中-query-和-querystring"><a href="#koa2中-query-和-querystring" class="headerlink" title="koa2中 query 和 querystring"></a>koa2中 query 和 querystring</h3><p>在 koa 中，GET请求获取请求数据request对象中的 query 方法和 querystring 方法， query方法返回的是格式化好的参数，querystring 方法返回的是请求字符串。</p><p><strong>koa2如何获取get方式的路由参数，比如xxx？name=123 获取name值</strong></p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">ctx.request.query</span><br><span class="line"><span class="comment">// =&gt; &#123;name: &#x27;123&#x27;&#125;</span></span><br><span class="line">ctx.query</span><br><span class="line"><span class="comment">// =&gt; &#123;name: &#x27;123&#x27;&#125;</span></span><br></pre></td></tr></table></figure><p><code>ctx.request</code>  是 <code>Koa</code> 请求对象。可以通过 <code>querystring</code>  获取请求路径中的 <code>query</code> 字符串，通过 <code>query</code> 获取格式化好的参数。<br><code>ctx.query</code> 是 <code>route.query</code> 的别名。</p><p><a href="https://www.jianshu.com/p/a37fd499f0c1">阅读过：nuxt - nuxtServerInit &amp; 页面渲染前的store处理 &amp; context</a></p><h3 id="koa2-使用passport权限认证中间件"><a href="#koa2-使用passport权限认证中间件" class="headerlink" title="koa2 使用passport权限认证中间件"></a>koa2 使用passport权限认证中间件</h3><p><a href="https://segmentfault.com/a/1190000011557953">参考：koa2 使用passport权限认证中间件</a></p><h3 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h3><p><a href="http://www.imooc.com/wenda/detail/591712">更多内容参考：了解护照序列化反序列化</a></p><p>故名思议就是将结构化的对象转换为字节序列，反之就叫做反序列化。</p><p><strong>为什么要序列化和反序列化？</strong></p><p>内存当中的对象是结构化的，当你需要将这个对象在网络当中传输的时候，或者要保存到文件或者数据库当中的时候，你就需要将它序列化成字节流，便于处理。</p><p>而反过来，传输过去之后，或者从文件和数据库里读取出来的时候，又要重新构建恢复出原来的对象。</p><p>类比就是，比如我们打电话，电线不能直接传声音，需要把声音转换为电流，过去再把电流转换为声音。</p><h3 id="为什么utils-axios-js-要创建一个实例"><a href="#为什么utils-axios-js-要创建一个实例" class="headerlink" title="为什么utils/axios.js 要创建一个实例"></a>为什么utils/axios.js 要创建一个实例</h3><p>以下内容参考： <a href="https://zh.nuxtjs.org/guide/async-data">nuxt.js 官方中文文档</a></p><p>如果您的项目中直接使用了 <code>node_modules</code> 中的 <code>axios</code> ，并且使用 <code>axios.interceptors</code> 添加拦截器对请求或响应数据进行了处理，确保使用 <code>axios.create</code> 创建实例后再使用。否则多次刷新页面请求服务器，服务端渲染会重复添加拦截器，导致数据处理错误。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">import axios from &#x27;axios&#x27;</span><br><span class="line"><span class="keyword">const</span> myaxios = axios.create(&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br><span class="line">myaxios.interceptors.response.use(function (response) &#123;</span><br><span class="line">  <span class="keyword">return</span> response.data</span><br><span class="line">&#125;, function (error) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><hr/><p><font color="Tomato"><strong>如若本文有瑕疵需修改的地方，请提出来，谢谢您的贡献！</strong></font></p><p><font color=chocolate>欢迎关注微信公众号：小狮子前端Vue</font></p><p>谢谢您的支持！✿✿ヽ(°▽°)ノ✿</p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【源码开放】Hexo+Github 博客butterfly 和 matery 主题 搭建完全教程【整理】</title>
      <link href="posts/520520/"/>
      <url>posts/520520/</url>
      
        <content type="html"><![CDATA[<blockquote><p>时间：2021年2月8日，本篇文章不再更新教程，本站已更新butterfly主题3.6.1以上，将会注重内容的输出，当然如若您需要请教问题，请留言板留言或者在本站关于我页面找到我，前端技术交流群：666151691，欢迎大家的加入~</p></blockquote><h2 id="阅读须知"><a href="#阅读须知" class="headerlink" title="阅读须知"></a>阅读须知</h2><blockquote><p>注意，本篇博客并不是从零手把手教你去搭博客，那样会很花费时间去写一篇文档，况且从零搭建的博客一搜也是一大把，太多重复的内容就没必要继续写了。因此，对于不知道怎么搭建的伙伴，我会提供我搭建时用到的学习资料，任意选一篇按着教程搭建就好了。另外，本篇博客教程内容主要是记载本站美化DIY方面，更多后续内容将会更新在本站内 <a href="https://yangchaoyi.vip/">https://yangchaoyi.vip</a> 教程内容可复制引用，但请加一个参考链接，谢谢！</p></blockquote><h2 id="关于博客是否开源"><a href="#关于博客是否开源" class="headerlink" title="关于博客是否开源"></a>关于博客是否开源</h2><p>因为本站博客也是最近重新搭建起来的，还有一些优化和功能也在完善。当然，我也会朝着开源方向发展，但<strong>具体什么时候公开博客源码，这还不确定，还需要一段时间准备</strong>。因为选择去开源的话还需要修改很多信息内容，有些隐私以及安全部分需要进行修改，也需要进行版本发布等等。这些都需要一段时间去准备的。</p><p>但你也<strong>不用因为看到这里就觉得这篇文章没有价值了</strong>，我们搭建博客嘛，在于搭的过程，是一个不断迭代的过程，本篇会开源自己当前主题美化教程，你按着教程来，一样可以拥有自己风格的博客。</p><h2 id="博客源码开放"><a href="#博客源码开放" class="headerlink" title="博客源码开放"></a>博客源码开放</h2><p>======  更新！吼吼吼 ========</p><p>目前是已经在做开源的准备了，当然还有一些优化项和功能增加后续在慢慢更新，请小伙伴们关注<a href="https://github.com/Chocolate1999/hexo-blog-lionkk">本仓库</a>，点个star即可，然后记得关注<code>readme</code>的动态更新，添加的特性与教程都会与代码同步更新。为了回馈开源，这不是生成后的网页文件，是您可以直接使用的源码，您只需要把博客相关信息换成您自己的就可以部署了，对于新手或者不懂编程的小伙伴来说，简直是福音，极大简化了您构建博客的工作量和复杂度，每个人都可以下载并修改成自己喜欢样式！如果你有修改想法，欢迎PR！最后，我们还是给这个开源小项目取个名字吧，由于本人狮子座（单身，苦笑），而且微信公众号名字也是取名：<code>小狮子前端Vue</code>，由于并不是自己开发的主题，起名就不添加<code>theme</code>了，那就叫 <code>hexo-blog-lionkk</code>。&lt;&lt;&lt;&lt;&lt;<a href="https://github.com/Chocolate1999/hexo-blog-lionkk">源代码下载</a>&gt;&gt;&gt;&gt;&gt;</p><p><strong>简单使用方法：</strong></p><p><code>star</code> 本项目仓库 ^ o ^<br>安装<a href="https://git-scm.com/downloads">Git</a>, 安装<a href="https://nodejs.org/en/">nodeJS</a><br>你可以直接<code>fork</code>一份源码到你的仓库，<code>clone</code>到本地<br>在本地博客仓库运行<code>npm i</code>命令安装依赖包<br>修改配置信息，改成自己的信息<br>运行命令<code>hexo clean</code>（清除生成文件），<code>hexo g</code>（生成网页）， <code>hexo s</code>（本地预览），<code>hexo d</code>（部署）</p><p>有什么问题可以在文章最后评论区<strong>留言和讨论</strong>，当然，欢迎点击文章最后的打赏按键，请博主一杯冰阔乐，笑～</p><blockquote><p>最后，如果项目和教程对你有所帮助或者你看见了还算比较喜欢，欢迎给我star，谢谢您！</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在本科大二下学期的时候，因为参与了学校 <code>acm</code> 选拔，获得了参与蓝桥杯比赛的名额，又或者说是门票吧 <a href="https://yangchaoyi.vip/posts/24659/#%E5%BC%95%E8%A8%80">推荐阅读：关于我的大学ACM江湖</a> ，从那个时候开始，我就开始写起了博客，因为学校一位老师的成就，我就选择了 <code>CSDN</code> 这个平台，从那个时候到现在，我几乎每个月都会写博客，到现在已经是一种习惯了。我习惯性的将我所学记录并且分享开源，自己遇到的 <code>bug</code> 记录下来，让看到博客的伙伴少走点坑。<a href="https://yangchaoyi.vip/posts/37335/">必读文章：【长文总结】2020 从零到博客专家 过去的我，现在的我，将来的我</a> </p><p>一晃大学就快结束了，我也成功获得了 <code>CSDN博客专家</code> 荣誉称号。到了大三，也是到了确定自己方向时刻了，考虑之后，选择走前端，成为一个前端程序员。于是呢，我就想着自己 <code>DIY</code> 一个属于自己的博客，有一个比较漂亮的页面，或许能激发阅读兴趣呢？</p><p>本博客基于<code>Hexo</code>，所以首先要了解一下我们搭建博客所要用到的框架。<code>Hexo</code>是高效的静态网站生成框架，它基于<code>Node.js</code>，快速，简单且功能强大，是搭建博客的首选框架。大家可以进入<a href="https://hexo.io/zh-cn/">hexo</a>官网进行详细查看，因为<code>Hexo</code>的创建者是台湾人，对中文的支持很友好，可以选择中文进行查看。通过<code>Hexo</code>，你可以直接使用<code>Markdown</code>语法来撰写博客。相信很多小伙伴写工程都写过<code>README.md</code>文件吧，对，就是这个格式的！写完后只需两三条命令即可将生成的网页上传到<code>github</code>或者<code>coding</code>等代码管理托管平台，然后别人就可以浏览你的博客网页啦。是不是很简单？你无需关心网页源代码的具体生成细节，只需要用心写好你的博客文章内容就行了。</p><blockquote><p>简单总结：Hexo, 产品成熟，使用简单，功能强大，有丰富的各种插件资源；但，像发布后台、站内搜索，评论系统类似诉求，虽然有对应的工具，但也需要自己折腾下，后续我们一步一步介绍。</p></blockquote><p>本站目前的主题是 <code>hexo-theme-butterfly</code> ，在此之前呢，使用过 <code>hexo-theme-matery</code>主题来建站。因此本教程更多的是介绍<code>hexo-theme-butterfly</code>，至于我为什么选择更换这个主题呢？读者可以对比一下它和 <code>csdn</code> 呢，是不是有点相像，既有了原本的界面，页面又更加美观一点，简直喜欢的不要不要的~</p><p>本教程暂时分为五个部分：</p><ul><li>第一部分： <code>hexo-theme-matery</code>主题搭建介绍</li><li>第二部分： <code>hexo-theme-butterfly</code>主题搭建美化DIY教程</li><li>第三部分：分享本站所用的学习资料以及本篇文章所参考的文章</li><li>第四部分：彩蛋（暂时没想到好的标题，给点神秘感hhh）</li><li>第五部分：总结</li></ul><h2 id="第一部分-matery主题搭建介绍"><a href="#第一部分-matery主题搭建介绍" class="headerlink" title="第一部分 matery主题搭建介绍"></a>第一部分 matery主题搭建介绍</h2><h3 id="阅读须知-1"><a href="#阅读须知-1" class="headerlink" title="阅读须知"></a>阅读须知</h3><p>由于更换了主题，但是域名并没有更换，因此下文界面链接可能失效了，但是附上了相关图片介绍，尽管本文并不是详细介绍 <code>matery</code>主题搭建过程，但是在文章内容部分也是提供了一些 dalao 搭建资料，小伙伴们可以参考他们的搭建过程。当然，如果你和我一样，选择<code>butterfly</code>主题，可以跳过第一部分，直接去第二部分即可。</p><h3 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h3><p>原本是计划刷题继续提升自己的，奈何看了一个b站up主的关于搭建个人博客的视频，其中有提到对于计算机的我们来说，有一个属于自己的博客是挺重要的，不仅能作为自己的记录，而且还能写进自己简历，丰富大学生活等等。</p><p><font color=red size=4>于是，我就折腾了大概10多天左右，从一开始搭建hexo博客</font></p><p><a href="https://blog.csdn.net/weixin_42429718/article/details/104239306">搭建个人博客 Hexo框架 （自制）</a></p><p><font color=red size=4>到使用了yila主题，但做着做着发现原来主题上面还有升级版的主题，我看到了yilia主题的升级版yelee主题，于是花了3天左右的时间按照教程快速开发了一个个人主页如下图：</font></p><p><a href="https://blog.csdn.net/weixin_42429718/article/details/104264485">Hexo yilia主题 搭建个人主页【整合目录】</a></p><p><a href="http://yangchaoyi1021.cn/">可以进去瞧一瞧，传送门</a></p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200218165557659.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><font color=red size=4>当然，关于yilia主题，挺适合刚入门hexo的伙伴。</font></p><p>这篇博客是我用yilia主题常用的，推荐阅读</p><p><a href="https://blog.csdn.net/lynnbest/article/details/79845944">Hexo yilia 主题一揽子使用方案</a></p><p><font color=red size=4>然后就是我上面那个图关于yelee主题，下面就是官方文档，按照教程来的话，最多一周就能快速拥有一个自己的博客了</font></p><p><a href="http://moxfive.xyz/yelee/new-features.html" >yelee主题使用说明（官方文档）</a></p><h3 id="我的主题"><a href="#我的主题" class="headerlink" title="我的主题"></a>我的主题</h3><p>然而，最后我搭建选择的主题呢，以上都不是,<font color=chocolate size=4>我采用的是hexo-theme-matery</font></p><p>以下就是原主题相关特性，大家可以简单看一看</p><p><font color=red size=4>主题特性:</font></p><ul><li><code>简单漂亮</code>，<code>文章内容美观易读</code></li><li>Material Design 设计</li><li><code>响应式设计</code>，博客在桌面端、平板、手机等设备上均能很好的展现</li><li>首页<code>轮播文章</code>及每天动态切换 Banner 图片</li><li><code>瀑布流式</code>的博客文章列表（文章无特色图片时会有 24 张漂亮的图片代替）</li><li><code>时间轴式</code>的归档页</li><li>词云的标签页和雷达图的分类页</li><li><code>丰富的关于我</code>页面（包括关于我、文章统计图、我的项目、我的技能、相册等）</li><li>可自定义的数据的<code>友情链接</code>页面</li><li>支持文章置顶和文章打赏</li><li>支持 <code>MathJax</code></li><li>TOC 目录</li><li>可设置复制文章内容时追加<code>版权信息</code></li><li>可设置阅读文章时做<code>密码验证</code></li><li>Gitalk、Gitment、Valine 和 Disqus <code>评论模块</code>（推荐使用 Gitalk）</li><li>集成了<code>不蒜子统计</code>、<code>谷歌分析</code>（Google Analytics）和<code>文章字数统计</code>等功能</li><li>支持在首页的音乐播放和视频播放功能</li></ul><h3 id="简单概述"><a href="#简单概述" class="headerlink" title="简单概述"></a>简单概述</h3><p><font color=red size=4>显然，看完了特性也还不知道会是啥样，那就整点图？？？</font></p><hr><p><imgsrc="https://img-blog.csdnimg.cn/2020021621451031.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70"></img></p><p><font color=chocolate size=4>什么？看完图，还想直接上手体验，好，满足你</font></p><p><a href="https://yangchaoyi.vip/">超逸の博客——传送门</a></p><p>好了，到此结束…</p><hr><h3 id="我的搭建过程"><a href="#我的搭建过程" class="headerlink" title="我的搭建过程"></a>我的搭建过程</h3><p><font color=red size=4>显然，我也是一个小白，花了一周的时间才有了现在这样个人博客，我就简述一下我的零基础搭建过程：</font></p><p>配置hexo环境——创建好了第一个hexo框架——尝试学习yilia主题</p><p>发现了yelee主题，果断重新写——三天就搭建了一个测试版，不断优化压缩（gulp,cdn等等）</p><p>成功搭建了一个个人博客（喜悦，成就感）——从大佬的友链里面发现了更大佬，界面非常美观——赶紧按着大佬教程从零再码一次（因为有了之前的基础，开发也还算挺快的）</p><p>又是三天成型，有了测试版——域名备案——解决在国内访问速度慢的原因</p><p>github+coding双部署——添加各种插件（豆瓣，天气，看板娘等）——测试访问速度</p><p>最后，开发完毕！</p><p><a href="https://yangchaoyi.vip/">嘿！ 传送门</a></p><h3 id="学习资料合集（重点在这！）"><a href="#学习资料合集（重点在这！）" class="headerlink" title="学习资料合集（重点在这！）"></a>学习资料合集（重点在这！）</h3><p><font color=red size=4>前面还是稍微扯了一点个人总结，下面我将分享，我这一周来查阅的资料。</font></p><p>当然，只分享真正能解决问题的博客，我查阅的资料很多很多，下面是一些我遇到的问题以及一些优秀的大佬整理的超详细搭建教程：</p><hr><h3 id="搭建全教程（真大佬写的，超详细）"><a href="#搭建全教程（真大佬写的，超详细）" class="headerlink" title="搭建全教程（真大佬写的，超详细）"></a>搭建全教程（真大佬写的，超详细）</h3><p><gon>洪卫大佬写的教程，我就是跟着他的教程开发的，首推！</p><p><a href="https://sunhwee.com/posts/6e8839eb.html">Hexo+Github博客搭建完全教程</a></p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/2020021817392216.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt="洪卫大佬主页"></p><p>下面这位大佬总共写了四篇，这里我就链接了他的第一篇，剩下几篇去主页找找就好了，和上面洪卫大佬主题风格不一样，而且还专门写了一篇pwa，真是好心人！不过我更喜欢这位大佬的主题颜色，所以我结合了洪卫和sitoi大佬的博客搭建教程！</p><p><a href="https://sitoi.cn/posts/6666.html">基于 Hexo GitHub 从零开始搭建个人博客</a></p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200218173853770.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt="sitoi大佬主页"><br>下面是过客~励心大佬的超详细版搭建教程，后面才发现，我很多问题是在这篇文章中解决的！关于解决github访问速度问题，部署在coding和码云上等等，总之，这位大佬干货分享满满，我看完简直要感动哭了，居然如此详细，终于解决了我的bug！！！</p><p><a href="https://yafine-blog.cn/posts/4ab2.html">Hexo+github搭建博客(超级详细版，精细入微)</a></p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200218174037293.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt="过客~励心大佬主页"></p><h3 id="关于我搭建过程问题解决"><a href="#关于我搭建过程问题解决" class="headerlink" title="关于我搭建过程问题解决"></a>关于我搭建过程问题解决</h3><p><font color=red size=4>（以下问题不分先后，能够解决你的问题那就很好了，如果不能解决你的问题，请在评论区留言，看到了立即回复您，然后更新博客）</font></p><h3 id="入门必看"><a href="#入门必看" class="headerlink" title="入门必看"></a>入门必看</h3><p><a href="https://blog.csdn.net/weixin_42429718/article/details/104264485">Hexo yilia主题 搭建个人主页【整合目录】</a></p><h3 id="修改主题颜色（调整自己喜欢的背景颜色）"><a href="#修改主题颜色（调整自己喜欢的背景颜色）" class="headerlink" title="修改主题颜色（调整自己喜欢的背景颜色）"></a>修改主题颜色（调整自己喜欢的背景颜色）</h3><p>在主题文件的 <code>/source/css/matery.css</code>文件中，搜索 <code>.bg-color</code>来修改背景颜色：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">.bg-color &#123;</span><br><span class="line">    background-image: linear-gradient(to right, #1f4d71 0%, #71bbb6 100%);</span><br><span class="line">    opacity: <span class="number">0.9</span>;</span><br><span class="line">    <span class="comment">/* 透明度*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="相关插件"><a href="#相关插件" class="headerlink" title="相关插件"></a>相关插件</h3><p><a href="https://www.jinrishici.com/#">每日诗词api</a></p><p><a href="https://hitokoto.cn/">Hitokoto（一言）api</a></p><p><a href="https://cj.weather.com.cn/plugin/pc">给hexo博客添加天气插件的网站</a></p><p><a href="https://liyangzone.com/2019/07/22/hexo%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E4%B8%80%E7%BA%A7%E5%88%86%E7%B1%BB%E7%9B%B8%E5%86%8C/">hexo博客添加一级分类相册功能</a></p><p><a href="https://www.tidio.com/panel/bots/manage/898302">Tidio聊天机器人插件</a></p><p><a href="https://sitoi.cn/posts/49115.html#toc-heading-1">基于 Hexo GitHub 从零开始搭建个人博客（四）：让你的博客完美支持 PWA</a></p><p><a href="https://ciweigg2.github.io/2019/11/02/matery-zhu-ti-an-zhuang-dou-ban-cha-jian/">Matery主题安装豆瓣插件</a></p><h3 id="优化加速"><a href="#优化加速" class="headerlink" title="优化加速"></a>优化加速</h3><p><a href="https://leaferx.online/2017/06/16/use-gulp-to-minimize/">利用 Gulp 来压缩你的 Hexo 博客</a></p><p><a href="https://blog.sky03.cn/posts/29055.html">国内Github访问加速</a></p><p><a href="https://blog.sky03.cn/posts/1663.html">静态博客访问优化之终极解决方案</a></p><p><a href="https://blog.sky03.cn/posts/42790.html#toc-heading-4">Hexo进阶之各种优化</a></p><p><a href="https://blog.csdn.net/appleyuchi/article/details/92795620">hexo使用katex引擎(markdown渲染加速)</a></p><p><a href="https://yafine-blog.cn/posts/ee35.html">使用Jsdelivr CDN加速博客访问速度</a></p><p><a href="https://blog.sky03.cn/posts/42790.html#toc-heading-18">SEO优化</a></p><h3 id="部署相关"><a href="#部署相关" class="headerlink" title="部署相关"></a>部署相关</h3><p><a href="https://www.cnblogs.com/qiao20/p/11274726.html">如何申请阿里云免费SSL证书（可用于https网站）并下载下来</a></p><p><a href="https://blog.csdn.net/qq_37683287/article/details/91559605">为自定义域名的Hexo博客升级到Https网站</a></p><p><a href="http://www.isetsuna.com/hexo/deploy-qiniu/">Hexo博客系列（六）：部署到七牛</a></p><p><a href="http://ping.chinaz.com/">（站长工具）ping服务器，网站测速</a></p><p><a href="https://coding.net/">coding国内部署——传送门</a></p><p><a href="https://yafine-blog.cn/posts/51fb.html">Hexo博客部署到码云和Coding（提高国内访问速度）</a></p><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p><a href="https://www.logosc.cn/">定制个人logo强大网站</a></p><p><a href="http://ibruce.info/2015/04/04/busuanzi/">不蒜子官网（如果统计无效，多半是链接失效了，去获取最新的）</a></p><p><a href="https://yafine-blog.cn/posts/eb3a.html">使用PicGo+Github搭建免费图床</a></p><p>最后，我们压缩完后，有些指令不能用简称了，以下是我部署时常用指令</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g -s</span><br><span class="line">hexo server</span><br><span class="line">gulp</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>我的博客基本上算是开发完毕了，实现了代码压缩+CDN优化+国内外双部署</p><p>还未完成的部分：备份源码+SEO优化，但这些是可选项，后续再花点时间折腾一下就好了，感谢你能看到这篇文章，觉得不错的话，记得点个赞，加个关注！</p><p><font color=red size=4>（如果以上内容能够解决你的问题那就很好了，如果不能解决你的问题，请在评论区留言，看到了立即回复您，然后更新博客，欢迎您的加入！）</font></p><h2 id="第二部分-butterfly-主题搭建美化DIY教程"><a href="#第二部分-butterfly-主题搭建美化DIY教程" class="headerlink" title="第二部分 butterfly 主题搭建美化DIY教程"></a>第二部分 butterfly 主题搭建美化DIY教程</h2><h3 id="阅读须知-2"><a href="#阅读须知-2" class="headerlink" title="阅读须知"></a>阅读须知</h3><blockquote><p>在本文开头就有说明，在此再说明一下，并不是从零搭建butterfly，只提供相关美化DIY教程，主要针对新手，每一步都算比较详细，所以可能会显得比较啰嗦，所以建议基础比较好小伙伴根据目录选择自己感兴趣的部分跳着看，不要文章没看，上来先喷一下！谢谢⊙o⊙</p></blockquote><h3 id="页面底部-footer-跳动的心"><a href="#页面底部-footer-跳动的心" class="headerlink" title="页面底部 footer 跳动的心"></a>页面底部 footer 跳动的心</h3><h4 id="Butterfly-主题"><a href="#Butterfly-主题" class="headerlink" title="Butterfly 主题"></a>Butterfly 主题</h4><p>编辑博客根目录 <code>/themes/Butterfly/layout/includes/footer.pug</code>文件，</p><p>第一步，将以下内容</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&amp;copy;$&#123;theme.since&#125; - $&#123;nowYear&#125; By $&#123;config.author&#125;</span><br></pre></td></tr></table></figure><p>改为</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&amp;copy;$&#123;theme.since&#125; - $&#123;nowYear + <span class="string">&#x27; &#x27;</span>&#125; &lt;i id=<span class="string">&quot;heartbeat&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;fa fas fa-heartbeat&quot;</span>&gt;&lt;/i&gt; $&#123;config.author&#125;</span><br></pre></td></tr></table></figure><p>第二步，将以下内容</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&amp;copy;$&#123;nowYear&#125; By $&#123;config.author&#125; </span><br></pre></td></tr></table></figure><p>改为</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&amp;copy;$&#123;nowYear + <span class="string">&#x27; &#x27;</span>&#125; &lt;i id=<span class="string">&quot;heartbeat&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;fa fas fa-heartbeat&quot;</span>&gt;&lt;/i&gt; $&#123;config.author&#125;</span><br></pre></td></tr></table></figure><p>将以下内容添加到 <code>&lt;head&gt;&lt;/head&gt;</code> 标签内：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;link rel=<span class="string">&quot;stylesheet&quot;</span> href=<span class="string">&quot;https://cdn.jsdelivr.net/gh/HCLonely/images@master/others/heartbeat.min.css&quot;</span>&gt;</span><br></pre></td></tr></table></figure><p>具体放置位置，可以参考下图：<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200420132925497.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""><br>这样，就有一颗跳动的心 <font color=red>❤</font>啦 ✿✿ヽ(°▽°)ノ✿<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200420132948247.png" alt=""></p><h4 id="其他主题"><a href="#其他主题" class="headerlink" title="其他主题"></a>其他主题</h4><p>将<code>&lt;i id=&quot;heartbeat&quot; class=&quot;fa fas fa-heartbeat&quot;&gt;&lt;/i&gt;</code>添加到需要显示的位置</p><p>同上第 2 步</p><h3 id="添加访客地图"><a href="#添加访客地图" class="headerlink" title="添加访客地图"></a>添加访客地图</h3><p>前往 <a href="https://clustrmaps.com/">clustrmaps</a> 网站注册一个帐号</p><p>找到 <code>Free Tools</code>下面的 <code>Website Widget</code>, 点击 <code>Get Map Widget</code></p><p>输入你的博客网址，点击<code>Next</code></p><p>根据你自己的喜好选择样式<code>Map widget</code>或 <code>Globe Widget</code>（本人使用后者）</p><p>找到如下代码，记住 <code>src (****** 的部分)</code>:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span> id=<span class="string">&quot;clstr_globe&quot;</span> src=<span class="string">&quot;**********************&quot;</span>&gt;</span><br></pre></td></tr></table></figure><p>在 <code>themes\Butterfly\layout\includes\widget</code>文件夹新建<code>card_map.pug</code>文件，文件内容如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">.card-widget.card-map</span><br><span class="line">  .card-content</span><br><span class="line">    .item-headline</span><br><span class="line">      i.fa.fa-globe-asia(aria-hidden=<span class="string">&quot;true&quot;</span>)</span><br><span class="line">      span= _p(<span class="string">&#x27;aside.card_map&#x27;</span>)</span><br><span class="line">    script#clstr_globe(type=<span class="string">&quot;text/javascript&quot;</span> defer=<span class="string">&quot;defer&quot;</span> src=<span class="string">&quot;此处填入你自己的代码&quot;</span>)</span><br></pre></td></tr></table></figure><p>编辑 <code>themes\Butterfly\layout\includes\widget\index.pug</code>文件，在你想要显示的位置插入以下代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> theme.aside.card_map</span><br><span class="line">        !=partial(<span class="string">&#x27;includes/widget/card_map&#x27;</span>, &#123;&#125;, &#123;<span class="attr">cache</span>:theme.fragment_cache&#125;)</span><br></pre></td></tr></table></figure><p>具体放置位置，可以参考下图：<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200419190844832.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""><br>编辑 <code>butterfly.yml</code> 文件，在 <code>card_webinfo</code> 下面添加一行<code>card_map: true</code></p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200419191112811.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""><br>如果没有图标的话，就将 <code>fontawesome  v5</code>版本开启</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"># fontawesome圖標</span><br><span class="line"># 默認使用的是 fontawesome v4版本的圖標</span><br><span class="line">fontawesome_v5:</span><br><span class="line">  enable: <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>编辑 <code>themes\Butterfly\languages\zh-CN.yml</code>文件 (请根据你的网站语言选择)，找到 <strong>card_announcement: 公告</strong> , 在下面添加一行 <strong>card_map: 访客地图</strong> (后面的文本可自定义)</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200419191159352.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""><br>如果不想显示，直接把 <code>butterfly.yml</code>文件的<code>card_map: true</code> 改为 <code>card_map: false</code> 即可</p><h3 id="添加Pixiv-日榜"><a href="#添加Pixiv-日榜" class="headerlink" title="添加Pixiv 日榜"></a>添加Pixiv 日榜</h3><p>在 <code>themes\Butterfly\layout\includes\widget</code>文件夹新建 <code>card_pixiv.pug</code>文件，文件内容如下：</p><p>注意：最后三行要保持空格间距一样（直接复制下面代码即可）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">.card-widget.card-pixiv</span><br><span class="line"> .card-content</span><br><span class="line">  .item-headline</span><br><span class="line">    i.fa.fa-image(aria-hidden=<span class="string">&quot;true&quot;</span>)</span><br><span class="line">    span= _p(<span class="string">&#x27;aside.card_pixiv&#x27;</span>)</span><br><span class="line">    iframe(src=<span class="string">&quot;https://cloud.mokeyjay.com/pixiv&quot;</span> frameborder=<span class="string">&quot;0&quot;</span>  style=<span class="string">&quot;width:99%;height:380px;margin:0;&quot;</span>)</span><br></pre></td></tr></table></figure><p><a href="https://cloud.mokeyjay.com/pixiv">https://cloud.mokeyjay.com/pixiv</a> 使用的是<a href="https://www.mokeyjay.com/">超能小紫</a>提供的服务，也可以自行搭建，搭建方式请看<a href="https://www.mokeyjay.com/archives/1063">这里</a></p><p>编辑 <code>themes\Butterfly\layout\includes\widget\index.pug</code> 文件，在你想要显示的位置插入以下代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> theme.aside.card_pixiv</span><br><span class="line">        !=partial(<span class="string">&#x27;includes/widget/card_pixiv&#x27;</span>, &#123;&#125;, &#123;<span class="attr">cache</span>:theme.fragment_cache&#125;)</span><br></pre></td></tr></table></figure><p>具体放置位置，参考下图：<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200419183941492.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><p>编辑 <code>butterfly.yml</code>文件，在 <code>card_webinfo</code> 下面添加一行 <code>card_pixiv: true</code></p><p>可以通过搜索关键词 <code>aside</code>，找到对应位置添加<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200419184046471.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""><br>编辑 <code>themes\Butterfly\languages\zh-CN.yml</code>文件 (请根据你的网站语言选择)，找到 <strong>card_announcement: 公告</strong> , 在下面添加一行 <strong>card_pixiv: Pixiv日榜Top50</strong>(后面的文本可自定义)</p><p>如果不想显示，直接把 <code>butterfly.yml</code>文件的 <code>card_pixiv: true</code>改为 <code>card_pixiv: false</code>即可</p><h3 id="添加日历"><a href="#添加日历" class="headerlink" title="添加日历"></a>添加日历</h3><p>安装 <code>hexo-generator-calendar</code> 插件</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">cnpm install --save git:<span class="comment">//github.com/howiefh/hexo-generator-calendar.git</span></span><br></pre></td></tr></table></figure><p>下载 <code>calendar.js</code>和 <code>languages.js</code> 文件，保存到 <code>themes\Butterfly\source\js</code> 目录</p><ul><li><a href="https://github.com/pengloo53/Hexo-theme-light_cn/blob/master/source/js/calendar.js">calendar.js</a> 下载地址</li><li><a href="https://github.com/pengloo53/Hexo-theme-light_cn/blob/master/source/js/languages.js">languages.js</a> 下载地址</li></ul><p>编辑<code>calendar.js</code> 文件，在文件最后<code>&#125;(jQuery));</code>之前添加:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    $(<span class="string">&#x27;#calendar&#x27;</span>).aCalendar(<span class="string">&#x27;zh-CN&#x27;</span>);<span class="comment">//&#x27;zh-CN&#x27;请根据自己博客的语言选择</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>具体位置参考下图：<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200419193746630.png" alt=""></p><p>编辑 <code>butterfly.yml</code> 文件，以下两个你 <code>butterfly.yml</code>文件里有哪个就用那个，不要都用！选择一个即可</p><ul><li>在 <code>CDN_USE-&gt;js</code> 下面添加如下内容（本人采用这种方式）：</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">- <span class="regexp">/js/</span>calendar.js</span><br><span class="line">- <span class="regexp">/js/</span>languages.js</span><br></pre></td></tr></table></figure><p>具体位置参考下图：<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200419193929972.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><ul><li>在 <code>inject-&gt;bottom</code>下面添加如下内容（如果用了上述方法就不要用了）：</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">- <span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;/js/calendar.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">- <span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;/js/languages.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>新建 <code>calendar.styl</code>文件，保存到 <code>themes\Butterfly\source\css\_layout</code> 目录下</p><p><a href="https://raw.githubusercontent.com/pengloo53/Hexo-theme-light_cn/master/source/css/_partial/calendar.styl">源文件传送门</a></p><p>原下载处使用会有bug，你可以直接复制如下我改好的代码即可</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#calendar</span><br><span class="line">  a</span><br><span class="line">    text-decoration none</span><br><span class="line"></span><br><span class="line">.cal-head</span><br><span class="line">  margin-bottom: 15px</span><br><span class="line">  position relative</span><br><span class="line">  height 20px</span><br><span class="line">  padding 8px 6px 2px 6px</span><br><span class="line"></span><br><span class="line">.cal-prev,.cal-next</span><br><span class="line">  position absolute</span><br><span class="line">  top 9px</span><br><span class="line">  width 16px</span><br><span class="line">  height 18px</span><br><span class="line">  padding 3px 4px</span><br><span class="line">  border 1px solid transparent</span><br><span class="line">  color #333</span><br><span class="line">  outline <span class="number">0</span></span><br><span class="line"></span><br><span class="line">.cal-prev</span><br><span class="line">  left 8px</span><br><span class="line">  &amp;:before</span><br><span class="line">    border-right 9px solid #333</span><br><span class="line"></span><br><span class="line">.cal-next</span><br><span class="line">  right 8px</span><br><span class="line">  &amp;:before</span><br><span class="line">    border-left 9px solid #333</span><br><span class="line"></span><br><span class="line">.cal-prev:before,.cal-next:before</span><br><span class="line">  content <span class="string">&#x27;&#x27;</span></span><br><span class="line">  display block</span><br><span class="line">  width <span class="number">0</span></span><br><span class="line">  height <span class="number">0</span></span><br><span class="line">  border-top 5px solid transparent</span><br><span class="line">  border-bottom 5px solid transparent</span><br><span class="line"></span><br><span class="line">.cal-title</span><br><span class="line">  width 120px</span><br><span class="line">  margin <span class="number">0</span> auto</span><br><span class="line">  color #333</span><br><span class="line">  font bold 14px/18px Arial</span><br><span class="line">  text-align center</span><br><span class="line">  a</span><br><span class="line">    border 1px solid transparent</span><br><span class="line">    color #9f9f9f</span><br><span class="line"></span><br><span class="line">.cal,</span><br><span class="line">.cal th,</span><br><span class="line">.cal td</span><br><span class="line">  border 1px solid #d1d1d1</span><br><span class="line"></span><br><span class="line">.cal</span><br><span class="line">  display: table</span><br><span class="line">  border-collapse separate</span><br><span class="line">  border-spacing <span class="number">0</span></span><br><span class="line">  border-width 1px <span class="number">0</span> <span class="number">0</span> 1px</span><br><span class="line">  table-layout fixed</span><br><span class="line">  width <span class="number">100</span>%</span><br><span class="line">  margin <span class="number">0</span></span><br><span class="line">  th</span><br><span class="line">    background #9f9f9f</span><br><span class="line">    color #fff</span><br><span class="line">    border-width <span class="number">0</span> 1px 1px <span class="number">0</span></span><br><span class="line">    font-weight <span class="number">700</span></span><br><span class="line">  td</span><br><span class="line">    border-width <span class="number">0</span> 1px 1px <span class="number">0</span></span><br><span class="line">  tbody</span><br><span class="line">    a</span><br><span class="line">      background-color #007acc</span><br><span class="line">      color #fff</span><br><span class="line">      display block</span><br><span class="line">      font-weight <span class="number">700</span></span><br><span class="line">    .cal-today</span><br><span class="line">      background-color #66ecfd</span><br><span class="line">      color #fff</span><br><span class="line">  .cal-gray</span><br><span class="line">    color #bbb8b8</span><br><span class="line"></span><br><span class="line">[data-theme=<span class="string">&#x27;dark&#x27;</span>] .cal .cal-gray</span><br><span class="line">  color #505050</span><br><span class="line"></span><br><span class="line">.cal th,</span><br><span class="line">.cal td</span><br><span class="line">  font-weight normal</span><br><span class="line">  line-height <span class="number">2.5625</span></span><br><span class="line">  padding <span class="number">0</span></span><br><span class="line">  text-align center</span><br><span class="line"></span><br><span class="line">[data-theme=<span class="string">&#x27;dark&#x27;</span>] .cal .cal-foot</span><br><span class="line">  color #9f9f9f</span><br><span class="line"></span><br><span class="line">.cal .cal-foot</span><br><span class="line">  color #2ca6cb</span><br><span class="line"></span><br><span class="line">.cal-title a:hover,</span><br><span class="line">.cal-prev:hover,</span><br><span class="line">.cal-next:hover,</span><br><span class="line">.cal .cal-foot:hover,</span><br><span class="line">.cal .cal-foot:focus,</span><br><span class="line">.cal tbody a:hover,</span><br><span class="line">.cal tbody a:focus</span><br><span class="line">  background-color #686868</span><br><span class="line">  color #fff</span><br><span class="line">  cursor pointer</span><br></pre></td></tr></table></figure><p>在<code>themes\Butterfly\layout\includes\widget</code> 文件夹新建<code>card_calendar.pug</code> 文件，文件内容如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">.card-widget.card-calendar</span><br><span class="line">  .card-content</span><br><span class="line">    .item-headline</span><br><span class="line">      i.far.fa-calendar-alt(aria-hidden=<span class="string">&quot;true&quot;</span>)</span><br><span class="line">      span= _p(<span class="string">&#x27;aside.card_calendar&#x27;</span>)</span><br><span class="line">    div.widget-wrap</span><br><span class="line">    div#calendar.widget</span><br></pre></td></tr></table></figure><p>编辑<code>themes\Butterfly\layout\includes\widget\index.pug</code> 文件，在你想要显示的位置插入以下代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> theme.aside.card_calendar</span><br><span class="line">        !=partial(<span class="string">&#x27;includes/widget/card_calendar&#x27;</span>, &#123;&#125;, &#123;<span class="attr">cache</span>:theme.fragment_cache&#125;)</span><br></pre></td></tr></table></figure><p>具体位置参考下图：<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200419194253473.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><p>编辑 <code>butterfly.yml</code>文件，在 <code>card_webinfo</code>下面添加一行<code>card_calendar: true</code></p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/2020041919435677.png" alt=""></p><p>编辑<code>themes\Butterfly\languages\zh-CN.yml</code>文件 (请根据你的网站语言选择)，找到 <strong>card_announcement: 公告</strong> , 在下面添加一行 <strong>card_calendar: 日历</strong> (后面的文本可自定义)</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200419194436425.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><p>如果不想显示，直接把 <code>butterfly.yml</code>文件的<code>card_calendar: true</code>改为<code>card_calendar: false</code> 即可</p><h3 id="添加哔哩哔哩番剧页面插件"><a href="#添加哔哩哔哩番剧页面插件" class="headerlink" title="添加哔哩哔哩番剧页面插件"></a>添加哔哩哔哩番剧页面插件</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install hexo-bilibili-bangumi --save</span><br></pre></td></tr></table></figure><h4 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install hexo-bilibili-bangumi --update --save</span><br></pre></td></tr></table></figure><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>将下面的配置写入站点的配置文件<code>_config.yml</code>里 (不是主题的配置文件)。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">bangumi:</span><br><span class="line">  enable: <span class="literal">true</span> </span><br><span class="line">  vmid: </span><br><span class="line">  title: <span class="string">&#x27;追番列表&#x27;</span></span><br><span class="line">  quote: <span class="string">&#x27;生命不息，追番不止！&#x27;</span></span><br><span class="line">  show: <span class="number">1</span></span><br><span class="line">  loading: <span class="string">&#x27;/img/bangumi-loading.gif&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>配置介绍</strong></p><ul><li>enable: 是否启用</li><li>vmid: 哔哩哔哩番剧页面的 vmid(uid), 如何获取？</li><li>title: 该页面的标题</li><li>quote: 写在页面开头的一段话，支持 html 语法</li><li>show: 初始显示页面：0: 想看 , 1: 在看 , 2: 看过，默认为 1</li><li>loading: 图片加载完成前的 loading 图片</li></ul><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>前往你的 Hexo 博客的根目录</p><p>输入如下命令</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">hexo <span class="keyword">new</span> page bangumis</span><br></pre></td></tr></table></figure><p>找到<code>source/bangumis/index.md</code>这个文件</p><p>修改这个文件，添加 <code>type: &quot;bangumis&quot;</code>：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: bangumis</span><br><span class="line">date: <span class="number">2018</span>-<span class="number">01</span>-<span class="number">05</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span></span><br><span class="line">type: <span class="string">&quot;bangumis&quot;</span></span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>防止请求次数过多插件不再自动获取番剧数据，所以请根据自己的需要在 <code>hexo generate 或 hexo deploy</code> 之前使用<code>hexo bangumi -u</code> 命令更新番剧数据！</p><p>删除数据命令:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">hexo bangumi -d</span><br></pre></td></tr></table></figure><h4 id="获取-uid"><a href="#获取-uid" class="headerlink" title="获取 uid"></a>获取 uid</h4><p>登录哔哩哔哩后前往 <a href=" https://space.bilibili.com/">https://space.bilibili.com/</a> 页面，网址最后的一串数字就是 uid</p><p><strong>效果展示</strong><br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/2020042013115126.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><h3 id="添加卡通人物（看板娘）"><a href="#添加卡通人物（看板娘）" class="headerlink" title="添加卡通人物（看板娘）"></a>添加卡通人物（看板娘）</h3><p>输入如下命令获取 live2d：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install --save hexo-helper-live2d</span><br></pre></td></tr></table></figure><p>输入以下命令，下载相应的模型，将 <code>haruto</code> 更换成你想要的模型名称即可（本人就选haruto），更多模型选择请<a href="https://github.com/xiazeyu/live2d-widget-models">点击此处</a>，各个模型的预览请<a href="https://huaji8.top/post/live2d-plugin-2.0/">访问原作者的博客</a></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install live2d-widget-model-haruto</span><br></pre></td></tr></table></figure><p>打开站点目录下的 <code>_config.yml</code>文件，添加如下代码：</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">live2d:</span><br><span class="line">enable: <span class="literal">true</span></span><br><span class="line">scriptFrom: local</span><br><span class="line">model: </span><br><span class="line">use: live2d-widget-model-haruto #模型选择</span><br><span class="line">display: </span><br><span class="line">position: right  #模型位置</span><br><span class="line">width: 150       #模型宽度</span><br><span class="line">height: 300      #模型高度</span><br><span class="line">mobile: </span><br><span class="line">show: false      #是否在手机端显示</span><br></pre></td></tr></table></figure><p>执行 <code>hexo g</code> &amp; <code>hexo s</code>，查看页面，发现就会多一个卡通人物啦 ✿✿ヽ(°▽°)ノ✿</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200420075033482.png" alt=""></p><p>参考：</p><p><a href="https://blog.csdn.net/qq_36759224/article/details/85420403">Hexo 博客优化之博客美化系列（持续更新）</a></p><h3 id="地址栏添加-abbrlink"><a href="#地址栏添加-abbrlink" class="headerlink" title="地址栏添加 abbrlink"></a>地址栏添加 abbrlink</h3><p><strong>背景：</strong></p><p>不想要2020/xx/xx/xxx/xx这样比较长的说明，想要简短一点的。</p><p><strong>解决：</strong></p><p>安装 <code>hexo-abbrlink</code> 插件</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install hexo-abbrlink</span><br></pre></td></tr></table></figure><p>编辑 站点的 <code>_config.yml</code>文件，找到 <code>permalink</code> , 改成 <strong>permalink: posts/:abbrlink/</strong></p><p>具体位置，可以参考下图：</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200420073332447.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""><br>最后，在你写的文章 front部分，添加自定义 <code>abbrlink</code> 即可。<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200420073353594.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""><br>地址栏变化，成功 ✿✿ヽ(°▽°)ノ✿<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200420073441986.png" alt=""></p><h3 id="Gallery-相册图库"><a href="#Gallery-相册图库" class="headerlink" title="Gallery 相册图库"></a>Gallery 相册图库</h3><p>一个图库集合。</p><p>写法</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;gallery-group-main&quot;</span>&gt;</span><br><span class="line">&#123;% galleryGroup name description link img-url %&#125;</span><br><span class="line">&#123;% galleryGroup name description link img-url %&#125;</span><br><span class="line">&#123;% galleryGroup name description link img-url %&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><ul><li>name：图库名字</li><li>description：图库描述</li><li>link：连接到对应相册的地址</li><li>img-url：图库封面的地址</li></ul><p>例如：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;gallery-group-main&quot;</span>&gt;</span><br><span class="line">&#123;% galleryGroup <span class="string">&#x27;壁纸&#x27;</span> <span class="string">&#x27;收藏的一些壁纸&#x27;</span> <span class="string">&#x27;/Gallery/wallpaper&#x27;</span> https:<span class="comment">//i.loli.net/2019/11/10/T7Mu8Aod3egmC4Q.png %&#125;</span></span><br><span class="line">&#123;% galleryGroup <span class="string">&#x27;漫威&#x27;</span> <span class="string">&#x27;关于漫威的图片&#x27;</span> <span class="string">&#x27;/Gallery/marvel&#x27;</span> https:<span class="comment">//i.loli.net/2019/12/25/8t97aVlp4hgyBGu.jpg %&#125;</span></span><br><span class="line">&#123;% galleryGroup <span class="string">&#x27;OH MY GIRL&#x27;</span> <span class="string">&#x27;关于OH MY GIRL的图片&#x27;</span> <span class="string">&#x27;/Gallery/ohmygirl&#x27;</span> https:<span class="comment">//i.loli.net/2019/12/25/hOqbQ3BIwa6KWpo.jpg %&#125;</span></span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/20191226003414.png"></img></p><h3 id="豆瓣插件（movie、book、game）"><a href="#豆瓣插件（movie、book、game）" class="headerlink" title="豆瓣插件（movie、book、game）"></a>豆瓣插件（movie、book、game）</h3><h4 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install hexo-douban --save</span><br></pre></td></tr></table></figure><p>在最外层站点 <code>_config.yml</code> （⚠️ 注意：不是主题的配置文件）添加如下内容</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"># 豆瓣</span><br><span class="line">douban:</span><br><span class="line">  user: <span class="number">211251422</span></span><br><span class="line">  builtin: <span class="literal">true</span></span><br><span class="line">  book:</span><br><span class="line">    title: <span class="string">&#x27;好书推荐&#x27;</span></span><br><span class="line">    quote: <span class="string">&#x27;读书好，好读书，读好书&#x27;</span></span><br><span class="line">  movie:</span><br><span class="line">    title: <span class="string">&#x27;电影&#x27;</span></span><br><span class="line">    quote: <span class="string">&#x27;那些在电影院看过的电影&#x27;</span></span><br><span class="line">  timeout: <span class="number">10000</span> </span><br></pre></td></tr></table></figure><ul><li>user: 你的豆瓣ID。打开豆瓣，登入账户，然后在右上角点击 ”个人主页“，这时候地址栏的URL大概是这样：<a href="https://www.douban.com/people/xxxxxx/">https://www.douban.com/people/xxxxxx/</a> ，其中的”xxxxxx”就是你的个人ID了。</li><li>builtin: 是否将生成页面的功能嵌入 hexo s 和 hexo g 中，默认是 false ，另一可选项为 true 。</li><li>title: 该页面的标题。</li><li>quote: 写在页面开头的一段话,支持html语法。</li><li>timeout: 爬取数据的超时时间，默认是 10000ms，如果在使用时发现报了超时的错(ETIMEOUT)可以把这个数据设置的大一点。<br>如果只想显示某一个页面(比如movie)，那就把其他的配置项注释掉即可</li></ul><h4 id="配置-config-文件"><a href="#配置-config-文件" class="headerlink" title="配置 config 文件"></a>配置 config 文件</h4><p>在你的主题的 <code>butterfly.yml</code> 文件中配置以下内容，如下：</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line"># 如果你有使用hexo-douban，可配置這個</span><br><span class="line">douban:</span><br><span class="line">   meta: <span class="literal">true</span></span><br><span class="line">   movies_img: https:<span class="comment">//cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/movie.jpg</span></span><br><span class="line">   books_img: https:<span class="comment">//cdn.jsdelivr.net/npm/blog-gallery@1.0.0/1/20200206161657.webp</span></span><br><span class="line">#   games_img:</span><br></pre></td></tr></table></figure><h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><p>前往你的 Hexo 博客的根目录</p><p>输入如下命令</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">hexo <span class="keyword">new</span> page books</span><br></pre></td></tr></table></figure><p>找到<code>source/books/index.md</code>这个文件</p><p>修改这个文件，添加 <code>type: &quot;books&quot;</code>：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 书单</span><br><span class="line">date: <span class="number">2020</span>-<span class="number">04</span>-<span class="number">19</span> <span class="number">12</span>:<span class="number">58</span>:<span class="number">56</span></span><br><span class="line">type: <span class="string">&quot;books&quot;</span></span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>同理，对于电影页面</p><p>前往你的 Hexo 博客的根目录</p><p>输入如下命令</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">hexo <span class="keyword">new</span> page movies</span><br></pre></td></tr></table></figure><p>找到<code>source/movies/index.md</code>这个文件</p><p>修改这个文件，添加 <code>type: &quot;movies&quot;</code>：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 电影</span><br><span class="line">date: <span class="number">2020</span>-<span class="number">04</span>-<span class="number">19</span> <span class="number">12</span>:<span class="number">58</span>:<span class="number">56</span></span><br><span class="line">type: <span class="string">&quot;movies&quot;</span></span><br><span class="line">---</span><br></pre></td></tr></table></figure><h3 id="友链界面加入自定义文字"><a href="#友链界面加入自定义文字" class="headerlink" title="友链界面加入自定义文字"></a>友链界面加入自定义文字</h3><p>具体效果如下：<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200424114754770.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><h4 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h4><p>第一步，在<code>themes/Butterfly/layout/flink.pug</code> 文件内加入如下代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">p(style=<span class="string">&quot;font-size:14px;font-weight:bold&quot;</span>)= theme.PS</span><br><span class="line">hr</span><br><span class="line">h2= theme.require_headline</span><br><span class="line">ul</span><br><span class="line">  li= theme.requirement1</span><br><span class="line">  li= theme.requirement2</span><br><span class="line">  li= theme.requirement3</span><br><span class="line">  li= theme.requirement4</span><br><span class="line">  li= theme.requirement5</span><br><span class="line">  li= theme.requirement6</span><br><span class="line">hr</span><br><span class="line">h2= theme.myInfo</span><br><span class="line">ul</span><br><span class="line">  li= theme.info1</span><br><span class="line">  li= theme.info2</span><br><span class="line">  li= theme.info3</span><br><span class="line">  li= theme.info4</span><br></pre></td></tr></table></figure><p>具体位置请参考下图：<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200424124244315.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""><br>第二步，在<code>source/_data/butterfly.yml</code> 内加入如下代码（位置随意）：</p><blockquote><p>这里提供我的模板，当然你需要修改成为你自己的风格。</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"># 友链界面美化</span><br><span class="line">PS: PS：欢迎交换友链，以下是相关注意事项。</span><br><span class="line">require_headline: A Few Requirements</span><br><span class="line">requirement1: 本站不参与商业性网站、下载站、视频站等</span><br><span class="line">requirement2: HTTP和HTTPS均可，不强制性要求小绿锁，但是只有一个IP或者带端口的不接受哦</span><br><span class="line">requirement3: 网站要有维护，定期或不定期均可，线下朋友请忽略这一条</span><br><span class="line">requirement4: 申请友链在评论区留言即可，但需先添加本站友链（申请格式如下文所述）</span><br><span class="line">requirement5: 有一定数量的原创文章，建站一周以上（大佬可以无视以上要求）</span><br><span class="line">requirement6: 如果你想联系我，在About页面中有我的相关联系方式</span><br><span class="line">myInfo: My Blog Info</span><br><span class="line">info1: <span class="string">&#x27;name: 超逸の技术博客&#x27;</span></span><br><span class="line">info2: <span class="string">&#x27;link: https://yangchaoyi.vip/&#x27;</span></span><br><span class="line">info3: <span class="string">&#x27;avatar: https://cdn.jsdelivr.net/gh/Chocolate1999/cdn/img/avatar.png&#x27;</span></span><br><span class="line">info4: <span class="string">&#x27;descr: 不是只会写业务代码の前端攻城狮&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="友链链接区块加入一行小字"><a href="#友链链接区块加入一行小字" class="headerlink" title="友链链接区块加入一行小字"></a>友链链接区块加入一行小字</h3><p>具体效果图如下所示：</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200424124816463.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><h4 id="配置-2"><a href="#配置-2" class="headerlink" title="配置"></a>配置</h4><p>第一步，在<code>themes/Butterfly/layout/flink.pug</code> 文件内加入如下代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">h4= i.cdescr</span><br></pre></td></tr></table></figure><p>具体位置，请参考如下：</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200424124920612.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""><br>第二步，此后我们在<code>source/_data/link.yml</code> 中就可以多加一栏变量了，例如：<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200424124947577.png" alt=""></p><h3 id="跳过-hexo-的渲染"><a href="#跳过-hexo-的渲染" class="headerlink" title="跳过 hexo 的渲染"></a>跳过 hexo 的渲染</h3><p>或许你会问这个到底有啥用呢？来两张图你就知道了：</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200424150921963.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""><br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200424151000759.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><p><a href="https://xiabor.com/2020/04/21/hexo3/#%E5%A6%82%E4%BD%95%E8%B7%B3%E8%BF%87hexo%E7%9A%84%E6%B8%B2%E6%9F%93">Xuexi’s Blog：【参考】Hexo大结局</a></p><p>参考了如上博客后，我就增加了这两个界面，因为我们部署到 <code>github pages</code> 其实就是静态页面，你明白了hexo渲染机制后，你可以做的界面就会更多了，比如有些大佬博客会加入一些游戏，例如<code>2048</code>，<code>3D魔方</code>等等，这些我后续考虑再加进去。</p><p>你所需要的就是找到开源的静态页面，添加进去，然后跳过<code>hexo</code>渲染即可。</p><h3 id="友链样式美化"><a href="#友链样式美化" class="headerlink" title="友链样式美化"></a>友链样式美化</h3><p>本次更新新增呼吸灯效果，<code>github</code>源码仓库已同步更新。<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200426160609547.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""><br>实现效果步骤如下：</p><p>将<code>themes/Butterfly/layout/flink.pug</code> 原本的文件内容删去，直接负责替换如下内容：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#page</span><br><span class="line">  .flink#article-container</span><br><span class="line">    each i <span class="keyword">in</span> site.data.link</span><br><span class="line">      h2= i.class_name</span><br><span class="line">      .post-cards</span><br><span class="line">        .md-links</span><br><span class="line">          each item <span class="keyword">in</span> i.link_list</span><br><span class="line">            .md-links-item(style= item.color ? <span class="string">`--primary-color:<span class="subst">$&#123;item.color&#125;</span>;border-width:<span class="subst">$&#123;item.width&#125;</span>;border-style:<span class="subst">$&#123;item.style&#125;</span>;animation: <span class="subst">$&#123;item.custom&#125;</span> <span class="subst">$&#123;item.time&#125;</span> infinite alternate; background:<span class="subst">$&#123;item.background&#125;</span>`</span> : <span class="string">&#x27;border-width:0px;border-style:solid;animation: link_custom 0s infinite alternate;background:0&#x27;</span>)</span><br><span class="line">              a.customcolor(href=item.link  title=item.name target=<span class="string">&quot;_blank&quot;</span> rel=item.remove ? <span class="string">&quot;external nofollow&quot;</span> : <span class="string">&quot;&quot;</span> style=item.namecolor ? <span class="string">`--namecolor:<span class="subst">$&#123;item.namecolor&#125;</span>`</span> : <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">                <span class="keyword">if</span> theme.lazyload.enable</span><br><span class="line">                  img.lazyload(data-src=item.avatar onerror=<span class="string">`this.onerror=null;this.src=&#x27;`</span> + url_for(theme.lodding_bg.flink) + <span class="string">`&#x27;`</span> alt=item.name,style=item.rotate ? <span class="string">`--primary-rotate:<span class="subst">$&#123;item.rotate&#125;</span>;--autotime:<span class="subst">$&#123;item.autotime&#125;</span>;`</span> : <span class="string">&#x27;--primary-rotate:0deg&#x27;</span> <span class="class"><span class="keyword">class</span></span>=item.autorotate ? <span class="string">`<span class="subst">$&#123;item.autorotate&#125;</span>`</span> : <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                  img(src=item.avatar onerror=<span class="string">`this.onerror=null;this.src=&#x27;`</span> + url_for(theme.lodding_bg.flink) + <span class="string">`&#x27;`</span> alt=item.name )</span><br><span class="line">                .md-links-title= item.name </span><br><span class="line">                .md-links-des= item.descr</span><br><span class="line">    != page.content</span><br><span class="line">  <span class="keyword">if</span> page.comments !== <span class="literal">false</span></span><br><span class="line">    include includes/comments/index.pug</span><br></pre></td></tr></table></figure><p>在主题配置文件 <code>source/_data/butterfly.yml</code> 添加如下样式</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">https:<span class="comment">//cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@master/Hexo/css/flink.min.css</span></span><br></pre></td></tr></table></figure><p>具体位置，你可以搜索用<code>ctrl+f</code>键搜索<code>css</code>，添加进去。<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200426160933761.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""><br>当然，如果你是<code>clone</code> 的 <code>dev</code> 分支，最新版本的话，可以这样引入 <code>css</code>：</p><p>具体位置，你可以搜索用<code>ctrl+f</code>键搜索<code>inject</code>，可以直接覆盖你之前的代码或者添加进去都可以。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"># inject</span><br><span class="line"># 插入代码到头部&lt;/head&gt;之前 和 尾部&lt;/body&gt;之前</span><br><span class="line">inject:</span><br><span class="line">  head:</span><br><span class="line">  # - &lt;link rel=&quot;stylesheet&quot; href=&quot;xxxxx&quot;&gt;</span><br><span class="line">    - <span class="xml"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@master/Hexo/css/flink.min.css&quot;</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>各种参数说明（可自行搭配）如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"># 边框大小 默认为0 </span><br><span class="line">width: 0px</span><br><span class="line"># 边框样式 默认 solid</span><br><span class="line">style: solid</span><br><span class="line"># 边框颜色 默认淡蓝色 #49b1f5</span><br><span class="line">color: <span class="string">&quot;#0078e7&quot;</span></span><br><span class="line"># 自动旋转 可选值 flash（闪现） link_custom（单色呼吸灯） link_custom1（彩色呼吸灯）</span><br><span class="line">custom: link_custom1</span><br><span class="line"># 动画时长设定，默认为0</span><br><span class="line">time: 4s</span><br><span class="line"># name的颜色</span><br><span class="line">namecolor: <span class="string">&quot;#ff9191&quot;</span></span><br><span class="line"># descr的颜色</span><br><span class="line">descolor: <span class="string">&quot;#ff9191&quot;</span></span><br><span class="line"># 背景颜色</span><br><span class="line">background: <span class="number">0</span></span><br><span class="line"># 鼠标悬停旋转角度</span><br><span class="line">rotate: 360deg</span><br><span class="line"># 自动旋转 latuo左旋转 rauto右旋转</span><br><span class="line">autorotate: <span class="string">&quot;lauto&quot;</span></span><br><span class="line"># 旋转的周期（时长）</span><br><span class="line">autotime: 2s</span><br><span class="line">#移除此链接的权重 0为否 非0为移除</span><br><span class="line">remove: <span class="number">0</span></span><br></pre></td></tr></table></figure><p>参考：<a href="https://www.antmoe.com/posts/1dc865d0/index.html">小康博客：Hexo关于Butterfly的一些小修改</a></p><h3 id="添加全局吸底APlayer"><a href="#添加全局吸底APlayer" class="headerlink" title="添加全局吸底APlayer"></a>添加全局吸底APlayer</h3><h4 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h4><p>打开 <code>themes\Butterfly\layout\includes\head.pug</code></p><p>结尾加一句</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">include ./third-party/aplayer.pug</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200519114724631.png" alt=""></p><h4 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h4><p>然后在<code>themes\Butterfly\layout\includes\third-party\</code>里面新建一个文件叫 <code>aplayer.pug</code> ,内容如下</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> theme.aplayer &amp;&amp; theme.aplayer.enable</span><br><span class="line">.aplayer(data-id=theme.aplayer.id data-server=theme.aplayer.server data-type=theme.aplayer.type data-fixed=theme.aplayer.fixed data-mini=theme.aplayer.mini data-listFolded=theme.aplayer.listFolded data-order=theme.aplayer.order data-preload=theme.aplayer.preload)</span><br><span class="line">each item in theme.aplayer.css</span><br><span class="line">link(rel=&#x27;stylesheet&#x27;, href=item)</span><br><span class="line">each item in theme.aplayer.js</span><br><span class="line">script(src=item)</span><br></pre></td></tr></table></figure><h4 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h4><p>然后打开<code>butterfly.yml</code>(如果你没有启用的话,就打开<code>source/_data/butterfly.yml</code>) 加入以下内容</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">##侧边栏歌单</span><br><span class="line">aplayer:</span><br><span class="line">  enable: <span class="literal">true</span></span><br><span class="line">  js:</span><br><span class="line">    - https:<span class="comment">//cdn.bootcss.com/aplayer/1.10.1/APlayer.min.js</span></span><br><span class="line">    - https:<span class="comment">//cdn.jsdelivr.net/npm/meting@1.2.0/dist/Meting.min.js</span></span><br><span class="line">  css:</span><br><span class="line">    - https:<span class="comment">//cdn.bootcss.com/aplayer/1.10.1/APlayer.min.css</span></span><br><span class="line">  id: <span class="number">2693598459</span></span><br><span class="line">  server: netease </span><br><span class="line">  type: playlist</span><br><span class="line">  fixed: &#x27;true&#x27;</span><br><span class="line">  order: random</span><br><span class="line">  preload: none</span><br><span class="line">  listFolded: &#x27;false&#x27;</span><br></pre></td></tr></table></figure><h4 id="解决与TOC冲突问题"><a href="#解决与TOC冲突问题" class="headerlink" title="解决与TOC冲突问题"></a>解决与TOC冲突问题</h4><p>然后重新生成就可以看到 <code>aplayer</code>了,这里的id是我的网易云歌单号,可以修改成别的.<br>但是浏览 <code>Page</code> 时会发现 <code>aplayer</code> 会和 <code>TOC</code>(怎么又是它) 的切换按钮重合<br>打开 <code>themes\Butterfly\source\css\_global\index.styl</code><br>修改第61行</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200519114915192.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""><br>最后，大功告成 ✿✿ヽ(°▽°)ノ✿<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/2020051911514933.png" alt=""></p><p>参考：<br>Author: <a href=" http://home.ustc.edu.cn/~pscgylotti/blogs/2020/05/09/butterfly/">Pscgylotti</a></p><h3 id="主页冒泡特效和页脚"><a href="#主页冒泡特效和页脚" class="headerlink" title="主页冒泡特效和页脚"></a>主页冒泡特效和页脚</h3><p>首先，在 <code>themes/Butterfly/source/js</code> 目录下创建一个 <code>chocolate.js</code>  文件（名称可自定义）</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/2020101220213955.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70#pic_center" alt=""><br>直接复制导入如下代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 气泡</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubble</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  $(<span class="string">&#x27;#page-header&#x27;</span>).circleMagic(&#123;</span><br><span class="line">      radius: <span class="number">10</span>,</span><br><span class="line">      density: <span class="number">.2</span>,</span><br><span class="line">      color: <span class="string">&#x27;rgba(255,255,255,.4)&#x27;</span>,</span><br><span class="line">      clearOffset: <span class="number">0.99</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;! <span class="function"><span class="keyword">function</span>(<span class="params">p</span>) </span>&#123;</span><br><span class="line">  p.fn.circleMagic = <span class="function"><span class="keyword">function</span>(<span class="params">t</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> o, a, n, r, e = !<span class="number">0</span>,</span><br><span class="line">          i = [],</span><br><span class="line">          d = p.extend(&#123; <span class="attr">color</span>: <span class="string">&quot;rgba(255,0,0,.5)&quot;</span>, <span class="attr">radius</span>: <span class="number">10</span>, <span class="attr">density</span>: <span class="number">.3</span>, <span class="attr">clearOffset</span>: <span class="number">.2</span> &#125;, t),</span><br><span class="line">          l = <span class="built_in">this</span>[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>) </span>&#123; e = !(<span class="built_in">document</span>.body.scrollTop &gt; a) &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">s</span>(<span class="params"></span>) </span>&#123; o = l.clientWidth, a = l.clientHeight, l.height = a + <span class="string">&quot;px&quot;</span>, n.width = o, n.height = a &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">h</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (e)</span><br><span class="line">              <span class="keyword">for</span> (<span class="keyword">var</span> t <span class="keyword">in</span> r.clearRect(<span class="number">0</span>, <span class="number">0</span>, o, a), i) i[t].draw();</span><br><span class="line">          requestAnimationFrame(h)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="keyword">var</span> t = <span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line">          <span class="function"><span class="keyword">function</span> <span class="title">e</span>(<span class="params"></span>) </span>&#123; t.pos.x = <span class="built_in">Math</span>.random() * o, t.pos.y = a + <span class="number">100</span> * <span class="built_in">Math</span>.random(), t.alpha = <span class="number">.1</span> + <span class="built_in">Math</span>.random() * d.clearOffset, t.scale = <span class="number">.1</span> + <span class="number">.3</span> * <span class="built_in">Math</span>.random(), t.speed = <span class="built_in">Math</span>.random(), <span class="string">&quot;random&quot;</span> === d.color ? t.color = <span class="string">&quot;rgba(&quot;</span> + <span class="built_in">Math</span>.floor(<span class="number">255</span> * <span class="built_in">Math</span>.random()) + <span class="string">&quot;, &quot;</span> + <span class="built_in">Math</span>.floor(<span class="number">0</span> * <span class="built_in">Math</span>.random()) + <span class="string">&quot;, &quot;</span> + <span class="built_in">Math</span>.floor(<span class="number">0</span> * <span class="built_in">Math</span>.random()) + <span class="string">&quot;, &quot;</span> + <span class="built_in">Math</span>.random().toPrecision(<span class="number">2</span>) + <span class="string">&quot;)&quot;</span> : t.color = d.color &#125;</span><br><span class="line">          t.pos = &#123;&#125;, e(), <span class="built_in">this</span>.draw = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; t.alpha &lt;= <span class="number">0</span> &amp;&amp; e(), t.pos.y -= t.speed, t.alpha -= <span class="number">5e-4</span>, r.beginPath(), r.arc(t.pos.x, t.pos.y, t.scale * d.radius, <span class="number">0</span>, <span class="number">2</span> * <span class="built_in">Math</span>.PI, !<span class="number">1</span>), r.fillStyle = t.color, r.fill(), r.closePath() &#125;</span><br><span class="line">      &#125;! <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">          o = l.offsetWidth, a = l.offsetHeight,</span><br><span class="line">              <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                  <span class="keyword">var</span> t = <span class="built_in">document</span>.createElement(<span class="string">&quot;canvas&quot;</span>);</span><br><span class="line">                  t.id = <span class="string">&quot;canvas&quot;</span>, t.style.top = <span class="number">0</span>, t.style.zIndex = <span class="number">0</span>, t.style.position = <span class="string">&quot;absolute&quot;</span>, l.appendChild(t), t.parentElement.style.overflow = <span class="string">&quot;hidden&quot;</span></span><br><span class="line">              &#125;(), (n = <span class="built_in">document</span>.getElementById(<span class="string">&quot;canvas&quot;</span>)).width = o, n.height = a, r = n.getContext(<span class="string">&quot;2d&quot;</span>);</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">var</span> t = <span class="number">0</span>; t &lt; o * d.density; t++) &#123;</span><br><span class="line">              <span class="keyword">var</span> e = <span class="keyword">new</span> f;</span><br><span class="line">              i.push(e)</span><br><span class="line">          &#125;</span><br><span class="line">          h()</span><br><span class="line">      &#125;(), <span class="built_in">window</span>.addEventListener(<span class="string">&quot;scroll&quot;</span>, c, !<span class="number">1</span>), <span class="built_in">window</span>.addEventListener(<span class="string">&quot;resize&quot;</span>, s, !<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;(jQuery);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用气泡方法</span></span><br><span class="line">bubble();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* xkTool */</span></span><br><span class="line"><span class="keyword">var</span> chocolate = <span class="keyword">new</span> xkTool();</span><br><span class="line">chocolate.footFish();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>最后，在主题 <code>butterfly.tml</code> 文件中，通过 <code>ctrl+f</code> 导入一下刚刚写的 <code>js</code> 文件。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20201012202325605.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70#pic_center" alt=""></p><h3 id="添加UP酱"><a href="#添加UP酱" class="headerlink" title="添加UP酱"></a>添加UP酱</h3><p>添加如图所示UP酱<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20201012202825802.png#pic_center" alt=""><br>首先，在 <code>themes/Butterfly/source/css</code> 目录下创建一个 <code>chocolate.css</code>  文件（名称可自定义）</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20201012202945145.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70#pic_center" alt=""><br>直接复制导入如下代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 隐藏回到顶部按钮，替换为up酱 */</span></span><br><span class="line"></span><br><span class="line">#go-up i &#123;</span><br><span class="line">    display: none;</span><br><span class="line">    background-color: transparent !important;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#go-up &#123;</span><br><span class="line">    background-color: transparent !important;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#upj &#123;</span><br><span class="line">    transform: translate(-70px, -80px) !important;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后在上文主页冒泡特效创建的 <code>chocoalte.js</code> 文件中插入如下代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*添加图片top*/</span></span><br><span class="line"><span class="keyword">var</span> top_up = <span class="string">&quot;&lt;img id=&#x27;upj&#x27; class=&#x27;upj&#x27; style=&#x27;max-width: 1000%; transform: translate(-70px,-70px);&#x27; src=&#x27;https://cdn.jsdelivr.net/gh/lete114/CDN/Use/up.gif&#x27; title=&#x27;回到顶部&#x27; &gt;&quot;</span>;</span><br><span class="line"><span class="comment">/*添加到返回顶部按钮下*/</span></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&quot;go-up&quot;</span>).innerHTML += top_up;</span><br></pre></td></tr></table></figure><p>具体插入代码位置可以参考下图：<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20201012203100116.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70#pic_center" alt=""></p><p>最后，在主题 <code>butterfly.tml</code> 文件中，通过 <code>ctrl+f</code> 导入一下刚刚写的 <code>css</code> 文件。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20201012203124561.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70#pic_center" alt=""></p><h3 id="添加贡献日历"><a href="#添加贡献日历" class="headerlink" title="添加贡献日历"></a>添加贡献日历</h3><h4 id="前言-2"><a href="#前言-2" class="headerlink" title="前言"></a>前言</h4><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/2020121716092624.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""><br>考虑到最近很多小伙伴询问我这个贡献日历是怎么添加的，现在来出一份教程，废话留在文末尾，到时候再看。现在进入正文：</p><blockquote><p>由于某些原因，原教程已删，提供原大佬链接：<a href="https://zfe.space/post/6948.html">https://zfe.space/post/6948.html</a>  大家可以去溜达溜达，大佬文章是最新版的！</p></blockquote><h3 id="后续内容"><a href="#后续内容" class="headerlink" title="后续内容"></a>后续内容</h3><p><strong>须知：</strong> 由于<code>CSDN</code> 对于长文章更新会有人工审核，因此不断更新迭代的话可能会有些许麻烦，有时可能文章会失效，所以目前你所看到的内容其实不是最新版本的，所有后续更新内容都会持续更新在本站内，<a href="https://yangchaoyi.vip/">https://yangchaoyi.vip</a></p><h2 id="第三部分-分享本站所用的学习资料以及本篇文章所参考的文章"><a href="#第三部分-分享本站所用的学习资料以及本篇文章所参考的文章" class="headerlink" title="第三部分 分享本站所用的学习资料以及本篇文章所参考的文章"></a>第三部分 分享本站所用的学习资料以及本篇文章所参考的文章</h2><h3 id="阅读须知-3"><a href="#阅读须知-3" class="headerlink" title="阅读须知"></a>阅读须知</h3><blockquote><p>本篇内容以及本站博客搭建都是参考了许许多多的文章，因此可能有些内容遗漏掉您的文章注明出处，您可以在本篇内容底部评论留言，收到消息，我会立即更新文章出处，为您带来打扰实在不好意思。</p></blockquote><h3 id="butterfly主题添加功能"><a href="#butterfly主题添加功能" class="headerlink" title="butterfly主题添加功能"></a>butterfly主题添加功能</h3><p><a href="https://bili33.top/2020/03/19/butterfly-customize/#%E5%8F%8B%E9%93%BE%E7%95%8C%E9%9D%A2%E5%8A%A0%E5%85%A5%E6%9B%B4%E5%A4%9A%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E6%96%87%E5%AD%97">GamerNoTitle：【参考】友链界面加入更多的自定义文字</a></p><p><a href="https://zkpeace.com/2020/02/17/%E4%B8%BA%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E6%96%B0%E7%89%B9%E6%80%A7%E8%AE%B0%E5%BD%95/#%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8E%A8%E9%80%81">Kp Zhang：为本博客添加新特性记录</a></p><p><a href=""></a></p><h3 id="dalao文档"><a href="#dalao文档" class="headerlink" title="dalao文档"></a>dalao文档</h3><p><a href="https://jerryc.me/categories/Butterfly%E6%96%87%E6%AA%94/">JerryC：Butterfly作者文档</a></p><p><a href="https://sunhwee.com/posts/6e8839eb.html#toc-heading-4">洪卫の博客：Hexo+Github博客搭建完全教程</a></p><p><a href="https://blog.hclonely.com/posts/57bd67ce/">HCLonely Blog：Hexo博客DIY</a></p><h3 id="配置Valine-Admin-邮件回复提醒"><a href="#配置Valine-Admin-邮件回复提醒" class="headerlink" title="配置Valine Admin 邮件回复提醒"></a>配置Valine Admin 邮件回复提醒</h3><p><a href="http://www.zhaojun.im/hexo-valine-admin/">赵俊的博客：【参考】Hexo 优化 — Valine 扩展之邮件通知</a></p><p><a href="https://xiabor.com/2019/12/28/valine-admin/#valine%E7%9A%84%E9%82%AE%E4%BB%B6%E6%8F%90%E9%86%92">Xuexi’s Blog：【参考】配置Valine Admin 邮件回复提醒</a></p><h2 id="第四部分-彩蛋"><a href="#第四部分-彩蛋" class="headerlink" title="第四部分 彩蛋"></a>第四部分 彩蛋</h2><p>biubiubiu~ 让我猜猜你是不是看了前文说是有彩蛋，直接跳到这里来看了，如果被我猜中的话，请评论如下内容：<code>我上当了！</code></p><p>哈哈哈，好了，整点正常点的，正如上文所说，一时间也想不到好的标题，就整个有吸引力的hhh</p><p><strong>关于本站</strong></p><p>本站源代码开放，同时也欢迎小伙伴们交换友链，具体说明可在 <a href="https://yangchaoyi.vip/link/">友链页</a> 查看。</p><p>上文说了很多，都是关于如何搭建博客，怎样美化，但是一点也没介绍我的<code>博客文化</code>，现在就简单介绍一下吧：</p><p>首先，我的博客建立之初心还是以学习目的的，并且是与下面 <code>笔记仓库</code> 和我的 <code>CSDN内容</code> 进行绑定的，后续我都会将优质内容码上去。</p><p><a href="https://github.com/Chocolate1999/Front-end-learning-to-organize-notes">传送门：小狮子前端の学习笔记</a><br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200424154115206.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><p>截止到20年4月24日，已经有了18个star（不包括自己hh），里面多是前端学习整理的笔记，也是选择开源，<strong>因为知识与技术是开源的，但是学习与消化知识是靠的自己。</strong></p><p>我相信，我的这个笔记仓库定会影响一部分人，能让一部分前端甚至普通程序员受益颇多，学习是一辈子都要坚持的事情。坚持下来的人一定很酷~</p><p>看到这里的你，应该是比较优秀的了，因为本文多多少少还是些许啰嗦了点，毕竟要写一篇搭建文档嘛，<strong>一个项目的好不好，很大部分就取决你的文档写的够不够优秀。</strong> 因为项目出了bug，好的文档能够让你事半功倍，而且一份详细的文档，对于二次开发与优化也是极有帮助的！</p><p>另外，博主建了一个关于算法的群：<font color=chocolate>ACM/LeetCode/Codeforces 群号：1044593736</font></p><p><strong>To acmer:</strong></p><p>欢迎各位acmer入群，在这里你可以讨论算法，约cf，讨论面试题，或者你也可以分享转发优质内容，但与学习无关的请勿打扰。群文件已上传部分学习资料，后续会一直补充。加油，少年！</p><p>继续补充：从一开始本群只有10人不到，到现在快突破100人了。从群里没有人冒泡，到现在开始讨论cf、leetcode、代码等，也算是看到了成长吧，我觉得是一件比较有成就感的事情！很多入群的伙伴，或许是看了我之前写的关于ACM江湖的文章，亦或是成为CSDN博客专家之路的文章。不管如何，你依旧是曾经那个追风的少年，加油！</p><p>最后，来几一句觉得不错的名言吧：</p><p><font color=chocolate>算法改变世界，算法创造未来！</font></p><h2 id="第五部分-总结"><a href="#第五部分-总结" class="headerlink" title="第五部分 总结"></a>第五部分 总结</h2><p>一口气没想到就到了总结时刻了，每次总结我都是草草的结束了，但这次来点正式一点的。（这次总结一定要超过200字！手动狗头）</p><h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p> <strong>神奇の沟通</strong></p><ul><li>沟通是<font color=red> <strong>传递</strong></font> 沟通是<font color=red> <strong>交流</strong></font></li><li>沟通是<font color=red> <strong>分享</strong></font> 沟通是<font color=red> <strong>智慧</strong></font></li><li>沟通是<font color=red> <strong>友谊</strong></font> 沟通是<font color=red> <strong>力量</strong></font></li></ul><p>“ <strong><font color=chocolate>认识自我、超越自我</font></strong> “ 是沟通的最高境界</p><ul><li>当你在项目中感觉所要学习的人和事越来越多时，说明你在 <strong><font color=chocolate>成长</font></strong> 。</li><li>当你感觉要责怪的人和事越来越少时，说明你在 <strong><font color=chocolate>成熟</font></strong> 。</li><li>当你在项目中不断获得了友谊和朋友时，说明你将取得项目的 <strong><font color=chocolate>成功</font></strong> 。</li></ul><p>人们能够记住的东西有如下规律：</p><ul><li><strong>听到</strong>的内容的 <font color=chocolate>5%</font></li><li><strong>读过</strong>的内容的<font color=chocolate>10%</font></li><li><strong>见过</strong>的内容的 <font color=chocolate>30%</font></li><li><strong>讨论过</strong>的内容的 <font color=chocolate>50%</font></li><li><strong>亲自做</strong>的内容的 <font color=chocolate>75%</font></li><li><strong>教给别人</strong>所做过的事情的 <font color=chocolate>90%</font></li></ul><p>因此，我觉得我如果把我学过的知识开源也是一件有意义的事情，你读完本篇文章后，你学会了搭建博客，你得到了好处，我呢，因为这篇文档，也让自己受益颇多，将知识梳理的同时，也对这件事情记忆深刻了，这难道不是双赢的局面嘛。所以，赶快给本仓库点个star吧，<a href="https://github.com/Chocolate1999/Front-end-learning-to-organize-notes">传送门：小狮子前端の学习笔记</a>。请博主一杯冰阔乐，笑～</p><p>本篇博客介绍就到此结束了，完结，撒花✿✿ヽ(°▽°)ノ✿，后续更新内内容的话，上文也有提及过，会更新到<a href="https://yangchaoyi.vip/">https://yangchaoyi.vip</a> 里，到时候会置顶的，打开应该就能看到啦~</p><p>有什么问题可以在文章最后评论区留言和讨论，当然，你有更加优秀的文章或者新花样，都可以提出来，热烈欢迎~</p><blockquote><p>最后，如果项目和教程对你有所帮助或者你看见了还算比较喜欢，欢迎给我star，谢谢您！</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>🐮写给零基础的前端算法入门指南，acmer带女友刷80+【递归与回溯篇】｜牛气冲天新年征文</title>
      <link href="posts/20210216/"/>
      <url>posts/20210216/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>各位小伙伴们新年好呀，时隔一周，俺又回来更新文章啦！在上一篇发出去之后，虽然没有得到很多的阅读量，但是后面几篇文章还是得要更新出来，我想总能够帮助一小部分人咯~</p><blockquote><p>现在和大家分享一下我们是如何准备算法这一块的，春招即将开启，还能最后准备一下，希望对大家有所帮助。</p></blockquote><p>原本打算通过一篇文章介绍一下，推荐一下自己的刷题方式和刷题路线，得到一些伙伴的反馈：最好还是更加详细，面向零基础，小白这些，还有<code>github</code>访问速度也是一方面问题，可能图片都加载不出来。</p><p>因此，我打算分模块出几期文章，这样你只用通过首发在掘金的文章即可了解 <code>Chocolate</code> 同学整体刷题汇总啦。马上就要过年了，希望能够帮助你的春招。打算出的内容计划安排如下：</p><ul><li>🐮写给零基础的前端算法入门指南，acmer带女友刷80+【栈与队列与链表篇】（已完成🎉）</li><li>🐮写给零基础的前端算法入门指南，acmer带女友刷80+【递归与回溯篇】（本期已完成🎉）</li><li>🐮写给零基础的前端算法入门指南，acmer带女友刷80+【双指针与字符串篇】</li><li>🐮写给零基础的前端算法入门指南，acmer带女友刷80+【二叉树篇】</li><li>🐮写给零基础的前端算法入门指南，acmer带女友刷80+【动态规划DP篇】</li><li>🐮写给零基础的前端算法入门指南，acmer带女友刷80+【总结篇】</li></ul><h1 id="算法这一块到底如何准备"><a href="#算法这一块到底如何准备" class="headerlink" title="算法这一块到底如何准备"></a>算法这一块到底如何准备</h1><p>首先，我来简单介绍一下自己，在校打过ACM（如果没听过，当我没说，因为没有很大价值的牌牌，铁牌，参赛证以及证书倒是一堆）</p><p>如果你知道acm，并且参与过，对于国内前端（注意是说前端）面试的话，应该不需要花费很长的刷题时间，如果大家有想法了解我的acm经历的话，这个后续我会考虑在 <a href="https://space.bilibili.com/351534170">B站发布一期视频</a>。</p><p>那么对于零基础的小白来说，可能需要花10-20天左右时间来准备算法，而对于非科班来说这个周期可能会更长一点。那么，现在我准备来分享我是如何带着女友零基础刷题的。</p><ul><li>第一点，明确算法它不是很难的东西，理解了其实就那会事，或许你还会喜欢上做题，当然，对于acm大佬做的题就另当别论了，这篇文章主体与面试水平为准</li><li>第二点，前端对于算法这一块的考察相对来说会偏简单一点，我在春秋招过程中遇到的笔试题都是一些常见的题目，比如搜索，贪心，简单动态规划，经典排序算法，都是以 <code>leetcode</code>一些简单以及中等难度的居多，而这些算法对于科班来说的话，应该在学校都学习过，比如算法分析与设计，数据结构与算法这一类课程，那么有这个基础，你的刷题时间又可以进行缩短了</li><li>第三点，既然说到要刷题，该如何刷，我在掘金参考了几个大佬（文末有参考处），大家都会推荐分专题来刷，在这里，我也是非常推荐的，在这里，我希望的是将刷算法题的数量再减少一点，带你入门，当你刷完这些专题之后，你就有相关思维能力主动去刷题了，而不是很被动的去刷，这样也很方便自己总结归纳~</li><li>其它，可以参考大佬的文章，这里不再赘述…</li></ul><h1 id="一份思维导图，让你的刷题路线更简单"><a href="#一份思维导图，让你的刷题路线更简单" class="headerlink" title="一份思维导图，让你的刷题路线更简单"></a>一份思维导图，让你的刷题路线更简单</h1><p>开门见山地说，首先提供一份思维导图，让知识由繁到简。</p><p><img src= "/img/loading.gif" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/30337832145d4969833ccb6cf4009d7e~tplv-k3u1fbpfcp-watermark.image" alt=""></p><blockquote><p>获取高清PDF，请在微信公众号【小狮子前端】回复【LeetCode】，一起刷题或者交流学习可以加企鹅群【666151691】</p></blockquote><blockquote><p>本仓库刷题路线参考 <a href="https://github.com/sl1673495/leetcode-javascript">ssh</a>  （给大佬点赞）<br>仓库地址：<a href="https://github.com/sl1673495/leetcode-javascript">https://github.com/sl1673495/leetcode-javascript</a></p></blockquote><p>感谢大佬的归纳总结，原本打算在大佬那里打卡学习，后面考虑不太友好，还是自己新建了一个仓库打卡学习。</p><p>其次，本仓库解题代码大部分是自己的代码风格，题量也进行了拓展，将会持续更新下去，何不star收藏一下？</p><h1 id="仓库介绍"><a href="#仓库介绍" class="headerlink" title="仓库介绍"></a>仓库介绍</h1><blockquote><p>仓库地址：<a href="https://github.com/Chocolate1999/leetcode-javascript">https://github.com/Chocolate1999/leetcode-javascript</a></p></blockquote><p>本仓库将全程使用的语言是 <code>JavaScript</code>，是一个纯前端刷题路线，对于前端刷题没有方向的小伙伴简直是福音。解题代码会记录在本仓库的 <code>Issues</code> 中，会按照 <code>label</code>进行分类。比如想查看 「递归与回溯」 分类下的问题，那么选择标签进行筛选即可。</p><p>同时，小伙伴们可以在 <code>Issues</code> 中提交自己的解题代码，🤝 欢迎 <code>Contributing</code> ，可打卡刷题，坚持下来的人最酷！Give a ⭐️ if this project helped you !</p><h1 id="刷题路线"><a href="#刷题路线" class="headerlink" title="刷题路线"></a>刷题路线</h1><p>下面正式开始我们的刷题之路，给本篇文章点个赞，拿出自己心仪的键盘，开始！</p><blockquote><p>以下专题顺序仅个人以及面试高频点来总结的刷题方式，大家可以根据自己的想法来组合。更多题集请参考本仓库哈~</p></blockquote><h2 id="热身题"><a href="#热身题" class="headerlink" title="热身题"></a>热身题</h2><p><img src= "/img/loading.gif" data-lazy-src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/680b01925d5e41cabb0adfe496a5042f~tplv-k3u1fbpfcp-watermark.image#pic_center" alt=""></p><h3 id="面试题-16-11-跳水板"><a href="#面试题-16-11-跳水板" class="headerlink" title="面试题 16.11. 跳水板"></a>面试题 16.11. 跳水板</h3><p><a href="https://leetcode-cn.com/problems/diving-board-lcci">面试题 16.11. 跳水板原题传送门</a></p><p><strong>题目描述</strong></p><p>你正在使用一堆木板建造跳水板。有两种类型的木板，其中长度较短的木板长度为shorter，长度较长的木板长度为longer。你必须正好使用k块木板。编写一个方法，生成跳水板所有可能的长度。</p><p>返回的长度需要从小到大排列。</p><p>示例 1</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">shorter = <span class="number">1</span></span><br><span class="line">longer = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">k = <span class="number">3</span></span><br><span class="line">输出： [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">解释：</span><br><span class="line">可以使用 <span class="number">3</span> 次 shorter，得到结果 <span class="number">3</span>；使用 <span class="number">2</span> 次 shorter 和 <span class="number">1</span> 次 longer，得到结果 <span class="number">4</span> 。以此类推，得到最终结果。</span><br></pre></td></tr></table></figure><p>提示：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> &lt; shorter &lt;= longer</span><br><span class="line"><span class="number">0</span> &lt;= k &lt;= <span class="number">100000</span></span><br></pre></td></tr></table></figure><p><strong>解题思路</strong></p><p>排列组合也算比较简单，需要 <code>k</code> 个板子，当我们短板有 <code>i</code> 个的时候，长板子就是 <code>k-i</code> 个，由于题目要求是将结果从小到大进行排序，那么我们起初就尽可能多的取短板子，最后结果就是通过 <code>[0,k]</code> 范围内遍历一遍即可。</p><p>对于特殊情况，即短板和长板长度相同时，我们只需要返回 <code>k*len</code> 即可，不然会重复计算。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> divingBoard = <span class="function"><span class="keyword">function</span>(<span class="params">shorter, longer, k</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k===<span class="number">0</span>) <span class="keyword">return</span> []</span><br><span class="line">    <span class="keyword">if</span>(shorter === longer) <span class="keyword">return</span> [k*shorter]</span><br><span class="line">    <span class="keyword">let</span> res = []</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=k;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">let</span> shortCnt = i</span><br><span class="line">        <span class="keyword">let</span> longCnt = k-i</span><br><span class="line">        <span class="keyword">let</span> cnt = shortCnt*shorter + longCnt*longer</span><br><span class="line">        res.push(cnt)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="1291-顺次数"><a href="#1291-顺次数" class="headerlink" title="1291. 顺次数"></a>1291. 顺次数</h3><p><a href="https://leetcode-cn.com/problems/sequential-digits">1291. 顺次数原题传送门</a></p><p><strong>题目描述</strong></p><p>我们定义「顺次数」为：每一位上的数字都比前一位上的数字大 1 的整数。</p><p>请你返回由 [low, high] 范围内所有顺次数组成的 有序 列表（从小到大排序）。</p><p>示例 1：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">输出：low = 100, high = 300</span><br><span class="line">输出：<span class="selector-attr">[123,234]</span></span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">输出：low = 1000, high = 13000</span><br><span class="line">输出：<span class="selector-attr">[1234,2345,3456,4567,5678,6789,12345]</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>提示：</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">10 &lt;= low &lt;= high &lt;= 10^9</span><br></pre></td></tr></table></figure><p><strong>解题思路</strong></p><p>「顺次数」为：每一位上的数字都比前一位上的数字大 1 的整数。</p><p>也就是例如 <code>1234</code>这样的数字，然后给你一段区间确定范围。</p><p>官方给了枚举方式，反正数据量也不是很大，但是我觉得还是有很多数字没必要枚举，可以直接剪枝掉。我的做法是先求出最小值和最大值对应字符串的长度，即求出我们能枚举的数字的长度范围。</p><p>然后我们的起点的最小值从 <code>1</code> 开始，起点的最大值从 <code>10-len</code> 开始。为什么是 <code>10-len</code>？举例说明，示例1给的是 <code>[100,300]</code>范围的值，那么可枚举的长度 <code>len</code> 为 3，起点的最大值就位 10 - 3 = 7。那么此时顺次数为 <code>789</code> 但是不在我们区间范围内，舍弃。然后<code>8、9</code>开头的数字就不需要枚举了。 这样，我们就能剪掉一部门数据了。（虽然暴力是永远滴神…）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">low</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">high</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> sequentialDigits = <span class="function"><span class="keyword">function</span>(<span class="params">low, high</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = []</span><br><span class="line">    <span class="keyword">let</span> lowLen = low.toString().length</span><br><span class="line">    <span class="keyword">let</span> highLen = high.toString().length</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=lowLen;i&lt;=highLen;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">1</span>;j&lt;=<span class="number">10</span>-i;j++)&#123;</span><br><span class="line">            <span class="keyword">let</span> str = <span class="string">&#x27;&#x27;</span></span><br><span class="line">            <span class="keyword">let</span> num = j</span><br><span class="line">            str += num</span><br><span class="line">            <span class="keyword">let</span> k = i-<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span>(k--)&#123;</span><br><span class="line">                num++</span><br><span class="line">                str += num</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">let</span> ans = <span class="built_in">parseInt</span>(str)</span><br><span class="line">            <span class="keyword">if</span>(ans&gt;=low &amp;&amp; ans&lt;=high)&#123;</span><br><span class="line">                res.push(ans)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h2><p><img src= "/img/loading.gif" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e62290db28694f91a72900fdf776a433~tplv-k3u1fbpfcp-watermark.image#pic_center" alt=""></p><h3 id="73-矩阵置零"><a href="#73-矩阵置零" class="headerlink" title="73. 矩阵置零"></a>73. 矩阵置零</h3><p><a href="https://leetcode-cn.com/problems/set-matrix-zeroes">73. 矩阵置零原题传送门</a></p><p><strong>题目描述</strong></p><p>给定一个 m x n 的矩阵，如果一个元素为 0，则将其所在行和列的所有元素都设为 0。请使用原地算法。</p><p>示例 1:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">[</span><br><span class="line">  [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">]</span><br><span class="line">输出: </span><br><span class="line">[</span><br><span class="line">  [<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">[</span><br><span class="line">  [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>],</span><br><span class="line">  [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>]</span><br><span class="line">]</span><br><span class="line">输出: </span><br><span class="line">[</span><br><span class="line">  [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">  [<span class="number">0</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">0</span>],</span><br><span class="line">  [<span class="number">0</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">0</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>进阶:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">一个直接的解决方案是使用  O(mn) 的额外空间，但这并不是一个好的解决方案。</span><br><span class="line">一个简单的改进方案是使用 O(m + n) 的额外空间，但这仍然不是最好的解决方案。</span><br><span class="line">你能想出一个常数空间的解决方案吗？</span><br></pre></td></tr></table></figure><p><strong>解题思路</strong></p><p>用 O(n) 空间复杂度来做，先遍历矩阵，找到等于0的坐标，然后遍历坐标，将对应行和列置为 0 即可</p><p>时间复杂度 O(m * n)</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> setZeroes = <span class="function"><span class="keyword">function</span>(<span class="params">matrix</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> n = matrix.length</span><br><span class="line">    <span class="keyword">let</span> m = matrix[<span class="number">0</span>].length</span><br><span class="line">    <span class="keyword">let</span> arr = []</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][j] == <span class="number">0</span>)&#123;</span><br><span class="line">                arr.push([i,j])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(arr.length)&#123;</span><br><span class="line">        <span class="keyword">let</span> [x,y] = arr.pop()</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;n;i++) matrix[i][y] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">0</span>;j&lt;m;j++) matrix[x][j] = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> matrix</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>另外一种，<strong>原地算法</strong>，空间复杂度 O(1)，我们无需借助外部空间。找到下标为 0 的坐标，然后直接对该行和该列不等于 0 的数字设置为 <code>-0</code> 即可。这里巧妙运用了 <code>JS</code> 中的 <code>Object.is()</code>方法，此时 <code>0</code> 和<code>-0</code> 不相等，但是最终返回的矩阵还是为 <code>0</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> setZeroes = <span class="function"><span class="keyword">function</span>(<span class="params">matrix</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;matrix.length;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">0</span>;j&lt;matrix[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">Object</span>.is(matrix[i][j],<span class="number">0</span>))&#123;</span><br><span class="line">                <span class="comment">// 对行进行操作</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">let</span> k=<span class="number">0</span>;k&lt;matrix.length;k++)</span><br><span class="line">                    <span class="keyword">if</span>(!<span class="built_in">Object</span>.is(matrix[k][j],<span class="number">0</span>) &amp;&amp; k!==i) matrix[k][j] = -<span class="number">0</span></span><br><span class="line">                <span class="comment">// 对列进行操作</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">let</span> k=<span class="number">0</span>;k&lt;matrix[<span class="number">0</span>].length;k++)</span><br><span class="line">                    <span class="keyword">if</span>(!<span class="built_in">Object</span>.is(matrix[i][k],<span class="number">0</span>) &amp;&amp; k!==j) matrix[i][k] = -<span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> matrix</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="54-螺旋矩阵"><a href="#54-螺旋矩阵" class="headerlink" title="54. 螺旋矩阵"></a>54. 螺旋矩阵</h3><p><a href="https://leetcode-cn.com/problems/spiral-matrix">54. 螺旋矩阵原题传送门</a></p><p><strong>题目描述</strong></p><p>给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。</p><p>示例 1:</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line"> <span class="selector-attr">[ 1, 2, 3 ]</span>,</span><br><span class="line"> <span class="selector-attr">[ 4, 5, 6 ]</span>,</span><br><span class="line"> <span class="selector-attr">[ 7, 8, 9 ]</span></span><br><span class="line">]</span><br><span class="line">输出: <span class="selector-attr">[1,2,3,6,9,8,7,4,5]</span></span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  <span class="selector-attr">[1, 2, 3, 4]</span>,</span><br><span class="line">  <span class="selector-attr">[5, 6, 7, 8]</span>,</span><br><span class="line">  <span class="selector-attr">[9,10,11,12]</span></span><br><span class="line">]</span><br><span class="line">输出: <span class="selector-attr">[1,2,3,4,8,12,11,10,9,5,6,7]</span></span><br></pre></td></tr></table></figure><p><strong>解题思路</strong></p><p>和 <a href="https://blog.csdn.net/weixin_42429718/article/details/108535286">上一期</a> 螺旋矩阵差不多，这个是让我么输出，而上次是让我们构造，还是按照螺旋矩阵模拟即可，先从左到右，在从上到下，再从右到左，再从下到上。</p><p>不过这里的矩阵行和列不相同了，可能会出现不成环的情况，那么最后会留一列或一行出来，这里借用<a href="https://leetcode-cn.com/problems/spiral-matrix/solution/shou-hui-tu-jie-liang-chong-bian-li-de-ce-lue-kan-/">大佬</a>一张图：</p><p><img src= "/img/loading.gif" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9ea8f7bf70e441f982cc92fd6f18426a~tplv-k3u1fbpfcp-zoom-1.image" alt=""><br>然后我们需要提前跳出去一下，就是避免重复计算，总数够了直接跳出去。注意下面代码 <code>break</code>。只能放在那里，因为遍历顺序，如果最后留下一行的话，需要从左到右遍历，此时 <code>top &gt; bottom</code>  。如果最后留下一列的话，需要从上到下遍历，此时 <code>left &gt; right</code>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[][]&#125;</span> <span class="variable">matrix</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> spiralOrder = <span class="function"><span class="keyword">function</span>(<span class="params">matrix</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!matrix.length) <span class="keyword">return</span> []</span><br><span class="line">    <span class="keyword">let</span> n = matrix.length</span><br><span class="line">    <span class="keyword">let</span> m = matrix[<span class="number">0</span>].length</span><br><span class="line">    <span class="keyword">let</span> total = n*m</span><br><span class="line">    <span class="keyword">let</span> top = <span class="number">0</span>,bottom = n-<span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>,right = m-<span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> res = []</span><br><span class="line">    <span class="keyword">while</span>(res.length &lt; total)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=left;i&lt;=right;i++) res.push(matrix[top][i]) <span class="comment">// 从左到右</span></span><br><span class="line">        top++</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=top;i&lt;=bottom;i++) res.push(matrix[i][right]) <span class="comment">// 从上到下</span></span><br><span class="line">        right--</span><br><span class="line">        <span class="comment">/* 因为n 和 m 不相同的时候，最后可能会留一列或一行，避免重复计算，总数够了直接跳出去 */</span></span><br><span class="line">        <span class="keyword">if</span>(res.length === total) <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=right;i&gt;=left;i--) res.push(matrix[bottom][i]) <span class="comment">// 从右到左</span></span><br><span class="line">        bottom--</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=bottom;i&gt;=top;i--) res.push(matrix[i][left]) <span class="comment">// 从下到上</span></span><br><span class="line">        left++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="59-螺旋矩阵-II"><a href="#59-螺旋矩阵-II" class="headerlink" title="59. 螺旋矩阵 II"></a>59. 螺旋矩阵 II</h3><p><a href="https://leetcode-cn.com/problems/spiral-matrix-ii">59. 螺旋矩阵 II原题传送门</a></p><p><strong>题目描述</strong></p><p>给定一个正整数 n，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。</p><p>示例:</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">输入: 3</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line"> <span class="selector-attr">[ 1, 2, 3 ]</span>,</span><br><span class="line"> <span class="selector-attr">[ 8, 9, 4 ]</span>,</span><br><span class="line"> <span class="selector-attr">[ 7, 6, 5 ]</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>解题思路</strong></p><p>按照螺旋矩阵模拟即可，先从左到右，在从上到下，再从右到左，再从下到上。</p><p>每次进行<code>cur++</code>操作，直到累加到<code>total</code>为止。最后返回二维数组即可（没想到 <code>js</code>二维数组也是这样方便…）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[][]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> generateMatrix = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> top = <span class="number">0</span>, bottom =n-<span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>, right = n-<span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> res = []</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;n;i++) res[i] = []</span><br><span class="line">    <span class="keyword">let</span> cur = <span class="number">1</span>, total = n*n</span><br><span class="line">    <span class="keyword">while</span>(cur&lt;=total)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=left;i&lt;=right;i++) res[top][i] = cur++  <span class="comment">// 从左到右</span></span><br><span class="line">        top++</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=top;i&lt;=bottom;i++) res[i][right] = cur++ <span class="comment">// 从上到下</span></span><br><span class="line">        right--</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=right;i&gt;=left;i--) res[bottom][i] = cur++ <span class="comment">// 从右到左</span></span><br><span class="line">        bottom--</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=bottom;i&gt;=top;i--) res[i][left] = cur++ <span class="comment">// 从下到上</span></span><br><span class="line">        left++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="子集"><a href="#子集" class="headerlink" title="子集"></a>子集</h2><p><img src= "/img/loading.gif" data-lazy-src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7f5fbae783db41acbd25ee8c7b3dfad8~tplv-k3u1fbpfcp-watermark.image" alt=""></p><h3 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a>46. 全排列</h3><p><a href="https://leetcode-cn.com/problems/permutations">46. 全排列原题传送门</a></p><p><strong>题目描述</strong></p><p>给定一个 没有重复 数字的序列，返回其所有可能的全排列。</p><p>示例:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>解题思路</strong></p><p>序列不重复就很简单了，维护一个 <code>vis</code>数组，不重复取就好了。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> permute = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res = [];</span><br><span class="line">  <span class="keyword">let</span> vis = &#123;&#125;;</span><br><span class="line">  <span class="keyword">let</span> dfs = <span class="function">(<span class="params">t</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (t.length == nums.length) &#123;</span><br><span class="line">      res.push(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (vis[i]) <span class="keyword">continue</span>;</span><br><span class="line">      vis[i] = <span class="literal">true</span>;</span><br><span class="line">      t.push(nums[i]);</span><br><span class="line">      dfs(t.slice());</span><br><span class="line">      t.pop();</span><br><span class="line">      vis[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  dfs([]);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="47-全排列-II"><a href="#47-全排列-II" class="headerlink" title="47. 全排列 II"></a>47. 全排列 II</h3><p><a href="https://leetcode-cn.com/problems/permutations-ii">47. 全排列 II原题传送门</a></p><p><strong>题目描述</strong></p><p>给定一个可包含重复数字的序列，返回所有不重复的全排列。</p><p>示例:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>解题思路</strong></p><p>本题是求全排列，并且排列不能重复。我们用一个 <code>vis</code>数组维护一下，让每一条路线保证不重复选取元素，而对于每一层而言，需要判断相邻元素是否相同，相同的就没必要走了，例如下图中红色三角形部分。</p><p><img src= "/img/loading.gif" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ef6ca8a013504d59a995b6b3b33cf132~tplv-k3u1fbpfcp-zoom-1.image" alt=""><br>果当前的选项 <code>nums[i]</code> ，与同一层的上一个选项 <code>nums[i - 1]</code> 相同，且 <code>nums[i - 1]</code>有意义（即索引 <code>&gt;= 0</code>），且没有被使用过，那就跳过该选项。</p><p>因为 <code>nums[i - 1]</code>如果被使用过，它会被修剪掉，不是一个选项了，即便它和 <code>nums[i]</code>重复，<code>nums[i]</code>还是可以选的。</p><p><a href="https://leetcode-cn.com/problems/permutations-ii/solution/shou-hua-tu-jie-li-yong-yue-shu-tiao-jian-chong-fe/">参考xiao_ben_zhu大佬题解</a></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> permuteUnique = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    nums.sort(<span class="function">(<span class="params">a,b</span>) =&gt;</span> a-b);</span><br><span class="line">    <span class="keyword">let</span> vis = &#123;&#125;;</span><br><span class="line">    <span class="keyword">let</span> dfs = <span class="function">(<span class="params">t</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(t.length === nums.length)&#123;</span><br><span class="line">        res.push(t);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i-<span class="number">1</span>&gt;=<span class="number">0</span> &amp;&amp; nums[i] == nums[i-<span class="number">1</span>] &amp;&amp; !vis[i-<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(vis[i]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[i] = <span class="literal">true</span>;</span><br><span class="line">        t.push(nums[i]);</span><br><span class="line">        dfs(t.slice(),i+<span class="number">1</span>);</span><br><span class="line">        t.pop();</span><br><span class="line">        vis[i] = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs([],<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="78-子集"><a href="#78-子集" class="headerlink" title="78. 子集"></a>78. 子集</h3><p><a href="https://leetcode-cn.com/problems/subsets">78. 子集原题传送门</a></p><p><strong>题目描述</strong></p><p>给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。</p><p>说明：解集不能包含重复的子集。</p><p>示例:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; [1,2,3]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [1],</span><br><span class="line">  [2],</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [1,3],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  []</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>解题思路</strong></p><p>一道组合相关的题目，采用回溯来做即可，题目说明不包含重复元素，于是我们也无需排序然后判断相邻元素是否相等来去重了。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> subsets = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res = [];</span><br><span class="line">  <span class="keyword">let</span> dfs = <span class="function">(<span class="params">t,start</span>) =&gt;</span> &#123;</span><br><span class="line">    res.push(t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=start;i&lt;nums.length;i++)&#123;</span><br><span class="line">      t.push(nums[i]);</span><br><span class="line">      dfs(t.slice(),i+<span class="number">1</span>);</span><br><span class="line">      t.pop();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  dfs([],<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="90-子集-II"><a href="#90-子集-II" class="headerlink" title="90. 子集 II"></a>90. 子集 II</h3><p><a href="https://leetcode-cn.com/problems/subsets-ii">90. 子集 II原题传送门</a></p><p><strong>题目描述</strong></p><p>给定一个可能包含重复元素的整数数组 <code>nums</code>，返回该数组所有可能的子集（幂集）。</p><p>说明：解集不能包含重复的子集。</p><p>示例:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">2</span>],</span><br><span class="line">  [<span class="number">1</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line">  []</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>解题思路</strong></p><p>本题还是挺有意思的，我们要求的是子集，但是子集要进行去重操作，采用的做法是先对原数组进行排序，那么排序后的数组重复的元素必定是相邻的，然后在遍历解空间树的时候，要做一个去重的操作，当遇到重复出现，也就是和前面相邻元素相同的时候，直接跳过该节点，不让它向下递归。具体示意图如下：</p><p><img src= "/img/loading.gif" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0a6775fbce0642c29ef39b21ca3ef2c2~tplv-k3u1fbpfcp-zoom-1.image" alt=""><br><a href="https://leetcode-cn.com/problems/subsets-ii/solution/li-jie-li-jie-qu-zhong-cao-zuo-by-jin-ai-yi/">参考大佬题解</a></p><p><code>dfs</code>的话，一条路会一直走下去，然后回溯回来，在走之前，<code>start</code>是当前层第一个元素，只有当前元素下标大于 <code>start</code>才会有重复元素，而对于不同层的重复元素，我们不应该切断，应该继续走，不然就不会有 <code>[1,2,2]</code>这样的子集出现了。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> subsetsWithDup = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res = [];</span><br><span class="line">  nums.sort(<span class="function">(<span class="params">a,b</span>)=&gt;</span>a-b);</span><br><span class="line">  <span class="keyword">let</span> dfs = <span class="function">(<span class="params">t,start</span>) =&gt;</span> &#123;</span><br><span class="line">    res.push(t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=start;i&lt;nums.length;i++)&#123;</span><br><span class="line">      <span class="comment">// 同层重复，跳过</span></span><br><span class="line">      <span class="keyword">if</span>(i&gt;start &amp;&amp; nums[i-<span class="number">1</span>] == nums[i]) <span class="keyword">continue</span>;</span><br><span class="line">      t.push(nums[i]);</span><br><span class="line">      dfs(t.slice(),i+<span class="number">1</span>);</span><br><span class="line">      t.pop();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  dfs([],<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="递归与回溯"><a href="#递归与回溯" class="headerlink" title="递归与回溯"></a>递归与回溯</h2><p><img src= "/img/loading.gif" data-lazy-src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/be726155ff8749d4a13dd1f36b1edfe7~tplv-k3u1fbpfcp-watermark.image#pic_center" alt=""></p><h3 id="784-字母大小写全排列"><a href="#784-字母大小写全排列" class="headerlink" title="784. 字母大小写全排列"></a>784. 字母大小写全排列</h3><p><a href="https://leetcode-cn.com/problems/letter-case-permutation">784. 字母大小写全排列原题传送门</a></p><p><strong>题目描述</strong></p><p>给定一个字符串S，通过将字符串S中的每个字母转变大小写，我们可以获得一个新的字符串。返回所有可能得到的字符串集合。</p><p>示例：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">输入：S = <span class="string">&quot;a1b2&quot;</span></span><br><span class="line">输出：[<span class="string">&quot;a1b2&quot;</span>, <span class="string">&quot;a1B2&quot;</span>, <span class="string">&quot;A1b2&quot;</span>, <span class="string">&quot;A1B2&quot;</span>]</span><br><span class="line"></span><br><span class="line">输入：S = <span class="string">&quot;3z4&quot;</span></span><br><span class="line">输出：[<span class="string">&quot;3z4&quot;</span>, <span class="string">&quot;3Z4&quot;</span>]</span><br><span class="line"></span><br><span class="line">输入：S = <span class="string">&quot;12345&quot;</span></span><br><span class="line">输出：[<span class="string">&quot;12345&quot;</span>]</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>提示：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">S 的长度不超过<span class="number">12</span>。</span><br><span class="line">S 仅由数字和字母组成。</span><br></pre></td></tr></table></figure><p><strong>解题思路</strong></p><p>这道题就是递归操作，没有回溯，是一个挺有意思的题目，在讲解思路之前，我先搬运一下大佬的图解，方便我后续补充。</p><p><a href="https://leetcode-cn.com/problems/letter-case-permutation/solution/shen-du-you-xian-bian-li-hui-su-suan-fa-python-dai/">参考大佬 liweiwei1419 图解</a></p><p>第一步<br><img src= "/img/loading.gif" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6bda7c0a0868442d914e44e7e958e9b9~tplv-k3u1fbpfcp-zoom-1.image" alt=""><br>第二步<br><img src= "/img/loading.gif" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aeccab3832da4a0aaed6ef0f034d66bd~tplv-k3u1fbpfcp-zoom-1.image" alt=""><br>第三步<br><img src= "/img/loading.gif" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8d8428bf39f14fd899b5622803aef6cc~tplv-k3u1fbpfcp-zoom-1.image" alt=""><br>第四步</p><p><img src= "/img/loading.gif" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c1eb2cd278b24b68a7c4ef584f5627f8~tplv-k3u1fbpfcp-zoom-1.image" alt=""><br>第五步<br><img src= "/img/loading.gif" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c13eb1af70ca4504b4b9b9a42ef221d1~tplv-k3u1fbpfcp-zoom-1.image" alt=""><br>第六步<br><img src= "/img/loading.gif" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5161fa187ddb4115804728731c7bc02c~tplv-k3u1fbpfcp-zoom-1.image" alt=""><br>好了，有了上述图解之后（还是感谢大佬的图解，万分感谢orz），我相信明白的已经明白了，如果不明白我继续解释。</p><p>此题我们只需要从头往后遍历一遍即可，对于非字母节点，我们只会产生一个分支，而对于字母节点，我们可以产生两个分支，即大写字母和小写字母。（详细请参见下述代码）</p><p>于是，我们只要简单搜一遍就可以了。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">S</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> letterCasePermutation = <span class="function"><span class="keyword">function</span>(<span class="params">S</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = []</span><br><span class="line">    <span class="keyword">let</span> dfs = <span class="function">(<span class="params">t,str</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(t.length === S.length)</span><br><span class="line">            <span class="keyword">return</span> res.push(t)</span><br><span class="line">        <span class="keyword">let</span> ch = str[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">let</span> nextStr = str.substr(<span class="number">1</span>)</span><br><span class="line">        <span class="comment">// 当前位置为数字，只有一个分支</span></span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">isNaN</span>(<span class="built_in">Number</span>(ch)))&#123;</span><br><span class="line">            dfs(t+ch,nextStr)</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//当前位置为字母，会产生两个分支</span></span><br><span class="line">            <span class="keyword">let</span> tmp = ch.toUpperCase()</span><br><span class="line">            <span class="keyword">if</span>(tmp === ch) tmp = ch.toLowerCase()</span><br><span class="line">            dfs(t+ch,nextStr)</span><br><span class="line">            dfs(t+tmp,nextStr)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="string">&#x27;&#x27;</span>,S)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="面试题-08-08-有重复字符串的排列组合"><a href="#面试题-08-08-有重复字符串的排列组合" class="headerlink" title="面试题 08.08. 有重复字符串的排列组合"></a>面试题 08.08. 有重复字符串的排列组合</h3><p><a href="https://leetcode-cn.com/problems/permutation-ii-lcci">面试题 08.08. 有重复字符串的排列组合原题传送门</a></p><p><strong>题目描述</strong></p><p>有重复字符串的排列组合。编写一种方法，计算某字符串的所有排列组合。</p><p>示例1:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">输入：S = <span class="string">&quot;qqe&quot;</span></span><br><span class="line">输出：[<span class="string">&quot;eqq&quot;</span>,<span class="string">&quot;qeq&quot;</span>,<span class="string">&quot;qqe&quot;</span>]</span><br></pre></td></tr></table></figure><p>示例2:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">输入：S = <span class="string">&quot;ab&quot;</span></span><br><span class="line">输出：[<span class="string">&quot;ab&quot;</span>, <span class="string">&quot;ba&quot;</span>]</span><br></pre></td></tr></table></figure><p>提示:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">字符都是英文字母。</span><br><span class="line">字符串长度在[<span class="number">1</span>, <span class="number">9</span>]之间。</span><br></pre></td></tr></table></figure><p><strong>解题思路</strong></p><p>全排列，直接用回溯法即可，数据量比较小，暴力完事~</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> permutation = <span class="function"><span class="keyword">function</span> (<span class="params">S</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">  <span class="keyword">let</span> vis = []</span><br><span class="line">  <span class="keyword">let</span> dfs = <span class="function">(<span class="params">t</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (t.length === S.length) <span class="keyword">return</span> res.add(t)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; S.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (vis[i]) <span class="keyword">continue</span></span><br><span class="line">      vis[i] = <span class="literal">true</span></span><br><span class="line">      dfs(t + S[i])</span><br><span class="line">      vis[i] = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  dfs(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span> [...res]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="980-不同路径-III"><a href="#980-不同路径-III" class="headerlink" title="980. 不同路径 III"></a>980. 不同路径 III</h3><p><a href="https://leetcode-cn.com/problems/unique-paths-iii">980. 不同路径 III原题传送门</a></p><p><strong>题目描述</strong></p><p>在二维网格 <code>grid</code> 上，有 4 种类型的方格：</p><p><code>1</code> 表示起始方格。且只有一个起始方格。<br><code>2</code> 表示结束方格，且只有一个结束方格。<br><code>0</code> 表示我们可以走过的空方格。<br><code>-1</code> 表示我们无法跨越的障碍。<br>返回在四个方向（上、下、左、右）上行走时，从起始方格到结束方格的不同路径的数目。</p><p>每一个无障碍方格都要通过一次，但是一条路径中不能重复通过同一个方格。</p><p>示例 1：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">输入：[[<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>,-<span class="number">1</span>]]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：我们有以下两条路径：</span><br><span class="line"><span class="number">1.</span> (<span class="number">0</span>,<span class="number">0</span>),(<span class="number">0</span>,<span class="number">1</span>),(<span class="number">0</span>,<span class="number">2</span>),(<span class="number">0</span>,<span class="number">3</span>),(<span class="number">1</span>,<span class="number">3</span>),(<span class="number">1</span>,<span class="number">2</span>),(<span class="number">1</span>,<span class="number">1</span>),(<span class="number">1</span>,<span class="number">0</span>),(<span class="number">2</span>,<span class="number">0</span>),(<span class="number">2</span>,<span class="number">1</span>),(<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line"><span class="number">2.</span> (<span class="number">0</span>,<span class="number">0</span>),(<span class="number">1</span>,<span class="number">0</span>),(<span class="number">2</span>,<span class="number">0</span>),(<span class="number">2</span>,<span class="number">1</span>),(<span class="number">1</span>,<span class="number">1</span>),(<span class="number">0</span>,<span class="number">1</span>),(<span class="number">0</span>,<span class="number">2</span>),(<span class="number">0</span>,<span class="number">3</span>),(<span class="number">1</span>,<span class="number">3</span>),(<span class="number">1</span>,<span class="number">2</span>),(<span class="number">2</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">输入：[[<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>]]</span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：我们有以下四条路径： </span><br><span class="line"><span class="number">1.</span> (<span class="number">0</span>,<span class="number">0</span>),(<span class="number">0</span>,<span class="number">1</span>),(<span class="number">0</span>,<span class="number">2</span>),(<span class="number">0</span>,<span class="number">3</span>),(<span class="number">1</span>,<span class="number">3</span>),(<span class="number">1</span>,<span class="number">2</span>),(<span class="number">1</span>,<span class="number">1</span>),(<span class="number">1</span>,<span class="number">0</span>),(<span class="number">2</span>,<span class="number">0</span>),(<span class="number">2</span>,<span class="number">1</span>),(<span class="number">2</span>,<span class="number">2</span>),(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="number">2.</span> (<span class="number">0</span>,<span class="number">0</span>),(<span class="number">0</span>,<span class="number">1</span>),(<span class="number">1</span>,<span class="number">1</span>),(<span class="number">1</span>,<span class="number">0</span>),(<span class="number">2</span>,<span class="number">0</span>),(<span class="number">2</span>,<span class="number">1</span>),(<span class="number">2</span>,<span class="number">2</span>),(<span class="number">1</span>,<span class="number">2</span>),(<span class="number">0</span>,<span class="number">2</span>),(<span class="number">0</span>,<span class="number">3</span>),(<span class="number">1</span>,<span class="number">3</span>),(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="number">3.</span> (<span class="number">0</span>,<span class="number">0</span>),(<span class="number">1</span>,<span class="number">0</span>),(<span class="number">2</span>,<span class="number">0</span>),(<span class="number">2</span>,<span class="number">1</span>),(<span class="number">2</span>,<span class="number">2</span>),(<span class="number">1</span>,<span class="number">2</span>),(<span class="number">1</span>,<span class="number">1</span>),(<span class="number">0</span>,<span class="number">1</span>),(<span class="number">0</span>,<span class="number">2</span>),(<span class="number">0</span>,<span class="number">3</span>),(<span class="number">1</span>,<span class="number">3</span>),(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="number">4.</span> (<span class="number">0</span>,<span class="number">0</span>),(<span class="number">1</span>,<span class="number">0</span>),(<span class="number">2</span>,<span class="number">0</span>),(<span class="number">2</span>,<span class="number">1</span>),(<span class="number">1</span>,<span class="number">1</span>),(<span class="number">0</span>,<span class="number">1</span>),(<span class="number">0</span>,<span class="number">2</span>),(<span class="number">0</span>,<span class="number">3</span>),(<span class="number">1</span>,<span class="number">3</span>),(<span class="number">1</span>,<span class="number">2</span>),(<span class="number">2</span>,<span class="number">2</span>),(<span class="number">2</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">输入：[[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">0</span>]]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：</span><br><span class="line">没有一条路能完全穿过每一个空的方格一次。</span><br><span class="line">请注意，起始和结束方格可以位于网格中的任意位置。</span><br></pre></td></tr></table></figure><p>提示：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> &lt;= grid.length * grid[<span class="number">0</span>].length &lt;= <span class="number">20</span></span><br></pre></td></tr></table></figure><p><strong>解题思路</strong></p><p>回溯算法，不过这道题需要我们走完所有空格，所以我们起初遍历的时候需要统计一下空格的数目，然后还有一个注意点就是重点也算是可走的路径的一个点，也需要统计进去，所以代码 <code>cnt</code> 值 初始化为 1</p><p>接下来就是回溯过程了，写了一个 <code>check</code> 函数，进行简单判断剪枝，然后就是往四个方向搜，每走一个格子就将当前格子设置为障碍（即 <code>-1</code>），然后搜索完后，回溯时，需要将障碍重设置为空格。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[][]&#125;</span> <span class="variable">grid</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> uniquePathsIII = <span class="function"><span class="keyword">function</span>(<span class="params">grid</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> cnt = <span class="number">1</span> <span class="comment">// 统计地图中可走的方格个数，包括终点，故初始值为1</span></span><br><span class="line">    <span class="keyword">let</span> sx,sy <span class="comment">// 记录起点坐标</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;grid.length;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">0</span>;j&lt;grid[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(grid[i][j] === <span class="number">1</span>)&#123;</span><br><span class="line">                sx = i</span><br><span class="line">                sy = j</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(grid[i][j] === <span class="number">0</span>)&#123;</span><br><span class="line">                cnt++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dfs(sx,sy,cnt,grid)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 剪枝条件</span></span><br><span class="line"><span class="keyword">let</span> check = <span class="function">(<span class="params">sx,sy,grid</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(sx&lt;<span class="number">0</span> || sx&gt;=grid.length || sy&lt;<span class="number">0</span> || sy&gt;=grid[<span class="number">0</span>].length || grid[sx][sy] == -<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dfs = <span class="function">(<span class="params">sx,sy,cnt,grid</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(!check(sx,sy,grid)) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span>(grid[sx][sy] === <span class="number">2</span>)&#123; <span class="comment">// 走到终点时，也要判断一下当前所有空格是否走完</span></span><br><span class="line">        <span class="keyword">return</span> cnt === <span class="number">0</span> ? <span class="number">1</span>:<span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="number">0</span></span><br><span class="line">    grid[sx][sy] = -<span class="number">1</span>  <span class="comment">//走过的空格进行标记，设置为障碍即可</span></span><br><span class="line">    res += dfs(sx+<span class="number">1</span>,sy,cnt-<span class="number">1</span>,grid)  <span class="comment">// 四个方向进行搜索</span></span><br><span class="line">    res += dfs(sx,sy+<span class="number">1</span>,cnt-<span class="number">1</span>,grid)</span><br><span class="line">    res += dfs(sx-<span class="number">1</span>,sy,cnt-<span class="number">1</span>,grid)</span><br><span class="line">    res += dfs(sx,sy-<span class="number">1</span>,cnt-<span class="number">1</span>,grid)</span><br><span class="line">    grid[sx][sy] = <span class="number">0</span>  <span class="comment">// 回溯过程，不影响后续dfs</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1219-黄金矿工"><a href="#1219-黄金矿工" class="headerlink" title="1219. 黄金矿工"></a>1219. 黄金矿工</h3><p><a href="https://leetcode-cn.com/problems/path-with-maximum-gold">1219. 黄金矿工原题传送门</a></p><p><strong>题目描述</strong></p><p>你要开发一座金矿，地质勘测学家已经探明了这座金矿中的资源分布，并用大小为 <code>m * n</code> 的网格 <code>grid</code> 进行了标注。每个单元格中的整数就表示这一单元格中的黄金数量；如果该单元格是空的，那么就是 <code>0</code>。</p><p>为了使收益最大化，矿工需要按以下规则来开采黄金：</p><p>每当矿工进入一个单元，就会收集该单元格中的所有黄金。<br>矿工每次可以从当前位置向上下左右四个方向走。<br>每个单元格只能被开采（进入）一次。<br>不得开采（进入）黄金数目为 <code>0</code> 的单元格。<br>矿工可以从网格中 任意一个 有黄金的单元格出发或者是停止。</p><p>示例 1：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">输入：grid = [[<span class="number">0</span>,<span class="number">6</span>,<span class="number">0</span>],[<span class="number">5</span>,<span class="number">8</span>,<span class="number">7</span>],[<span class="number">0</span>,<span class="number">9</span>,<span class="number">0</span>]]</span><br><span class="line">输出：<span class="number">24</span></span><br><span class="line">解释：</span><br><span class="line">[[<span class="number">0</span>,<span class="number">6</span>,<span class="number">0</span>],</span><br><span class="line"> [<span class="number">5</span>,<span class="number">8</span>,<span class="number">7</span>],</span><br><span class="line"> [<span class="number">0</span>,<span class="number">9</span>,<span class="number">0</span>]]</span><br><span class="line">一种收集最多黄金的路线是：<span class="number">9</span> -&gt; <span class="number">8</span> -&gt; <span class="number">7</span>。</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">输入：grid = [[<span class="number">1</span>,<span class="number">0</span>,<span class="number">7</span>],[<span class="number">2</span>,<span class="number">0</span>,<span class="number">6</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">0</span>,<span class="number">3</span>,<span class="number">0</span>],[<span class="number">9</span>,<span class="number">0</span>,<span class="number">20</span>]]</span><br><span class="line">输出：<span class="number">28</span></span><br><span class="line">解释：</span><br><span class="line">[[<span class="number">1</span>,<span class="number">0</span>,<span class="number">7</span>],</span><br><span class="line"> [<span class="number">2</span>,<span class="number">0</span>,<span class="number">6</span>],</span><br><span class="line"> [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],</span><br><span class="line"> [<span class="number">0</span>,<span class="number">3</span>,<span class="number">0</span>],</span><br><span class="line"> [<span class="number">9</span>,<span class="number">0</span>,<span class="number">20</span>]]</span><br><span class="line">一种收集最多黄金的路线是：<span class="number">1</span> -&gt; <span class="number">2</span> -&gt; <span class="number">3</span> -&gt; <span class="number">4</span> -&gt; <span class="number">5</span> -&gt; <span class="number">6</span> -&gt; <span class="number">7</span>。</span><br></pre></td></tr></table></figure><p>提示：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> &lt;= grid.length, grid[i].length &lt;= <span class="number">15</span></span><br><span class="line"><span class="number">0</span> &lt;= grid[i][j] &lt;= <span class="number">100</span></span><br><span class="line">最多 <span class="number">25</span> 个单元格中有黄金。</span><br></pre></td></tr></table></figure><p><strong>解题思路</strong></p><p>这题也是搜索相关，四个方向，不允许重复，不过这次我们需要从不同起点搜索，而且为了减少搜索次数，我们得从黄金数量不为0的点开始搜。然后每当走不下去的时候，就比较一下当前黄金数量，求出最大值即可。</p><p><img src= "/img/loading.gif" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b531b6c0a9434b7197cf335fdf04644c~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[][]&#125;</span> <span class="variable">grid</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> getMaximumGold = <span class="function"><span class="keyword">function</span>(<span class="params">grid</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!grid || !grid.length) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> vis = []</span><br><span class="line">    <span class="comment">// 最终收集的最多黄金数量</span></span><br><span class="line">    <span class="keyword">let</span> maxGold = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;grid.length;i++) vis[i] = []</span><br><span class="line">    <span class="comment">// 剪枝条件</span></span><br><span class="line">    <span class="keyword">let</span> check = <span class="function">(<span class="params">x,y</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span> || x&gt;=grid.length || y&lt;<span class="number">0</span> || y&gt;=grid[<span class="number">0</span>].length || vis[x][y] === <span class="number">1</span> || !grid[x][y]) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> dfs = <span class="function">(<span class="params">x,y,total</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(check(x,y))&#123;</span><br><span class="line">            vis[x][y] = <span class="number">1</span> <span class="comment">//防止重复</span></span><br><span class="line">            dfs(x+<span class="number">1</span>,y,total+grid[x][y]) <span class="comment">// 四个方向搜索</span></span><br><span class="line">            dfs(x,y+<span class="number">1</span>,total+grid[x][y])</span><br><span class="line">            dfs(x-<span class="number">1</span>,y,total+grid[x][y])</span><br><span class="line">            dfs(x,y-<span class="number">1</span>,total+grid[x][y])</span><br><span class="line">            vis[x][y] = <span class="number">0</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 走到底了，就比较一下当前黄金数量</span></span><br><span class="line">            maxGold = <span class="built_in">Math</span>.max(maxGold,total)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 起点从非0单元格开始</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;grid.length;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">0</span>;j&lt;grid[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(grid[i][j])&#123;</span><br><span class="line">                dfs(i,j,<span class="number">0</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxGold</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="79-单词搜索"><a href="#79-单词搜索" class="headerlink" title="79. 单词搜索"></a>79. 单词搜索</h3><p><a href="https://leetcode-cn.com/problems/word-search">79. 单词搜索原题传送门</a></p><p><strong>题目描述</strong></p><p>给定一个二维网格和一个单词，找出该单词是否存在于网格中。</p><p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p><p>示例:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">board =</span><br><span class="line">[</span><br><span class="line">  [<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;E&#x27;</span>],</span><br><span class="line">  [<span class="string">&#x27;S&#x27;</span>,<span class="string">&#x27;F&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;S&#x27;</span>],</span><br><span class="line">  [<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;D&#x27;</span>,<span class="string">&#x27;E&#x27;</span>,<span class="string">&#x27;E&#x27;</span>]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">给定 word = <span class="string">&quot;ABCCED&quot;</span>, 返回 <span class="literal">true</span></span><br><span class="line">给定 word = <span class="string">&quot;SEE&quot;</span>, 返回 <span class="literal">true</span></span><br><span class="line">给定 word = <span class="string">&quot;ABCB&quot;</span>, 返回 <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>提示：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">board 和 word 中只包含大写和小写英文字母。</span><br><span class="line"><span class="number">1</span> &lt;= board.length &lt;= <span class="number">200</span></span><br><span class="line"><span class="number">1</span> &lt;= board[i].length &lt;= <span class="number">200</span></span><br><span class="line"><span class="number">1</span> &lt;= word.length &lt;= <span class="number">10</span>^<span class="number">3</span></span><br></pre></td></tr></table></figure><p><strong>解题思路</strong></p><p>上一期做了单词搜索2 <code>hard</code> 版本之后，这道题也想用字典树玩一玩，没想到超时了，后面一想，数据确实有点大，而且对于一个单词来说，建立一颗字典树岂不是很浪费，还要花时间码代码…</p><p>本题也是回溯的思路，不过期间做了一点小优化，还是通过动态更改当前所走的格子，省去了那份 开辟<code>vis</code> 数组的空间。</p><p>对于递归层次，由于最后一次计算时，层次多算了一次（即多加了一次），所以条件为 <code>&gt;</code>。</p><p><img src= "/img/loading.gif" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e4f7c855b6574ce993f4c4d88e4616b9~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> exist = <span class="function"><span class="keyword">function</span>(<span class="params">grid, word</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> dfs = <span class="function">(<span class="params">x,y,t</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 最后一次还会 +1 因此，条件是大于</span></span><br><span class="line">    <span class="keyword">if</span>(t &gt; word.length-<span class="number">1</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 剪枝条件</span></span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">0</span> || x&gt;=grid.length || y&lt;<span class="number">0</span> || y&gt;=grid[<span class="number">0</span>].length || grid[x][y]!= word[t] || grid[x][y] == <span class="string">&#x27;#&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">let</span> tmp = grid[x][y]</span><br><span class="line">    <span class="comment">// 开始走</span></span><br><span class="line">    grid[x][y] = <span class="string">&#x27;#&#x27;</span></span><br><span class="line">    <span class="comment">// 从四个方向搜索，只要一个方向搜索有结果，那么直接返回 true即可</span></span><br><span class="line">    <span class="keyword">let</span> res = dfs(x+<span class="number">1</span>,y,t+<span class="number">1</span>) || dfs(x,y+<span class="number">1</span>,t+<span class="number">1</span>) || dfs(x-<span class="number">1</span>,y,t+<span class="number">1</span>) || dfs(x,y-<span class="number">1</span>,t+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span>(res) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment">// 回溯（重置）</span></span><br><span class="line">    grid[x][y] = tmp</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;grid.length;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">0</span>;j&lt;grid[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(grid[i][j] == word[<span class="number">0</span>])&#123;</span><br><span class="line">        <span class="keyword">let</span> res = dfs(i,j,<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span>(res) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="212-单词搜索-II"><a href="#212-单词搜索-II" class="headerlink" title="212. 单词搜索 II"></a>212. 单词搜索 II</h3><p><a href="https://leetcode-cn.com/problems/word-search-ii">212. 单词搜索 II原题传送门</a></p><p><strong>题目描述</strong></p><p>给定一个二维网格 <code>board</code> 和一个字典中的单词列表 <code>words</code>，找出所有同时在二维网格和字典中出现的单词。</p><p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母在一个单词中不允许被重复使用。</p><p>示例:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">words = [<span class="string">&quot;oath&quot;</span>,<span class="string">&quot;pea&quot;</span>,<span class="string">&quot;eat&quot;</span>,<span class="string">&quot;rain&quot;</span>] and board =</span><br><span class="line">[</span><br><span class="line">  [<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;n&#x27;</span>],</span><br><span class="line">  [<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;t&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;e&#x27;</span>],</span><br><span class="line">  [<span class="string">&#x27;i&#x27;</span>,<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;k&#x27;</span>,<span class="string">&#x27;r&#x27;</span>],</span><br><span class="line">  [<span class="string">&#x27;i&#x27;</span>,<span class="string">&#x27;f&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;v&#x27;</span>]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">输出: [<span class="string">&quot;eat&quot;</span>,<span class="string">&quot;oath&quot;</span>]</span><br><span class="line">说明:</span><br><span class="line">你可以假设所有输入都由小写字母 a-z 组成。</span><br></pre></td></tr></table></figure><p>提示:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">你需要优化回溯算法以通过更大数据量的测试。你能否早点停止回溯？</span><br><span class="line">如果当前单词不存在于所有单词的前缀中，则可以立即停止回溯。什么样的数据结构可以有效地执行这样的操作？散列表是否可行？为什么？ 前缀树如何？如果你想学习如何实现一个基本的前缀树，请先查看这个问题： 实现Trie（前缀树）。</span><br></pre></td></tr></table></figure><p><strong>解题思路</strong></p><p><a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/solution/shi-xian-trie-qian-zhui-shu-by-leetcode/">参考力扣官网分析：实现 Trie (前缀树)</a></p><ul><li><p>判断是否找到了，通过传递节点的END来判断</p></li><li><p>判断是否重复访问，通过动态更改走过的网格点来判断，就不需要再定义一个<code>vis</code>数组了</p></li></ul><p><a href="https://leetcode-cn.com/problems/word-search-ii/solution/212-dan-ci-sou-suo-ii-by-alexer-660/">参考大佬：秦时明月字典树建树解法（二）</a></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> findWords = <span class="function"><span class="keyword">function</span>(<span class="params">grid, words</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 存放最终结果集</span></span><br><span class="line">  <span class="keyword">let</span> res = []</span><br><span class="line">  <span class="comment">// 字典树节点</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.end = <span class="literal">false</span></span><br><span class="line">      <span class="built_in">this</span>.child = &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 最终形成的字典树根节点</span></span><br><span class="line">  <span class="keyword">let</span> root = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">let</span> Trie = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    root = <span class="keyword">new</span> TrieNode()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 建立字典树</span></span><br><span class="line">  Trie.prototype.insert = <span class="function">(<span class="params">word</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> cur = root</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;word.length;i++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(!cur.child[word[i]])&#123;</span><br><span class="line">        cur.child[word[i]] = <span class="keyword">new</span> TrieNode()</span><br><span class="line">      &#125;</span><br><span class="line">      cur = cur.child[word[i]]</span><br><span class="line">    &#125;</span><br><span class="line">    cur.end = <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 创建根节点</span></span><br><span class="line">  <span class="keyword">let</span> trie = <span class="keyword">new</span> Trie()</span><br><span class="line">  <span class="comment">// 进行建树操作</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;words.length;i++)&#123;</span><br><span class="line">    trie.insert(words[i])</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> dfs = <span class="function">(<span class="params">x,y,t,cur</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(cur.end)&#123;</span><br><span class="line">      res.push(t)</span><br><span class="line">      cur.end = <span class="literal">false</span> <span class="comment">// 避免重复计算</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 剪枝条件：1.边界处理 2.下一步是否可走 3.下一步字典树是否可走</span></span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">0</span> || x&gt;=grid.length || y&lt;<span class="number">0</span> || y&gt;=grid[<span class="number">0</span>].length || grid[x][y] == <span class="string">&#x27;#&#x27;</span> || !cur.child[grid[x][y]]) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">let</span> tmp = grid[x][y]</span><br><span class="line">    grid[x][y] = <span class="string">&#x27;#&#x27;</span>  <span class="comment">// 走</span></span><br><span class="line">    cur = cur.child[tmp]</span><br><span class="line">    dfs(x+<span class="number">1</span>,y,t+tmp,cur)  <span class="comment">// 上下左右四个方向遍历</span></span><br><span class="line">    dfs(x,y+<span class="number">1</span>,t+tmp,cur)</span><br><span class="line">    dfs(x-<span class="number">1</span>,y,t+tmp,cur)</span><br><span class="line">    dfs(x,y-<span class="number">1</span>,t+tmp,cur)</span><br><span class="line">    grid[x][y] = tmp <span class="comment">// 回溯（还原）</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 对单词表进行全局搜索</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;grid.length;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">0</span>;j&lt;grid[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">      dfs(i,j,<span class="string">&#x27;&#x27;</span>,root)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>附上完整字典树（前缀树）模板，日后可用~</p><p><strong>在 Trie 树中查找键</strong></p><p>每个键在 <code>trie</code> 中表示为从根到内部节点或叶的路径。我们用第一个键字符从根开始，。检查当前节点中与键字符对应的链接。有两种情况：</p><ul><li>存在链接。我们移动到该链接后面路径中的下一个节点，并继续搜索下一个键字符。</li><li>不存在链接。若已无键字符，且当前结点标记为 <code>isEnd</code>，则返回 <code>true</code>。否则有两种可能，均返回 <code>false</code>:<br>还有键字符剩余，但无法跟随 <code>Trie</code> 树的键路径，找不到键。<br>没有键字符剩余，但当前结点没有标记为 <code>isEnd</code>。也就是说，待查找键只是<code>Trie</code>树中另一个键的前缀。</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/431ea3d098804eab88e4cc677c956330~tplv-k3u1fbpfcp-zoom-1.image" alt=""><br><strong>查找 Trie 树中的键前缀</strong></p><p>该方法与在 <code>Trie</code> 树中搜索键时使用的方法非常相似。我们从根遍历 <code>Trie</code> 树，直到键前缀中没有字符，或者无法用当前的键字符继续 <code>Trie</code> 中的路径。与上面提到的“搜索键”算法唯一的区别是，到达键前缀的末尾时，总是返回 <code>true</code>。我们不需要考虑当前 <code>Trie</code> 节点是否用 <code>“isend”</code> 标记，因为我们搜索的是键的前缀，而不是整个键。</p><p><img src= "/img/loading.gif" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/20c06dfbfe20496c9ff5747ca8cda21b~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> findWords = <span class="function"><span class="keyword">function</span>(<span class="params">grid, words</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 存放最终结果集</span></span><br><span class="line">  <span class="keyword">let</span> res = []</span><br><span class="line">  <span class="comment">// 字典树节点</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.end = <span class="literal">false</span></span><br><span class="line">      <span class="built_in">this</span>.child = &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 最终形成的字典树根节点</span></span><br><span class="line">  <span class="keyword">let</span> root = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">let</span> Trie = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    root = <span class="keyword">new</span> TrieNode()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 建立字典树</span></span><br><span class="line">  Trie.prototype.insert = <span class="function">(<span class="params">word</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> cur = root</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;word.length;i++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(!cur.child[word[i]])&#123;</span><br><span class="line">        cur.child[word[i]] = <span class="keyword">new</span> TrieNode()</span><br><span class="line">      &#125;</span><br><span class="line">      cur = cur.child[word[i]]</span><br><span class="line">    &#125;</span><br><span class="line">    cur.end = <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 在 Trie 树中查找键</span></span><br><span class="line">  <span class="keyword">let</span> searchPrefix = <span class="function">(<span class="params">word</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> cur = root</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;word.length;i++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(cur.child[word[i]])&#123;</span><br><span class="line">        cur = cur.child[word[i]]</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur</span><br><span class="line">  &#125;</span><br><span class="line">  Trie.prototype.search = <span class="function">(<span class="params">word</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> cur = searchPrefix(word)</span><br><span class="line">    <span class="keyword">return</span> cur !== <span class="literal">null</span> &amp;&amp; cur.end</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 查找 Trie 树中的键前缀</span></span><br><span class="line">  Trie.prototype.startsWith = <span class="function">(<span class="params">pre</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> searchPrefix(pre) != <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 创建根节点</span></span><br><span class="line">  <span class="keyword">let</span> trie = <span class="keyword">new</span> Trie()</span><br><span class="line">  <span class="comment">// 进行建树操作</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;words.length;i++)&#123;</span><br><span class="line">    trie.insert(words[i])</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> dfs = <span class="function">(<span class="params">x,y,t,cur</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(cur.end)&#123;</span><br><span class="line">      res.push(t)</span><br><span class="line">      cur.end = <span class="literal">false</span> <span class="comment">// 避免重复计算</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 剪枝条件：1.边界处理 2.下一步是否可走 3.下一步字典树是否可走</span></span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">0</span> || x&gt;=grid.length || y&lt;<span class="number">0</span> || y&gt;=grid[<span class="number">0</span>].length || grid[x][y] == <span class="string">&#x27;#&#x27;</span> || !cur.child[grid[x][y]]) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">let</span> tmp = grid[x][y]</span><br><span class="line">    grid[x][y] = <span class="string">&#x27;#&#x27;</span>  <span class="comment">// 走</span></span><br><span class="line">    cur = cur.child[tmp]</span><br><span class="line">    dfs(x+<span class="number">1</span>,y,t+tmp,cur)  <span class="comment">// 上下左右四个方向遍历</span></span><br><span class="line">    dfs(x,y+<span class="number">1</span>,t+tmp,cur)</span><br><span class="line">    dfs(x-<span class="number">1</span>,y,t+tmp,cur)</span><br><span class="line">    dfs(x,y-<span class="number">1</span>,t+tmp,cur)</span><br><span class="line">    grid[x][y] = tmp <span class="comment">// 回溯（还原）</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 对单词表进行全局搜索</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;grid.length;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">0</span>;j&lt;grid[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">      dfs(i,j,<span class="string">&#x27;&#x27;</span>,root)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="77-组合"><a href="#77-组合" class="headerlink" title="77. 组合"></a>77. 组合</h3><p><a href="https://leetcode-cn.com/problems/combinations">77. 组合原题传送门</a></p><p><strong>题目描述</strong></p><p>给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合。</p><p>示例:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">输入: n = <span class="number">4</span>, k = <span class="number">2</span></span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">2</span>,<span class="number">4</span>],</span><br><span class="line">  [<span class="number">3</span>,<span class="number">4</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">4</span>],</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>解题思路</strong></p><p>直接套用组合题解题模板即可</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> combine = <span class="function"><span class="keyword">function</span> (<span class="params">n, k</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res = [];</span><br><span class="line">  <span class="keyword">let</span> dfs = <span class="function">(<span class="params">t, start</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (t.length === k) &#123;</span><br><span class="line">      res.push(t);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = start; i &lt;= n; i++) &#123;</span><br><span class="line">      t.push(i);</span><br><span class="line">      dfs(t.slice(), i + <span class="number">1</span>);</span><br><span class="line">      t.pop();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  dfs([], <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39. 组合总和"></a>39. 组合总和</h3><p><a href="https://leetcode-cn.com/problems/combination-sum">39. 组合总和原题传送门</a></p><p><strong>题目描述</strong></p><p>给定一个无重复元素的数组 <code>candidates</code> 和一个目标数 <code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为 <code>target</code> 的组合。</p><p><code>candidates</code> 中的数字可以无限制重复被选取。</p><p>说明：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">所有数字（包括 target）都是正整数。</span><br><span class="line">解集不能包含重复的组合。 </span><br></pre></td></tr></table></figure><p>示例 1：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">输入：candidates = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>], target = <span class="number">7</span>,</span><br><span class="line">所求解集为：</span><br><span class="line">[</span><br><span class="line">  [<span class="number">7</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">输入：candidates = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>], target = <span class="number">8</span>,</span><br><span class="line">所求解集为：</span><br><span class="line">[</span><br><span class="line">  [<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">3</span>,<span class="number">5</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>提示：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> &lt;= candidates.length &lt;= <span class="number">30</span></span><br><span class="line"><span class="number">1</span> &lt;= candidates[i] &lt;= <span class="number">200</span></span><br><span class="line">candidate 中的每个元素都是独一无二的。</span><br><span class="line"><span class="number">1</span> &lt;= target &lt;= <span class="number">500</span></span><br></pre></td></tr></table></figure><p><strong>解题思路</strong></p><p>这道题是组合题，但是这道题有意思的是当前元素可以重复无限制选取，那么我们可以改一下另外一道组合题的思路，下一层也从 <code>i</code>开始即可，然后本题元素重复，那么我们不需要进行排序然后剪枝了。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当前元素可以无限制选取，下一层也从i开始取</span></span><br><span class="line">dfs(t.slice(),i,sum+candidates[i]); </span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c0152ab0b1b6434d9a0093723ef91fa9~tplv-k3u1fbpfcp-zoom-1.image" alt=""><br><a href="https://leetcode-cn.com/problems/combination-sum/solution/shou-hua-tu-jie-zu-he-zong-he-combination-sum-by-x/">参考xiao_ben_zhu图解</a></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> combinationSum = <span class="function"><span class="keyword">function</span>(<span class="params">candidates, target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res = [];</span><br><span class="line">  <span class="keyword">let</span> dfs = <span class="function">(<span class="params">t,start,sum</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(sum &gt;= target)&#123; <span class="comment">// 防止爆掉</span></span><br><span class="line">      <span class="keyword">if</span>(sum === target)&#123;</span><br><span class="line">        res.push(t);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=start;i&lt;candidates.length;i++)&#123;</span><br><span class="line">      t.push(candidates[i]);</span><br><span class="line">      <span class="comment">// 当前元素可以无限制选取，下一层也从i开始取</span></span><br><span class="line">      dfs(t.slice(),i,sum+candidates[i]); </span><br><span class="line">      t.pop();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  dfs([],<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="40-组合总和-II"><a href="#40-组合总和-II" class="headerlink" title="40. 组合总和 II"></a>40. 组合总和 II</h3><p><a href="https://leetcode-cn.com/problems/combination-sum-ii">40. 组合总和 II原题传送门</a></p><p><strong>题目描述</strong></p><p>给定一个数组 <code>candidates</code>和一个目标数 target ，找出<code>candidates</code> 中所有可以使数字和为<code>target</code>的组合。</p><p><code>candidates</code>中的每个数字在每个组合中只能使用一次。</p><p>说明：</p><p>所有数字（包括目标数）都是正整数。<br>解集不能包含重复的组合。<br>示例 1:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">输入: candidates = [<span class="number">10</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">5</span>], target = <span class="number">8</span>,</span><br><span class="line">所求解集为:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">1</span>, <span class="number">7</span>],</span><br><span class="line">  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>],</span><br><span class="line">  [<span class="number">2</span>, <span class="number">6</span>],</span><br><span class="line">  [<span class="number">1</span>, <span class="number">1</span>, <span class="number">6</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">输入: candidates = [<span class="number">2</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>], target = <span class="number">5</span>,</span><br><span class="line">所求解集为:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">5</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>解题思路</strong></p><p>这道题也是一道组合题，但是这道题数组里面是存在重复元素的，组合题的话，为了更好地去重，我们可以先对数组进行排序，然后对于每一层如果相邻元素相同，就剪掉该分支即可。<br><img src= "/img/loading.gif" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/adfe07f096ee4ea1b8bdd1033a5773e0~tplv-k3u1fbpfcp-zoom-1.image" alt=""><br><a href="https://leetcode-cn.com/problems/combination-sum-ii/solution/man-tan-wo-li-jie-de-hui-su-chang-wen-shou-hua-tu-/">参考xiao_ben_zhu大佬图解</a></p><p>注意求和那里，如果只判断是否相等的话，可能会出现爆掉情况。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> combinationSum2 = <span class="function"><span class="keyword">function</span> (<span class="params">candidates, target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res = [];</span><br><span class="line">  candidates.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">  <span class="keyword">let</span> dfs = <span class="function">(<span class="params">t, start, sum</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (sum &gt;= target) &#123; <span class="comment">// 加这外层，超出范围了也终止，防爆栈</span></span><br><span class="line">      <span class="keyword">if</span> (sum === target) &#123;</span><br><span class="line">        res.push(t);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 组合</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = start; i &lt; candidates.length; i++) &#123;</span><br><span class="line">      <span class="comment">// 组合元素不能重复，去掉同一层重复的元素</span></span><br><span class="line">      <span class="keyword">if</span> (i &gt; start &amp;&amp; candidates[i] == candidates[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">      t.push(candidates[i]);</span><br><span class="line">      <span class="comment">// 组合元素去重，即当前选择和下一层的不能重复</span></span><br><span class="line">      dfs(t.slice(), i + <span class="number">1</span>, sum + candidates[i]);</span><br><span class="line">      t.pop();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  dfs([], <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="216-组合总和-III"><a href="#216-组合总和-III" class="headerlink" title="216. 组合总和 III"></a>216. 组合总和 III</h3><p><a href="https://leetcode-cn.com/problems/combination-sum-iii">216. 组合总和 III原题传送门</a></p><p><strong>题目描述</strong></p><p>找出所有相加之和为 <code>n</code> 的 <code>k</code> 个数的组合。组合中只允许含有 <code>1 - 9</code> 的正整数，并且每种组合中不存在重复的数字。</p><p>说明：</p><p>所有数字都是正整数。<br>解集不能包含重复的组合。<br>示例 1:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">输入: k = <span class="number">3</span>, n = <span class="number">7</span></span><br><span class="line">输出: [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>]]</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">输入: k = <span class="number">3</span>, n = <span class="number">9</span></span><br><span class="line">输出: [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">6</span>], [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>], [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]]</span><br></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><p><strong>解题思路</strong></p><p>首先，还是搬运一下大佬的图解，然后我再来解释一番。<br><img src= "/img/loading.gif" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/59118b9f68544174af1f019354145779~tplv-k3u1fbpfcp-zoom-1.image" alt=""><br><a href="https://leetcode-cn.com/problems/combination-sum-iii/solution/shou-hua-tu-jie-216-zu-he-zong-he-iii-by-xiao_ben_/">参考xiao_ben_zhu大佬图解</a></p><p>本题需要一层一层来，第一层我们可以有 <code>i</code>(1-9)个选择，而第二层的每一个值只有 <code>i+1</code>个选择了，因为不能重复。比如你第一次拿了 <code>2</code>，在下一次，你只能从 <code>3</code>开始拿了，如果还是 <code>1</code>的话就会有重复的组合了。这样我们也不用维护 <code>vis</code>数组来去重，因为每一层取的值是不一样的。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> combinationSum3 = <span class="function"><span class="keyword">function</span> (<span class="params">k, n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res = [];</span><br><span class="line">  <span class="keyword">let</span> dfs = <span class="function">(<span class="params">t, start, sum</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (t.length === k &amp;&amp; sum === n) &#123;</span><br><span class="line">      res.push(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = start; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">      t.push(i);</span><br><span class="line">      dfs(t.slice(), i + <span class="number">1</span>, sum + i);</span><br><span class="line">      t.pop();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  dfs([], <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="401-二进制手表"><a href="#401-二进制手表" class="headerlink" title="401. 二进制手表"></a>401. 二进制手表</h3><p><a href="https://leetcode-cn.com/problems/binary-watch">401. 二进制手表原题传送门</a></p><p><strong>题目描述</strong></p><p>二进制手表顶部有 4 个 LED 代表 <strong>小时（0-11）</strong>，底部的 6 个 LED 代表 <strong>分钟（0-59）</strong>。</p><p>每个 LED 代表一个 0 或 1，最低位在右侧。</p><p><img src= "/img/loading.gif" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/10703e3641de4430be4ed602da9e71c8~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>例如，上面的二进制手表读取 “3:25”。</p><p>给定一个非负整数 n 代表当前 LED 亮着的数量，返回所有可能的时间。</p><p>示例：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">输入: n = <span class="number">1</span></span><br><span class="line">返回: [<span class="string">&quot;1:00&quot;</span>, <span class="string">&quot;2:00&quot;</span>, <span class="string">&quot;4:00&quot;</span>, <span class="string">&quot;8:00&quot;</span>, <span class="string">&quot;0:01&quot;</span>, <span class="string">&quot;0:02&quot;</span>, <span class="string">&quot;0:04&quot;</span>, <span class="string">&quot;0:08&quot;</span>, <span class="string">&quot;0:16&quot;</span>, <span class="string">&quot;0:32&quot;</span>]</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>提示：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">输出的顺序没有要求。</span><br><span class="line">小时不会以零开头，比如 “<span class="number">01</span>:<span class="number">00</span>” 是不允许的，应为 “<span class="number">1</span>:<span class="number">00</span>”。</span><br><span class="line">分钟必须由两位数组成，可能会以零开头，比如 “<span class="number">10</span>:<span class="number">2</span>” 是无效的，应为 “<span class="number">10</span>:<span class="number">02</span>”。</span><br><span class="line">超过表示范围（小时 <span class="number">0</span>-<span class="number">11</span>，分钟 <span class="number">0</span>-<span class="number">59</span>）的数据将会被舍弃，也就是说不会出现 <span class="string">&quot;13:00&quot;</span>, <span class="string">&quot;0:61&quot;</span> 等时间。</span><br></pre></td></tr></table></figure><p><strong>解题思路</strong></p><p>回溯算法，我的解法类似于全排列做法，将10个小灯泡进行排列组合，然后根据 <code>0</code> 和 <code>1</code> 来判断灯泡是否亮，如果亮了，加上对应二进制，然后将 <code>0-3</code>分给小时来计算，将 <code>4-9</code>分给分钟来计算，但是要考虑一下，就是可能会出现重复情况，于是用 <code>Set</code>数据结构维护一下就好了。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> readBinaryWatch = <span class="function"><span class="keyword">function</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">    <span class="keyword">let</span> vis = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10</span>).fill(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">let</span> check = <span class="function">(<span class="params">hour,minutes</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(hour&gt;=<span class="number">0</span> &amp;&amp; hour&lt;=<span class="number">11</span> &amp;&amp; minutes&gt;=<span class="number">0</span> &amp;&amp; minutes&lt;=<span class="number">59</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> dfs = <span class="function">(<span class="params">t,vis</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(t==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> hour = vis[<span class="number">0</span>]*<span class="number">1</span> + vis[<span class="number">1</span>]*<span class="number">2</span> + vis[<span class="number">2</span>]*<span class="number">4</span> + vis[<span class="number">3</span>]*<span class="number">8</span>;</span><br><span class="line">        <span class="keyword">let</span> minutes = vis[<span class="number">4</span>]*<span class="number">1</span> + vis[<span class="number">5</span>]*<span class="number">2</span> + vis[<span class="number">6</span>]*<span class="number">4</span> + vis[<span class="number">7</span>]*<span class="number">8</span> + vis[<span class="number">8</span>]*<span class="number">16</span> + vis[<span class="number">9</span>]*<span class="number">32</span>;</span><br><span class="line">        <span class="keyword">if</span>(check(hour,minutes))&#123;</span><br><span class="line">          <span class="keyword">let</span> tmp = <span class="string">`<span class="subst">$&#123;hour&#125;</span>:<span class="subst">$&#123;minutes &gt;= <span class="number">10</span>? minutes: <span class="string">&#x27;0&#x27;</span>+minutes&#125;</span>`</span>;</span><br><span class="line">          res.add(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[i]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[i] = <span class="number">1</span>;</span><br><span class="line">        dfs(t-<span class="number">1</span>,vis);</span><br><span class="line">        vis[i] = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(num,vis);</span><br><span class="line">    <span class="keyword">return</span> [...res];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>补充，后面看到有大佬这样做，进行了去重操作，关键点在回溯 <code>for</code>循环那里。其实这个相当于全排列了。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> readBinaryWatch = <span class="function"><span class="keyword">function</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">let</span> vis = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10</span>).fill(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">let</span> check = <span class="function">(<span class="params">hour,minutes</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(hour&gt;=<span class="number">0</span> &amp;&amp; hour&lt;=<span class="number">11</span> &amp;&amp; minutes&gt;=<span class="number">0</span> &amp;&amp; minutes&lt;=<span class="number">59</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> dfs = <span class="function">(<span class="params">t,cnt,vis</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(t==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> hour = vis[<span class="number">0</span>]*<span class="number">1</span> + vis[<span class="number">1</span>]*<span class="number">2</span> + vis[<span class="number">2</span>]*<span class="number">4</span> + vis[<span class="number">3</span>]*<span class="number">8</span>;</span><br><span class="line">        <span class="keyword">let</span> minutes = vis[<span class="number">4</span>]*<span class="number">1</span> + vis[<span class="number">5</span>]*<span class="number">2</span> + vis[<span class="number">6</span>]*<span class="number">4</span> + vis[<span class="number">7</span>]*<span class="number">8</span> + vis[<span class="number">8</span>]*<span class="number">16</span> + vis[<span class="number">9</span>]*<span class="number">32</span>;</span><br><span class="line">        <span class="keyword">if</span>(check(hour,minutes))&#123;</span><br><span class="line">          <span class="keyword">let</span> tmp = <span class="string">`<span class="subst">$&#123;hour&#125;</span>:<span class="subst">$&#123;minutes &gt;= <span class="number">10</span>? minutes: <span class="string">&#x27;0&#x27;</span>+minutes&#125;</span>`</span>;</span><br><span class="line">          res.push(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> i=cnt;i&lt;=<span class="number">10</span>-t;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[i]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[i] = <span class="number">1</span>;</span><br><span class="line">        dfs(t-<span class="number">1</span>,i+<span class="number">1</span>,vis);</span><br><span class="line">        vis[i] = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(num,<span class="number">0</span>,vis);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="37-解数独"><a href="#37-解数独" class="headerlink" title="37. 解数独"></a>37. 解数独</h3><p><a href="https://leetcode-cn.com/problems/sudoku-solver">37. 解数独原题传送门</a></p><p><strong>题目描述</strong></p><p>编写一个程序，通过填充空格来解决数独问题。</p><p>一个数独的解法需<strong>遵循如下规则</strong>：</p><p>数字 1-9 在每一行只能出现一次。<br>数字 1-9 在每一列只能出现一次。<br>数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。<br>空白格用 <code>&#39;.&#39;</code> 表示。</p><p><img src= "/img/loading.gif" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d1ee26d3924d4add918f366f62adbf3d~tplv-k3u1fbpfcp-zoom-1.image" alt=""><br>一个数独。</p><p><img src= "/img/loading.gif" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/281ebc894dee4897a4e7e959ce2591bb~tplv-k3u1fbpfcp-zoom-1.image" alt=""><br>答案被标成红色。</p><p>提示：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">给定的数独序列只包含数字 <span class="number">1</span>-<span class="number">9</span> 和字符 <span class="string">&#x27;.&#x27;</span> 。</span><br><span class="line">你可以假设给定的数独只有唯一解。</span><br><span class="line">给定数独永远是 9x9 形式的。</span><br></pre></td></tr></table></figure><p><strong>解题思路</strong></p><p>我们一行一行的放，如果能得到一个解，直接返回 <code>true</code>，然后剪枝条件如下述 <code>check</code>函数。<br><img src= "/img/loading.gif" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b1b7d133600947f298d694c72ea8ad8f~tplv-k3u1fbpfcp-zoom-1.image" alt=""><br><a href="https://leetcode-cn.com/problems/sudoku-solver/solution/shou-hua-tu-jie-jie-shu-du-hui-su-suan-fa-sudoku-s/">参考xiao_ben_zhu大佬图解</a></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> solveSudoku = <span class="function"><span class="keyword">function</span> (<span class="params">board</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> check = <span class="function">(<span class="params">x, y, val</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 一行或者一列有重复元素，剪掉</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (board[x][i] == val || board[i][y] == val) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> xx = <span class="built_in">Math</span>.floor(x / <span class="number">3</span>) * <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">let</span> yy = <span class="built_in">Math</span>.floor(y / <span class="number">3</span>) * <span class="number">3</span>;</span><br><span class="line">    <span class="comment">// 3x3宫格内重复的情况，剪掉</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (board[xx + i][yy + j] == val) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 没有冲突情况</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> dfs = <span class="function">(<span class="params">x, y</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (y == <span class="number">9</span>) &#123;</span><br><span class="line">      x++;</span><br><span class="line">      y = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> (x == <span class="number">9</span>) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 都填完了，直接返回 true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (board[x][y] != <span class="string">&#x27;.&#x27;</span>) <span class="keyword">return</span> dfs(x, y + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (check(x, y, <span class="built_in">String</span>(i))) <span class="keyword">continue</span>;</span><br><span class="line">      board[x][y] = <span class="built_in">String</span>(i);</span><br><span class="line">      <span class="keyword">if</span> (dfs(x, y + <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 如果往下走，能够解出数独，直接返回 true</span></span><br><span class="line">      board[x][y] = <span class="string">&#x27;.&#x27;</span>; <span class="comment">// 回溯，因为往下走得不到一个解</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  dfs(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> board;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="51-N-皇后"><a href="#51-N-皇后" class="headerlink" title="51. N 皇后"></a>51. N 皇后</h3><p><a href="https://leetcode-cn.com/problems/n-queens">51. N 皇后原题传送门</a></p><p><strong>题目描述</strong></p><p>n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。<br><img src= "/img/loading.gif" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/99b6f31cf14a4af4b4e69721030d31f7~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>上图为 8 皇后问题的一种解法。</p><p>给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。</p><p>每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。</p><p>示例：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">输入：<span class="number">4</span></span><br><span class="line">输出：[</span><br><span class="line"> [<span class="string">&quot;.Q..&quot;</span>,  <span class="comment">// 解法 1</span></span><br><span class="line">  <span class="string">&quot;...Q&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Q...&quot;</span>,</span><br><span class="line">  <span class="string">&quot;..Q.&quot;</span>],</span><br><span class="line"></span><br><span class="line"> [<span class="string">&quot;..Q.&quot;</span>,  <span class="comment">// 解法 2</span></span><br><span class="line">  <span class="string">&quot;Q...&quot;</span>,</span><br><span class="line">  <span class="string">&quot;...Q&quot;</span>,</span><br><span class="line">  <span class="string">&quot;.Q..&quot;</span>]</span><br><span class="line">]</span><br><span class="line">解释: <span class="number">4</span> 皇后问题存在两个不同的解法。</span><br></pre></td></tr></table></figure><p>提示：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">皇后彼此不能相互攻击，也就是说：任何两个皇后都不能处于同一条横行、纵行或斜线上。</span><br></pre></td></tr></table></figure><p><strong>解题思路</strong></p><p>对于 n 皇后问题，经典的回溯算法，我们采用一行放一个，然后逐行来放，这样我们就不用在剪枝的时候判断是否同行了。只需要判断是否同列 或者 同一斜线就好了。<br><img src= "/img/loading.gif" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fd64956a0dad4675a79d73274255eebf~tplv-k3u1fbpfcp-zoom-1.image" alt=""><br><a href="https://leetcode-cn.com/problems/n-queens/solution/shou-hua-tu-jie-cong-jing-dian-de-nhuang-hou-wen-t/">参考xiao_ben_zhu大佬图解</a></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> solveNQueens = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res = [];</span><br><span class="line">  <span class="keyword">let</span> grid = <span class="keyword">new</span> <span class="built_in">Array</span>(n); <span class="comment">// 初始化一个地图</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">    grid[i] = <span class="keyword">new</span> <span class="built_in">Array</span>(n).fill(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 剪枝条件 </span></span><br><span class="line">  <span class="keyword">let</span> check = <span class="function">(<span class="params">x,y</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;x;i++)&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">        <span class="comment">// 判断同列 或者 同一斜线即可（不需要判断同行是因为一行一行放的，一定不同行）</span></span><br><span class="line">        <span class="keyword">if</span>(grid[i][j] == <span class="string">&#x27;Q&#x27;</span> &amp;&amp; (j == y || i+j == x+y || i-j == x-y) )&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> dfs = <span class="function">(<span class="params">t</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(t === n )&#123;</span><br><span class="line">      <span class="keyword">let</span> ans = grid.slice(); <span class="comment">// 拷贝一份，对输出做处理</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        ans[i] = ans[i].join(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      res.push(ans);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(check(t,i)) <span class="keyword">continue</span>;</span><br><span class="line">      grid[t][i] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">      dfs(t+<span class="number">1</span>);</span><br><span class="line">      grid[t][i] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  dfs(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="131-分割回文串"><a href="#131-分割回文串" class="headerlink" title="131. 分割回文串"></a>131. 分割回文串</h3><p><a href="https://leetcode-cn.com/problems/palindrome-partitioning">131. 分割回文串原题传送门</a></p><p><strong>题目描述</strong></p><p>给定一个字符串 <code>s</code>，将 <code>s</code> 分割成一些子串，使每个子串都是回文串。</p><p>返回 s 所有可能的分割方案。</p><p>示例:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">输入: <span class="string">&quot;aab&quot;</span></span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [<span class="string">&quot;aa&quot;</span>,<span class="string">&quot;b&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;a&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>解题思路</strong></p><p>借鉴 <a href="https://leetcode-cn.com/problems/palindrome-partitioning/solution/chui-su-fa-jian-dan-jie-ti-chao-qing-xi-tu-li-by-z/">zesong-wang-c</a> 大佬的图解<br><img src= "/img/loading.gif" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d00f75bd8aa942c0bccea61185dc284c~tplv-k3u1fbpfcp-zoom-1.image" alt=""><br>本题采用回溯思想，看上图基本已经明白，每次进行一次切割，直到切到最后一个元素，然后压入结果集合里，期间对于每次切割的字符串，我们判断一下是否是回文，如果不是，直接减掉即可。</p><p>和组合的思想有点类似。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断是否是回文</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPal</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> len = <span class="built_in">Math</span>.floor(str.length / <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">if</span> (len === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> add = str.length % <span class="number">2</span> === <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> subStr = str.slice(<span class="number">0</span>, len);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (subStr[len - i - <span class="number">1</span>] !== str[len + add + i]) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> partition = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res = [];</span><br><span class="line">  <span class="keyword">let</span> dfs = <span class="function">(<span class="params">cur, start</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 当前已经到达了最后一个元素</span></span><br><span class="line">    <span class="keyword">if</span> (start &gt;= s.length) &#123;</span><br><span class="line">      res.push(cur.slice());</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = start; i &lt; s.length; i++) &#123;</span><br><span class="line">      <span class="comment">// 字符串切割</span></span><br><span class="line">      <span class="keyword">let</span> str = s.slice(start, i + <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (str &amp;&amp; isPal(str) ) &#123;</span><br><span class="line">        cur.push(str);</span><br><span class="line">        dfs(cur, i + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 回溯</span></span><br><span class="line">        cur.pop();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  dfs([], <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="93-复原IP地址"><a href="#93-复原IP地址" class="headerlink" title="93. 复原IP地址"></a>93. 复原IP地址</h3><p><a href="https://leetcode-cn.com/problems/restore-ip-addresses">93. 复原IP地址原题传送门</a></p><p><strong>题目描述</strong></p><p>给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。</p><p>有效的 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 ‘.’ 分隔。</p><p>例如：<code>&quot;0.1.2.201&quot; 和 &quot;192.168.1.1&quot;</code> 是 有效的 IP 地址，但是 <code>&quot;0.011.255.245&quot;、&quot;192.168.1.312&quot; 和 &quot;192.168@1.1&quot;</code> 是 无效的 IP 地址。</p><p>示例 1：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;25525511135&quot;</span></span><br><span class="line">输出：[<span class="string">&quot;255.255.11.135&quot;</span>,<span class="string">&quot;255.255.111.35&quot;</span>]</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;0000&quot;</span></span><br><span class="line">输出：[<span class="string">&quot;0.0.0.0&quot;</span>]</span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;1111&quot;</span></span><br><span class="line">输出：[<span class="string">&quot;1.1.1.1&quot;</span>]</span><br></pre></td></tr></table></figure><p>示例 4：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;010010&quot;</span></span><br><span class="line">输出：[<span class="string">&quot;0.10.0.10&quot;</span>,<span class="string">&quot;0.100.1.0&quot;</span>]</span><br></pre></td></tr></table></figure><p>示例 5：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;101023&quot;</span></span><br><span class="line">输出：[<span class="string">&quot;1.0.10.23&quot;</span>,<span class="string">&quot;1.0.102.3&quot;</span>,<span class="string">&quot;10.1.0.23&quot;</span>,<span class="string">&quot;10.10.2.3&quot;</span>,<span class="string">&quot;101.0.2.3&quot;</span>]</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>提示：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> &lt;= s.length &lt;= <span class="number">3000</span></span><br><span class="line">s 仅由数字组成</span><br></pre></td></tr></table></figure><p><strong>解题思路</strong></p><p>直接看图解，显然要用回溯来做，我的做法是对于当前位置，我们可以有三种选择，选一个，选两个，还有选三个。此时就需要判断一下是不是会出现选出边界的情况。</p><p>然后对于我们选择的数字，要判断是否出现前导 0 ，同时也要看一下如果是三位数字的话，是不是会超过 255 。题目不能重复选择，于是用组合思想，免去 <code>vis</code> 数组。<br><img src= "/img/loading.gif" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/15606c9f37ed4a7e8c628356b14b4a58~tplv-k3u1fbpfcp-zoom-1.image" alt=""><br>借助大佬 <a href="https://leetcode-cn.com/problems/restore-ip-addresses/solution/shou-hua-tu-jie-huan-yuan-dfs-hui-su-de-xi-jie-by-/">xiao_ben_zhu</a> 图解</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> restoreIpAddresses = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res = [];</span><br><span class="line">  <span class="keyword">let</span> dfs = <span class="function">(<span class="params">cur, start</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (cur.length == <span class="number">4</span> &amp;&amp; start&gt;=s.length) &#123;</span><br><span class="line">      res.push(cur.join(<span class="string">&#x27;.&#x27;</span>));</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cur.length == <span class="number">4</span> &amp;&amp; start != s.length) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> k=<span class="number">1</span>;k&lt;=<span class="number">3</span>;k++)&#123;</span><br><span class="line">      <span class="comment">// 如果取的范围超过了字符串长度，直接剪掉</span></span><br><span class="line">      <span class="keyword">if</span>(start+k-<span class="number">1</span>&gt;=s.length) <span class="keyword">return</span>;</span><br><span class="line">      <span class="comment">// 切割字符串</span></span><br><span class="line">      <span class="keyword">let</span> str = s.substring(start,start+k);</span><br><span class="line">      <span class="keyword">if</span>(str.length&gt;=<span class="number">2</span> &amp;&amp; str[<span class="number">0</span>] == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">      <span class="keyword">if</span>(str.length&gt;=<span class="number">3</span> &amp;&amp; +str &gt; <span class="number">255</span>) <span class="keyword">return</span>;</span><br><span class="line">      cur.push(str);</span><br><span class="line">      dfs(cur.slice(),start+k);</span><br><span class="line">      <span class="comment">// 回溯</span></span><br><span class="line">      cur.pop();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  dfs([], <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22. 括号生成"></a>22. 括号生成</h3><p><a href="https://leetcode-cn.com/problems/generate-parentheses">22. 括号生成原题传送门</a></p><p><strong>题目描述</strong></p><p>数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。</p><p>示例：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">输入：n = <span class="number">3</span></span><br><span class="line">输出：[</span><br><span class="line">       <span class="string">&quot;((()))&quot;</span>,</span><br><span class="line">       <span class="string">&quot;(()())&quot;</span>,</span><br><span class="line">       <span class="string">&quot;(())()&quot;</span>,</span><br><span class="line">       <span class="string">&quot;()(())&quot;</span>,</span><br><span class="line">       <span class="string">&quot;()()()&quot;</span></span><br><span class="line">     ]</span><br></pre></td></tr></table></figure><p><strong>解题思路</strong></p><p>这道题，看了大佬的题解，发现真是有意思，现在来解释一下。</p><p>我们可以直接走可行的情况，对于不可行的情况，自然就剪掉了。</p><p>关键在于左右括号如何选择，首先，对于左括号，起初我们必然是要选的，然后我们也可以全部选完，因此，只要有左括号我们必须选，而对于右括号而言，它的剩余数量必须大于剩余左括号数量，我们才能选右括号。</p><p>举个反例，假如我们现在已经有了 <code>(())</code>，<code>n = 3</code>，然后左右括号都还剩一个，如果理解选 <code>)</code>，岂不是就 <code>(()))</code>了，显示不是有效的括号，应该被剪掉才是，因此，我们必须严格右括号剩余数量必须大于剩余左括号数量，我们才能选右括号。<br><img src= "/img/loading.gif" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8c21508b81d54bd99c5fac09b8e0e089~tplv-k3u1fbpfcp-zoom-1.image" alt=""><br>参考 <a href="https://leetcode-cn.com/problems/generate-parentheses/solution/shou-hua-tu-jie-gua-hao-sheng-cheng-hui-su-suan-fa/">笨猪爆破组</a> 大佬图解</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> generateParenthesis = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res = [];</span><br><span class="line">  <span class="keyword">let</span> dfs = <span class="function">(<span class="params">cur, left, right</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (cur.length === <span class="number">2</span> * n) &#123;</span><br><span class="line">      res.push(cur);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 左括号还存在，就可以选左括号</span></span><br><span class="line">    <span class="keyword">if</span> (left &gt; <span class="number">0</span>) dfs(cur + <span class="string">&#x27;(&#x27;</span>, left - <span class="number">1</span>, right);</span><br><span class="line">    <span class="comment">// 右括号数量要大于左括号，才可以选右括号</span></span><br><span class="line">    <span class="keyword">if</span> (right &gt; left) dfs(cur + <span class="string">&#x27;)&#x27;</span>, left, right - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  dfs(<span class="string">&#x27;&#x27;</span>, n, n);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="本文参考"><a href="#本文参考" class="headerlink" title="本文参考"></a>本文参考</h2><ul><li><a href="https://juejin.cn/post/6844903919722692621">前端该如何准备数据结构和算法？</a></li><li><a href="https://juejin.cn/post/6847009772500156429">写给前端的算法进阶指南，我是如何两个月零基础刷200题</a></li><li><a href="https://juejin.cn/post/6844904061947346957">(1.8w字)负重前行，前端工程师如何系统练习数据结构和算法？【上】</a></li><li>leetcode &amp;&amp; leetcode各位题解大佬们，感谢你们~</li></ul><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>❤️关注+点赞+收藏+评论+转发❤️，原创不易，您的支持将会是我最大的动力~</p><p><a href="https://yangchaoyi.vip/">访问超逸の博客</a>，方便小伙伴阅读玩耍~</p><p>最后，祝各位新年快乐，牛年大吉，好运++，在准备春招の你，能够早点结束春招，offer拿到手软，希望我的文章能够帮助到你，我们很快会在下期相遇~</p><p>【作者：Chocolate】<a href="https://juejin.cn/user/2981531267112520/posts">https://juejin.cn/user/2981531267112520/posts</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>🐮写给零基础的前端算法入门指南，acmer带女友刷80+【栈与队列与链表篇】｜牛气冲天新年征文</title>
      <link href="posts/20210208/"/>
      <url>posts/20210208/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前的文章大部分都是写给女友系列，但有一段时间没有进行更新了，一方面春招要准备开始了，另一方面女友还在准备年前面试，面试之后的复盘总结是挺重要的。</p><blockquote><p>访问 <a href="https://juejin.cn/user/3922690515936312/posts">HearLing的个人主页</a> 会持续分享前端知识体系。</p></blockquote><p>好像越要到过年了，一些写作时间还多了起来，现在和大家分享一下我们是如何准备算法这一块的，正好春招即将开启，年前还能最后准备一下，希望对大家有所帮助。</p><blockquote><p>本文若未经作者授权，禁止转载，如若发现雷同，必将追究责任到底！</p></blockquote><p>原本打算通过一篇文章介绍一下，推荐一下自己的刷题方式和刷题路线，得到一些伙伴的反馈：最好还是更加详细，面向零基础，小白这些，还有<code>github</code>访问速度也是一方面问题，可能图片都加载不出来。</p><p>因此，我打算分模块出几期文章，这样你只用通过首发在掘金的文章即可了解 <code>Chocolate</code> 同学整体刷题汇总啦。马上就要过年了，希望能够帮助你的春招。打算出的内容计划安排如下：</p><ul><li>🐮写给零基础的前端算法入门指南，acmer带女友刷80+【栈与队列与链表篇】（本期已完成🎉）</li><li>🐮写给零基础的前端算法入门指南，acmer带女友刷80+【递归与回溯篇】</li><li>🐮写给零基础的前端算法入门指南，acmer带女友刷80+【双指针与字符串篇】</li><li>🐮写给零基础的前端算法入门指南，acmer带女友刷80+【二叉树篇】</li><li>🐮写给零基础的前端算法入门指南，acmer带女友刷80+【动态规划DP篇】</li><li>🐮写给零基础的前端算法入门指南，acmer带女友刷80+【总结篇】</li></ul><h1 id="算法这一块到底如何准备"><a href="#算法这一块到底如何准备" class="headerlink" title="算法这一块到底如何准备"></a>算法这一块到底如何准备</h1><p>首先，我来简单介绍一下自己，在校打过ACM（如果没听过，当我没说，因为没有很大价值的牌牌，铁牌，参赛证以及证书倒是一堆）</p><p>如果你知道acm，并且参与过，对于国内前端（注意是说前端）面试的话，应该不需要花费很长的刷题时间，如果大家有想法了解我的acm经历的话，这个后续我会考虑在 <a href="https://space.bilibili.com/351534170">B站发布一期视频</a>。</p><p>那么对于零基础的小白来说，可能需要花10-20天左右时间来准备算法，而对于非科班来说这个周期可能会更长一点。那么，现在我准备来分享我是如何带着女友零基础刷题的。</p><ul><li>第一点，明确算法它不是很难的东西，理解了其实就那会事，或许你还会喜欢上做题，当然，对于acm大佬做的题就另当别论了，这篇文章主体与面试水平为准</li><li>第二点，前端对于算法这一块的考察相对来说会偏简单一点，我在春秋招过程中遇到的笔试题都是一些常见的题目，比如搜索，贪心，简单动态规划，经典排序算法，都是以 <code>leetcode</code>一些简单以及中等难度的居多，而这些算法对于科班来说的话，应该在学校都学习过，比如算法分析与设计，数据结构与算法这一类课程，那么有这个基础，你的刷题时间又可以进行缩短了</li><li>第三点，既然说到要刷题，该如何刷，我在掘金参考了几个大佬（文末有参考处），大家都会推荐分专题来刷，在这里，我也是非常推荐的，在这里，我希望的是将刷算法题的数量再减少一点，带你入门，当你刷完这些专题之后，你就有相关思维能力主动去刷题了，而不是很被动的去刷，这样也很方便自己总结归纳~</li><li>其它，可以参考大佬的文章，这里不再赘述…</li></ul><h1 id="一份思维导图，让你的刷题路线更简单"><a href="#一份思维导图，让你的刷题路线更简单" class="headerlink" title="一份思维导图，让你的刷题路线更简单"></a>一份思维导图，让你的刷题路线更简单</h1><p>开门见山地说，首先提供一份思维导图，让知识由繁到简。</p><p><img src= "/img/loading.gif" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/30337832145d4969833ccb6cf4009d7e~tplv-k3u1fbpfcp-watermark.image" alt=""></p><blockquote><p>获取高清PDF，请在微信公众号【小狮子前端】回复【LeetCode】，一起刷题或者交流学习可以加企鹅群【666151691】</p></blockquote><blockquote><p>本仓库刷题路线参考 <a href="https://github.com/sl1673495/leetcode-javascript">ssh</a>  （给大佬点赞）<br>仓库地址：<a href="https://github.com/sl1673495/leetcode-javascript">https://github.com/sl1673495/leetcode-javascript</a></p></blockquote><p>感谢大佬的归纳总结，原本打算在大佬那里打卡学习，后面考虑不太友好，还是自己新建了一个仓库打卡学习。</p><p>其次，本仓库解题代码大部分是自己的代码风格，题量也进行了拓展，将会持续更新下去，何不star收藏一下？</p><h1 id="仓库介绍"><a href="#仓库介绍" class="headerlink" title="仓库介绍"></a>仓库介绍</h1><blockquote><p>仓库地址：<a href="https://github.com/Chocolate1999/leetcode-javascript">https://github.com/Chocolate1999/leetcode-javascript</a></p></blockquote><p>本仓库将全程使用的语言是 <code>JavaScript</code>，是一个纯前端刷题路线，对于前端刷题没有方向的小伙伴简直是福音。解题代码会记录在本仓库的 <code>Issues</code> 中，会按照 <code>label</code>进行分类。比如想查看 「递归与回溯」 分类下的问题，那么选择标签进行筛选即可。</p><p>同时，小伙伴们可以在 <code>Issues</code> 中提交自己的解题代码，🤝 欢迎 <code>Contributing</code> ，可打卡刷题，坚持下来的人最酷！Give a ⭐️ if this project helped you !</p><h1 id="刷题路线"><a href="#刷题路线" class="headerlink" title="刷题路线"></a>刷题路线</h1><p>下面正式开始我们的刷题之路，给本篇文章点个赞，拿出自己心仪的键盘，开始！</p><blockquote><p>以下专题顺序仅个人以及面试高频点来总结的刷题方式，大家可以根据自己的想法来组合。更多题集请参考本仓库哈~</p></blockquote><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p><img src= "/img/loading.gif" data-lazy-src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b6eddcb4e97d457985ce2174022c75c0~tplv-k3u1fbpfcp-watermark.image" alt=""></p><h3 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a>20. 有效的括号</a></h3><p><a href="https://leetcode-cn.com/problems/valid-parentheses/">20. 有效的括号原题传送门</a></p><p><strong>题解</strong></p><p>发现越靠后的左括号，最先匹配，也就是<code>后进先出</code>的思想，于是考虑使用栈这个数据结构。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isValid = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果是奇数，不可能匹配成功，直接返回false</span></span><br><span class="line">  <span class="keyword">if</span>(s.length &amp; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  <span class="keyword">let</span> stack = []</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;s.length;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(s[i] === <span class="string">&#x27;(&#x27;</span> || s[i] === <span class="string">&#x27;&#123;&#x27;</span> || s[i] === <span class="string">&#x27;[&#x27;</span>) stack.push(s[i])</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(s[i] === <span class="string">&#x27;)&#x27;</span> &amp;&amp; stack[stack.length-<span class="number">1</span>] === <span class="string">&#x27;(&#x27;</span>) stack.pop()</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(s[i] === <span class="string">&#x27;&#125;&#x27;</span> &amp;&amp; stack[stack.length-<span class="number">1</span>] === <span class="string">&#x27;&#123;&#x27;</span>) stack.pop()</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(s[i] === <span class="string">&#x27;]&#x27;</span> &amp;&amp; stack[stack.length-<span class="number">1</span>] === <span class="string">&#x27;[&#x27;</span>) stack.pop()</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> !stack.length</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="946-验证栈序列"><a href="#946-验证栈序列" class="headerlink" title="946. 验证栈序列"></a>946. 验证栈序列</h3><p><a href="https://leetcode-cn.com/problems/validate-stack-sequences/">946. 验证栈序列原题传送门</a></p><p> <strong>题目描述</strong></p><p>给定 <code>pushed</code> 和 <code>popped</code> 两个序列，每个序列中的 值都不重复，只有当它们可能是在最初空栈上进行的推入 <code>push</code> 和弹出 <code>pop</code> 操作序列的结果时，返回 <code>true</code>；否则，返回 <code>false</code> 。</p><p>示例 1：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">输入：pushed = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>], popped = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：我们可以按以下顺序执行：</span><br><span class="line">push(<span class="number">1</span>), push(<span class="number">2</span>), push(<span class="number">3</span>), push(<span class="number">4</span>), pop() -&gt; <span class="number">4</span>,</span><br><span class="line">push(<span class="number">5</span>), pop() -&gt; <span class="number">5</span>, pop() -&gt; <span class="number">3</span>, pop() -&gt; <span class="number">2</span>, pop() -&gt; <span class="number">1</span></span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">输入：pushed = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>], popped = [<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：<span class="number">1</span> 不能在 <span class="number">2</span> 之前弹出。</span><br></pre></td></tr></table></figure><p>提示：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> &lt;= pushed.length == popped.length &lt;= <span class="number">1000</span></span><br><span class="line"><span class="number">0</span> &lt;= pushed[i], popped[i] &lt; <span class="number">1000</span></span><br><span class="line">pushed 是 popped 的排列。</span><br></pre></td></tr></table></figure><p><strong>解题思路</strong></p><p>借助一个新栈来存放入栈的元素，然后每次和出栈的元素进行比对，如果匹配成功，双方进行出栈操作，最后，如果这个新栈为空，那么代表这个栈入栈和出栈序列是合理的，返回 <code>true</code>，否则返回<code>false</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">pushed</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">popped</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> validateStackSequences = <span class="function"><span class="keyword">function</span>(<span class="params">pushed, popped</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 借助一个新的栈</span></span><br><span class="line">    <span class="keyword">let</span> stack = []</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> cur <span class="keyword">of</span> pushed)&#123;</span><br><span class="line">        <span class="comment">// 存放入栈的元素</span></span><br><span class="line">        stack.push(cur)</span><br><span class="line">        <span class="comment">// 和出栈元素进行比对，如果匹配都弹出栈</span></span><br><span class="line">        <span class="keyword">while</span>(stack[stack.length-<span class="number">1</span>] === popped[<span class="number">0</span>] &amp;&amp; stack.length)&#123;</span><br><span class="line">            stack.pop()</span><br><span class="line">            popped.shift()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> !stack.length</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="921-使括号有效的最少添加"><a href="#921-使括号有效的最少添加" class="headerlink" title="921. 使括号有效的最少添加"></a>921. 使括号有效的最少添加</h3><p><a href="https://leetcode-cn.com/problems/minimum-add-to-make-parentheses-valid/">921. 使括号有效的最少添加原题传送门</a></p><p><strong>题目描述</strong></p><p>给定一个由<code>&#39;(&#39;</code> 和<code>&#39;)&#39;</code> 括号组成的字符串 <code>S</code>，我们需要添加最少的括号<code>（ &#39;(&#39; 或是 &#39;)&#39;</code>，可以在任何位置），以使得到的括号字符串有效。</p><p>从形式上讲，只有满足下面几点之一，括号字符串才是有效的：</p><p>它是一个空字符串，或者<br>它可以被写成 <code>AB</code> （A 与 B 连接）, 其中 A 和 B 都是有效字符串，或者<br>它可以被写作 <code>(A)</code>，其中 A 是有效字符串。<br>给定一个括号字符串，返回为使结果字符串有效而必须添加的最少括号数。</p><p>示例 1：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">输入：<span class="string">&quot;())&quot;</span></span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">输入：<span class="string">&quot;(((&quot;</span></span><br><span class="line">输出：<span class="number">3</span></span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">输入：<span class="string">&quot;()&quot;</span></span><br><span class="line">输出：<span class="number">0</span></span><br></pre></td></tr></table></figure><p>示例 4：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">输入：<span class="string">&quot;()))((&quot;</span></span><br><span class="line">输出：<span class="number">4</span></span><br></pre></td></tr></table></figure><p>提示：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">S.length &lt;= <span class="number">1000</span></span><br><span class="line">S 只包含 <span class="string">&#x27;(&#x27;</span> 和 <span class="string">&#x27;)&#x27;</span> 字符。</span><br></pre></td></tr></table></figure><p><strong>解题思路</strong></p><p>借助一个新栈，然后遍历当前字符串，如果当前栈顶元素和目前字符括号匹配，则弹出栈顶元素，否则进行入栈操作，最后需要的括号数即为栈剩余的元素个数</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">S</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> minAddToMakeValid = <span class="function"><span class="keyword">function</span>(<span class="params">S</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 长度为0，无须添加</span></span><br><span class="line">    <span class="keyword">if</span>(!S.length) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> stack = []</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;S.length;i++)&#123;</span><br><span class="line">        <span class="keyword">let</span> ch = S[i]</span><br><span class="line">        <span class="comment">// 如果当前栈顶元素和目前字符括号匹配，则弹出栈顶元素</span></span><br><span class="line">        <span class="keyword">if</span>(ch === <span class="string">&#x27;)&#x27;</span> &amp;&amp; stack[stack.length-<span class="number">1</span>] === <span class="string">&#x27;(&#x27;</span>) stack.pop()</span><br><span class="line">        <span class="keyword">else</span> stack.push(ch)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 栈的剩余元素个数，即需要的括号数</span></span><br><span class="line">    <span class="keyword">return</span> stack.length</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="901-股票价格跨度"><a href="#901-股票价格跨度" class="headerlink" title="901. 股票价格跨度"></a>901. 股票价格跨度</h3><p><a href="https://leetcode-cn.com/problems/online-stock-span/">901. 股票价格跨度原题传送门</a></p><p> <strong>题目描述</strong></p><p>编写一个 <code>StockSpanner</code> 类，它收集某些股票的每日报价，并返回该股票当日价格的跨度。</p><p>今天股票价格的跨度被定义为股票价格小于或等于今天价格的最大连续日数（从今天开始往回数，包括今天）。</p><p>例如，如果未来7天股票的价格是<code>[100, 80, 60, 70, 60, 75, 85]</code>，那么股票跨度将是<code>[1, 1, 1, 2, 1, 4, 6]</code>。</p><p>示例：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">输入：[<span class="string">&quot;StockSpanner&quot;</span>,<span class="string">&quot;next&quot;</span>,<span class="string">&quot;next&quot;</span>,<span class="string">&quot;next&quot;</span>,<span class="string">&quot;next&quot;</span>,<span class="string">&quot;next&quot;</span>,<span class="string">&quot;next&quot;</span>,<span class="string">&quot;next&quot;</span>], [[],[<span class="number">100</span>],[<span class="number">80</span>],[<span class="number">60</span>],[<span class="number">70</span>],[<span class="number">60</span>],[<span class="number">75</span>],[<span class="number">85</span>]]</span><br><span class="line">输出：[<span class="literal">null</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>]</span><br><span class="line">解释：</span><br><span class="line">首先，初始化 S = StockSpanner()，然后：</span><br><span class="line">S.next(<span class="number">100</span>) 被调用并返回 <span class="number">1</span>，</span><br><span class="line">S.next(<span class="number">80</span>) 被调用并返回 <span class="number">1</span>，</span><br><span class="line">S.next(<span class="number">60</span>) 被调用并返回 <span class="number">1</span>，</span><br><span class="line">S.next(<span class="number">70</span>) 被调用并返回 <span class="number">2</span>，</span><br><span class="line">S.next(<span class="number">60</span>) 被调用并返回 <span class="number">1</span>，</span><br><span class="line">S.next(<span class="number">75</span>) 被调用并返回 <span class="number">4</span>，</span><br><span class="line">S.next(<span class="number">85</span>) 被调用并返回 <span class="number">6</span>。</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">注意 (例如) S.next(<span class="number">75</span>) 返回 <span class="number">4</span>，因为截至今天的最后 <span class="number">4</span> 个价格</span><br><span class="line">(包括今天的价格 <span class="number">75</span>) 小于或等于今天的价格。</span><br></pre></td></tr></table></figure><p>提示：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">调用 StockSpanner.next(int price) 时，将有 <span class="number">1</span> &lt;= price &lt;= <span class="number">10</span>^<span class="number">5</span>。</span><br><span class="line">每个测试用例最多可以调用  <span class="number">10000</span> 次 StockSpanner.next。</span><br><span class="line">在所有测试用例中，最多调用 <span class="number">150000</span> 次 StockSpanner.next。</span><br><span class="line">此问题的总时间限制减少了 <span class="number">50</span>%。</span><br></pre></td></tr></table></figure><p><strong>解题思路</strong></p><p>正如题意，我们要求当前元素之前，比自己小（可以相等）的元素个数，并且元素个数包括本身，那么我们最后的结果应该还要加1.</p><p>于是按题意，我们采用跨度法，举个例子，对于例子6，1，2，3，4，9，从后往前逆推一下，当我们新插入9的时候，如果发现前一位的4比9小，那么是否说明比9小的数量就等于比4小的数量加1？然而这是错的，因为首位的6比9小，却比4大，因此截止数字的4时候，比4小的数量中并不包含6与9的对比。</p><p>因此，我们还要跳到 6 的位置再去计算小于等于自己的元素。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> StockSpanner = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 存储股票跨度</span></span><br><span class="line">    <span class="built_in">this</span>.spanner = []</span><br><span class="line">    <span class="comment">// 存储股票价格</span></span><br><span class="line">    <span class="built_in">this</span>.stockPrice = []</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">price</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">StockSpanner.prototype.next = <span class="function"><span class="keyword">function</span>(<span class="params">price</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 对于第一天进行特殊判断</span></span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">this</span>.spanner.length)&#123;</span><br><span class="line">        <span class="built_in">this</span>.spanner.push(<span class="number">1</span>)</span><br><span class="line">        <span class="built_in">this</span>.stockPrice.push(price)</span><br><span class="line">        <span class="comment">// 直接返回1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> cnt = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> idx = <span class="built_in">this</span>.stockPrice.length-<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span>(price &gt;= <span class="built_in">this</span>.stockPrice[idx] &amp;&amp; idx&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        cnt += <span class="built_in">this</span>.spanner[idx]</span><br><span class="line">        idx -= <span class="built_in">this</span>.spanner[idx]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 加上本身</span></span><br><span class="line">    cnt++</span><br><span class="line">    <span class="comment">// 进行更新操作，将当前股票价格和跨度入栈</span></span><br><span class="line">    <span class="built_in">this</span>.spanner.push(cnt)</span><br><span class="line">    <span class="built_in">this</span>.stockPrice.push(price)</span><br><span class="line">    <span class="keyword">return</span> cnt</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your StockSpanner object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * var obj = new StockSpanner()</span></span><br><span class="line"><span class="comment"> * var param_1 = obj.next(price)</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h3 id="739-每日温度"><a href="#739-每日温度" class="headerlink" title="739. 每日温度"></a>739. 每日温度</h3><p><a href="https://leetcode-cn.com/problems/daily-temperatures/">739. 每日温度原题传送门</a></p><p> <strong>题目描述</strong></p><p>请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。</p><p>例如，给定一个列表 <code>temperatures = [73, 74, 75, 71, 69, 72, 76, 73]</code>，你的输出应该是 <code>[1, 1, 4, 2, 1, 1, 0, 0]</code>。</p><p>提示：气温 列表长度的范围是 <code>[1, 30000]</code>。每个气温的值的均为华氏度，都是在 <code>[30, 100]</code> 范围内的整数。</p><p><strong>解题思路</strong></p><p>本题用到了单调栈的思路，将原本需要  O(n^2) 的时间复杂度降低到了 O(n)。</p><p>我们只需要维护一个新栈，首先遍历整个数组，只要栈不为空，如果当前的数字大于栈顶元素，则必定是第一个大于它的元素，我们只需要求出相差距离，然后存入结果就好了。</p><p>维护的新栈存放的是我们的元素下标，这样我们求距离时就很方便了，本题我觉得可以说是单调栈的一个模板题。专栏后续会有单调栈其它题目，可以查阅哈。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">T</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> dailyTemperatures = <span class="function"><span class="keyword">function</span>(<span class="params">T</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> stack = []</span><br><span class="line">    <span class="comment">// 初始化气温列表，默认值为0</span></span><br><span class="line">    <span class="keyword">let</span> res = <span class="keyword">new</span> <span class="built_in">Array</span>(T.length).fill(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;T.length;i++)&#123;</span><br><span class="line">        <span class="comment">//将栈顶元素下标对应的值和当前元素进行比较</span></span><br><span class="line">        <span class="keyword">while</span>(T[i] &gt; T[stack[stack.length-<span class="number">1</span>]] &amp;&amp; stack.length)&#123;</span><br><span class="line">            <span class="keyword">let</span> idx = stack.pop()</span><br><span class="line">            res[idx] = i-idx</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="907-子数组的最小值之和"><a href="#907-子数组的最小值之和" class="headerlink" title="907. 子数组的最小值之和"></a>907. 子数组的最小值之和</h3><p><a href="https://leetcode-cn.com/problems/sum-of-subarray-minimums/">907. 子数组的最小值之和原题传送门</a></p><p><strong>题目描述</strong></p><p>给定一个整数数组 A，找到 <code>min(B)</code> 的总和，其中 B 的范围为 A 的每个（连续）子数组。</p><p>由于答案可能很大，因此返回答案模 <code>10^9 + 7</code>。</p><p>示例：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">输入：[<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">17</span></span><br><span class="line">解释：</span><br><span class="line">子数组为 [<span class="number">3</span>]，[<span class="number">1</span>]，[<span class="number">2</span>]，[<span class="number">4</span>]，[<span class="number">3</span>,<span class="number">1</span>]，[<span class="number">1</span>,<span class="number">2</span>]，[<span class="number">2</span>,<span class="number">4</span>]，[<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>]，[<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>]，[<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>]。 </span><br><span class="line">最小值为 <span class="number">3</span>，<span class="number">1</span>，<span class="number">2</span>，<span class="number">4</span>，<span class="number">1</span>，<span class="number">1</span>，<span class="number">2</span>，<span class="number">1</span>，<span class="number">1</span>，<span class="number">1</span>，和为 <span class="number">17</span>。</span><br></pre></td></tr></table></figure><p>提示：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> &lt;= A &lt;= <span class="number">30000</span></span><br><span class="line"><span class="number">1</span> &lt;= A[i] &lt;= <span class="number">30000</span></span><br></pre></td></tr></table></figure><p><strong>解题思路</strong></p><p>搬运 <code>jack-108</code>大佬的<a href="https://leetcode-cn.com/problems/sum-of-subarray-minimums/solution/guan-fang-er-jie-fa-javascript-xiang-jie-by-jack-1/">题解</a>：</p><p>既然是求子数组中最小值的和，就是求 以 A[i] 作为最小数能构成的数组有多少个。</p><p>比如 <code>[2,4,1,2]</code> ,以<code>1</code> 为最小数。能构成的数组数为 <code>(2+1)*(1+1)</code> ，<code>2</code> 表示 <code>1</code>左面有两个比它大的数，<code>1</code> 表示 <code>1</code> 右面有一个比它大的数。</p><p>用单调栈求出 <code>A[i]</code> 对应的左右最近比 <code>A[i]</code> 小的数，记索引为 <code>prev,next，A[i]</code>为最小数能形成的数组为</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(i-prev[i])*(next[i]-i)</span><br></pre></td></tr></table></figure><p>这里为什么没有加 <code>1</code> 了呢，因为 <code>prev[i]</code>已经是比 <code>A[i]</code> 小的数了，能和 <code>A[i]</code> 形成数组的都是比 <code>A[i]</code> 大的数。</p><p><strong>我的解题方式：</strong></p><p>注释已经足够详细，还是补充一下，我参考了大佬的解题代码，只不过我是直接求出来了以当前 <code>A[i]</code> 为最小值的子数组左右两边 大于或等于当前值的个数。这样后续求和直接相乘即可。（不过这里要<strong>强调一下</strong>，如果左边设置大于等于了，右边就只能是大于了，不然会重复计算相等的值）</p><p>开始有点看不懂大佬为啥左边初始化为 <code>-1</code>，右边初始化为 <code>A.length</code>  。假如我们遇到了这种情况，左边都比当前 <code>A[i]</code> 要大，那我们维护的单调递减栈就会不断出栈，不断出栈，直到栈为空为止，此时左边个数应该为 <code>i+1</code>（从 0 开始计数嘛），那么这部分大佬设为 <code>-1</code> 就很巧妙了，问题也就自然明白啦，个人感觉自己写的还是比较好理解一点，不然直接弄一个 <code>-1</code> ，第一次用单调栈，还是不太熟…</p><p>那么对于右边初始化为 <code>A.length</code> ，也是同理啦，当右边都比当前 <code>A[i]</code> 要大，那我们维护的单调递减栈就会不断出栈，不断出栈，直到栈为空为止，此时右边个数应该为 <code>A.length-i</code>（不用<code>+1</code>的原因是从0计数），那么这部分大佬设为 <code>A.length</code> 就很巧妙了，依旧清晰明了。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">A</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> sumSubarrayMins = <span class="function"><span class="keyword">function</span>(<span class="params">A</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> mod = <span class="number">1e9</span>+<span class="number">7</span></span><br><span class="line">  <span class="comment">// 维护一个栈</span></span><br><span class="line">  <span class="keyword">let</span> stack = []</span><br><span class="line">  <span class="comment">// 求以A[i]为最小值的子数组左边大于或等于自己的个数</span></span><br><span class="line">  <span class="keyword">let</span> prev = []</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;A.length;i++)&#123;</span><br><span class="line">    <span class="keyword">while</span>(stack.length &amp;&amp; A[stack[stack.length-<span class="number">1</span>]] &gt;= A[i]) stack.pop()</span><br><span class="line">    <span class="comment">// 如果栈为空，即左边都比自己大，则返回i+1，否则返回i-栈顶元素（即保存的下标值）</span></span><br><span class="line">    prev[i] = stack.length ? i - stack[stack.length-<span class="number">1</span>] : i+<span class="number">1</span></span><br><span class="line">    stack.push(i)</span><br><span class="line">  &#125;</span><br><span class="line">  stack = []</span><br><span class="line">  <span class="comment">// 求以A[i]为最小值的子数组右边大于自己的个数（没有等号是因为不会重复计算相等的值）</span></span><br><span class="line">  <span class="keyword">let</span> nextv = []</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=A.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">    <span class="keyword">while</span>(stack.length &amp;&amp; A[stack[stack.length-<span class="number">1</span>]] &gt; A[i]) stack.pop()</span><br><span class="line">    <span class="comment">// 如果栈为空，即右边都比自己大，则返回A.length-i，否则返回栈顶元素（即保存的下标值）-i</span></span><br><span class="line">    nextv[i] = stack.length? stack[stack.length-<span class="number">1</span>] - i : A.length-i</span><br><span class="line">    stack.push(i)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;A.length;i++)&#123;</span><br><span class="line">    <span class="comment">// 以A[i] 为最小值的子数组的组合共有prev[i]*nextv[i]种情况，那么和的话乘以A[i]累加即可</span></span><br><span class="line">    sum += (prev[i]*nextv[i]*A[i])</span><br><span class="line">    <span class="comment">// 按题意，进行取模运算</span></span><br><span class="line">    sum %= mod</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="1190-反转每对括号间的子串"><a href="#1190-反转每对括号间的子串" class="headerlink" title="1190. 反转每对括号间的子串"></a>1190. 反转每对括号间的子串</h3><p><a href="https://leetcode-cn.com/problems/reverse-substrings-between-each-pair-of-parentheses/">1190. 反转每对括号间的子串原题传送门</a></p><p><strong>题目描述</strong></p><p>给出一个字符串 <code>s</code>（仅含有小写英文字母和括号）。</p><p>请你按照从括号内到外的顺序，逐层反转每对匹配括号中的字符串，并返回最终的结果。</p><p>注意，您的结果中 不应 包含任何括号。</p><p>示例 1：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;(abcd)&quot;</span></span><br><span class="line">输出：<span class="string">&quot;dcba&quot;</span></span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;(u(love)i)&quot;</span></span><br><span class="line">输出：<span class="string">&quot;iloveu&quot;</span></span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;(ed(et(oc))el)&quot;</span></span><br><span class="line">输出：<span class="string">&quot;leetcode&quot;</span></span><br></pre></td></tr></table></figure><p>示例 4：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;a(bcdefghijkl(mno)p)q&quot;</span></span><br><span class="line">输出：<span class="string">&quot;apmnolkjihgfedcbq&quot;</span></span><br></pre></td></tr></table></figure><p>提示：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> &lt;= s.length &lt;= <span class="number">2000</span></span><br><span class="line">s 中只有小写英文字母和括号</span><br><span class="line">我们确保所有括号都是成对出现的</span><br></pre></td></tr></table></figure><p><strong>解题思路</strong></p><p>初始化栈，栈顶元素为 “ “<br>遇到<code>&#39;(&#39;</code>: 向栈顶压入空字符串<br>遇到<code>&#39;)&#39;</code>: 把栈顶的最后一个元素翻转 + 栈顶倒数第二个元素<br>遇到 字符: 直接将栈顶最后一个元素与它拼上</p><p><a href="https://leetcode-cn.com/problems/reverse-substrings-between-each-pair-of-parentheses/solution/1190-fan-zhuan-mei-dui-gua-hao-jian-de-zi-chuan-ji/">参考 tuotuoli 大佬解题思路</a></p><p>样例栈数组操作示意：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">样例：a(bcdefghijkl(mno)p)q</span><br><span class="line"></span><br><span class="line">a [<span class="string">&#x27;a&#x27;</span>]</span><br><span class="line">( [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;&#x27;</span>]</span><br><span class="line">b [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]</span><br><span class="line">c [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;bc&#x27;</span>]</span><br><span class="line">d [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;bcd&#x27;</span>]</span><br><span class="line">e [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;bcde&#x27;</span>]</span><br><span class="line">f [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;bcdef&#x27;</span>]</span><br><span class="line">g [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;bcdefg&#x27;</span>]</span><br><span class="line">h [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;bcdefgh&#x27;</span>]</span><br><span class="line">i [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;bcdefghi&#x27;</span>]</span><br><span class="line">j [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;bcdefghij&#x27;</span>]</span><br><span class="line">k [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;bcdefghijk&#x27;</span>]</span><br><span class="line">l [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;bcdefghijkl&#x27;</span>]</span><br><span class="line">( [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;bcdefghijkl&#x27;</span>, <span class="string">&#x27;&#x27;</span>]</span><br><span class="line">m [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;bcdefghijkl&#x27;</span>, <span class="string">&#x27;m&#x27;</span>]</span><br><span class="line">n [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;bcdefghijkl&#x27;</span>, <span class="string">&#x27;mn&#x27;</span>]</span><br><span class="line">o [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;bcdefghijkl&#x27;</span>, <span class="string">&#x27;mno&#x27;</span>]</span><br><span class="line">) [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;bcdefghijklonm&#x27;</span>]</span><br><span class="line">p [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;bcdefghijklonmp&#x27;</span>]</span><br><span class="line">) [<span class="string">&#x27;apmnolkjihgfedcb&#x27;</span>]</span><br><span class="line">q [<span class="string">&#x27;apmnolkjihgfedcbq&#x27;</span>]</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reverseParentheses = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> stack = [<span class="string">&#x27;&#x27;</span>]</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;s.length;i++)&#123;</span><br><span class="line">    <span class="keyword">let</span> ch = s[i]</span><br><span class="line">    <span class="keyword">if</span>(ch === <span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">      stack.push(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ch === <span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">      <span class="keyword">let</span> str = stack.pop()</span><br><span class="line">      <span class="keyword">let</span> tmp = str.split(<span class="string">&#x27;&#x27;</span>).reverse().join(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">      stack[stack.length-<span class="number">1</span>] += tmp</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      stack[stack.length-<span class="number">1</span>] += ch</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> stack.pop()</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="1249-移除无效的括号"><a href="#1249-移除无效的括号" class="headerlink" title="1249. 移除无效的括号"></a>1249. 移除无效的括号</h3><p><a href="https://leetcode-cn.com/problems/minimum-remove-to-make-valid-parentheses/">1249. 移除无效的括号原题传送门</a></p><p> <strong>题目描述</strong></p><p>给你一个由<code>&#39;(&#39;</code>、<code>&#39;)&#39;</code> 和小写字母组成的字符串 <code>s</code>。</p><p>你需要从字符串中删除最少数目的 <code>&#39;(&#39;</code> 或者 <code>&#39;)&#39;</code>（可以删除任意位置的括号)，使得剩下的「括号字符串」有效。</p><p>请返回任意一个合法字符串。</p><p>有效「括号字符串」应当符合以下 任意一条 要求：</p><p>空字符串或只包含小写字母的字符串<br>可以被写作 <code>AB</code>（A 连接 B）的字符串，其中 <code>A</code> 和 <code>B</code> 都是有效「括号字符串」<br>可以被写作 (A) 的字符串，其中 <code>A</code> 是一个有效的「括号字符串」</p><p>示例 1：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;lee(t(c)o)de)&quot;</span></span><br><span class="line">输出：<span class="string">&quot;lee(t(c)o)de&quot;</span></span><br><span class="line">解释：<span class="string">&quot;lee(t(co)de)&quot;</span> , <span class="string">&quot;lee(t(c)ode)&quot;</span> 也是一个可行答案。</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;a)b(c)d&quot;</span></span><br><span class="line">输出：<span class="string">&quot;ab(c)d&quot;</span></span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;))((&quot;</span></span><br><span class="line">输出：<span class="string">&quot;&quot;</span></span><br><span class="line">解释：空字符串也是有效的</span><br></pre></td></tr></table></figure><p>示例 4：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;(a(b(c)d)&quot;</span></span><br><span class="line">输出：<span class="string">&quot;a(b(c)d)&quot;</span></span><br></pre></td></tr></table></figure><p>提示：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> &lt;= s.length &lt;= <span class="number">10</span>^<span class="number">5</span></span><br><span class="line">s[i] 可能是 <span class="string">&#x27;(&#x27;</span>、<span class="string">&#x27;)&#x27;</span> 或英文小写字母</span><br></pre></td></tr></table></figure><p><strong>解题思路</strong></p><p>一开始我是想着只要对应括号匹配就好了，将多余的右括号删掉，但是这个样例 <code>))((</code> 不可能过的，因为左括号也可以不匹配呀。于是我想着将括号对应字符串索引存起来，起初我们可以将不匹配的右括号还是按原来方法删掉就好了，匹配一个就删掉一个对应左括号的索引值，最后多出来的索引值全删掉就好了，这样就不会出现左括号还余留的情况。</p><p>这里提示一下：不要用 <code>splice</code>去删除指定下标的元素，<code>splice</code>会改变原数组长度，而你原本存的下标是基于原数组的。<br><code>delete</code>方法不会改变数组长度，但删除的那个位置会变成<code>&#39;undefined&#39;</code>，所以我们用<code>fliter</code>方法过滤一遍出有效值 <code>arr=arr.filter(item=&gt;item)</code></p><p>最后通过 <code>res.join(&#39;&#39;)</code> 方法，将数组转换成我们最后要的字符串即可。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> minRemoveToMakeValid = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = [...s]</span><br><span class="line">    <span class="keyword">let</span> stack = []</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=-<span class="number">0</span>;i&lt;s.length;i++)&#123;</span><br><span class="line">        <span class="keyword">let</span> ch = s[i]</span><br><span class="line">        <span class="keyword">if</span>(ch === <span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">            stack.push(i)</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ch === <span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(stack.length) stack.pop()</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">delete</span>(res[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(stack.length)&#123;</span><br><span class="line">        <span class="keyword">let</span> idx = stack.pop()</span><br><span class="line">        <span class="keyword">delete</span>(res[idx])</span><br><span class="line">    &#125;</span><br><span class="line">    res = res.filter(<span class="function"><span class="params">item</span>=&gt;</span>item)</span><br><span class="line">    <span class="keyword">return</span> res.join(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p><img src= "/img/loading.gif" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/81c1b4b85f164005bcd42d6980f1bf5f~tplv-k3u1fbpfcp-watermark.image" alt=""></p><h3 id="933-最近的请求次数"><a href="#933-最近的请求次数" class="headerlink" title="933. 最近的请求次数"></a>933. 最近的请求次数</h3><p><a href="https://leetcode-cn.com/problems/number-of-recent-calls/">933. 最近的请求次数原题传送门</a></p><p><strong>题目描述</strong></p><p>写一个<code>RecentCounter</code> 类来计算最近的请求。</p><p>它只有一个方法：<code>ping(int t)</code>，其中 t 代表以毫秒为单位的某个时间。</p><p>返回从 <code>3000</code>毫秒前到现在的 ping 数。</p><p>任何处于<code>[t - 3000, t]</code>时间范围之内的 <code>ping</code> 都将会被计算在内，包括当前（指 t 时刻）的 <code>ping</code>。</p><p>保证每次对 <code>ping</code> 的调用都使用比之前更大的 t 值。</p><p>示例：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">输入：inputs = [<span class="string">&quot;RecentCounter&quot;</span>,<span class="string">&quot;ping&quot;</span>,<span class="string">&quot;ping&quot;</span>,<span class="string">&quot;ping&quot;</span>,<span class="string">&quot;ping&quot;</span>], inputs = [[],[<span class="number">1</span>],[<span class="number">100</span>],[<span class="number">3001</span>],[<span class="number">3002</span>]]</span><br><span class="line">输出：[<span class="literal">null</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure><p>提示：</p><p>每个测试用例最多调用<code>10000</code>次 ping。<br>每个测试用例会使用严格递增的 <code>t</code>值来调用 <code>ping</code>。<br>每次调用 ping 都有<code>1 &lt;= t &lt;= 10^9</code>。</p><p><strong>题解</strong></p><p>根据样例，发现越早发出的请求越早不在 <code>3000ms</code> 内的请求里</p><p>满足<strong>先进先出</strong>，考虑用队列</p><p>那么就将新请求加入队列，<code>3000ms</code>前发出的请求就出队列</p><p>队列的长度即为最近请求次数。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> RecentCounter = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.queue = []</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">t</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">RecentCounter.prototype.ping = <span class="function"><span class="keyword">function</span>(<span class="params">t</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 将新请求加入队列</span></span><br><span class="line">  <span class="built_in">this</span>.queue.push(t)</span><br><span class="line">  <span class="comment">// 3000ms 前发出的请求就出队列</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">this</span>.queue[<span class="number">0</span>] &lt; t-<span class="number">3000</span>)&#123;</span><br><span class="line">    <span class="built_in">this</span>.queue.shift()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.queue.length</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your RecentCounter object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * var obj = new RecentCounter()</span></span><br><span class="line"><span class="comment"> * var param_1 = obj.ping(t)</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p><img src= "/img/loading.gif" data-lazy-src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1895179bd62e4cb7b5f75631a9722dd6~tplv-k3u1fbpfcp-watermark.image" alt=""></p><h3 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2. 两数相加"></a>2. 两数相加</h3><p><a href="https://leetcode-cn.com/problems/add-two-numbers/">2. 两数相加原题传送门</a></p><p><strong>题目描述</strong></p><p>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 <strong>逆序</strong> 的方式存储的，并且它们的每个节点只能存储 一位 数字。</p><p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p><p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p>示例：</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">输入：(2 <span class="selector-tag">-</span>&gt; 4 <span class="selector-tag">-</span>&gt; 3) + (5 <span class="selector-tag">-</span>&gt; 6 <span class="selector-tag">-</span>&gt; 4)</span><br><span class="line">输出：7 <span class="selector-tag">-</span>&gt; 0 <span class="selector-tag">-</span>&gt; 8</span><br><span class="line">原因：342 + 465 = 807</span><br></pre></td></tr></table></figure><p><strong>解题思路</strong></p><p>模拟相加，创建一个新的链表，注意一下进位，由于本题按照逆序来输出的，直接从头结点开始遍历就好了，两个链表其中一个为空节点，直接置为0即可。</p><p>同时，要注意，最后一个进位的情况，要进行判断一下。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val, next) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.next = (next===undefined ? null : next)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">l1</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">l2</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> addTwoNumbers = <span class="function"><span class="keyword">function</span> (<span class="params">l1, l2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> head = <span class="keyword">new</span> ListNode(<span class="string">&#x27;head&#x27;</span>); <span class="comment">// 头结点</span></span><br><span class="line">    <span class="keyword">let</span> p = head;</span><br><span class="line">    <span class="keyword">let</span> cnt = <span class="number">0</span>; <span class="comment">// 进位</span></span><br><span class="line">    <span class="keyword">while</span> (l1 || l2) &#123;</span><br><span class="line">        <span class="keyword">let</span> ans = (l1 ? l1.val : <span class="number">0</span>) + (l2 ? l2.val : <span class="number">0</span>) + cnt;</span><br><span class="line">        cnt = ans &gt;= <span class="number">10</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        p.next = <span class="keyword">new</span> ListNode(ans % <span class="number">10</span>);</span><br><span class="line">        p = p.next;</span><br><span class="line">        l1 &amp;&amp; (l1 = l1.next);</span><br><span class="line">        l2 &amp;&amp; (l2 = l2.next);</span><br><span class="line">    &#125;</span><br><span class="line">    cnt &amp;&amp; (p.next = <span class="keyword">new</span> ListNode(cnt));</span><br><span class="line">    <span class="keyword">return</span> head.next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a>206. 反转链表</h3><p><a href="https://leetcode-cn.com/problems/reverse-linked-list/">206. 反转链表原题传送门</a></p><p><strong>题目描述</strong></p><p>反转一个单链表。</p><p>示例:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">输入: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>-&gt;NULL</span><br><span class="line">输出: <span class="number">5</span>-&gt;<span class="number">4</span>-&gt;<span class="number">3</span>-&gt;<span class="number">2</span>-&gt;<span class="number">1</span>-&gt;NULL</span><br></pre></td></tr></table></figure><p>进阶:<br>你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</p><p><strong>解题思路</strong></p><p><strong>非递归解法</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">head</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reverseList = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> pre = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> cur = head;</span><br><span class="line">    <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">        <span class="keyword">let</span> tmp = cur.next;</span><br><span class="line">        cur.next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>递归解法</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">head</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reverseList = <span class="function"><span class="keyword">function</span> (<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> reverse = <span class="function">(<span class="params">pre, cur</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!cur) <span class="keyword">return</span> pre;</span><br><span class="line">        <span class="keyword">let</span> tmp = cur.next;</span><br><span class="line">        cur.next = pre;</span><br><span class="line">        <span class="keyword">return</span> reverse(cur, tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> reverse(<span class="literal">null</span>, head);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="92-反转链表-II"><a href="#92-反转链表-II" class="headerlink" title="92. 反转链表 II"></a>92. 反转链表 II</h3><p><a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/">92. 反转链表 II原题传送门</a></p><p><strong>题目描述</strong></p><p>反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。</p><p>说明:<br>1 ≤ m ≤ n ≤ 链表长度。</p><p>示例:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">输入: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>-&gt;NULL, m = <span class="number">2</span>, n = <span class="number">4</span></span><br><span class="line">输出: <span class="number">1</span>-&gt;<span class="number">4</span>-&gt;<span class="number">3</span>-&gt;<span class="number">2</span>-&gt;<span class="number">5</span>-&gt;NULL</span><br></pre></td></tr></table></figure><p><strong>解题思路</strong></p><p><strong>借助递归</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">head</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">m</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reverseBetween = <span class="function"><span class="keyword">function</span> (<span class="params">head, m, n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> reverse = <span class="function">(<span class="params">pre, cur</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!cur) <span class="keyword">return</span> pre;</span><br><span class="line">        <span class="keyword">let</span> tmp = cur.next;</span><br><span class="line">        cur.next = pre;</span><br><span class="line">        <span class="keyword">return</span> reverse(cur, tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> dummyHead = <span class="keyword">new</span> ListNode();</span><br><span class="line">    dummyHead.next = head;</span><br><span class="line">    <span class="keyword">let</span> p = dummyHead;</span><br><span class="line">    <span class="keyword">let</span> k = m - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 先找到需要反转链表部分的前驱节点</span></span><br><span class="line">    <span class="keyword">while</span> (k--) &#123;</span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 保存前驱节点</span></span><br><span class="line">    <span class="keyword">let</span> front = p;</span><br><span class="line">    <span class="comment">// 找到需要反转链表部分的头节点</span></span><br><span class="line">    <span class="keyword">let</span> frontNode = front.next;</span><br><span class="line">    k = n - m + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 再找到需要反转链表部分的尾节点</span></span><br><span class="line">    <span class="keyword">while</span> (k--) &#123;</span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 找到需要反转链表部分的尾节点</span></span><br><span class="line">    <span class="keyword">let</span> endNode = p;</span><br><span class="line">    <span class="comment">// 保存后继节点</span></span><br><span class="line">    <span class="keyword">let</span> end = endNode.next;</span><br><span class="line">    <span class="comment">// 将后继值为空，开始反转链表</span></span><br><span class="line">    endNode.next = <span class="literal">null</span>;</span><br><span class="line">    front.next = reverse(<span class="literal">null</span>, frontNode);</span><br><span class="line">    <span class="comment">// 原本的反转链表部分的头节点现在变成了尾节点，指向原本的后继节点</span></span><br><span class="line">    frontNode.next = end;</span><br><span class="line">    <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>迭代解法</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">head</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">m</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reverseBetween = <span class="function"><span class="keyword">function</span>(<span class="params">head, m, n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> dummyHead = <span class="keyword">new</span> ListNode();</span><br><span class="line">    dummyHead.next = head;</span><br><span class="line">    <span class="keyword">let</span> p = dummyHead;</span><br><span class="line">    <span class="keyword">let</span> k = m-<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 先找到需要反转链表部分的前驱节点</span></span><br><span class="line">    <span class="keyword">while</span> (k--) &#123;</span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 保存前驱节点</span></span><br><span class="line">    <span class="keyword">let</span> front = p;</span><br><span class="line">    <span class="keyword">let</span> pre = frontNode = front.next;</span><br><span class="line">    <span class="keyword">let</span> cur = pre.next;</span><br><span class="line">    k = n-m;</span><br><span class="line">    <span class="comment">// 长度为3的链表需要反转2次，那么长度为n的链表需要反转n-1次</span></span><br><span class="line">    <span class="keyword">while</span>(k--)&#123;</span><br><span class="line">        <span class="keyword">let</span> tmp = cur.next;</span><br><span class="line">        cur.next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将原本前驱节点的next指向当前反转后的链表</span></span><br><span class="line">    front.next = pre;</span><br><span class="line">    <span class="comment">// 原本反转链表的头节点现在变成了尾结点，指向后继节点</span></span><br><span class="line">    frontNode.next = cur;</span><br><span class="line">    <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203. 移除链表元素"></a>203. 移除链表元素</h3><p><a href="https://leetcode-cn.com/problems/remove-linked-list-elements/">203. 移除链表元素原题传送门</a></p><p><strong>题目描述</strong></p><p>删除链表中等于给定值 val 的所有节点。</p><p>示例:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">输入: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">6</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>-&gt;<span class="number">6</span>, val = <span class="number">6</span></span><br><span class="line">输出: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span></span><br></pre></td></tr></table></figure><p><strong>解题思路</strong></p><p>创建一个新链表，遇到相同值的情况，将当前节点的next指向下一个节点的next，否则继续遍历。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> removeElements = <span class="function"><span class="keyword">function</span>(<span class="params">head, val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> dummyHead = <span class="keyword">new</span> ListNode(); <span class="comment">// 哑结点</span></span><br><span class="line">    dummyHead.next = head;</span><br><span class="line">    <span class="keyword">let</span> p = dummyHead;</span><br><span class="line">    <span class="keyword">while</span>(p.next)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p.next.val === val)&#123;</span><br><span class="line">            p.next = p.next.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24. 两两交换链表中的节点"></a>24. 两两交换链表中的节点</h3><p><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/">24. 两两交换链表中的节点原题传送门</a></p><p> <strong>题目描述</strong></p><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p><p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p><p>示例:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">给定 <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>, 你应该返回 <span class="number">2</span>-&gt;<span class="number">1</span>-&gt;<span class="number">4</span>-&gt;<span class="number">3.</span></span><br></pre></td></tr></table></figure><p><strong>解题思路</strong></p><p>非递归解法</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">head</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> swapPairs = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">    <span class="keyword">let</span> hummyHead = <span class="keyword">new</span> ListNode(); <span class="comment">// 虚拟节点</span></span><br><span class="line">    hummyHead.next = head;</span><br><span class="line">    <span class="keyword">let</span> p = hummyHead;</span><br><span class="line">    <span class="keyword">let</span> node1,node2; <span class="comment">// 当前要交换的两个节点</span></span><br><span class="line">    <span class="keyword">while</span>((node1 = p.next) &amp;&amp; (node2 = p.next.next))&#123;</span><br><span class="line">        <span class="comment">// 进行交换操作</span></span><br><span class="line">        node1.next = node2.next;</span><br><span class="line">        node2.next = node1;</span><br><span class="line">        <span class="comment">// 将链表串起来</span></span><br><span class="line">        p.next = node2;</span><br><span class="line">        p = node1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hummyHead.next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>递归解法</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">head</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> swapPairs = <span class="function"><span class="keyword">function</span> (<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!head || !head.next) <span class="keyword">return</span> head;</span><br><span class="line">    <span class="keyword">let</span> node1 = head, node2 = head.next;</span><br><span class="line">    node1.next = swapPairs(node2.next);</span><br><span class="line">    node2.next = node1;</span><br><span class="line">    <span class="keyword">return</span> node2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="剑指-Offer-18-删除链表的节点"><a href="#剑指-Offer-18-删除链表的节点" class="headerlink" title="剑指 Offer 18. 删除链表的节点"></a>剑指 Offer 18. 删除链表的节点</h3><p><a href="https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/">剑指 Offer 18. 删除链表的节点原题传送门</a></p><p><strong>题目描述</strong></p><p>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。</p><p>返回删除后的链表的头节点。</p><p>注意：此题对比原题有改动</p><p>示例 1:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">输入: head = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">9</span>], val = <span class="number">5</span></span><br><span class="line">输出: [<span class="number">4</span>,<span class="number">1</span>,<span class="number">9</span>]</span><br><span class="line">解释: 给定你链表中值为 <span class="number">5</span> 的第二个节点，那么在调用了你的函数之后，该链表应变为 <span class="number">4</span> -&gt; <span class="number">1</span> -&gt; <span class="number">9.</span></span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">输入: head = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">9</span>], val = <span class="number">1</span></span><br><span class="line">输出: [<span class="number">4</span>,<span class="number">5</span>,<span class="number">9</span>]</span><br><span class="line">解释: 给定你链表中值为 <span class="number">1</span> 的第三个节点，那么在调用了你的函数之后，该链表应变为 <span class="number">4</span> -&gt; <span class="number">5</span> -&gt; <span class="number">9.</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>说明：</p><p>题目保证链表中节点的值互不相同<br>若使用 C 或 C++ 语言，你不需要 free 或 delete 被删除的节点</p><p><strong>解题思路</strong></p><p>创建一个新链表，遇到相同值的情况，将当前节点的next指向下一个节点的next，否则继续遍历。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">head</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">val</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> deleteNode = <span class="function"><span class="keyword">function</span>(<span class="params">head, val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> dummyHead = <span class="keyword">new</span> ListNode();</span><br><span class="line">    dummyHead.next = head;</span><br><span class="line">    <span class="keyword">let</span> p = dummyHead;</span><br><span class="line">    <span class="keyword">while</span>(p.next)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p.next.val === val)&#123;</span><br><span class="line">            p.next = p.next.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            p = p.next;   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="19-删除链表的倒数第N个节点"><a href="#19-删除链表的倒数第N个节点" class="headerlink" title="19. 删除链表的倒数第N个节点"></a>19. 删除链表的倒数第N个节点</h3><p><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第N个节点原题传送门</a></p><p><strong>题目描述</strong></p><p>给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。</p><p>示例：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">给定一个链表: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>, 和 n = <span class="number">2.</span></span><br><span class="line"></span><br><span class="line">当删除了倒数第二个节点后，链表变为 <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">5.</span></span><br></pre></td></tr></table></figure><p>说明：</p><p>给定的 n 保证是有效的。</p><p>进阶：</p><p>你能尝试使用一趟扫描实现吗？</p><p><strong>解题思路</strong></p><p>双指针，先让一个指针q走n 步，然后另一个指针p一起走，当第一个指针q走到尾的时候，此时p指针就指向了我们要删除的节点，进行删除即可。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">head</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> removeNthFromEnd = <span class="function"><span class="keyword">function</span>(<span class="params">head, n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> dummyHead = <span class="keyword">new</span> ListNode();</span><br><span class="line">    dummyHead.next = head;</span><br><span class="line">    <span class="keyword">let</span> p = dummyHead;</span><br><span class="line">    <span class="keyword">let</span> q = dummyHead;</span><br><span class="line">    <span class="keyword">let</span> k = n;</span><br><span class="line">    <span class="keyword">while</span>(k--) q = q.next; <span class="comment">// 先让一个指针先走n步</span></span><br><span class="line">    <span class="keyword">while</span>(q.next)&#123; <span class="comment">// 一起走</span></span><br><span class="line">        q = q.next;</span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    p.next = p.next.next; <span class="comment">// 找到删除节点，进行删除</span></span><br><span class="line">    <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142. 环形链表 II"></a>142. 环形链表 II</h3><p><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">142. 环形链表 II原题传送门</a></p><p><strong>题目描述</strong></p><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p><p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意，pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中。</p><p>说明：不允许修改给定的链表。</p><p>进阶：</p><p>你是否可以不用额外空间解决此题？</p><p>示例 1：</p><p><img src= "/img/loading.gif" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d205c94e33e241eabb1efe947b869c27~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">输入：head = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">0</span>,-<span class="number">4</span>], pos = <span class="number">1</span></span><br><span class="line">输出：返回索引为 <span class="number">1</span> 的链表节点</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure><p>示例 2：</p><p><img src= "/img/loading.gif" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/da427b97310d4aa0a1fa54873f33dc23~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>,<span class="number">2</span>], pos = <span class="number">0</span></span><br><span class="line">输出：返回索引为 <span class="number">0</span> 的链表节点</span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure><p>示例 3：</p><p><img src= "/img/loading.gif" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/390ee2644cc74617ab21059aa03b536d~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>], pos = -<span class="number">1</span></span><br><span class="line">输出：返回 <span class="literal">null</span></span><br><span class="line">解释：链表中没有环。</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li>链表中节点的数目范围在范围 <code>[0, 104]</code> 内</li><li><code>-10^5 &lt;= Node.val &lt;= 10^5</code></li><li>pos 的值为 -1 或者链表中的一个有效索引</li></ul><p><strong>解题思路</strong></p><p>两个快慢指针，从头节点出发，如果链表有环，快指针肯定可以在环内和慢指针相遇。没有环就不可能再相遇，相遇必在环内。</p><p><img src= "/img/loading.gif" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/68084fc2002a4e818c60f7599b3302eb~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p><img src= "/img/loading.gif" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/822ae46ed29b4d2aba0e39638c3a0ac1~tplv-k3u1fbpfcp-zoom-1.image" alt=""><br>相遇时，慢指针走的距离：<code>D+S1D+S1</code></p><p>假设相遇时快指针已经绕环 n 次，它走的距离：<code>D+n(S1+S2)+S1D+n(S1+S2)+S1</code></p><p>因为快指针的速度是 2 倍，所以相同时间走的距离也是 2 倍：</p><p>D+n(S1+S2)+S1 = 2(D+S1)</p><p>求解得到：<strong>(n-1)S1+ nS2=D</strong></p><p>我们不关心在相遇时快指针已经绕了几次环，我们取 n = 1 ，消掉了 S1：</p><p><strong>D=S2</strong></p><p>那么，当快慢指针第一次相遇时，将快指针放回到头节点，由于 <code>D=s2</code>，那么我们快慢指针一起走，都走1步，它们必定会走到入环点，然后相遇，此时就可返回对应指针下标。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">head</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> detectCycle = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> fast = head, low = head; <span class="comment">// 首先，都从头节点出现</span></span><br><span class="line">    <span class="keyword">while</span>(fast)&#123; <span class="comment">// 确保存在环</span></span><br><span class="line">        <span class="keyword">if</span>(fast.next == <span class="literal">null</span>)  <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// fast.next 为null表示无环</span></span><br><span class="line">        low = low.next; <span class="comment">// 慢指针走一步</span></span><br><span class="line">        fast = fast.next.next; <span class="comment">// 快指针走两步</span></span><br><span class="line">        <span class="keyword">if</span>(low == fast)&#123; <span class="comment">// 初次相遇</span></span><br><span class="line">            fast = head; <span class="comment">// 快指针回到头节点</span></span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(fast == low)&#123;</span><br><span class="line">                    <span class="keyword">return</span> low;</span><br><span class="line">                &#125;</span><br><span class="line">                fast = fast.next; <span class="comment">// 快慢指针一起走</span></span><br><span class="line">                low = low.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>参考 <a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/solution/141ti-de-kuo-zhan-ru-guo-lian-biao-you-huan-ru-he-/">笨猪爆破组</a> 图解</p><h2 id="本文参考"><a href="#本文参考" class="headerlink" title="本文参考"></a>本文参考</h2><ul><li><a href="https://juejin.cn/post/6844903919722692621">前端该如何准备数据结构和算法？</a></li><li><a href="https://juejin.cn/post/6847009772500156429">写给前端的算法进阶指南，我是如何两个月零基础刷200题</a></li><li><a href="https://juejin.cn/post/6844904061947346957">(1.8w字)负重前行，前端工程师如何系统练习数据结构和算法？【上】</a></li></ul><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>❤️关注+点赞+收藏+评论+转发❤️，原创不易，您的支持将会是我最大的动力~</p><p><a href="https://yangchaoyi.vip/">访问超逸の博客</a>，方便小伙伴阅读玩耍~</p><p>最后，给看到这里的你拜个年，牛年大吉，好运++，在准备春招の你，能够早点结束春招，offer拿到手软，希望我的文章能够帮助到你，我们很快会在下期相遇~</p><blockquote><p>本文若未经作者授权，禁止转载，如若发现雷同，必将追究责任到底！</p></blockquote><p>【作者：Chocolate】<a href="https://juejin.cn/user/2981531267112520/posts">https://juejin.cn/user/2981531267112520/posts</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>🐮写给零基础的前端算法入门指南，acmer带女友刷80+【双指针与字符串篇】</title>
      <link href="posts/20210221/"/>
      <url>posts/20210221/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上一篇的反馈还算不错，原来拜完年后真有一批人开始学习啦，2021春招陆续开始啦，我能给大家帮助的就是尽量在2月份给大家更新完算法入门专栏，能帮助到大家很开心~</p><blockquote><p>现在和大家分享一下我们是如何准备算法这一块的，春招即将开启，还能最后准备一下，希望对大家有所帮助。</p></blockquote><p>原本打算通过一篇文章介绍一下，推荐一下自己的刷题方式和刷题路线，得到一些伙伴的反馈：最好还是更加详细，面向零基础，小白这些，还有<code>github</code>访问速度也是一方面问题，可能图片都加载不出来。</p><p>因此，我打算分模块出几期文章，这样你只用通过首发在掘金的文章即可了解 <code>Chocolate</code> 同学整体刷题汇总啦。马上就要过年了，希望能够帮助你的春招。打算出的内容计划安排如下：</p><ul><li>🐮写给零基础的前端算法入门指南，acmer带女友刷80+【栈与队列与链表篇】（<a href="https://juejin.cn/post/6926801566699618312">已完成🎉</a>）</li><li>🐮写给零基础的前端算法入门指南，acmer带女友刷80+【递归与回溯篇】（<a href="https://juejin.cn/post/6929755669683765261">已完成🎉</a>）</li><li>🐮写给零基础的前端算法入门指南，acmer带女友刷80+【双指针与字符串篇】（本期已完成🎉）</li><li>🐮写给零基础的前端算法入门指南，acmer带女友刷80+【二叉树篇】</li><li>🐮写给零基础的前端算法入门指南，acmer带女友刷80+【动态规划DP篇】</li><li>🐮写给零基础的前端算法入门指南，acmer带女友刷80+【总结篇】</li></ul><p>欢迎访问 <a href="https://github.com/Chocolate1999/Front-end-learning-to-organize-notes/issues">GitHub仓库</a>，目前已经有 552 道大厂真题了，涵盖各类前端的真题，祝你春秋招牛气冲天~</p><h1 id="算法这一块到底如何准备"><a href="#算法这一块到底如何准备" class="headerlink" title="算法这一块到底如何准备"></a>算法这一块到底如何准备</h1><p>首先，我来简单介绍一下自己，在校打过ACM（如果没听过，当我没说，因为没有很大价值的牌牌，铁牌，参赛证以及证书倒是一堆）</p><p>如果你知道acm，并且参与过，对于国内前端（注意是说前端）面试的话，应该不需要花费很长的刷题时间，如果大家有想法了解我的acm经历的话，这个后续我会考虑在 <a href="https://space.bilibili.com/351534170">B站发布一期视频</a>。</p><p>那么对于零基础的小白来说，可能需要花10-20天左右时间来准备算法，而对于非科班来说这个周期可能会更长一点。那么，现在我准备来分享我是如何带着女友零基础刷题的。</p><ul><li>第一点，明确算法它不是很难的东西，理解了其实就那会事，或许你还会喜欢上做题，当然，对于acm大佬做的题就另当别论了，这篇文章主体与面试水平为准</li><li>第二点，前端对于算法这一块的考察相对来说会偏简单一点，我在春秋招过程中遇到的笔试题都是一些常见的题目，比如搜索，贪心，简单动态规划，经典排序算法，都是以 <code>leetcode</code>一些简单以及中等难度的居多，而这些算法对于科班来说的话，应该在学校都学习过，比如算法分析与设计，数据结构与算法这一类课程，那么有这个基础，你的刷题时间又可以进行缩短了</li><li>第三点，既然说到要刷题，该如何刷，我在掘金参考了几个大佬（文末有参考处），大家都会推荐分专题来刷，在这里，我也是非常推荐的，在这里，我希望的是将刷算法题的数量再减少一点，带你入门，当你刷完这些专题之后，你就有相关思维能力主动去刷题了，而不是很被动的去刷，这样也很方便自己总结归纳~</li><li>其它，可以参考大佬的文章，这里不再赘述…</li></ul><h1 id="一份思维导图，让你的刷题路线更简单"><a href="#一份思维导图，让你的刷题路线更简单" class="headerlink" title="一份思维导图，让你的刷题路线更简单"></a>一份思维导图，让你的刷题路线更简单</h1><p>开门见山地说，首先提供一份思维导图，让知识由繁到简。</p><p><img src= "/img/loading.gif" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/30337832145d4969833ccb6cf4009d7e~tplv-k3u1fbpfcp-watermark.image" alt=""></p><blockquote><p>获取高清PDF，请在微信公众号【小狮子前端】回复【LeetCode】，一起刷题或者交流学习可以加企鹅群【666151691】</p></blockquote><blockquote><p>本仓库刷题路线参考 <a href="https://github.com/sl1673495/leetcode-javascript">ssh</a>  （给大佬点赞）<br>仓库地址：<a href="https://github.com/sl1673495/leetcode-javascript">https://github.com/sl1673495/leetcode-javascript</a></p></blockquote><p>感谢大佬的归纳总结，原本打算在大佬那里打卡学习，后面考虑不太友好，还是自己新建了一个仓库打卡学习。</p><p>其次，本仓库解题代码大部分是自己的代码风格，题量也进行了拓展，将会持续更新下去，何不star收藏一下？</p><h1 id="仓库介绍"><a href="#仓库介绍" class="headerlink" title="仓库介绍"></a>仓库介绍</h1><blockquote><p>仓库地址：<a href="https://github.com/Chocolate1999/leetcode-javascript">https://github.com/Chocolate1999/leetcode-javascript</a></p></blockquote><p>本仓库将全程使用的语言是 <code>JavaScript</code>，是一个纯前端刷题路线，对于前端刷题没有方向的小伙伴简直是福音。解题代码会记录在本仓库的 <code>Issues</code> 中，会按照 <code>label</code>进行分类。比如想查看 「递归与回溯」 分类下的问题，那么选择标签进行筛选即可。</p><p>同时，小伙伴们可以在 <code>Issues</code> 中提交自己的解题代码，🤝 欢迎 <code>Contributing</code> ，可打卡刷题，坚持下来的人最酷！Give a ⭐️ if this project helped you !</p><h1 id="刷题路线"><a href="#刷题路线" class="headerlink" title="刷题路线"></a>刷题路线</h1><p>下面正式开始我们的刷题之路，给本篇文章点个赞，拿出自己心仪的键盘，开始！</p><blockquote><p>以下专题顺序仅个人以及面试高频点来总结的刷题方式，大家可以根据自己的想法来组合。更多题集请参考本仓库哈~</p></blockquote><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><p><img src= "/img/loading.gif" data-lazy-src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/11ff44ce2bac48368365e677eda3bce2~tplv-k3u1fbpfcp-watermark.image" alt=""></p><h3 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a>15. 三数之和</h3><p><a href="https://leetcode-cn.com/problems/3sum">三数之和原题传送门</a></p><p><strong>题目描述</strong></p><p>给你一个包含 n 个整数的数组 <code>nums</code>，判断 <code>nums</code> 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。</p><p>注意：答案中不可以包含重复的三元组。</p><p>示例：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">给定数组 nums = [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">4</span>]，</span><br><span class="line"></span><br><span class="line">满足要求的三元组集合为：</span><br><span class="line">[</span><br><span class="line">  [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">  [-<span class="number">1</span>, -<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>解题思路</strong></p><p>因为不能有重复的解，为了简化操作，我们先对数组排序，于是判断一个元素是否重复，只需看它和它前面的元素是否相等即可</p><p>双指针的移动时，避免出现重复解</p><p>得到一个解后，需要左右指针向 “内” 收缩，为了避免指向重复的元素</p><ul><li>左指针要在 left &lt; right 的前提下，一直右移，直到指向不重复的元素</li><li>右指针要在 left &lt; right 的前提下，一直左移，直到指向不重复的元素</li></ul><p>优化点，如果当前元素值大于0了，由于我们事先排好序了，不存在三个数相加为0了，此时直接break就好了。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[][]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> threeSum = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> len = nums.length;</span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">2</span>) <span class="keyword">return</span> [];</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    nums.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b); <span class="comment">// 从小到大进行排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len - <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] === nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>; <span class="comment">// 去掉重复项</span></span><br><span class="line">        <span class="keyword">let</span> L = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">let</span> R = len - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (L &lt; R) &#123;</span><br><span class="line">            <span class="keyword">let</span> sum = nums[i] + nums[L] + nums[R]; <span class="comment">// 三数之和</span></span><br><span class="line">            <span class="keyword">if</span> (sum === <span class="number">0</span>) &#123;</span><br><span class="line">                res.push([nums[i], nums[L], nums[R]]);</span><br><span class="line">                <span class="keyword">while</span> (L &lt; R &amp;&amp; nums[L] == nums[L + <span class="number">1</span>]) L++; <span class="comment">// 去重，直到指向不一样的数</span></span><br><span class="line">                <span class="keyword">while</span> (L &lt; R &amp;&amp; nums[R] == nums[R - <span class="number">1</span>]) R--;</span><br><span class="line">                L++;</span><br><span class="line">                R--;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                L++; <span class="comment">// 和小于0，就是左边值太小了，往右移</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                R--; <span class="comment">// 和大于0，就是右边值太大了，往左移</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="16-最接近的三数之和"><a href="#16-最接近的三数之和" class="headerlink" title="16. 最接近的三数之和"></a>16. 最接近的三数之和</h3><p><a href="https://leetcode-cn.com/problems/3sum-closest">16. 最接近的三数之和传送门</a></p><p><strong>题目描述</strong></p><p>给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。</p><p>示例：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">输入：nums = [-<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,-<span class="number">4</span>], target = <span class="number">1</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：与 target 最接近的和是 <span class="number">2</span> (-<span class="number">1</span> + <span class="number">2</span> + <span class="number">1</span> = <span class="number">2</span>) 。</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li>3 &lt;= nums.length &lt;= 10^3</li><li>-10^3 &lt;= nums[i] &lt;= 10^3</li><li>-10^4 &lt;= target &lt;= 10^4</li></ul><p><strong>解题思路</strong></p><p>这道题和15有一点区别，我们只要求最接近 <code>target</code> 的三树之和，那么我们就需要每次更新一下，最接近的和，简单来说就是比较一下，然后本题也没有去重操作，相对来说考虑情况会更少一点。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">target</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> threeSumClosest = <span class="function"><span class="keyword">function</span> (<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> len = nums.length;</span><br><span class="line">    nums.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b); <span class="comment">// 从小到大进行排序</span></span><br><span class="line">    <span class="keyword">let</span> res = nums[<span class="number">0</span>] + nums[<span class="number">1</span>] + nums[len - <span class="number">1</span>]; <span class="comment">// 初始化随机一个res</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len - <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> L = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">let</span> R = len - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (L &lt; R) &#123;</span><br><span class="line">            <span class="keyword">let</span> sum = nums[i] + nums[L] + nums[R]; <span class="comment">// 三数之和</span></span><br><span class="line">            sum &gt; target ? R-- : L++; <span class="comment">// 比目标值大，就往左内缩，小的话，就往右内缩</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">Math</span>.abs(sum - target) &lt; <span class="built_in">Math</span>.abs(res - target)) &#123;</span><br><span class="line">                res = sum; <span class="comment">// 迭代更新res</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="75-颜色分类"><a href="#75-颜色分类" class="headerlink" title="75. 颜色分类"></a>75. 颜色分类</h3><p><a href="https://leetcode-cn.com/problems/sort-colors">75. 颜色分类原题传送门</a></p><p><strong>题目描述</strong></p><p>给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p><p>此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p><p>注意:<br>不能使用代码库中的排序函数来解决这道题。</p><p>示例:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">2</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>]</span><br><span class="line">输出: [<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure><p>进阶：</p><p>一个直观的解决方案是使用计数排序的两趟扫描算法。<br>首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。<br>你能想出一个仅使用常数空间的一趟扫描算法吗？</p><p><strong>解题思路</strong></p><p>双指针，当前值为2，那么就和右边指针进行交换，反之当前值为0，那么就和左边指针进行交换，为1就不动。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;void&#125;</span> </span>Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> sortColors = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> len = nums.length;</span><br><span class="line">    <span class="keyword">let</span> L = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> R = len - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= R) &#123;</span><br><span class="line">        <span class="keyword">while</span> (nums[i] == <span class="number">2</span> &amp;&amp; i &lt; R) &#123; <span class="comment">// 当前值为2，那么就和右边指针进行交换</span></span><br><span class="line">            [nums[i], nums[R]] = [nums[R], nums[i]];</span><br><span class="line">            R--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (nums[i] == <span class="number">0</span> &amp;&amp; i &gt; L) &#123; <span class="comment">// 当前值为0，那么就和左边指针进行交换</span></span><br><span class="line">            [nums[i], nums[L]] = [nums[L], nums[i]];</span><br><span class="line">            L++;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我想下面这份代码应该会更好理解一点：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;void&#125;</span> </span>Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> sortColors = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> len = nums.length;</span><br><span class="line">    <span class="keyword">let</span> L = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> R = len - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= R) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == <span class="number">0</span>) &#123; <span class="comment">// 当前值为0，那么就和左边指针进行交换</span></span><br><span class="line">            [nums[i], nums[L]] = [nums[L], nums[i]];</span><br><span class="line">            L++;</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] == <span class="number">2</span>) &#123; <span class="comment">// 当前值为2，那么就和右边指针进行交换</span></span><br><span class="line">            [nums[i], nums[R]] = [nums[R], nums[i]];</span><br><span class="line">            R--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344. 反转字符串"></a>344. 反转字符串</h3><p><a href="https://leetcode-cn.com/problems/reverse-string">344. 反转字符串原题传送门</a></p><p><strong>题目描述</strong></p><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 <code>char[]</code> 的形式给出。</p><p>不要给另外的数组分配额外的空间，你必须<strong>原地修改输入数组</strong>、使用 O(1) 的额外空间解决这一问题。</p><p>你可以假设数组中的所有字符都是 <code>ASCII</code> 码表中的可打印字符。</p><p>示例 1：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">输入：[<span class="string">&quot;h&quot;</span>,<span class="string">&quot;e&quot;</span>,<span class="string">&quot;l&quot;</span>,<span class="string">&quot;l&quot;</span>,<span class="string">&quot;o&quot;</span>]</span><br><span class="line">输出：[<span class="string">&quot;o&quot;</span>,<span class="string">&quot;l&quot;</span>,<span class="string">&quot;l&quot;</span>,<span class="string">&quot;e&quot;</span>,<span class="string">&quot;h&quot;</span>]</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">输入：[<span class="string">&quot;H&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;n&quot;</span>,<span class="string">&quot;n&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;h&quot;</span>]</span><br><span class="line">输出：[<span class="string">&quot;h&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;n&quot;</span>,<span class="string">&quot;n&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;H&quot;</span>]</span><br></pre></td></tr></table></figure><p><strong>解题思路</strong></p><p>方法一：利用JS原生api</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;character[]&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;void&#125;</span> </span>Do not return anything, modify s in-place instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reverseString = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.reverse();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>方法二：双指针，头尾交换</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;character[]&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;void&#125;</span> </span>Do not return anything, modify s in-place instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reverseString = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>, j = s.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        [s[i], s[j]] = [s[j], s[i]]; <span class="comment">// 双指针，交换</span></span><br><span class="line">        i++ , j--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11. 盛最多水的容器"></a>11. 盛最多水的容器</h3><p><a href="https://leetcode-cn.com/problems/container-with-most-water">11. 盛最多水的容器原题传送门</a></p><p>题目描述<br>给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p><p><strong>说明</strong>：你不能倾斜容器，且 n 的值至少为 2。</p><p><img src= "/img/loading.gif" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cc61c088f5224f3cbeb09475bf856f91~tplv-k3u1fbpfcp-zoom-1.image" alt=""><br>图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</p><p>示例：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">输入：[<span class="number">1</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">7</span>]</span><br><span class="line">输出：<span class="number">49</span></span><br></pre></td></tr></table></figure><p><strong>解题思路</strong></p><p>双指针做法，我们需要枚举所有情况，有一点贪心的思想，每次我们得看短的板子让我们容纳的面积。每次都选择左右指针最短的那个板子，计算出当前容纳的最多的水，然后从短的板子指针出发向内缩，这样不断求，最终我们可以枚举所有情况，自然可以枚举出最大容器面积。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">height</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maxArea = <span class="function"><span class="keyword">function</span> (<span class="params">height</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> len = height.length;</span><br><span class="line">    <span class="keyword">let</span> L = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> R = len - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (L &lt; R) &#123;</span><br><span class="line">        <span class="keyword">if</span> (height[L] &lt; height[R]) &#123;  <span class="comment">// 选择短板效应</span></span><br><span class="line">            <span class="keyword">let</span> ans = height[L] * (R - L);</span><br><span class="line">            L++;</span><br><span class="line">            res = <span class="built_in">Math</span>.max(res, ans); <span class="comment">// 求当前容纳最多的水</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> ans = height[R] * (R - L);</span><br><span class="line">            res = <span class="built_in">Math</span>.max(res, ans);</span><br><span class="line">            R--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42. 接雨水"></a>42. 接雨水</h3><p><a href="https://leetcode-cn.com/problems/trapping-rain-water">42. 接雨水原题传送门</a></p><p><strong>题目描述</strong></p><p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。<br><img src= "/img/loading.gif" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b973a19d3fd34d8a9a4417c6cb228968~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>上面是由数组 <code>[0,1,0,2,1,0,1,3,2,1,2,1]</code>表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 感谢 Marcos 贡献此图。</p><p>示例:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出: <span class="number">6</span></span><br></pre></td></tr></table></figure><p><strong>解题思路</strong></p><p>这个存放水，我们就需要看左边两边指针的柱子看谁的高度小了，当前是看高度小的了。</p><p>以左边为例：当前柱子存水量 = 最近最高柱子高度（只看左边到当前柱子） - 当前柱子高度</p><p>右边同理。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">height</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> trap = <span class="function"><span class="keyword">function</span> (<span class="params">height</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> len = height.length;</span><br><span class="line">    <span class="keyword">let</span> L = <span class="number">0</span>, R = len - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> leftHeight = <span class="number">0</span>, rightHeight = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (L &lt; R) &#123;</span><br><span class="line">        <span class="keyword">if</span> (height[L] &lt; height[R]) &#123; <span class="comment">// 左边高度小，当然看左边</span></span><br><span class="line">            leftHeight = <span class="built_in">Math</span>.max(leftHeight, height[L]);</span><br><span class="line">            res += leftHeight - height[L]; <span class="comment">// 当前柱子能存放的水</span></span><br><span class="line">            L++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 右边高度小，看右边</span></span><br><span class="line">            rightHeight = <span class="built_in">Math</span>.max(rightHeight, height[R]);</span><br><span class="line">            res += rightHeight - height[R]; <span class="comment">// 当前柱子能存放的水</span></span><br><span class="line">            R--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209. 长度最小的子数组"></a>209. 长度最小的子数组</h3><p><a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum">209. 长度最小的子数组</a></p><p><strong>题目描述</strong></p><p>给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。</p><p>示例：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">输入：s = <span class="number">7</span>, nums = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：子数组 [<span class="number">4</span>,<span class="number">3</span>] 是该条件下的长度最小的子数组。</span><br></pre></td></tr></table></figure><p>进阶：</p><ul><li>如果你已经完成了 O(n) 时间复杂度的解法, 请尝试 O(n log n) 时间复杂度的解法。</li></ul><p><strong>解题思路</strong></p><p>滑动窗口，利用双指针实现，从左到右看，满足条件就把左指针左移，找到最小的长度，然后每次窗口右指针都往右滑动，直到数组末尾。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> minSubArrayLen = <span class="function"><span class="keyword">function</span> (<span class="params">s, nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> len = nums.length;</span><br><span class="line">    <span class="keyword">let</span> L = <span class="number">0</span>, R = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="literal">Infinity</span>, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (R &lt; len) &#123;</span><br><span class="line">        sum += nums[R];</span><br><span class="line">        <span class="keyword">while</span> (sum &gt;= s) &#123; <span class="comment">// 滑动窗口</span></span><br><span class="line">            res = <span class="built_in">Math</span>.min(res, R - L + <span class="number">1</span>);</span><br><span class="line">            sum -= nums[L];</span><br><span class="line">            L++;</span><br><span class="line">        &#125;</span><br><span class="line">        R++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res == <span class="literal">Infinity</span> ? <span class="number">0</span> : res; <span class="comment">// 判断合法性</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="925-长按键入"><a href="#925-长按键入" class="headerlink" title="925. 长按键入"></a>925. 长按键入</h3><p><a href="https://leetcode-cn.com/problems/long-pressed-name">925. 长按键入</a></p><p><strong>题目描述</strong></p><p>你的朋友正在使用键盘输入他的名字 <code>name</code>。偶尔，在键入字符 <code>c</code> 时，按键可能会被长按，而字符可能被输入 1 次或多次。</p><p>你将会检查键盘输入的字符 <code>typed</code>。如果它对应的可能是你的朋友的名字（其中一些字符可能被长按），那么就返回 <code>True</code>。</p><p>示例 1：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">输入：name = <span class="string">&quot;alex&quot;</span>, typed = <span class="string">&quot;aaleex&quot;</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：<span class="string">&#x27;alex&#x27;</span> 中的 <span class="string">&#x27;a&#x27;</span> 和 <span class="string">&#x27;e&#x27;</span> 被长按。</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">输入：name = <span class="string">&quot;saeed&quot;</span>, typed = <span class="string">&quot;ssaaedd&quot;</span></span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：<span class="string">&#x27;e&#x27;</span> 一定需要被键入两次，但在 typed 的输出中不是这样。</span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">输入：name = <span class="string">&quot;leelee&quot;</span>, typed = <span class="string">&quot;lleeelee&quot;</span></span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure><p>示例 4：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">输入：name = <span class="string">&quot;laiden&quot;</span>, typed = <span class="string">&quot;laiden&quot;</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：长按名字中的字符并不是必要的。</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li><code>name.length</code> &lt;= 1000</li><li><code>typed.length</code> &lt;= 1000</li><li><code>name</code> 和 <code>typed</code> 的字符都是小写字母。</li></ul><p><strong>解题思路</strong></p><p>显而易见，采用双指针做法，通过 <code>cnt</code> 计数统计字符匹配成功个数，然后通过双指针进行比较匹配，其中有几个地方注意一下：</p><ul><li>如果 <code>typed</code> 和 <code>name</code> 的当前索引前一位都不相等的话，那么名字就不对应，直接跳出去，这里算是小小的优化了一下。</li><li>当 <code>typed</code> 走完才能跳出去，如果是 <code>i == n</code>  就跳出去的话，这种情况：name：abc | typed：abcd 就会判断出错</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">name</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">typed</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isLongPressedName = <span class="function"><span class="keyword">function</span> (<span class="params">name, typed</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> n = name.length; <span class="comment">// 求出字符串长度</span></span><br><span class="line">    <span class="keyword">let</span> m = typed.length;</span><br><span class="line">    <span class="keyword">let</span> cnt = <span class="number">0</span>; <span class="comment">// 统计匹配成功个数</span></span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>, j = <span class="number">0</span>; <span class="comment">// 双指针</span></span><br><span class="line">    <span class="keyword">let</span> flag = <span class="literal">false</span>; <span class="comment">// 判断是否中途遇到不匹配阶段</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (name[i] == typed[j]) &#123; <span class="comment">// 匹配成功</span></span><br><span class="line">            i++ , cnt++ , j++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (typed[j] == name[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果 typed 和 name 当前索引前一位都不相等的话，那么名字就不对应，直接跳出去</span></span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (j == m) <span class="keyword">break</span>; <span class="comment">// 当 typed走完才能跳出去，如果是 i == n  就跳出去的话，这种情况：abc | abcd 就会判断出错</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cnt === n &amp;&amp; j === m) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="763-划分字母区间"><a href="#763-划分字母区间" class="headerlink" title="763. 划分字母区间"></a>763. 划分字母区间</h3><p><a href="https://leetcode-cn.com/problems/partition-labels">763. 划分字母区间原题传送门</a></p><p><strong>题目描述</strong></p><p>字符串 <code>S</code> 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一个字母只会出现在其中的一个片段。返回一个表示每个字符串片段的长度的列表。</p><p>示例 1：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">输入：S = <span class="string">&quot;ababcbacadefegdehijhklij&quot;</span></span><br><span class="line">输出：[<span class="number">9</span>,<span class="number">7</span>,<span class="number">8</span>]</span><br><span class="line">解释：</span><br><span class="line">划分结果为 <span class="string">&quot;ababcbaca&quot;</span>, <span class="string">&quot;defegde&quot;</span>, <span class="string">&quot;hijhklij&quot;</span>。</span><br><span class="line">每个字母最多出现在一个片段中。</span><br><span class="line">像 <span class="string">&quot;ababcbacadefegde&quot;</span>, <span class="string">&quot;hijhklij&quot;</span> 的划分是错误的，因为划分的片段数较少。</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li><code>S</code> 的长度在 <code>[1, 500]</code> 之间。</li><li><code>S</code> 只包含小写字母 <code>&#39;a&#39;</code> 到 <code>&#39;z&#39;</code> 。</li></ul><p><strong>解题思路</strong></p><p>此题是一个挺有意思的题，既有<strong>贪心</strong>的味道，又有<strong>双指针</strong>的味道，下面说一下解题思路：</p><p>首先维护一个 <code>map</code>，它用来统计字当前字母的位置，而我们通过遍历就可以记录得到每个字母的最远位置。</p><p>然后，再次遍历字符串时，我们既可以得到当前字母的最远位置，根据贪心思想，为了让同一个字母只会出现在其中的一个片段，那么对于这个字母一定要是最远位置，我们就可以得到一个<strong>范围区间</strong>，即 <code>maxLen</code>。</p><p>得到了 <code>maxLen</code>后，我们还需要让 <code>i</code> 指针，即<strong>尾指针</strong>走到这个地方才算我们可以切分的片段。</p><p>（想想，如果不走到 <code>maxLen</code>的话，这个范围区间内的字母可能会有更远的位置，那么就无法满足让同一个字母只会出现在其中的一个片段这个条件了）</p><p><img src= "/img/loading.gif" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8bc1ca9e7b364e56879af9717c58b243~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>参考 <a href="https://leetcode-cn.com/problems/partition-labels/solution/shou-hua-tu-jie-hua-fen-zi-mu-qu-jian-ji-lu-zui-yu/">笨猪爆破组</a> 大佬图解。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">S</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> partitionLabels = <span class="function"><span class="keyword">function</span> (<span class="params">S</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> map = &#123;&#125;; <span class="comment">// 用来统计当前字母最远位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; S.length; i++) &#123;</span><br><span class="line">        map[S[i]] = i; <span class="comment">// 存储当前字母当前位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> start = <span class="number">0</span>; <span class="comment">// 头指针</span></span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">let</span> maxLen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; S.length; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> curMaxLen = map[S[i]];</span><br><span class="line">        maxLen = <span class="built_in">Math</span>.max(maxLen, curMaxLen); <span class="comment">// 计算出当前区间范围是否还可以继续扩大区间</span></span><br><span class="line">        <span class="keyword">if</span> (i === maxLen) &#123;</span><br><span class="line">            <span class="keyword">let</span> tmp = i - start + <span class="number">1</span>;</span><br><span class="line">            start = i + <span class="number">1</span>;</span><br><span class="line">            res.push(tmp);  <span class="comment">// 划分片段</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p><img src= "/img/loading.gif" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/267f581f3a894afa8145705f37232e59~tplv-k3u1fbpfcp-watermark.image" alt=""></p><h3 id="459-重复的子字符串"><a href="#459-重复的子字符串" class="headerlink" title="459. 重复的子字符串"></a>459. 重复的子字符串</h3><p><a href="https://leetcode-cn.com/problems/repeated-substring-pattern">459. 重复的子字符串原题传送门</a></p><p><strong>题目描述</strong></p><p>给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。</p><p>示例 1:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">输入: <span class="string">&quot;abab&quot;</span></span><br><span class="line"></span><br><span class="line">输出: True</span><br><span class="line"></span><br><span class="line">解释: 可由子字符串 <span class="string">&quot;ab&quot;</span> 重复两次构成。</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">输入: <span class="string">&quot;aba&quot;</span></span><br><span class="line"></span><br><span class="line">输出: False</span><br></pre></td></tr></table></figure><p>示例 3:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">输入: <span class="string">&quot;abcabcabcabc&quot;</span></span><br><span class="line"></span><br><span class="line">输出: True</span><br><span class="line"></span><br><span class="line">解释: 可由子字符串 <span class="string">&quot;abc&quot;</span> 重复四次构成。 (或者子字符串 <span class="string">&quot;abcabc&quot;</span> 重复两次构成。)</span><br></pre></td></tr></table></figure><p><strong>解题思路</strong></p><p>对于样例字符串，看是否由字符串的其中一个子串重复构成，我们可以将原字符串与自己拼接一次，然后从原字符串第1位（从0开始）找，看是否会找到拼接之后的字符串起始位，即 <code>s.length</code> 处，那么就不存在重复构成这样情况，否则，就存在，返回 <code>True</code>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> repeatedSubstringPattern = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (s+s).indexOf(s,<span class="number">1</span>) !== s.length</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>说明：</p><p>我想会有小伙伴疑惑，诶，为啥字符串这一块就这一道题呢？</p><p>首先，整理这一系列文章，主要是给大家提供一些刷题路线思路，题是千变万化的，并且一道题可能有很多种解题方式，我列举的题目大多数是我遇到过的原题，一份入门指南。其次，对于字符串而言，大部分都是与其它算法扯上关系，比如:</p><ul><li><a href="https://leetcode-cn.com/problems/generate-parentheses/">22. 括号生成</a>（回溯）</li><li><a href="https://leetcode-cn.com/problems/valid-parentheses/">20. 有效的括号</a>（栈）</li><li><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/">17. 电话号码的字母组合</a>（回溯、dfs）</li></ul><blockquote><p>另外，给大家提及一下，字符串这块考察范围多一点的就是回文，以及相关牵扯到的一系列问题，比如：马拉车算法、最长回文子串问题、如何判断一个回文、最长公共前缀等等，这些在 <code>leetcode</code> 上都是有原题的，而 <strong>马拉车</strong> 算法在笔试以及面试的时候我经常遇到，犹记得当时是面字节跳动公司遇到的，先从回文考察，最后牵扯到 <code>Manacher</code> 算法，如果你还没有听说过这个算法，挺好的，至少这篇文章帮助到你了，赶快去了解一下吧~</p></blockquote><p>至于电话号码的字母组合这道题在上一篇遗漏掉了，这是我2020年春招腾讯面试的真题，当时就被这道题给卡住了，后面发现其实也不是很难，现在来补充一下：</p><h3 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17. 电话号码的字母组合"></a>17. 电话号码的字母组合</h3><p> <a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/">17. 电话号码的字母组合原题传送门</a>（回溯、dfs）</p><p><strong>题目描述</strong></p><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><p><img src= "/img/loading.gif" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1b86d33d03fd424aadc097a9a2e3592f~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>示例:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">输入：<span class="string">&quot;23&quot;</span></span><br><span class="line">输出：[<span class="string">&quot;ad&quot;</span>, <span class="string">&quot;ae&quot;</span>, <span class="string">&quot;af&quot;</span>, <span class="string">&quot;bd&quot;</span>, <span class="string">&quot;be&quot;</span>, <span class="string">&quot;bf&quot;</span>, <span class="string">&quot;cd&quot;</span>, <span class="string">&quot;ce&quot;</span>, <span class="string">&quot;cf&quot;</span>].</span><br></pre></td></tr></table></figure><p>说明:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。</span><br></pre></td></tr></table></figure><p><strong>解题思路</strong></p><p>采用回溯做法，对于当前选项，我们可以重复选择，所以 <code>for</code> 循环那里从 0 开始，对于字母组合我们做一个 <code>map</code>映射即可。</p><p><img src= "/img/loading.gif" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0fe99b3d9ef84f05aaf2cd95919f5b97~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>参考 <a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/solution/shou-hua-tu-jie-liang-chong-jie-fa-dfshui-su-bfsya/">xiao_ben_zhu</a> 大佬的图解</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> letterCombinations = <span class="function"><span class="keyword">function</span> (<span class="params">digits</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!digits.length) <span class="keyword">return</span> [];</span><br><span class="line">  <span class="comment">// 直接映射</span></span><br><span class="line">  <span class="keyword">const</span> map = &#123; <span class="string">&#x27;2&#x27;</span>: <span class="string">&#x27;abc&#x27;</span>, <span class="string">&#x27;3&#x27;</span>: <span class="string">&#x27;def&#x27;</span>, <span class="string">&#x27;4&#x27;</span>: <span class="string">&#x27;ghi&#x27;</span>, <span class="string">&#x27;5&#x27;</span>: <span class="string">&#x27;jkl&#x27;</span>, <span class="string">&#x27;6&#x27;</span>: <span class="string">&#x27;mno&#x27;</span>, <span class="string">&#x27;7&#x27;</span>: <span class="string">&#x27;pqrs&#x27;</span>, <span class="string">&#x27;8&#x27;</span>: <span class="string">&#x27;tuv&#x27;</span>, <span class="string">&#x27;9&#x27;</span>: <span class="string">&#x27;wxyz&#x27;</span> &#125;;</span><br><span class="line">  <span class="keyword">let</span> res = [];</span><br><span class="line">  <span class="keyword">let</span> dfs = <span class="function">(<span class="params">cur, start</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt;= digits.length) &#123;</span><br><span class="line">      res.push(cur);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 取当前可选的字母组合</span></span><br><span class="line">    <span class="keyword">let</span> str = map[digits[start]];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">      dfs(cur + str[i], start + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  dfs(<span class="string">&#x27;&#x27;</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>解法2</p><p>这个是没用回溯之前写的一份代码，简单来说就是利用了<strong>层次遍历</strong>的特性，反正每次取字母都是可以重复的，直接遍历即可，然后进队列。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> letterCombinations = <span class="function"><span class="keyword">function</span>(<span class="params">digits</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!digits.length) <span class="keyword">return</span> []</span><br><span class="line">  <span class="keyword">const</span> map = &#123; <span class="string">&#x27;2&#x27;</span>: <span class="string">&#x27;abc&#x27;</span>, <span class="string">&#x27;3&#x27;</span>: <span class="string">&#x27;def&#x27;</span>, <span class="string">&#x27;4&#x27;</span>: <span class="string">&#x27;ghi&#x27;</span>, <span class="string">&#x27;5&#x27;</span>: <span class="string">&#x27;jkl&#x27;</span>, <span class="string">&#x27;6&#x27;</span>: <span class="string">&#x27;mno&#x27;</span>, <span class="string">&#x27;7&#x27;</span>: <span class="string">&#x27;pqrs&#x27;</span>, <span class="string">&#x27;8&#x27;</span>: <span class="string">&#x27;tuv&#x27;</span>, <span class="string">&#x27;9&#x27;</span>: <span class="string">&#x27;wxyz&#x27;</span> &#125;;</span><br><span class="line">  <span class="keyword">let</span> queue = []</span><br><span class="line">  queue.push(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;digits.length;i++)&#123;</span><br><span class="line">      <span class="keyword">let</span> size = queue.length</span><br><span class="line">      <span class="keyword">while</span>(size--)&#123;</span><br><span class="line">          <span class="keyword">let</span> cur = queue.shift()</span><br><span class="line">          <span class="keyword">let</span> str = map[digits[i]]</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">0</span>;j&lt;str.length;j++)&#123;</span><br><span class="line">              queue.push(cur+str[j])</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> queue</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="本文参考"><a href="#本文参考" class="headerlink" title="本文参考"></a>本文参考</h2><ul><li><a href="https://juejin.cn/post/6844903919722692621">前端该如何准备数据结构和算法？</a></li><li><a href="https://juejin.cn/post/6847009772500156429">写给前端的算法进阶指南，我是如何两个月零基础刷200题</a></li><li><a href="https://juejin.cn/post/6844904061947346957">(1.8w字)负重前行，前端工程师如何系统练习数据结构和算法？【上】</a></li><li>leetcode &amp;&amp; leetcode各位题解大佬们，感谢你们~</li></ul><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>❤️关注+点赞+收藏+评论+转发❤️，原创不易，您的支持将会是我最大的动力~</p><p><a href="https://yangchaoyi.vip/">访问超逸の博客</a>，方便小伙伴阅读玩耍~</p><p>最后，祝各位新年快乐，牛年大吉，好运++，在准备春招の你，能够早点结束春招，offer拿到手软，希望我的文章能够帮助到你，我们很快会在下期相遇~</p><blockquote><p>快来关注我吧，学习前端虽然很“苦”，但有 一百个Chocolate 的文章会更“甜”~</p></blockquote><p>【作者：一百个Chocolate】<a href="https://juejin.cn/user/2981531267112520/posts">https://juejin.cn/user/2981531267112520/posts</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【建议前端必刷】 用 js 刷LeetCode 算法专题（全）</title>
      <link href="posts/2020612/"/>
      <url>posts/2020612/</url>
      
        <content type="html"><![CDATA[<h2 id="写作初心"><a href="#写作初心" class="headerlink" title="写作初心"></a>写作初心</h2><h3 id="提问：为什么要学习数据结构和算法？"><a href="#提问：为什么要学习数据结构和算法？" class="headerlink" title="提问：为什么要学习数据结构和算法？"></a>提问：为什么要学习数据结构和算法？</h3><p>如果你能明确这个问题的答案，just do it ！直接跳过后面内容，开始刷题就好了。</p><h4 id="解决问题的思想"><a href="#解决问题的思想" class="headerlink" title="解决问题的思想"></a>解决问题的思想</h4><p>计算机只是一个很冰冷的机器，你给他下发什么样的指令，它就能作出什么样的反应。<br>而开发工程师要做的是如何把实际的问题转化成计算机的指令，如何转化，来看看《数据结构》的经典说法：</p><blockquote><p>设计出数据结构， 在施加以算法就行了。</p></blockquote><p>所以，很重要的一点，数据结构和算法对建立解决问题的思想非常重要。</p><blockquote><p>如果说 Java 是自动档轿车，C 就是手动档吉普。数据结构呢？是变速箱的工作原理。你完全可以不知道变速箱怎样工作，就把自动档的车子从 A 开到 B，而且未必就比懂得的人慢。写程序这件事，和开车一样，经验可以起到很大作用，但如果你不知道底层是怎么工作的，就永远只能开车，既不会修车，也不能造车。如果你对这两件事都不感兴趣也就罢了，数据结构懂得用就好。但若你此生在编程领域还有点更高的追求，数据结构是绕不开的课题。</p></blockquote><h4 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h4><p>这是非常现实的一点，也是很多前端学习数据结构和算法的原因。</p><p>一般对待算法的态度会分为以下几类：</p><ul><li><p><code>Google</code> 、<code>Microsoft</code> 等知名外企在面试工程师时，算法是起决定性因素的，前端工程师也是一样，基本是每一轮都会考察，即使你有非常强的背景，也有可能因为一两道算法答的不好而与这样的企业失之交臂。</p></li><li><p>第二类，算法占重要因素的，国内的某些大厂在面试时，也会把数据结构和算法作为重要的参考因素，基本是面试必考，如果你达不到一定的要求，会直接挂掉。</p></li><li><p>第三类，起加分作用，很多公司不会把数据结构和算法作为硬性要求，但是也会象征性的出一些题目，当你把一道算法题答的很漂亮，这绝对是加分项。</p></li></ul><p>可见，学好数据结构和算法对你跳槽更好的公司或者拿到更高的薪水，是非常重要的。</p><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>一个算法的时间复杂度反映了程序运行从开始到结束所需要的时间。把算法中基本操作重复执行的次数（频度）作为算法的时间复杂度。</p><p>没有循环语句，记作 <code>O(1)</code>，也称为常数阶。只有一重循环，则算法的基本操作的执行频度与问题规模n呈线性增大关系，记作 <code>O（n）</code>，也叫线性阶。</p><p>常见的时间复杂度有：</p><ul><li><code>O(1)</code>: Constant Complexity: Constant 常数复杂度</li><li><code>O(log n)</code>: Logarithmic Complexity: 对数复杂度</li><li><code>O(n)</code>: Linear Complexity: 线性时间复杂度</li><li><code>O(n^2)</code>: N square Complexity 平⽅方</li><li><code>O(n^3)</code>: N square Complexity ⽴立⽅方</li><li><code>O(2^n)</code>: Exponential Growth 指数</li><li><code>O(n!)</code>: Factorial 阶乘</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200612122631963.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>一个程序的空间复杂度是指运行完一个程序所需内存的大小。利用程序的空间复杂度，可以对程序的运行所需要的内存多少有个预先估计。</p><p>一个程序执行时除了需要存储空间和存储本身所使用的指令、常数、变量和输入数据外，还需要一些对数据进行操作的工作单元和存储一些为现实计算所需信息的辅助空间。</p><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><blockquote><p>选择一个目标值，比目标值小的放左边，比目标值大的放右边，目标值的位置已排好，将左右两侧再进行快排。</p></blockquote><h4 id="写法1"><a href="#写法1" class="headerlink" title="写法1"></a>写法1</h4><p>需要开辟空间，如下代码所示，开辟两个存储空间 <code>left</code> 和 <code>right</code> ，每次递归直接返回 <code>left</code> 、<code>tmp</code>、<code>right</code> 拼接后的数组。</p><p>不过此方法写法比较简单 ，但需要一些空间来换。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr=[<span class="number">1</span>,<span class="number">12</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr.length&lt;=<span class="number">1</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    <span class="keyword">var</span> mid = <span class="built_in">Math</span>.floor(arr.length/<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">var</span> tmp = arr.splice(mid,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">var</span> left = [];</span><br><span class="line">    <span class="keyword">var</span> right = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] &lt; tmp)&#123;</span><br><span class="line">            left.push(arr[i]);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            right.push(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> quickSort(left).concat(tmp,quickSort(right)); <span class="comment">//返回拼接数组</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(quickSort(arr));</span><br></pre></td></tr></table></figure><h4 id="写法2"><a href="#写法2" class="headerlink" title="写法2"></a>写法2</h4><p>记录一个索引 <code>le</code> 从数组最左侧开始，记录一个索引 <code>re</code> 从数组右侧开始</p><p>在 <code>le</code> &lt; <code>re</code> 的条件下，找到右侧小于 <code>target</code> 的值 <code>arr[re]</code>，并将其赋值到 <code>arr[le]</code></p><p>在 <code>le</code> &lt; <code>re</code>的条件下，找到左侧大于 <code>target</code> 的值 <code>arr[le]</code> ，并将其赋值到 <code>arr[re]</code> </p><p>这样让 <code>le=re</code>时，左侧的值全部小于 <code>target</code> ，右侧的值全部小于 <code>target</code>，将 <code>target</code> 放到该位置</p><p>此方法不需要额外存储空间，但写法思路稍有复杂。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr=[<span class="number">1</span>,<span class="number">12</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">arr,start,end</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(end-start&lt;<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">const</span> target = arr[start];</span><br><span class="line">    <span class="keyword">let</span> le = start;</span><br><span class="line">    <span class="keyword">let</span> re = end;</span><br><span class="line">    <span class="keyword">while</span>(le &lt; re)&#123;</span><br><span class="line">        <span class="keyword">while</span>(le&lt;re &amp;&amp; arr[re]&gt;=target) re--;</span><br><span class="line">        arr[le] = arr[re];</span><br><span class="line">        <span class="keyword">while</span>(le&lt;re &amp;&amp; arr[le]&lt;target) le++;</span><br><span class="line">        arr[re] = arr[le];</span><br><span class="line">    &#125;</span><br><span class="line">    arr[le] = target;</span><br><span class="line">    quickSort(arr,start,le-<span class="number">1</span>);</span><br><span class="line">    quickSort(arr,le+<span class="number">1</span>,end);</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(quickSort(arr,<span class="number">0</span>,arr.length-<span class="number">1</span>));</span><br></pre></td></tr></table></figure><p>时间复杂度：平均 <code>O(nlogn)</code>，最坏 <code>O(n2)</code>，实际上大多数情况下小于 <code>O(nlogn)</code></p><p>空间复杂度: <code>O(logn)</code>（递归调用消耗）</p><p>不稳定的排序</p><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><blockquote><p>循环数组，比较当前元素和下一个元素，如果当前元素比下一个元素大，向上冒泡。下一次循环继续上面的操作，不循环已经排序好的数。</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr=[<span class="number">1</span>,<span class="number">12</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr.length&lt;=<span class="number">1</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    <span class="keyword">let</span> len = arr.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">0</span>;j&lt;len-<span class="number">1</span>-i;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">                [arr[j],arr[j+<span class="number">1</span>]] = [arr[j+<span class="number">1</span>],arr[j]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(bubbleSort(arr));</span><br></pre></td></tr></table></figure><p>时间复杂度：<code>O(n2)</code></p><p>空间复杂度: <code>O(1)</code></p><p>稳定的排序</p><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><blockquote><p>每次排序取一个最大或最小的数字放到前面的有序序列中。</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr=[<span class="number">1</span>,<span class="number">12</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectSort</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr.length&lt;=<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">let</span> len=arr.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">let</span> minx=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=i;j&lt;len;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j]&lt;arr[minx])&#123;</span><br><span class="line">                minx=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        [arr[i],arr[minx]] = [arr[minx],arr[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(selectSort(arr));</span><br></pre></td></tr></table></figure><p>时间复杂度：<code>O(n2)</code></p><p>空间复杂度: <code>O(1)</code></p><p>不稳定的排序</p><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><blockquote><p>将左侧序列看成一个有序序列，每次将一个数字插入该有序序列。插入时，从有序序列最右侧开始比较，若比较的数较大，后移一位。</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr=[<span class="number">1</span>,<span class="number">12</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertSort</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr.length&lt;=<span class="number">1</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    <span class="keyword">let</span> len=arr.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">let</span> minx=arr[i];</span><br><span class="line">        <span class="keyword">let</span> j;</span><br><span class="line">        <span class="keyword">for</span>(j=i-<span class="number">1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j]&lt;minx) <span class="keyword">break</span>;</span><br><span class="line">            arr[j+<span class="number">1</span>]=arr[j];</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j+<span class="number">1</span>]=minx;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(insertSort(arr));</span><br></pre></td></tr></table></figure><p>时间复杂度：<code>O(n2)</code></p><p>空间复杂度: <code>O(1)</code></p><p>稳定的排序</p><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><blockquote><p>将大序列二分成小序列，将小序列排序后再将排序后的小序列归并成大序列。</p></blockquote><h4 id="写法1-1"><a href="#写法1-1" class="headerlink" title="写法1"></a>写法1</h4><p>分割数组时直接将数组分割为两个数组，合并时直接合并数组。</p><p>优点：思路简单，写法简单</p><p>缺点：空间复杂度略高，需要复制多个数组</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr=[<span class="number">1</span>,<span class="number">12</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeSort</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr.length&lt;=<span class="number">1</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    <span class="keyword">let</span> mid = <span class="built_in">Math</span>.floor(arr.length/<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">const</span> left = arr.slice(<span class="number">0</span>,mid);</span><br><span class="line">    <span class="keyword">const</span> right = arr.slice(mid);</span><br><span class="line">    <span class="keyword">return</span> merge(mergeSort(left),mergeSort(right));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params">left,right</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> ans = [];</span><br><span class="line">    <span class="keyword">while</span>(left.length &amp;&amp; right.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(left[<span class="number">0</span>]&lt;right[<span class="number">0</span>]) ans.push(left.shift());</span><br><span class="line">        <span class="keyword">else</span> ans.push(right.shift());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(left.length) ans.push(left.shift());</span><br><span class="line">    <span class="keyword">while</span>(right.length) ans.push(right.shift());</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(mergeSort(arr));</span><br></pre></td></tr></table></figure><h4 id="写法2-1"><a href="#写法2-1" class="headerlink" title="写法2"></a>写法2</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr=[<span class="number">1</span>,<span class="number">12</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeSort</span>(<span class="params">arr,left,right,tmp</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr.length&lt;=<span class="number">1</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    <span class="keyword">if</span>(left&lt;right)&#123;</span><br><span class="line">        <span class="keyword">let</span> mid = <span class="built_in">Math</span>.floor((left+right)/<span class="number">2</span>);</span><br><span class="line">        mergeSort(arr,left,mid,tmp);</span><br><span class="line">        mergeSort(arr,mid+<span class="number">1</span>,right,tmp);</span><br><span class="line">        merge(arr,left,right,tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params">arr,left,right,tmp</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> mid = <span class="built_in">Math</span>.floor((left+right)/<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">let</span> le = left;</span><br><span class="line">    <span class="keyword">let</span> re = mid+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(le&lt;=mid &amp;&amp; re&lt;=right)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[le]&lt;arr[re])&#123;</span><br><span class="line">            tmp[cnt++]=arr[le++];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            tmp[cnt++]=arr[re++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(le&lt;=mid)&#123;</span><br><span class="line">        tmp[cnt++]=arr[le++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(re&lt;=right)&#123;</span><br><span class="line">        tmp[cnt++]=arr[re++];</span><br><span class="line">    &#125;</span><br><span class="line">    cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=left;i&lt;=right;i++)&#123;</span><br><span class="line">        arr[i]=tmp[cnt++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(mergeSort(arr,<span class="number">0</span>,arr.length-<span class="number">1</span>,[]));</span><br></pre></td></tr></table></figure><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><blockquote><p>创建一个大顶堆，大顶堆的堆顶一定是最大的元素。交换第一个元素和最后一个元素，让剩余的元素继续调整为大顶堆。从后往前以此和第一个元素交换并重新构建，排序完成。</p></blockquote><p><a href="https://juejin.im/post/5cb8714be51d456e6154b425">推荐阅读：搞定JavaScript算法系列–堆排序</a></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr=[<span class="number">1</span>,<span class="number">12</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">heapSort</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr.length&lt;=<span class="number">1</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    createHeap(arr);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=arr.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        [arr[i],arr[<span class="number">0</span>]] = [arr[<span class="number">0</span>],arr[i]];</span><br><span class="line">        adjust(arr,<span class="number">0</span>,i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建大顶堆</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createHeap</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> len = arr.length;</span><br><span class="line">    <span class="keyword">const</span> start = <span class="built_in">parseInt</span>(len/<span class="number">2</span>)-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=start;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        adjust(arr,i,len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//下沉操作</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">adjust</span>(<span class="params">arr,target,len</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">2</span>*target+<span class="number">1</span>;i&lt;len;i=<span class="number">2</span>*i+<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//找到孩子节点中最大的</span></span><br><span class="line">        <span class="keyword">if</span>(i+<span class="number">1</span>&lt;len &amp;&amp; arr[i+<span class="number">1</span>]&gt;arr[i])&#123;</span><br><span class="line">            i=i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//下沉</span></span><br><span class="line">        <span class="keyword">if</span>(arr[i]&gt;arr[target])&#123;</span><br><span class="line">            [arr[i],arr[target]] = [arr[target],arr[i]];</span><br><span class="line">            target=i;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(heapSort(arr));</span><br></pre></td></tr></table></figure><h2 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h2><p><a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/">面试题51. 数组中的逆序对</a></p><h3 id="面试题51-数组中的逆序对"><a href="#面试题51-数组中的逆序对" class="headerlink" title="面试题51. 数组中的逆序对"></a>面试题51. 数组中的逆序对</h3><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> reversePairs = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    sum=<span class="number">0</span>;</span><br><span class="line">    mergeSort(nums);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeSort</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr.length&lt;=<span class="number">1</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    <span class="keyword">let</span> mid = <span class="built_in">Math</span>.floor(arr.length/<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">const</span> left = arr.slice(<span class="number">0</span>,mid);</span><br><span class="line">    <span class="keyword">const</span> right = arr.slice(mid);</span><br><span class="line">    <span class="keyword">return</span> merge(mergeSort(left),mergeSort(right));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params">left,right</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> ans = [];</span><br><span class="line">    <span class="keyword">while</span>(left.length &amp;&amp; right.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(left[<span class="number">0</span>]&lt;=right[<span class="number">0</span>]) ans.push(left.shift());</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            sum+=left.length;</span><br><span class="line">            ans.push(right.shift());</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(left.length) ans.push(left.shift());</span><br><span class="line">    <span class="keyword">while</span>(right.length) ans.push(right.shift());</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><p>时间复杂度O(nlogn)</p><p>空间复杂度O(n)</p><p>有了之前归并排序的例子了，解决这道题就是小菜一碟了，本人还是觉得上述代码写的比较得心应手，写法2不容易掌握，那就还是用写法1吧，虽然会占用一点空间，但是可以快速而且简单地 <code>ac</code>这道 <strong>困难</strong> 题，对，你没看错，这就是 <code>leecode</code> 上面一道面试常考的一道 <strong>困难题</strong>，就考察了分治的思想，直接归并代码码上！</p><p>下面贴一个解题思路：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">这个题解假设你已经明白归并排序的原理。</span><br><span class="line"></span><br><span class="line">就以arr = [<span class="number">7</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>]这个例子来讲解为什么一遍归并排序就看可以解决逆序对的问题。</span><br><span class="line"></span><br><span class="line">按照归并排序的思路，会将arr分解为arrL = [<span class="number">7</span>,<span class="number">5</span>],arrR = [<span class="number">6</span>,<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">继续分解为arrLL = [<span class="number">7</span>], arrLR = [<span class="number">5</span>]; arrRL = [<span class="number">6</span>], arrRR = [<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">自此分解完成。</span><br><span class="line"></span><br><span class="line">接下来合并：</span><br><span class="line"></span><br><span class="line">假设i为arrLL的数组下标，j为arrLR的数组下标, index为新数组res的下标，初始值都为<span class="number">0</span></span><br><span class="line"></span><br><span class="line">首先arrLL与arrLR合并，因为arrLL[i] &gt; arrLRj，</span><br><span class="line"></span><br><span class="line">所以可以说明arrLL中<span class="number">7</span>及其之后的所有数字都大于arrLR中的<span class="number">5</span>，</span><br><span class="line"></span><br><span class="line">也就是说<span class="number">7</span>及其之后的所有元素都可以与<span class="number">5</span>组成逆序对，</span><br><span class="line"></span><br><span class="line">所以此时<span class="number">7</span>及其之后的所有元素个数（leftLen - i）即我们要的逆序对数，需要添加到结果sum中。即sum += leftLen - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">（这也就是此算法高效的地方，一次可以查找到好多次的逆序对数，而且不会重复）</span><br><span class="line"></span><br><span class="line">合并之后为arrL=[<span class="number">5</span>,<span class="number">7</span>].</span><br><span class="line"></span><br><span class="line">根据上述方法将arrRL和arrRR合并为arrR=[<span class="number">4</span>,<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line">现在将arrL和arrR合并为arr：</span><br><span class="line"></span><br><span class="line"><span class="number">5</span> &gt; <span class="number">4</span>，说明<span class="number">5</span>及其之后的所有元素都能与<span class="number">4</span>组成逆序对；所以sum += （leftLen - <span class="number">1</span>）；</span><br><span class="line"></span><br><span class="line"><span class="number">5</span> &lt; <span class="number">6</span>，正常排序，不做处理</span><br><span class="line"></span><br><span class="line"><span class="number">7</span> &gt; <span class="number">6</span>，说明<span class="number">7</span>及其之后的所有元素都能与<span class="number">6</span>组成逆序对；所以sum += （leftLen - <span class="number">1</span>）；</span><br><span class="line"></span><br><span class="line"><span class="number">7</span>，正常排序，不作处理</span><br><span class="line"></span><br><span class="line">最后sum就是所有逆序对的总个数！</span><br></pre></td></tr></table></figure><p>而我用归并排序写法2写的代码，相对来说，更加清晰易懂，与上文解题思路差不多。</p><h2 id="数学运算"><a href="#数学运算" class="headerlink" title="数学运算"></a>数学运算</h2><h3 id="二进制中1的个数"><a href="#二进制中1的个数" class="headerlink" title="二进制中1的个数"></a>二进制中1的个数</h3><p><a href="https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/">面试题15. 二进制中1的个数</a></p><p>这是一道考察二进制的题目</p><p>二进制或运算符<code>（or）</code>：符号为 <code>|</code>，表示若两个二进制位都为0，则结果为0，否则为1。</p><p>二进制与运算符<code>（and）</code>：符号为 <code>&amp;</code>，表示若两个二进制位都为1，则结果为1，否则为0。</p><p>二进制否运算符<code>（not）</code>：符号为 <code>~</code>，表示对一个二进制位取反。</p><p>异或运算符<code>（xor）</code>：符号为 <code>^</code>，表示若两个二进制位不相同，则结果为1，否则为0</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span> - a positive integer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> hammingWeight = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> ff=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(ff)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ff&amp;n) ++cnt;</span><br><span class="line">        ff&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="数值的整数次方"><a href="#数值的整数次方" class="headerlink" title="数值的整数次方"></a>数值的整数次方</h3><p>其实这道题，应该是考察的快速幂知识，但是我不造为什么 <code>js</code>，对于负数情况会超时，用 <code>C++</code> 版本就一下过了。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">x</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> myPow = <span class="function"><span class="keyword">function</span>(<span class="params">x, n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">1</span> || n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> num = n;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="built_in">Math</span>.abs(num);i++)&#123;</span><br><span class="line">            ans*=x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans? <span class="number">1</span>/ans:<span class="literal">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(num)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num&amp;<span class="number">1</span>) ans*=x;</span><br><span class="line">            x*=x;</span><br><span class="line">            num&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>还是贴上C++版本吧，快速幂简单就过了。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">1</span> || n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">double</span> res=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> num=n;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            x=<span class="number">1</span>/x;</span><br><span class="line">            num=-num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(num)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num&amp;<span class="number">1</span>) res*=x;</span><br><span class="line">            x*=x;</span><br><span class="line">            num&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="数组中只出现一次的数字"><a href="#数组中只出现一次的数字" class="headerlink" title="数组中只出现一次的数字"></a>数组中只出现一次的数字</h3><p><a href="https://leetcode-cn.com/problems/single-number/">136. 只出现一次的数字</a></p><p>考察异或运算 <code>^</code>，一个数和0进行异或等于它本身，而自己和自己异或等于0，那么最后就只剩下出现奇数次的数字了。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> singleNumber = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        ans^=nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="不用加减乘除做加法"><a href="#不用加减乘除做加法" class="headerlink" title="不用加减乘除做加法"></a>不用加减乘除做加法</h3><p><a href="https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/">面试题65. 不用加减乘除做加法</a></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">a</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">b</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">return</span> add(a^b,(a&amp;b)&lt;&lt;<span class="number">1</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>本题主要考察二进制与位运算，两个二进制相异或即可相加，相与判断进位。</p><h3 id="字符串转换成整数"><a href="#字符串转换成整数" class="headerlink" title="字符串转换成整数"></a>字符串转换成整数</h3><p><a href="https://leetcode-cn.com/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/">面试题67. 把字符串转换成整数</a></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">str</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> strToInt = <span class="function"><span class="keyword">function</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    str = str.trim();</span><br><span class="line">    <span class="keyword">let</span> ans = <span class="built_in">parseInt</span>(str);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">isNaN</span>(ans)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> minx = <span class="built_in">Math</span>.pow(-<span class="number">2</span>,<span class="number">31</span>);</span><br><span class="line">    <span class="keyword">let</span> maxx = <span class="built_in">Math</span>.pow(<span class="number">2</span>,<span class="number">31</span>)-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(ans &lt; minx) <span class="keyword">return</span> minx;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(ans &gt; maxx) <span class="keyword">return</span> maxx;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="整数中1出现的次数"><a href="#整数中1出现的次数" class="headerlink" title="整数中1出现的次数"></a>整数中1出现的次数</h3><p><a href="https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/">面试题43. 1～n整数中1出现的次数</a></p><h3 id="1-2-3-…-n"><a href="#1-2-3-…-n" class="headerlink" title="1+2+3+…+n"></a>1+2+3+…+n</h3><p><a href="https://leetcode-cn.com/problems/qiu-12n-lcof/submissions/">面试题64. 求1+2+…+n</a></p><h4 id="写法1-2"><a href="#写法1-2" class="headerlink" title="写法1"></a>写法1</h4><p>使用递归，使用&amp;&amp;短路来终止递归</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> sumNums = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n&amp;&amp;(n+sumNums(n-<span class="number">1</span>));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="写法2-2"><a href="#写法2-2" class="headerlink" title="写法2"></a>写法2</h4><p>求和公式为<code>n(n+1)/2 = (n方+n)/2</code></p><p>可以用 <code>Math.pow</code> 函数求 <code>n方</code>，用位运算代替除法</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> sumNums = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">Math</span>.pow(n, <span class="number">2</span>) + n) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="丑数"><a href="#丑数" class="headerlink" title="丑数"></a>丑数</h3><p><a href="https://leetcode-cn.com/problems/chou-shu-lcof/">面试题49. 丑数</a></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> nthUglyNumber = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> arr = [<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">let</span> i2=i3=i5=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(arr.length &lt; n)&#123;</span><br><span class="line">        arr.push(<span class="built_in">Math</span>.min(arr[i2]*<span class="number">2</span>, arr[i3]*<span class="number">3</span>, arr[i5]*<span class="number">5</span>));</span><br><span class="line">        <span class="keyword">let</span> cur = arr[arr.length-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span>(arr[i2]*<span class="number">2</span> &lt;= cur) i2++;</span><br><span class="line">        <span class="keyword">while</span>(arr[i3]*<span class="number">3</span> &lt;= cur) i3++;</span><br><span class="line">        <span class="keyword">while</span>(arr[i5]*<span class="number">5</span> &lt;= cur) i5++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr[n-<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>丑数只能被2、3、5整除，说明第n个丑数只能是0 - n-1中某个丑数✖️2、✖️3、✖️5的结果。</p><p>而且，这个数即第0 - n-1个丑数✖️2、✖️3、✖️5的结果中比第n-1个丑数大的最小值。</p><p>按照上面的规律，我们可以依次求出第0 - n个丑数。</p><p>简单做法：</p><ul><li>1.每次把第0 - n-1个丑数✖️(2、3、5)</li><li>2.分别找到第0 - n-1个丑数✖️2、✖️3、✖️5的结果中比第n-1个丑数大的最小值。</li><li>3.比较三个数取最小值加入到丑数队列中</li></ul><p>优化：</p><ul><li>1.前面的数不必每个都乘</li><li>2.记录下✖️(2、3、5)后刚好比当前最大丑数大的这三个值的下标 i2,i3,i5</li><li>3.下次比较从这 i2,i3,i5 三个下标开始乘起</li><li>4.最后取arr[i2]✖️2、arr[i3]✖️3、arr[i5]✖️5 的最小值</li></ul><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><h3 id="二维数组查找"><a href="#二维数组查找" class="headerlink" title="二维数组查找"></a>二维数组查找</h3><h3 id="在排序数组中查找数字"><a href="#在排序数组中查找数字" class="headerlink" title="在排序数组中查找数字"></a>在排序数组中查找数字</h3><h3 id="整数中1出现的次数-1"><a href="#整数中1出现的次数-1" class="headerlink" title="整数中1出现的次数"></a>整数中1出现的次数</h3><h2 id="DFS和BFS"><a href="#DFS和BFS" class="headerlink" title="DFS和BFS"></a>DFS和BFS</h2>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【再也不怕面试官要你手写排序算法】一文详细解读前后端之各种排序算法</title>
      <link href="posts/61237/"/>
      <url>posts/61237/</url>
      
        <content type="html"><![CDATA[<h2 id="1、冒泡排序"><a href="#1、冒泡排序" class="headerlink" title="1、冒泡排序"></a>1、冒泡排序</h2><h3 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h3><blockquote><div>1.依次比较相邻的两个数，如果第一个比第二个小，不变。如果第一个比第二个大，调换顺序。一轮下来，最后一个是最大的数</div><div>2.对除了最后一个之外的数重复第一步，直到只剩一个数</div></blockquote><h3 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h3><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200331111904150.png#pic_center" alt=""></p><h3 id="算法实现（JS代码）"><a href="#算法实现（JS代码）" class="headerlink" title="算法实现（JS代码）"></a>算法实现（JS代码）</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;en&quot;</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;meta name=<span class="string">&quot;viewport&quot;</span> content=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> len=arr.length;</span><br><span class="line">            <span class="keyword">var</span> i,j;</span><br><span class="line">            <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;len-i-<span class="number">1</span>;j++)&#123;  </span><br><span class="line">                    <span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>]) <span class="comment">//两两之间进行比较</span></span><br><span class="line">                        swap(arr,j,j+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> arr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">swap</span>(<span class="params">arr,i,j</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> tmp=arr[i];</span><br><span class="line">            arr[i]=arr[j];</span><br><span class="line">            arr[j]=tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> arr=[<span class="number">1</span>,<span class="number">12</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">5</span>];</span><br><span class="line">        bubbleSort(arr);</span><br><span class="line">        <span class="built_in">console</span>.log(arr);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h3 id="执行结果1"><a href="#执行结果1" class="headerlink" title="执行结果1"></a>执行结果1</h3><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200331112633479.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><h3 id="算法实现（C-代码）"><a href="#算法实现（C-代码）" class="headerlink" title="算法实现（C++代码）"></a>算法实现（C++代码）</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int maxn=<span class="number">1e3</span>+<span class="number">5</span>;</span><br><span class="line">int a[maxn],n;</span><br><span class="line">int <span class="function"><span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;n;i++) cin&gt;&gt;a[i];</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(int j=<span class="number">0</span>;j&lt;n-i-<span class="number">1</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j]&gt;a[j+<span class="number">1</span>])</span><br><span class="line">                swap(a[j],a[j+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;n;i++) cout&lt;&lt;a[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="执行结果2"><a href="#执行结果2" class="headerlink" title="执行结果2"></a>执行结果2</h3><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200331202505962.png" alt=""></p><h2 id="2、选择排序"><a href="#2、选择排序" class="headerlink" title="2、选择排序"></a>2、选择排序</h2><h3 id="基本思路-1"><a href="#基本思路-1" class="headerlink" title="基本思路"></a>基本思路</h3><blockquote><div>1.找出最小的数，和第一个交换位置</div><div>2.在剩下的数中，找出最二小的数，放在第二个</div><div>3.依次类推，排出顺序</div></blockquote><h3 id="图示-1"><a href="#图示-1" class="headerlink" title="图示"></a>图示</h3><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200331113054561.png#pic_center" alt=""></p><h3 id="算法实现（JS代码）-1"><a href="#算法实现（JS代码）-1" class="headerlink" title="算法实现（JS代码）"></a>算法实现（JS代码）</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;en&quot;</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;meta name=<span class="string">&quot;viewport&quot;</span> content=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">selectionSort</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> len=arr.length;</span><br><span class="line">            <span class="keyword">var</span> i,j,xmin;</span><br><span class="line">            <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">                xmin=i;   <span class="comment">//将当前值设为最小值</span></span><br><span class="line">                <span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;len;j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(arr[j]&lt;arr[xmin])</span><br><span class="line">                        xmin=j;  <span class="comment">//在后面找到更小的值</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(i!=xmin)</span><br><span class="line">                    swap(arr,i,xmin) <span class="comment">//将找到的更小值进行交换</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> arr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">swap</span>(<span class="params">arr,i,j</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> tmp=arr[i];</span><br><span class="line">            arr[i]=arr[j];</span><br><span class="line">            arr[j]=tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> arr=[<span class="number">1</span>,<span class="number">12</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">5</span>];</span><br><span class="line">        selectionSort(arr);</span><br><span class="line">        <span class="built_in">console</span>.log(arr);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h3 id="执行结果1-1"><a href="#执行结果1-1" class="headerlink" title="执行结果1"></a>执行结果1</h3><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200331114113439.png" alt=""></p><h3 id="算法实现（C-代码）-1"><a href="#算法实现（C-代码）-1" class="headerlink" title="算法实现（C++代码）"></a>算法实现（C++代码）</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int maxn=<span class="number">1e3</span>+<span class="number">5</span>;</span><br><span class="line">int a[maxn],n;</span><br><span class="line">int <span class="function"><span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;n;i++) cin&gt;&gt;a[i];</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        int xmin=i;</span><br><span class="line">        <span class="keyword">for</span>(int j=i+<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j]&lt;a[xmin]) xmin=j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(xmin!=i) swap(a[xmin],a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;n;i++) cout&lt;&lt;a[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="执行结果2-1"><a href="#执行结果2-1" class="headerlink" title="执行结果2"></a>执行结果2</h3><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200331202505962.png" alt=""></p><h2 id="3、插入排序"><a href="#3、插入排序" class="headerlink" title="3、插入排序"></a>3、插入排序</h2><h3 id="基本思路-2"><a href="#基本思路-2" class="headerlink" title="基本思路"></a>基本思路</h3><blockquote><div>1.把数组分为[已排序]和[未排序]两部分,第一个数为[已排序]，其余为[未排序]</div><div>2.从[未排序]抽出第一个数，和[已排序]部分比较，插入到合适的位置</div></blockquote><h3 id="图示-2"><a href="#图示-2" class="headerlink" title="图示"></a>图示</h3><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200331115752579.png#pic_center" alt=""></p><h3 id="算法实现（Js代码）"><a href="#算法实现（Js代码）" class="headerlink" title="算法实现（Js代码）"></a>算法实现（Js代码）</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;en&quot;</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;meta name=<span class="string">&quot;viewport&quot;</span> content=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">insertSort</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> len=arr.length;</span><br><span class="line">            <span class="keyword">var</span> i,j,val;</span><br><span class="line">            <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">                val=arr[i];</span><br><span class="line">                <span class="keyword">for</span>(j=i-<span class="number">1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(arr[j]&lt;val) <span class="keyword">break</span>; <span class="comment">//找到可以放的位置即跳出</span></span><br><span class="line">                    arr[j+<span class="number">1</span>]=arr[j];</span><br><span class="line">                &#125;</span><br><span class="line">                arr[j+<span class="number">1</span>]=val;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> arr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> arr=[<span class="number">1</span>,<span class="number">12</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">5</span>];</span><br><span class="line">        insertSort(arr);</span><br><span class="line">        <span class="built_in">console</span>.log(arr);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h3 id="执行结果1-2"><a href="#执行结果1-2" class="headerlink" title="执行结果1"></a>执行结果1</h3><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200331114113439.png" alt=""></p><h3 id="算法实现（C-代码）-2"><a href="#算法实现（C-代码）-2" class="headerlink" title="算法实现（C++代码）"></a>算法实现（C++代码）</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int maxn=<span class="number">1e3</span>+<span class="number">5</span>;</span><br><span class="line">int a[maxn],n;</span><br><span class="line">int <span class="function"><span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;n;i++) cin&gt;&gt;a[i];</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        int val=a[i],j;</span><br><span class="line">        <span class="keyword">for</span>(j=i-<span class="number">1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j]&lt;val) <span class="keyword">break</span>;</span><br><span class="line">            a[j+<span class="number">1</span>]=a[j];</span><br><span class="line">        &#125;</span><br><span class="line">        a[j+<span class="number">1</span>]=val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;n;i++) cout&lt;&lt;a[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="执行结果2-2"><a href="#执行结果2-2" class="headerlink" title="执行结果2"></a>执行结果2</h3><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200331202505962.png" alt=""></p><h2 id="4、归并排序-分而治之"><a href="#4、归并排序-分而治之" class="headerlink" title="4、归并排序(分而治之)"></a>4、归并排序(分而治之)</h2><h3 id="基本思路-3"><a href="#基本思路-3" class="headerlink" title="基本思路"></a>基本思路</h3><blockquote><div>1.不断将数组对半分，直到每个数组只有一个</div><div>2.将分出来的部分重新合并</div><div>3.合并的时候按顺序排列</div></blockquote><h3 id="图示-3"><a href="#图示-3" class="headerlink" title="图示"></a>图示</h3><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200331131808651.png#pic_center" alt=""></p><h3 id="算法实现（JS代码）-2"><a href="#算法实现（JS代码）-2" class="headerlink" title="算法实现（JS代码）"></a>算法实现（JS代码）</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;en&quot;</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;meta name=<span class="string">&quot;viewport&quot;</span> content=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params">left,right</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> res=[],</span><br><span class="line">                i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">            <span class="comment">//合并两个数组（按照从小到大的顺序）</span></span><br><span class="line">            <span class="keyword">while</span>(i&lt;left.length&amp;&amp;j&lt;right.length)&#123;</span><br><span class="line">                <span class="keyword">if</span>(left[i]&lt;right[j])&#123;</span><br><span class="line">                    res.push(left[i++]);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    res.push(right[j++]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//数组拼接</span></span><br><span class="line">            <span class="keyword">return</span> res.concat(left.slice(i)).concat(right.slice(j));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">mergeSort</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> len=arr.length;</span><br><span class="line">            <span class="keyword">var</span> i,j;</span><br><span class="line">            <span class="comment">//不断拆分至只有一个数</span></span><br><span class="line">            <span class="keyword">if</span>(len&lt;=<span class="number">1</span>) <span class="keyword">return</span> arr;</span><br><span class="line">            <span class="keyword">var</span> mid=<span class="built_in">Math</span>.floor(len/<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">var</span> left=arr.slice(<span class="number">0</span>,mid),</span><br><span class="line">                right=arr.slice(mid);</span><br><span class="line">            <span class="keyword">return</span> merge(mergeSort(left),mergeSort(right));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> arr=[<span class="number">1</span>,<span class="number">12</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">5</span>];</span><br><span class="line">        arr=mergeSort(arr);</span><br><span class="line">        <span class="built_in">console</span>.log(arr);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h3 id="执行结果1-3"><a href="#执行结果1-3" class="headerlink" title="执行结果1"></a>执行结果1</h3><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200331114113439.png" alt=""></p><h3 id="算法实现（C-代码）-3"><a href="#算法实现（C-代码）-3" class="headerlink" title="算法实现（C++代码）"></a>算法实现（C++代码）</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int maxn=<span class="number">1e3</span>+<span class="number">5</span>;</span><br><span class="line">int a[maxn],n;</span><br><span class="line"><span class="keyword">void</span> <span class="function"><span class="title">mergeArray</span>(<span class="params">int le,int mid,int re</span>)</span>&#123;</span><br><span class="line">    int len=re-le+<span class="number">1</span>;</span><br><span class="line">    int * tmp=<span class="keyword">new</span> int[len];</span><br><span class="line">    int cnt=<span class="number">0</span>;</span><br><span class="line">    int i=le,j=mid+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=re)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&lt;=a[j]) tmp[cnt++]=a[i++];</span><br><span class="line">        <span class="keyword">else</span> tmp[cnt++]=a[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid) tmp[cnt++]=a[i++];</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=re) tmp[cnt++]=a[j++];</span><br><span class="line">    <span class="keyword">for</span>(int j=<span class="number">0</span>;j&lt;len;j++) a[le+j]=tmp[j];</span><br><span class="line">    <span class="keyword">delete</span> [] tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="function"><span class="title">mergeSort</span>(<span class="params">int le,int re</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(le&lt;re)&#123;</span><br><span class="line">        int mid=(le+re)/<span class="number">2</span>;</span><br><span class="line">        mergeSort(le,mid);</span><br><span class="line">        mergeSort(mid+<span class="number">1</span>,re);</span><br><span class="line">        mergeArray(le,mid,re);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int <span class="function"><span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;n;i++) cin&gt;&gt;a[i];</span><br><span class="line">    mergeSort(<span class="number">0</span>,n-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;n;i++) cout&lt;&lt;a[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="执行结果2-3"><a href="#执行结果2-3" class="headerlink" title="执行结果2"></a>执行结果2</h3><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200331202505962.png" alt=""></p><h2 id="5、快速排序"><a href="#5、快速排序" class="headerlink" title="5、快速排序"></a>5、快速排序</h2><h3 id="基本思路-4"><a href="#基本思路-4" class="headerlink" title="基本思路"></a>基本思路</h3><blockquote><div>1.以一个数为基准(中间的数)，比基准小的放到左边，比基准大的放到右边</div><div>2.再按此方法对这两部分数据分别进行快速排序（递归进行）</div><div>3.不能再分后退出递归，并重新将数组合并</div></blockquote><h3 id="图示-4"><a href="#图示-4" class="headerlink" title="图示"></a>图示</h3><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200331140023958.png#pic_center" alt=""></p><h3 id="算法实现（JS代码）-3"><a href="#算法实现（JS代码）-3" class="headerlink" title="算法实现（JS代码）"></a>算法实现（JS代码）</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;en&quot;</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;meta name=<span class="string">&quot;viewport&quot;</span> content=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">partition</span>(<span class="params">arr,p,q</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> i = p;</span><br><span class="line">            <span class="keyword">var</span> x= arr[p];</span><br><span class="line">            <span class="keyword">var</span> j;</span><br><span class="line">            <span class="keyword">for</span>(j=p+<span class="number">1</span>;j&lt;=q;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[j]&lt;=x)&#123;</span><br><span class="line">                    ++i;</span><br><span class="line">                    swap(arr,i,j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(arr,i,p);</span><br><span class="line">            <span class="keyword">return</span> i;  <span class="comment">//返回划分中间位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">arr,p,q</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(p&lt;q)&#123;</span><br><span class="line">                <span class="keyword">var</span> k = partition(arr,p,q);  <span class="comment">//确定划分中间位置</span></span><br><span class="line">                quickSort(arr,p,k-<span class="number">1</span>);   <span class="comment">//对左边部分进行递归</span></span><br><span class="line">                quickSort(arr,k+<span class="number">1</span>,q);   <span class="comment">//对右边部分进行递归</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//交换函数</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">swap</span>(<span class="params">arr,i,j</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> tmp=arr[i];</span><br><span class="line">            arr[i]=arr[j];</span><br><span class="line">            arr[j]=tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> arr=[<span class="number">1</span>,<span class="number">12</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">5</span>];</span><br><span class="line">        quickSort(arr,<span class="number">0</span>,arr.length-<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(arr);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h3 id="执行结果1-4"><a href="#执行结果1-4" class="headerlink" title="执行结果1"></a>执行结果1</h3><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200331114113439.png" alt=""></p><h3 id="算法实现（C-代码）-4"><a href="#算法实现（C-代码）-4" class="headerlink" title="算法实现（C++代码）"></a>算法实现（C++代码）</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int maxn=<span class="number">1e3</span>+<span class="number">5</span>;</span><br><span class="line">int a[maxn],n;</span><br><span class="line">int <span class="function"><span class="title">quick_partition</span>(<span class="params">int p,int q</span>)</span>&#123;</span><br><span class="line">    int i=p;</span><br><span class="line">    int x=a[p];</span><br><span class="line">    <span class="keyword">for</span>(int j=p+<span class="number">1</span>;j&lt;=q;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[j]&lt;=x)&#123;</span><br><span class="line">            ++i;</span><br><span class="line">            swap(a[i],a[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(a[i],a[p]);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="function"><span class="title">quick_sort</span>(<span class="params">int p,int q</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p&lt;q)&#123;</span><br><span class="line">        int k=quick_partition(p,q);</span><br><span class="line">        quick_sort(p,k-<span class="number">1</span>);</span><br><span class="line">        quick_sort(k+<span class="number">1</span>,q);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int <span class="function"><span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;n;i++) cin&gt;&gt;a[i];</span><br><span class="line">    quick_sort(<span class="number">0</span>,n-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;n;i++) cout&lt;&lt;a[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="执行结果2-4"><a href="#执行结果2-4" class="headerlink" title="执行结果2"></a>执行结果2</h3><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200331202505962.png" alt=""></p><h2 id="6、随机化快速排序"><a href="#6、随机化快速排序" class="headerlink" title="6、随机化快速排序"></a>6、随机化快速排序</h2><h3 id="基本思路-5"><a href="#基本思路-5" class="headerlink" title="基本思路"></a>基本思路</h3><blockquote><div>随机化快速排序只是在快排基础上将主元通过随机函数选取一下了。</div></blockquote><p><strong>关于js中随机产生【n , m】随机数实例：</strong></p><p>在本例中，我们将取得介于 1 到 10 之间的一个随机数：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.floor((<span class="built_in">Math</span>.random()*<span class="number">10</span>)+<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p><strong>输出结果：</strong></p><p>5</p><h3 id="算法实现（Js代码）-1"><a href="#算法实现（Js代码）-1" class="headerlink" title="算法实现（Js代码）"></a>算法实现（Js代码）</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;en&quot;</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;meta name=<span class="string">&quot;viewport&quot;</span> content=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        <span class="comment">//随机选取主元</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">randk</span>(<span class="params">arr,p,q</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> k = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*q+p);</span><br><span class="line">            swap(arr,p,k);</span><br><span class="line">            <span class="keyword">return</span> partition(arr,p,q);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">partition</span>(<span class="params">arr,p,q</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> i = p;</span><br><span class="line">            <span class="keyword">var</span> x= arr[p];</span><br><span class="line">            <span class="keyword">var</span> j;</span><br><span class="line">            <span class="keyword">for</span>(j=p+<span class="number">1</span>;j&lt;=q;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[j]&lt;=x)&#123;</span><br><span class="line">                    ++i;</span><br><span class="line">                    swap(arr,i,j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(arr,i,p);</span><br><span class="line">            <span class="keyword">return</span> i;  <span class="comment">//返回划分中间位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">arr,p,q</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(p&lt;q)&#123;</span><br><span class="line">                <span class="keyword">var</span> k = randk(arr,p,q);  <span class="comment">//确定划分中间位置</span></span><br><span class="line">                quickSort(arr,p,k-<span class="number">1</span>);   <span class="comment">//对左边部分进行递归</span></span><br><span class="line">                quickSort(arr,k+<span class="number">1</span>,q);   <span class="comment">//对右边部分进行递归</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//交换函数</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">swap</span>(<span class="params">arr,i,j</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> tmp=arr[i];</span><br><span class="line">            arr[i]=arr[j];</span><br><span class="line">            arr[j]=tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> arr=[<span class="number">1</span>,<span class="number">12</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">5</span>];</span><br><span class="line">        quickSort(arr,<span class="number">0</span>,arr.length-<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(arr);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h3 id="执行结果1-5"><a href="#执行结果1-5" class="headerlink" title="执行结果1"></a>执行结果1</h3><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200331114113439.png" alt=""></p><h3 id="算法实现（C-代码）-5"><a href="#算法实现（C-代码）-5" class="headerlink" title="算法实现（C++代码）"></a>算法实现（C++代码）</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int maxn=<span class="number">1e3</span>+<span class="number">5</span>;</span><br><span class="line">int a[maxn],n;</span><br><span class="line">int <span class="function"><span class="title">quick_partition</span>(<span class="params">int p,int q</span>)</span>&#123;</span><br><span class="line">    int i=p;</span><br><span class="line">    int x=a[p];</span><br><span class="line">    <span class="keyword">for</span>(int j=p+<span class="number">1</span>;j&lt;=q;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[j]&lt;=x)&#123;</span><br><span class="line">            ++i;</span><br><span class="line">            swap(a[i],a[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(a[i],a[p]);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">int <span class="function"><span class="title">rand</span>(<span class="params">int p,int q</span>)</span>&#123;</span><br><span class="line">    int k=rand()%(q-p+<span class="number">1</span>)+p;</span><br><span class="line">    swap(a[k],a[p]);</span><br><span class="line">    <span class="keyword">return</span> quick_partition(p,q);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="function"><span class="title">qsort</span>(<span class="params">int p,int q</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p&lt;q)&#123;</span><br><span class="line">        int k=rand(p,q);</span><br><span class="line">        qsort(p,k-<span class="number">1</span>);</span><br><span class="line">        qsort(k+<span class="number">1</span>,q);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int <span class="function"><span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;n;i++) cin&gt;&gt;a[i];</span><br><span class="line">    qsort(<span class="number">0</span>,n-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;n;i++) cout&lt;&lt;a[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="执行结果2-5"><a href="#执行结果2-5" class="headerlink" title="执行结果2"></a>执行结果2</h3><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200331202505962.png" alt=""></p><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p><font color="Tomato"><strong>如若本文有瑕疵需修改的地方，请提出来，谢谢您的贡献！</strong></font></p><p><font color=chocolate>欢迎关注微信公众号：小狮子前端Vue</font></p><p>谢谢您的支持！✿✿ヽ(°▽°)ノ✿</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode面试题集 和你一起愉快A题 （C++）（持续更新中）</title>
      <link href="posts/205591/"/>
      <url>posts/205591/</url>
      
        <content type="html"><![CDATA[<h2 id="阅读须知"><a href="#阅读须知" class="headerlink" title="阅读须知"></a>阅读须知</h2><p>本篇博客是根据 <code>LeetCode101: ALeetCodeGrindingGuide(C++Version)</code> 电子书籍整理而来的版本，参考了部分解题思路，now，一起愉快地A题吧，拿下满意的 Offer~</p><h2 id="LeetCode-455-分发饼干【贪心】"><a href="#LeetCode-455-分发饼干【贪心】" class="headerlink" title="LeetCode 455. 分发饼干【贪心】"></a>LeetCode 455. 分发饼干【贪心】</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>有一群孩子和一堆饼干，每个孩子有一个饥饿度，每个饼干都有一个大小。每个孩子只能吃 最多一个饼干，且只有饼干的大小大于孩子的饥饿度时，这个孩子才能吃饱。求解最多有多少孩 子可以吃饱。</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>贪心。对孩子饥饿度和饼干尺寸从小到大排序，然后逐一比较，满足条件就算一个孩子。</p><h3 id="AC"><a href="#AC" class="headerlink" title="AC"></a>AC</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">public:</span><br><span class="line">    int <span class="function"><span class="title">findContentChildren</span>(<span class="params">vector&lt;int&gt;&amp; g, vector&lt;int&gt;&amp; s</span>)</span> &#123;</span><br><span class="line">        sort(g.begin(),g.end());</span><br><span class="line">        sort(s.begin(),s.end());</span><br><span class="line">        int i=<span class="number">0</span>,j=<span class="number">0</span>,cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;g.size()&amp;&amp;j&lt;s.size())&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[j]&gt;=g[i]) ++cnt,i++,j++;</span><br><span class="line">            <span class="keyword">else</span> j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="LeetCode-135-分发糖果【贪心】"><a href="#LeetCode-135-分发糖果【贪心】" class="headerlink" title="LeetCode 135. 分发糖果【贪心】"></a>LeetCode 135. 分发糖果【贪心】</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>一群孩子站成一排，每一个孩子有自己的评分。现在需要给这些孩子发糖果，规则是如果一 个孩子的评分比自己身旁的一个孩子要高，那么这个孩子就必须得到比身旁孩子更多的糖果；所有孩子至少要有一个糖果。求解最少需要多少个糖果。</p><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li><p>把所有孩子的糖果数初始化为 1； 先从左往右遍历一遍，如果右边孩子的评分比左边的高，则右边孩子的糖果数更新为左边孩子的 糖果数加1；</p></li><li><p>再从右往左遍历一遍，如果左边孩子的评分比右边的高，且左边孩子当前的糖果数 不大于右边孩子的糖果数，则左边孩子的糖果数更新为右边孩子的糖果数加1。</p></li><li><p>通过这两次遍历， 分配的糖果就可以满足题目要求了。这里的贪心策略即为，在每次遍历中，只考虑并更新相邻一 侧的大小关系。 </p></li></ul><h3 id="AC-1"><a href="#AC-1" class="headerlink" title="AC"></a>AC</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">public:</span><br><span class="line">    int <span class="function"><span class="title">candy</span>(<span class="params">vector&lt;int&gt;&amp; ratings</span>)</span> &#123;</span><br><span class="line">        int size = ratings.size();</span><br><span class="line">        <span class="keyword">if</span>(size&lt;<span class="number">2</span>) <span class="keyword">return</span> size;</span><br><span class="line">        vector&lt;int&gt; v(size,<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//先从左到右遍历</span></span><br><span class="line">        <span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;size-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ratings[i+<span class="number">1</span>]&gt;ratings[i])</span><br><span class="line">                v[i+<span class="number">1</span>]=v[i]+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//再从右到左遍历</span></span><br><span class="line">        <span class="keyword">for</span>(int i=size-<span class="number">1</span>;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ratings[i-<span class="number">1</span>]&gt;ratings[i])</span><br><span class="line">                v[i-<span class="number">1</span>]=max(v[i-<span class="number">1</span>],v[i]+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> accumulate(v.begin(),v.end(),<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="LeetCode-435-无重叠区间【贪心】"><a href="#LeetCode-435-无重叠区间【贪心】" class="headerlink" title="LeetCode 435. 无重叠区间【贪心】"></a>LeetCode 435. 无重叠区间【贪心】</h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定多个区间，计算让这些区间互不重叠所需要移除区间的最少个数。起止相连不算重叠。</p><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>在选择要保留区间时，区间的结尾十分重要：选择的区间结尾越小，余留给其它区间的空间 就越大，就越能保留更多的区间。因此，我们采取的贪心策略为，优先保留结尾小且不相交的区间。 </li><li>具体实现方法为，先把区间按照结尾的大小进行增序排序，每次选择结尾最小且和前一个选 择的区间不重叠的区间。我们这里使用 C++ 的 Lambda，结合 std::sort() 函数进行自定义排序。</li><li>在样例中，排序后的数组为 [[1,2], [1,3], [2,4]]。按照我们的贪心策略，首先初始化为区间 [1,2]；由于 [1,3] 与 [1,2] 相交，我们跳过该区间；由于 [2,4] 与 [1,2] 不相交，我们将其保留。因此最终保留的区间为[[1,2],[2,4]]。</li></ul><p><strong>注意</strong> 需要根据实际情况判断按区间开头排序还是按区间结尾排序。</p><h3 id="AC-2"><a href="#AC-2" class="headerlink" title="AC"></a>AC</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">public:</span><br><span class="line">    int <span class="function"><span class="title">eraseOverlapIntervals</span>(<span class="params">vector&lt;vector&lt;int&gt;&gt;&amp; intervals</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(intervals.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        int n = intervals.size();</span><br><span class="line">        <span class="comment">//按照区间结尾从小到大排序</span></span><br><span class="line">        sort(intervals.begin(),intervals.end(),[](vector&lt;int&gt; a,vector&lt;int&gt; b)&#123;</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">1</span>] &lt; b[<span class="number">1</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">        int cnt=<span class="number">0</span>,pre=intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(intervals[i][<span class="number">0</span>]&lt;pre) ++cnt;</span><br><span class="line">            <span class="keyword">else</span> pre = intervals[i][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="LeetCode-167-两数之和-II-输入有序数组【玩转双指针】"><a href="#LeetCode-167-两数之和-II-输入有序数组【玩转双指针】" class="headerlink" title="LeetCode 167. 两数之和 II - 输入有序数组【玩转双指针】"></a>LeetCode 167. 两数之和 II - 输入有序数组【玩转双指针】</h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>在一个增序的整数数组里找到两个数，使它们的和为给定值。已知有且只有一对解。</p><h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>因为数组已经排好序，我们可以采用方向相反的双指针来寻找这两个数字，一个初始指向最 小的元素，即数组最左边，向右遍历；一个初始指向最大的元素，即数组最右边，向左遍历。 如果两个指针指向元素的和等于给定值，那么它们就是我们要的结果。</li><li>如果两个指针指向元 素的和小于给定值，我们把左边的指针右移一位，使得当前的和增加一点。如果两个指针指向元 素的和大于给定值，我们把右边的指针左移一位，使得当前的和减少一点。 </li><li>可以证明，对于排好序且有解的数组，双指针一定能遍历到最优解。证明方法如下：假设最 优解的两个数的位置分别是 l 和 r。我们假设在左指针在 l 左边的时候，右指针已经移动到了 r； 此时两个指针指向值的和小于给定值，因此左指针会一直右移直到到达 l。同理，如果我们假设 在右指针在 r 右边的时候，左指针已经移动到了 l；此时两个指针指向值的和大于给定值，因此 右指针会一直左移直到到达r。所以双指针在任何时候都不可能处于(l,r)之间，又因为不满足条 件时指针必须移动一个，所以最终一定会收敛在 l 和r。</li></ul><h3 id="AC-3"><a href="#AC-3" class="headerlink" title="AC"></a>AC</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; <span class="function"><span class="title">twoSum</span>(<span class="params">vector&lt;int&gt;&amp; numbers, int target</span>)</span> &#123;</span><br><span class="line">        int le=<span class="number">0</span>,re=numbers.size()-<span class="number">1</span>,sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(le&lt;re)&#123;</span><br><span class="line">            sum = numbers[le] + numbers[re];</span><br><span class="line">            <span class="keyword">if</span>(sum==target) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(sum&gt;target) --re;</span><br><span class="line">            <span class="keyword">else</span> ++le;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vector&lt;int&gt;&#123;le+<span class="number">1</span>,re+<span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="LeetCode-88-MergeSortedArray-Easy-【玩转双指针】"><a href="#LeetCode-88-MergeSortedArray-Easy-【玩转双指针】" class="headerlink" title="LeetCode 88. MergeSortedArray(Easy)【玩转双指针】"></a>LeetCode 88. MergeSortedArray(Easy)【玩转双指针】</h2><h3 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定两个有序数组，把两个数组合并为一个。</p><h3 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h3><p>由于题目要求不借助第三个数组，合并到 <code>nums1</code> 上，就用尾指针，然后逐一比较，运用归并排序的思想来解答。最后判断一下 <code>nums2</code> 数组是否还存在元素，若存在，直接放入（因为数组是有序的）。</p><h3 id="AC-4"><a href="#AC-4" class="headerlink" title="AC"></a>AC</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="keyword">void</span> <span class="function"><span class="title">merge</span>(<span class="params">vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n</span>)</span> &#123;</span><br><span class="line">        int pos = m+n-<span class="number">1</span>;</span><br><span class="line">        m-=<span class="number">1</span>,n-=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(m&gt;=<span class="number">0</span>&amp;&amp;n&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            nums1[pos--] = nums1[m] &gt; nums2[n]? nums1[m--]:nums2[n--];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(n&gt;=<span class="number">0</span>) nums1[pos--] = nums2[n--];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="LeetCode-142-Linked-List-Cycle-II【快慢指针】（Floyd判圈法）"><a href="#LeetCode-142-Linked-List-Cycle-II【快慢指针】（Floyd判圈法）" class="headerlink" title="LeetCode 142. Linked List Cycle II【快慢指针】（Floyd判圈法）"></a>LeetCode 142. Linked List Cycle II【快慢指针】（Floyd判圈法）</h2><h3 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个链表，如果有环路，找出环路的开始点。</p><h3 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h3><p>对于链表找环路的问题，有一个通用的解法——<strong>快慢指针（Floyd判圈法）</strong>。给定两个指针， 分别命名为 slow 和 fast，起始位置在链表的开头。每次 fast 前进两步，slow 前进一步。如果 fast 可以走到尽头，那么说明没有环路；如果fast可以无限走下去，那么说明一定有环路，且一定存 在一个时刻slow和fast相遇。当slow和fast第一次相遇时，我们将fast重新移动到链表开头，并 让slow和fast每次都前进一步。当slow和fast第二次相遇时，相遇的节点即为环路的开始点。</p><h3 id="AC-5"><a href="#AC-5" class="headerlink" title="AC"></a>AC</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode *<span class="function"><span class="title">detectCycle</span>(<span class="params">ListNode *head</span>)</span> &#123;</span><br><span class="line">        ListNode *slow = head,*fast = head;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            <span class="comment">//看fast是否走到链表结尾，进而判断是否存在环路</span></span><br><span class="line">            <span class="keyword">if</span>(!fast||!fast-&gt;next) <span class="keyword">return</span> NULL;</span><br><span class="line">            fast=fast-&gt;next-&gt;next;</span><br><span class="line">            slow=slow-&gt;next;</span><br><span class="line">        &#125;<span class="keyword">while</span>(slow!=fast);</span><br><span class="line">        <span class="comment">//如果存在，找节点位置</span></span><br><span class="line">        fast=head;</span><br><span class="line">        <span class="keyword">while</span>(slow!=fast)&#123;</span><br><span class="line">            fast=fast-&gt;next;</span><br><span class="line">            slow=slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fast;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="LeetCode-76-最小覆盖子串-【滑动窗口】"><a href="#LeetCode-76-最小覆盖子串-【滑动窗口】" class="headerlink" title="LeetCode 76. 最小覆盖子串 【滑动窗口】"></a>LeetCode 76. 最小覆盖子串 【滑动窗口】</h2><h3 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定两个字符串 S 和T，求 S 中包含T 所有字符的最短连续子字符串的长度，同时要求时间 复杂度不得超过O(n)。</p><h3 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h3><p>需要思考以下四个问题：</p><p>1、当移动 <code>right</code> 扩大窗口，即加入字符时，应该更新哪些数据？</p><p>2、什么条件下，窗口应该暂停扩大，开始移动<code>left</code> 缩小窗口？</p><p>3、当移动 <code>left</code>缩小窗口，即移出字符时，应该更新哪些数据？</p><p>4、我们要的结果应该在扩大窗口时还是缩小窗口时进行更新？</p><p>如果一个字符进入窗口，应该增加 <code>window</code>计数器；如果一个字符将移出窗口的时候，应该减少 <code>window</code> 计数器；当 <code>cnt</code>满足 <code>need</code>时应该收缩窗口；应该在收缩窗口的时候更新最终结果。</p><p>需要注意的是，当我们发现某个字符在<code>window</code>的数量满足了<code>need</code>的需要，就要更新 valid，表示有一个字符已经满足要求。而且，你能发现，两次对窗口内数据的更新操作是完全对称的。</p><p>当 <code>cnt == need.size()</code>时，说明<code>T</code> 中所有字符已经被覆盖，已经得到一个可行的覆盖子串，现在应该开始收缩窗口了，以便得到「最小覆盖子串」。</p><p>移动 <code>left</code>收缩窗口时，窗口内的字符都是可行解，所以应该在收缩窗口的阶段进行最小覆盖子串的更新，以便从可行解中找到长度最短的最终结果。</p><p><a href="https://leetcode-cn.com/problems/minimum-window-substring/solution/hua-dong-chuang-kou-suan-fa-tong-yong-si-xiang-by-/">参考 ：labuladong 大佬题解</a></p><h3 id="AC-6"><a href="#AC-6" class="headerlink" title="AC"></a>AC</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">public:</span><br><span class="line">    string <span class="function"><span class="title">minWindow</span>(<span class="params">string s, string t</span>)</span> &#123;</span><br><span class="line">        unordered_map&lt;char,int&gt; need,<span class="built_in">window</span>;</span><br><span class="line">        <span class="keyword">for</span>(char c : t) need[c]++;</span><br><span class="line">        int left=<span class="number">0</span>,right=<span class="number">0</span>,cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 记录最小覆盖子串的起始索引及长度</span></span><br><span class="line">        int start=<span class="number">0</span>,len=INT_MAX;</span><br><span class="line">        <span class="keyword">while</span>(right&lt;s.size())&#123;</span><br><span class="line">         <span class="comment">// c 是将移入窗口的字符</span></span><br><span class="line">            char c = s[right];</span><br><span class="line">            <span class="comment">// 右移窗口</span></span><br><span class="line">            right++;</span><br><span class="line">            <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">            <span class="keyword">if</span>(need.count(c))&#123;</span><br><span class="line">                <span class="built_in">window</span>[c]++;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">window</span>[c]==need[c])</span><br><span class="line">                    ++cnt;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 判断左侧窗口是否要收缩</span></span><br><span class="line">            <span class="keyword">while</span>(cnt==need.size())&#123;</span><br><span class="line">            <span class="comment">// 在这里更新最小覆盖子串</span></span><br><span class="line">                <span class="keyword">if</span>(right-left&lt;len)&#123;</span><br><span class="line">                    len=right-left;</span><br><span class="line">                    start=left;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// dd 是将移出窗口的字符</span></span><br><span class="line">                char dd = s[left];</span><br><span class="line">                <span class="comment">// 左移窗口</span></span><br><span class="line">                left++;</span><br><span class="line">                <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">                <span class="keyword">if</span>(need.count(dd))&#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">window</span>[dd]==need[dd]) --cnt;</span><br><span class="line">                    <span class="built_in">window</span>[dd]--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len == INT_MAX? <span class="string">&quot;&quot;</span> : s.substr(start,len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="LeetCode-567-字符串的排列-【滑动窗口】"><a href="#LeetCode-567-字符串的排列-【滑动窗口】" class="headerlink" title="LeetCode 567. 字符串的排列 【滑动窗口】"></a>LeetCode 567. 字符串的排列 【滑动窗口】</h2><h3 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定两个字符串 s1 和 s2，写一个函数来判断 s2 是否包含 s1 的排列。</p><p>换句话说，第一个字符串的排列之一是第二个字符串的子串。</p><p>示例1:</p><p>输入: s1 = “ab” s2 = “eidbaooo”<br>输出: True<br>解释: s2 包含 s1 的排列之一 (“ba”).</p><p>示例2:</p><p>输入: s1= “ab” s2 = “eidboaoo”<br>输出: False</p><p>注意：</p><ul><li>输入的字符串只包含小写字母</li><li>两个字符串的长度都在 [1, 10,000] 之间</li></ul><h3 id="解题思路-7"><a href="#解题思路-7" class="headerlink" title="解题思路"></a>解题思路</h3><p>这道题依旧是可以用滑动窗口算法来做，基本上与模板没什么太大差别。</p><p>需要修改的小地方：<br>1、本题移动 left 缩小窗口的时机是窗口大小 <code>大于或等于</code> s1.size() 时。</p><p>2、当发现 cnt == need.size() 时，就说明窗口中就是一个合法的排列，所以立即返回 true。</p><h3 id="AC-7"><a href="#AC-7" class="headerlink" title="AC"></a>AC</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkInclusion</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; window,need;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c:s1) need[c]++;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>,right=<span class="number">0</span>,cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> start=<span class="number">0</span>,len=INT_MAX;</span><br><span class="line">        <span class="keyword">while</span>(right&lt;s2.size())&#123;</span><br><span class="line">            <span class="keyword">char</span> c = s2[right];</span><br><span class="line">            right++;</span><br><span class="line">            <span class="keyword">if</span>(need.count(c))&#123;</span><br><span class="line">                window[c]++;</span><br><span class="line">                <span class="keyword">if</span>(window[c]==need[c]) ++cnt;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(right-left&gt;=s1.size())&#123;</span><br><span class="line">                <span class="keyword">if</span>(cnt == need.size())&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">char</span> dd = s2[left];</span><br><span class="line">                left++;</span><br><span class="line">                <span class="keyword">if</span>(need.count(dd))&#123;</span><br><span class="line">                    <span class="keyword">if</span>(window[dd]==need[dd]) --cnt;</span><br><span class="line">                    --window[dd];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="LeetCode-438-找到字符串中所有字母异位词【滑动窗口】"><a href="#LeetCode-438-找到字符串中所有字母异位词【滑动窗口】" class="headerlink" title="LeetCode 438. 找到字符串中所有字母异位词【滑动窗口】"></a>LeetCode 438. 找到字符串中所有字母异位词【滑动窗口】</h2><h3 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个字符串 s 和一个非空字符串 p，找到 s 中所有是 p 的字母异位词的子串，返回这些子串的起始索引。</p><p>字符串只包含小写英文字母，并且字符串 s 和 p 的长度都不超过 20100。</p><p>说明：</p><p>字母异位词指字母相同，但排列不同的字符串。<br>不考虑答案输出的顺序。<br>示例 1:</p><p>输入:<br>s: “cbaebabacd” p: “abc”</p><p>输出:<br>[0, 6]</p><p>解释:<br>起始索引等于 0 的子串是 “cba”, 它是 “abc” 的字母异位词。<br>起始索引等于 6 的子串是 “bac”, 它是 “abc” 的字母异位词。<br> 示例 2:</p><p>输入:<br>s: “abab” p: “ab”</p><p>输出:<br>[0, 1, 2]</p><p>解释:<br>起始索引等于 0 的子串是 “ab”, 它是 “ab” 的字母异位词。<br>起始索引等于 1 的子串是 “ba”, 它是 “ab” 的字母异位词。<br>起始索引等于 2 的子串是 “ab”, 它是 “ab” 的字母异位词。</p><h3 id="解题思路-8"><a href="#解题思路-8" class="headerlink" title="解题思路"></a>解题思路</h3><p>输入一个串 S，一个串 T，找到 S 中所有 T 的排列，返回它们的起始索引。</p><p>这道题依旧是可以用滑动窗口算法来做，基本上与模板没什么太大差别。</p><p>需要修改的小地方：<br>1、本题移动 left 缩小窗口的时机是窗口大小 大于或等于 s1.size() 时。</p><p>2、当发现 cnt == need.size() 时，就说明窗口中就是一个合法的排列，添加对应索引值（即 <code>left</code>值）</p><h3 id="AC-8"><a href="#AC-8" class="headerlink" title="AC"></a>AC</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findAnagrams</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; window,need;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c:p) need[c]++;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>,right=<span class="number">0</span>,cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> start=<span class="number">0</span>,len=INT_MAX;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">while</span>(right&lt;s.size())&#123;</span><br><span class="line">            <span class="keyword">char</span> c = s[right];</span><br><span class="line">            right++;</span><br><span class="line">            <span class="keyword">if</span>(need.count(c))&#123;</span><br><span class="line">                window[c]++;</span><br><span class="line">                <span class="keyword">if</span>(window[c]==need[c]) ++cnt;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(right-left&gt;=p.size())&#123;</span><br><span class="line">                <span class="keyword">if</span>(cnt == need.size())</span><br><span class="line">                    res.push_back(left);</span><br><span class="line">                <span class="keyword">char</span> dd = s[left];</span><br><span class="line">                left++;</span><br><span class="line">                <span class="keyword">if</span>(need.count(dd))&#123;</span><br><span class="line">                    <span class="keyword">if</span>(window[dd]==need[dd]) --cnt;</span><br><span class="line">                    --window[dd];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="LeetCode-3-无重复字符的最长子串【滑动窗口】"><a href="#LeetCode-3-无重复字符的最长子串【滑动窗口】" class="headerlink" title="LeetCode 3. 无重复字符的最长子串【滑动窗口】"></a>LeetCode 3. 无重复字符的最长子串【滑动窗口】</h2><h3 id="题目描述-9"><a href="#题目描述-9" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p><p>示例 1:</p><p>输入: “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。<br>示例 2:</p><p>输入: “bbbbb”<br>输出: 1<br>解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。<br>示例 3:</p><p>输入: “pwwkew”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。</p><ul><li>请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。</li></ul><h3 id="解题思路-9"><a href="#解题思路-9" class="headerlink" title="解题思路"></a>解题思路</h3><p>当 window[c] 值大于 1 时，说明窗口中存在重复字符，不符合条件，就该移动 left 缩小窗口。当收缩窗口完成后，此时就不存在重复元素了，判断最长子串即可。</p><h3 id="AC-9"><a href="#AC-9" class="headerlink" title="AC"></a>AC</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; window;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>,right=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(right&lt;s.size())&#123;</span><br><span class="line">            <span class="keyword">char</span> c = s[right];</span><br><span class="line">            right++;</span><br><span class="line">            window[c]++;</span><br><span class="line">            <span class="keyword">while</span>(window[c]&gt;<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">char</span> dd = s[left];</span><br><span class="line">                left++;</span><br><span class="line">                window[dd]--;</span><br><span class="line">            &#125;</span><br><span class="line">            ans=max(ans,right-left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="LeetCode-69-x-的平方根-【二分查找】"><a href="#LeetCode-69-x-的平方根-【二分查找】" class="headerlink" title="LeetCode 69. x 的平方根 【二分查找】"></a>LeetCode 69. x 的平方根 【二分查找】</h2><h3 id="题目描述-10"><a href="#题目描述-10" class="headerlink" title="题目描述"></a>题目描述</h3><p>实现 int sqrt(int x) 函数。</p><p>计算并返回 x 的平方根，其中 x 是非负整数。</p><p>由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p><p>示例 1:</p><p>输入: 4<br>输出: 2<br>示例 2:</p><p>输入: 8<br>输出: 2<br>说明: 8 的平方根是 2.82842…, </p><ul><li>由于返回类型是整数，小数部分将被舍去。</li></ul><h3 id="解题思路-10"><a href="#解题思路-10" class="headerlink" title="解题思路"></a>解题思路</h3><p>我们可以把这道题想象成，给定一个非负整数 a，求 f(x) = x^2^ −a = 0 的解。因为我们只考虑 x ≥ 0，所以 f(x)在定义域上是单调递增的。考虑到 f(0) = −a ≤ 0，f(a) = a^2^ −a ≥ 0，我们可以对[0,a]区间使用二分法找到 f(x) = 0的解。</p><p> 注意，在以下的代码里，为了防止除以0，我们把 a = 0的情况单独考虑，然后对区间[1,a] 进行二分查找。</p><p>使用了左闭右闭的写法。</p><h3 id="AC-10"><a href="#AC-10" class="headerlink" title="AC"></a>AC</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> left=<span class="number">1</span>,right=x,ans;</span><br><span class="line">        <span class="keyword">long</span> mid;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">            ans = x/mid;</span><br><span class="line">            <span class="keyword">if</span>(ans == mid) <span class="keyword">return</span> ans;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(ans &lt; mid) right = mid<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> left = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="LeetCode-34-在排序数组中查找元素的第一个和最后一个位置【二分查找】"><a href="#LeetCode-34-在排序数组中查找元素的第一个和最后一个位置【二分查找】" class="headerlink" title="LeetCode 34. 在排序数组中查找元素的第一个和最后一个位置【二分查找】"></a>LeetCode 34. 在排序数组中查找元素的第一个和最后一个位置【二分查找】</h2><h3 id="题目描述-11"><a href="#题目描述-11" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。</p><p>你的算法时间复杂度必须是 O(log n) 级别。</p><p>如果数组中不存在目标值，返回 [-1, -1]。</p><p>示例 1:</p><p>输入: nums = [5,7,7,8,8,10], target = 8<br>输出: [3,4]<br>示例 2:</p><p>输入: nums = [5,7,7,8,8,10], target = 6<br>输出: [-1,-1]</p><h3 id="解题思路-11"><a href="#解题思路-11" class="headerlink" title="解题思路"></a>解题思路</h3><p>可以看作是自己实现 C++ 里的 lower_bound 和 upper_bound 函数。</p><h3 id="AC-11"><a href="#AC-11" class="headerlink" title="AC"></a>AC</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">searchRange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.empty()) <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> lower = lower_bound(nums,target);</span><br><span class="line">        <span class="keyword">int</span> upper = upper_bound(nums,target)<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(lower == nums.size() || nums[lower]!=target)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;lower,upper&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lower_bound</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>,right=nums.size(),mid;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt;= target) right=mid;</span><br><span class="line">            <span class="keyword">else</span> left=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">upper_bound</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>,right=nums.size(),mid;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; target) right=mid;</span><br><span class="line">            <span class="keyword">else</span> left=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="LeetCode-81-搜索旋转排序数组-II【二分查找】"><a href="#LeetCode-81-搜索旋转排序数组-II【二分查找】" class="headerlink" title="LeetCode 81. 搜索旋转排序数组 II【二分查找】"></a>LeetCode 81. 搜索旋转排序数组 II【二分查找】</h2><h3 id="题目描述-12"><a href="#题目描述-12" class="headerlink" title="题目描述"></a>题目描述</h3><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p><p>( 例如，数组 [0,0,1,2,2,5,6] 可能变为 [2,5,6,0,0,1,2] )。</p><p>编写一个函数来判断给定的目标值是否存在于数组中。若存在返回 true，否则返回 false。</p><p>示例 1:</p><p>输入: nums = [2,5,6,0,0,1,2], target = 0<br>输出: true<br>示例 2:</p><p>输入: nums = [2,5,6,0,0,1,2], target = 3<br>输出: false</p><h3 id="解题思路-12"><a href="#解题思路-12" class="headerlink" title="解题思路"></a>解题思路</h3><p>本题是需要使用二分查找，怎么分是关键，举个例子：</p><p>第一类<br>10111 和 11101 这种。此种情况下 nums[start] == nums[mid]，分不清到底是前面有序还是后面有序，此时 start++ 即可。相当于去掉一个重复的干扰项。<br>第二类<br>2 3 4 5 6 7 1 这种，也就是 nums[start] &lt; nums[mid]。此例子中就是 2 &lt; 5；<br>这种情况下，前半部分有序。因此如果 nums[start] &lt;=target&lt;nums[mid]，则在前半部分找，否则去后半部分找。<br>第三类<br>6 7 1 2 3 4 5 这种，也就是 nums[start] &gt; nums[mid]。此例子中就是 6 &gt; 2；<br>这种情况下，后半部分有序。因此如果 nums[mid] &lt;target&lt;=nums[end]。则在后半部分找，否则去前半部分找。</p><h3 id="AC-12"><a href="#AC-12" class="headerlink" title="AC"></a>AC</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>,right=nums.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[left] == nums[mid]) left++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&lt;=nums[right])&#123;</span><br><span class="line">                <span class="keyword">if</span>(target&gt;nums[mid] &amp;&amp; target&lt;=nums[right])&#123;</span><br><span class="line">                    left=mid+<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    right=mid<span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(target&gt;=nums[left] &amp;&amp; target&lt;nums[mid])&#123;</span><br><span class="line">                    right=mid<span class="number">-1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    left=mid+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="LeetCode-215-数组中的第K个最大元素-【小顶堆与快速选择】"><a href="#LeetCode-215-数组中的第K个最大元素-【小顶堆与快速选择】" class="headerlink" title="LeetCode 215. 数组中的第K个最大元素 【小顶堆与快速选择】"></a>LeetCode 215. 数组中的第K个最大元素 【小顶堆与快速选择】</h2><h3 id="题目描述-13"><a href="#题目描述-13" class="headerlink" title="题目描述"></a>题目描述</h3><p>在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p><p>示例 1:</p><p>输入: [3,2,1,5,6,4] 和 k = 2<br>输出: 5<br>示例 2:</p><p>输入: [3,2,3,1,2,4,5,5,6] 和 k = 4<br>输出: 4<br>说明:</p><p>你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。</p><h3 id="解题思路-13"><a href="#解题思路-13" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>小顶推方式</li></ul><p>建一个只能存K个数字的小顶堆，超过K时候，每加进来一个，堆顶就要弹出一个。数组遍历完，最终堆顶的元素就是第K大的（堆里其他元素都比他还要大）。</p><ul><li>快速选择方式</li></ul><p><a href="https://en.wikipedia.org/wiki/Quickselect">快速选择算法</a> 的平均时间复杂度为 O(N)。就像快速排序那样，本算法也是 Tony Hoare 发明的，因此也被称为 Hoare选择算法。</p><p>本方法大致上与快速排序相同。简便起见，注意到第 k 个最大元素也就是第 N - k 个最小元素，因此可以用第 k 小算法来解决本问题。</p><p>首先，我们选择一个枢轴，并在线性时间内定义其在排序数组中的位置。这可以通过 划分算法 的帮助来完成。</p><blockquote><p>为了实现划分，沿着数组移动，将每个元素与枢轴进行比较，并将小于枢轴的所有元素移动到枢轴的左侧。</p></blockquote><p>这样，在输出的数组中，枢轴达到其合适位置。所有小于枢轴的元素都在其左侧，所有大于或等于的元素都在其右侧。</p><p>这样，数组就被分成了两部分。如果是快速排序算法，会在这里递归地对两部分进行快速排序，时间复杂度为 O(NlogN)。</p><p>而在这里，由于知道要找的第 N - k 小的元素在哪部分中，我们不需要对两部分都做处理，这样就将平均时间复杂度下降到 O(N)。</p><p>最终的算法十分直接了当 :</p><p>随机选择一个枢轴。</p><p>使用划分算法将枢轴放在数组中的合适位置 pos。将小于枢轴的元素移到左边，大于等于枢轴的元素移到右边。</p><p>比较 pos 和 N - k 以决定在哪边继续递归处理。</p><blockquote><p>! 注意，本算法也适用于有重复的数组</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/2020051916354839.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><h3 id="AC-13"><a href="#AC-13" class="headerlink" title="AC"></a>AC</h3><p>采用小顶推方式：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it:nums)&#123;</span><br><span class="line">            q.push(it);</span><br><span class="line">            <span class="keyword">if</span>(q.size()&gt;k) q.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> q.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>采用快速选择方式：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start=<span class="number">0</span>,end=nums.size()<span class="number">-1</span>,target=nums.size()-k;</span><br><span class="line">        <span class="keyword">while</span>(start&lt;end)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = quickSelect(nums,start,end);</span><br><span class="line">            <span class="keyword">if</span>(mid == target) <span class="keyword">return</span> nums[mid];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(target&gt;mid) start=mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> end=mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[start];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">quickSelect</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums,<span class="keyword">int</span> p,<span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=p+<span class="number">1</span>,j=q;</span><br><span class="line">        <span class="keyword">int</span> x=nums[p];</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;q &amp;&amp; nums[i]&lt;=x) ++i;</span><br><span class="line">            <span class="keyword">while</span>(j&gt;p &amp;&amp; nums[j]&gt;=x) --j;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;=j) <span class="keyword">break</span>;</span><br><span class="line">            swap(nums[i],nums[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums[p],nums[j]);</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="LeetCode-347-前-K-个高频元素【桶排序】"><a href="#LeetCode-347-前-K-个高频元素【桶排序】" class="headerlink" title="LeetCode 347. 前 K 个高频元素【桶排序】"></a>LeetCode 347. 前 K 个高频元素【桶排序】</h2><h3 id="题目描述-14"><a href="#题目描述-14" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个非空的整数数组，返回其中出现频率前 k 高的元素。</p><p>示例 1:</p><p>输入: nums = [1,1,1,2,2,3], k = 2<br>输出: [1,2]<br>示例 2:</p><p>输入: nums = [1], k = 1<br>输出: [1]</p><p>提示：</p><ul><li>你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。</li><li>你的算法的时间复杂度必须优于 O(n log n) , n 是数组的大小。</li><li>题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的。</li><li>你可以按任意顺序返回答案。</li></ul><h3 id="解题思路-14"><a href="#解题思路-14" class="headerlink" title="解题思路"></a>解题思路</h3><p>顾名思义，桶排序的意思是为每个值设立一个桶，桶内记录这个值出现的次数（或其它属 性），然后对桶进行排序。针对样例来说，我们先通过桶排序得到三个桶[1,2,3,4]，它们的值分别 为[4,2,1,1]，表示每个数字出现的次数。</p><p>紧接着，我们对桶的频次进行排序，前k 大个桶即是前k 个频繁的数。这里我们可以使用各种 排序算法，甚至可以再进行一次桶排序，把每个旧桶根据频次放在不同的新桶内。针对样例来说， 因为目前最大的频次是 4，我们建立 [1,2,3,4] 四个新桶，它们分别放入的旧桶为 [ [3,4],[2],[],[1] ]， 表示不同数字出现的频率。</p><p>最后，我们从后往前遍历，直到找到 k 个旧桶。</p><h3 id="AC-14"><a href="#AC-14" class="headerlink" title="AC"></a>AC</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">topKFrequent</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">long</span>,<span class="keyword">long</span>&gt; mp;</span><br><span class="line">        <span class="keyword">int</span> max_count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x:nums)&#123;</span><br><span class="line">            ++mp[x];</span><br><span class="line">            <span class="keyword">if</span>(max_count&lt;=mp[x]) max_count=mp[x];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; v(max_count+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it:mp)</span><br><span class="line">            v[it.second].push_back(it.first);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=max_count;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> x:v[i])&#123;</span><br><span class="line">                ans.push_back(x);</span><br><span class="line">                <span class="keyword">if</span>(ans.size()==k) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(ans.size()==k) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="LeetCode-695-岛屿的最大面积【dfs】"><a href="#LeetCode-695-岛屿的最大面积【dfs】" class="headerlink" title="LeetCode 695. 岛屿的最大面积【dfs】"></a>LeetCode 695. 岛屿的最大面积【dfs】</h2><h3 id="题目描述-15"><a href="#题目描述-15" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个包含了一些 0 和 1 的非空二维数组 grid 。</p><p>一个 岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在水平或者竖直方向上相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。</p><p>找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为 0 。)</p><p>示例 1:</p><blockquote><p>[[0,0,1,0,0,0,0,1,0,0,0,0,0],<br> [0,0,0,0,0,0,0,1,1,1,0,0,0],<br> [0,1,1,0,1,0,0,0,0,0,0,0,0],<br> [0,1,0,0,1,1,0,0,1,0,1,0,0],<br> [0,1,0,0,1,1,0,0,1,1,1,0,0],<br> [0,0,0,0,0,0,0,0,0,0,1,0,0],<br> [0,0,0,0,0,0,0,1,1,1,0,0,0],<br> [0,0,0,0,0,0,0,1,1,0,0,0,0]]</p></blockquote><p>对于上面这个给定矩阵应返回 6。注意答案不应该是 11 ，因为岛屿只能包含水平或垂直的四个方向的 1 。</p><p>示例 2:</p><blockquote><p>[[0,0,0,0,0,0,0,0]]</p></blockquote><p>对于上面这个给定的矩阵, 返回 0。</p><p>注意: 给定的矩阵grid 的长度和宽度都不超过 50。</p><h3 id="解题思路-15"><a href="#解题思路-15" class="headerlink" title="解题思路"></a>解题思路</h3><p>十分标准的搜索题，用来练手深度优先搜索。</p><h3 id="AC-15"><a href="#AC-15" class="headerlink" title="AC"></a>AC</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dir&#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(grid.empty() || grid[<span class="number">0</span>].empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max_area=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;grid.size();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;grid[<span class="number">0</span>].size();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j]==<span class="number">1</span>)&#123;</span><br><span class="line">                    max_area=max(max_area,dfs(grid,i,j));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_area;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(grid[x][y]==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        grid[x][y]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> xx,yy,ans=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            xx=x+dir[i],yy=y+dir[i+<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(xx&gt;=<span class="number">0</span>&amp;&amp;xx&lt;grid.size() &amp;&amp; yy&gt;=<span class="number">0</span>&amp;&amp;yy&lt;grid[<span class="number">0</span>].size())&#123;</span><br><span class="line">                ans+=dfs(grid,xx,yy);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="LeetCode-547-朋友圈【dfs】"><a href="#LeetCode-547-朋友圈【dfs】" class="headerlink" title="LeetCode 547. 朋友圈【dfs】"></a>LeetCode 547. 朋友圈【dfs】</h2><h3 id="题目描述-16"><a href="#题目描述-16" class="headerlink" title="题目描述"></a>题目描述</h3><p>班上有 N 名学生。其中有些人是朋友，有些则不是。他们的友谊具有是传递性。如果已知 A 是 B 的朋友，B 是 C 的朋友，那么我们可以认为 A 也是 C 的朋友。所谓的朋友圈，是指所有朋友的集合。</p><p>给定一个 N * N 的矩阵 M，表示班级中学生之间的朋友关系。如果M[i][j] = 1，表示已知第 i 个和 j 个学生互为朋友关系，否则为不知道。你必须输出所有学生中的已知的朋友圈总数。</p><p>示例 1:</p><blockquote><p>输入:<br>[[1,1,0],<br> [1,1,0],<br> [0,0,1]]<br>输出: 2<br>说明：已知学生0和学生1互为朋友，他们在一个朋友圈。<br>第2个学生自己在一个朋友圈。所以返回2。</p></blockquote><p>示例 2:</p><blockquote><p>输入:<br>[[1,1,0],<br> [1,1,1],<br> [0,1,1]]<br>输出: 1<br>说明：已知学生0和学生1互为朋友，学生1和学生2互为朋友，所以学生0和学生2也是朋友，所以他们三个在一个朋友圈，返回1。</p></blockquote><p>注意：</p><ul><li>N 在[1,200]的范围内。</li><li>对于所有学生，有M[i][i] = 1。</li><li>如果有M[i][j] = 1，则有M[j][i] = 1。</li></ul><h3 id="解题思路-16"><a href="#解题思路-16" class="headerlink" title="解题思路"></a>解题思路</h3><p>dfs。朋友圈的个数等于连通块的个数，搜索一遍就累加一次即可。</p><h3 id="AC-16"><a href="#AC-16" class="headerlink" title="AC"></a>AC</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; M)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=M.size(),cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">vis</span><span class="params">(n,<span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!vis[i])&#123;</span><br><span class="line">                dfs(M,vis,i);</span><br><span class="line">                ++cnt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; M,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&amp; vis,<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">        vis[u]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> m=M[u].size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(M[u][i]==<span class="number">1</span> &amp;&amp; !vis[i])</span><br><span class="line">                dfs(M,vis,i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="LeetCode-417-太平洋大西洋水流问题【dfs】"><a href="#LeetCode-417-太平洋大西洋水流问题【dfs】" class="headerlink" title="LeetCode 417. 太平洋大西洋水流问题【dfs】"></a>LeetCode 417. 太平洋大西洋水流问题【dfs】</h2><h3 id="题目描述-17"><a href="#题目描述-17" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个 m x n 的非负整数矩阵来表示一片大陆上各个单元格的高度。“太平洋”处于大陆的左边界和上边界，而“大西洋”处于大陆的右边界和下边界。</p><p>规定水流只能按照上、下、左、右四个方向流动，且只能从高到低或者在同等高度上流动。</p><p>请找出那些水流既可以流动到“太平洋”，又能流动到“大西洋”的陆地单元的坐标。</p><p>提示：</p><p>输出坐标的顺序不重要<br>m 和 n 都小于150</p><p>示例：</p><blockquote><p>给定下面的 5x5 矩阵:<br>  太平洋 ~   ~   ~   ~   ~<br>       ~  1   2   2   3  (5) *<br>       ~  3   2   3  (4) (4) *<br>       ~  2   4  (5)  3   1  *<br>       ~ (6) (7)  1   4   5  *<br>       ~ (5)  1   1   2   4  *<br>          *   *   *   *   * 大西洋<br>返回:<br>[[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] (上图中带括号的单元).</p></blockquote><h3 id="解题思路-17"><a href="#解题思路-17" class="headerlink" title="解题思路"></a>解题思路</h3><p>虽然题目要求的是满足向下流能到达两个大洋的位置，如果我们对所有的位置进行搜索，那么在不剪枝的情况下复杂度会很高。</p><p>因此我们可以反过来想，从两个大洋开始向上流，这样我们只需要对矩形四条边进行搜索。搜索完成后，只需遍历一遍矩阵，满足条件的位置即为两个大洋向上流都能到达的位置。</p><h3 id="AC-17"><a href="#AC-17" class="headerlink" title="AC"></a>AC</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dir&#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; pacificAtlantic(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.empty() || matrix[<span class="number">0</span>].empty()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">int</span> n=matrix.size(),m=matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; canReachT(n,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(m,<span class="literal">false</span>));</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; canReachD(n,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(m,<span class="literal">false</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            dfs(matrix,canReachT,i,<span class="number">0</span>);</span><br><span class="line">            dfs(matrix,canReachD,i,m<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            dfs(matrix,canReachT,<span class="number">0</span>,i);</span><br><span class="line">            dfs(matrix,canReachD,n<span class="number">-1</span>,i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(canReachT[i][j] &amp;&amp; canReachD[i][j])&#123;</span><br><span class="line">                    ans.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;i,j&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt;&amp; canReach,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(canReach[x][y]) <span class="keyword">return</span>;</span><br><span class="line">        canReach[x][y]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> xx,yy;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            xx=x+dir[i],yy=y+dir[i+<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(xx&gt;=<span class="number">0</span>&amp;&amp;xx&lt;matrix.size() &amp;&amp; yy&gt;=<span class="number">0</span>&amp;&amp;yy&lt;matrix[<span class="number">0</span>].size() &amp;&amp; matrix[x][y]&lt;=matrix[xx][yy])</span><br><span class="line">            dfs(matrix,canReach,xx,yy);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="LeetCode-46-全排列【dfs】"><a href="#LeetCode-46-全排列【dfs】" class="headerlink" title="LeetCode 46. 全排列【dfs】"></a>LeetCode 46. 全排列【dfs】</h2><h3 id="题目描述-18"><a href="#题目描述-18" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个 没有重复 数字的序列，返回其所有可能的全排列。</p><p>示例:</p><blockquote><p>输入: [1,2,3]<br>输出:<br>[<br>  [1,2,3],<br>  [1,3,2],<br>  [2,1,3],<br>  [2,3,1],<br>  [3,1,2],<br>  [3,2,1]<br>]</p></blockquote><h3 id="解题思路-18"><a href="#解题思路-18" class="headerlink" title="解题思路"></a>解题思路</h3><p>怎样输出所有的排列方式呢？对于每一个当前位置 i，我们可以将其于之后的任意位置交换， 然后继续处理位置 i+1，直到处理到最后一位。</p><p>为了防止我们每此遍历时都要新建一个子数组储存位置i之前已经交换好的数字，我们可以利用回溯法，只对原数组进行修改，在递归完成后再修改回来。 </p><p>我们以样例[1,2,3]为例，按照这种方法，我们输出的数组顺序为[[1,2,3],[1,3,2],[2,1,3],[2,3,1], [3,1,2],[3,2,1]]，可以看到所有的排列在这个算法中都被考虑到了。</p><h3 id="AC-18"><a href="#AC-18" class="headerlink" title="AC"></a>AC</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; permute(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        dfs(nums,<span class="number">0</span>,ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums,<span class="keyword">int</span> t,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; ans)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t==nums.size()<span class="number">-1</span>)&#123;</span><br><span class="line">            ans.push_back(nums);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=t;i&lt;nums.size();i++)&#123;</span><br><span class="line">            swap(nums[i],nums[t]);</span><br><span class="line">            dfs(nums,t+<span class="number">1</span>,ans);</span><br><span class="line">            swap(nums[i],nums[t]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 添加加载动画</title>
      <link href="posts/35726/"/>
      <url>posts/35726/</url>
      
        <content type="html"><![CDATA[<h2 id="butterfly主题"><a href="#butterfly主题" class="headerlink" title="butterfly主题"></a>butterfly主题</h2><h3 id="阅读须知"><a href="#阅读须知" class="headerlink" title="阅读须知"></a>阅读须知</h3><p>如果你是 <code>clone</code> 原主题 <code>dev</code> 分支的话，这篇博客可能不需要继续阅读下去，你只需将主题下<code>Butterfly.yml</code> 中 <code>preloader: false</code> 变为 <code>true</code> 即可。但是如果你是 <code>clone</code> 的 <code>master</code> 分支，和我一样，想自己搞一个加载动画，那就按着教程一步一步来。但我弄完之后，发现不开着或许会好一点，然后又变为<code>false</code>了。</p><h3 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h3><p>第一步，在 <code>themes/Butterfly/layout/includes/layout.pug</code> 添加如下代码：</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> theme.preloader</span><br><span class="line">      !=<span class="keyword">partial</span>(<span class="string">&#x27;includes/loading/loading&#x27;</span>, &#123;&#125;, &#123;cache:theme.fragment_cache&#125;)</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200425161421493.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""><br>继续，在 <code>themes/Butterfly/layout/404.pug</code> 添加如下代码：</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> theme.preloader</span><br><span class="line">  !=<span class="keyword">partial</span>(<span class="string">&#x27;includes/loading/loading&#x27;</span>, &#123;&#125;, &#123;cache:theme.fragment_cache&#125;)  </span><br><span class="line"><span class="keyword">if</span> theme.fireworks &amp;&amp; theme.fireworks.enable</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200425165337982.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><p>在 <code>themes/Butterfly/layout/includes/additional-js.pug</code> 最后一行添加如下代码：</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> theme.preloader</span><br><span class="line">  !=<span class="keyword">partial</span>(<span class="string">&#x27;includes/loading/loading-js&#x27;</span>, &#123;&#125;, &#123;cache:theme.fragment_cache&#125;)</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200425162511644.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><p>第二步，在 <code>themes/Butterfly/layout/includes</code> 下新建一个文件夹，命名为 <code>loading</code>，如下图所示，添加两个文件。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200425161524732.png" alt=""></p><p><code>loading-js.pug</code></p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">script.</span><br><span class="line">  <span class="keyword">var</span> endLoading = function () &#123;</span><br><span class="line">    document.body.style.overflow = <span class="string">&#x27;auto&#x27;</span>;</span><br><span class="line">    document.getElementById(<span class="string">&#x27;loading-box&#x27;</span>).classList.<span class="keyword">add</span>(<span class="string">&quot;loaded&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  window.addEventListener(<span class="string">&#x27;load&#x27;</span>,endLoading)</span><br></pre></td></tr></table></figure><p><code>loading.pug</code></p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#loading-box</span></span><br><span class="line">  .loading-left-bg</span><br><span class="line">  .loading-right-bg</span><br><span class="line">  .spinner-box</span><br><span class="line">    .configure-border<span class="number">-1</span></span><br><span class="line">      .configure-core</span><br><span class="line">    .configure-border<span class="number">-2</span></span><br><span class="line">      .configure-core</span><br><span class="line">    .loading-word= _p(<span class="string">&#x27;loading&#x27;</span>)</span><br></pre></td></tr></table></figure><p>第三步，在<code>themse/Butterfly/source/css/_layout/</code> 文件夹下新建 <code>loadding.styl</code>，复制下面代码，添加</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> hexo-config(<span class="string">&#x27;preloader&#x27;</span>)</span><br><span class="line">  loading-bg()</span><br><span class="line">    position: <span class="keyword">fixed</span></span><br><span class="line">    z-index: <span class="number">1000</span></span><br><span class="line">    width: <span class="number">50</span>%</span><br><span class="line">    height: <span class="number">100</span>%</span><br><span class="line">    background-color: $preloader-bg</span><br><span class="line">    transition: all <span class="number">.5</span>s</span><br><span class="line"></span><br><span class="line">  <span class="meta">#loading-box</span></span><br><span class="line">    .loading-left-bg</span><br><span class="line">      loading-bg()</span><br><span class="line"></span><br><span class="line">    .loading-right-bg</span><br><span class="line">      loading-bg()</span><br><span class="line">      right: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    .spinner-box</span><br><span class="line">      position: <span class="keyword">fixed</span></span><br><span class="line">      z-index: <span class="number">1001</span></span><br><span class="line">      display: flex</span><br><span class="line">      justify-content: center</span><br><span class="line">      align-items: center</span><br><span class="line">      width: <span class="number">100</span>%</span><br><span class="line">      height: <span class="number">100</span>vh</span><br><span class="line"></span><br><span class="line">      .configure-border<span class="number">-1</span></span><br><span class="line">        position: absolute</span><br><span class="line">        padding: <span class="number">3</span>px</span><br><span class="line">        width: <span class="number">115</span>px</span><br><span class="line">        height: <span class="number">115</span>px</span><br><span class="line">        background: <span class="meta">#ffab91</span></span><br><span class="line">        animation: configure-clockwise <span class="number">3</span>s ease-<span class="keyword">in</span>-<span class="keyword">out</span> <span class="number">0</span>s infinite alternate</span><br><span class="line"></span><br><span class="line">      .configure-border<span class="number">-2</span></span><br><span class="line">        left: <span class="number">-115</span>px</span><br><span class="line">        padding: <span class="number">3</span>px</span><br><span class="line">        width: <span class="number">115</span>px</span><br><span class="line">        height: <span class="number">115</span>px</span><br><span class="line">        background: rgb(<span class="number">63</span>, <span class="number">249</span>, <span class="number">220</span>)</span><br><span class="line">        transform: rotate(<span class="number">45</span>deg)</span><br><span class="line">        animation: configure-xclockwise <span class="number">3</span>s ease-<span class="keyword">in</span>-<span class="keyword">out</span> <span class="number">0</span>s infinite alternate</span><br><span class="line"></span><br><span class="line">      .loading-word</span><br><span class="line">        position: absolute</span><br><span class="line">        color: $white</span><br><span class="line">        font-size: <span class="number">.8</span>rem</span><br><span class="line"></span><br><span class="line">      .configure-core</span><br><span class="line">        width: <span class="number">100</span>%</span><br><span class="line">        height: <span class="number">100</span>%</span><br><span class="line">        background-color: $preloader-bg</span><br><span class="line"></span><br><span class="line">    &amp;.loaded</span><br><span class="line">      .loading-left-bg</span><br><span class="line">        transform: translate(<span class="number">-100</span>%, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">      .loading-right-bg</span><br><span class="line">        transform: translate(<span class="number">100</span>%, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">      .spinner-box</span><br><span class="line">        display: none</span><br><span class="line"></span><br><span class="line">  @keyframes configure-clockwise</span><br><span class="line">    <span class="number">0</span>%</span><br><span class="line">      transform: rotate(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="number">25</span>%</span><br><span class="line">      transform: rotate(<span class="number">90</span>deg)</span><br><span class="line"></span><br><span class="line">    <span class="number">50</span>%</span><br><span class="line">      transform: rotate(<span class="number">180</span>deg)</span><br><span class="line"></span><br><span class="line">    <span class="number">75</span>%</span><br><span class="line">      transform: rotate(<span class="number">270</span>deg)</span><br><span class="line"></span><br><span class="line">    <span class="number">100</span>%</span><br><span class="line">      transform: rotate(<span class="number">360</span>deg)</span><br><span class="line"></span><br><span class="line">  @keyframes configure-xclockwise</span><br><span class="line">    <span class="number">0</span>%</span><br><span class="line">      transform: rotate(<span class="number">45</span>deg)</span><br><span class="line"></span><br><span class="line">    <span class="number">25</span>%</span><br><span class="line">      transform: rotate(<span class="number">-45</span>deg)</span><br><span class="line"></span><br><span class="line">    <span class="number">50</span>%</span><br><span class="line">      transform: rotate(<span class="number">-135</span>deg)</span><br><span class="line"></span><br><span class="line">    <span class="number">75</span>%</span><br><span class="line">      transform: rotate(<span class="number">-225</span>deg)</span><br><span class="line"></span><br><span class="line">    <span class="number">100</span>%</span><br><span class="line">      transform: rotate(<span class="number">-315</span>deg)</span><br></pre></td></tr></table></figure><p>然后在<code>themse/Butterfly/source/css/_mode/darkmode.styl</code> 文件最后一行添加如下代码：</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> hexo-config(<span class="string">&#x27;preloader&#x27;</span>)</span><br><span class="line">  <span class="meta">#loading-box</span></span><br><span class="line">    .loading-left-bg,</span><br><span class="line">    .loading-right-bg,</span><br><span class="line">    .configure-core</span><br><span class="line">      background-color: darken(<span class="meta">#121212, 2)</span></span><br><span class="line"></span><br><span class="line">    .loading-word</span><br><span class="line">      color: alpha(<span class="meta">#FFFFFF, .6)</span></span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200425164207160.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><p>然后在<code>themse/Butterfly/source/css/var.styl</code> 文件大约在85行添加如下代码：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//preloader</span></span><br><span class="line">$preloader-bg = #<span class="number">37474f</span></span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200425164438387.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><p>第四步，在 <code>themes/Butterfly/languages/zh-CN.yml</code> 文件最后一行，添加如下代码</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">loading: 加载中...</span><br></pre></td></tr></table></figure><p>具体位置参考如下：<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200425161855816.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><p>将<code>themes/Butterfly/layout/includes/head/subtitle.pug</code> 文件替换为如下代码（将原本的删除）</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> theme.subtitle.enable</span><br><span class="line">  - <span class="keyword">var</span> source = theme.subtitle.source</span><br><span class="line">  - <span class="keyword">var</span> subtitleEffect = theme.subtitle.effect</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> subtitleEffect</span><br><span class="line">    script(src=url_for(theme.CDN.typed))</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> source == <span class="string">&#x27;1&#x27;</span></span><br><span class="line">    script.</span><br><span class="line">      <span class="keyword">var</span> subtitleType = function () &#123;</span><br><span class="line">        <span class="keyword">var</span> subtitleEffect = !&#123; subtitleEffect &#125;</span><br><span class="line">        fetch(<span class="string">&#x27;https://api.btstu.cn/yan/api.php?charset=utf-8&amp;encode=json&#x27;</span>,)</span><br><span class="line">          .then(function (res) &#123;</span><br><span class="line">            <span class="keyword">return</span> res.json()</span><br><span class="line">          &#125;)</span><br><span class="line">          .then(function (data) &#123;</span><br><span class="line">            <span class="keyword">if</span> (subtitleEffect) &#123;</span><br><span class="line">              <span class="keyword">var</span> sub = <span class="string">&#x27;!&#123;theme.subtitle.sub&#125;&#x27;</span>.length == <span class="number">0</span> ? <span class="keyword">new</span> Array() : <span class="string">&#x27;!&#123;theme.subtitle.sub&#125;&#x27;</span>.split(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">              <span class="keyword">var</span> both = sub.unshift(data.text)</span><br><span class="line">              <span class="keyword">var</span> typed = <span class="keyword">new</span> Typed(<span class="string">&#x27;#subtitle&#x27;</span>, &#123;</span><br><span class="line">                strings: sub,</span><br><span class="line">                startDelay: <span class="number">300</span>,</span><br><span class="line">                typeSpeed: <span class="number">150</span>,</span><br><span class="line">                loop: !&#123;theme.subtitle.loop&#125;,</span><br><span class="line">                backSpeed: <span class="number">50</span>,</span><br><span class="line">              &#125;)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              document.getElementById(<span class="string">&#x27;subtitle&#x27;</span>).innerHTML = data.text</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;)</span><br><span class="line">          .catch(function (err) &#123;</span><br><span class="line">            console.error(err)</span><br><span class="line">          &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">      window.addEventListener(<span class="string">&#x27;load&#x27;</span>, subtitleType)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> source == <span class="string">&#x27;2&#x27;</span></span><br><span class="line">    script.</span><br><span class="line">      <span class="keyword">var</span> subtitleType = function () &#123;</span><br><span class="line">        <span class="keyword">var</span> subtitleEffect = !&#123; subtitleEffect &#125;</span><br><span class="line">        fetch(<span class="string">&#x27;https://v1.hitokoto.cn&#x27;</span>)</span><br><span class="line">          .then(function (res) &#123;</span><br><span class="line">            <span class="keyword">return</span> res.json()</span><br><span class="line">          &#125;)</span><br><span class="line">          .then(function (data) &#123;</span><br><span class="line">            <span class="keyword">if</span> (subtitleEffect) &#123;</span><br><span class="line">              <span class="keyword">var</span> <span class="keyword">from</span> = <span class="string">&#x27;出自 &#x27;</span> + data.<span class="keyword">from</span></span><br><span class="line">              <span class="keyword">var</span> sub = <span class="string">&#x27;!&#123;theme.subtitle.sub&#125;&#x27;</span>.length == <span class="number">0</span> ? <span class="keyword">new</span> Array() : <span class="string">&#x27;!&#123;theme.subtitle.sub&#125;&#x27;</span>.split(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">              <span class="keyword">var</span> both = sub.unshift(data.hitokoto, <span class="keyword">from</span>)</span><br><span class="line">              <span class="keyword">var</span> typed = <span class="keyword">new</span> Typed(<span class="string">&#x27;#subtitle&#x27;</span>, &#123;</span><br><span class="line">                strings: sub,</span><br><span class="line">                startDelay: <span class="number">300</span>,</span><br><span class="line">                typeSpeed: <span class="number">150</span>,</span><br><span class="line">                loop: !&#123;theme.subtitle.loop&#125;,</span><br><span class="line">                backSpeed: <span class="number">50</span>,</span><br><span class="line">              &#125;)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              document.getElementById(<span class="string">&#x27;subtitle&#x27;</span>).innerHTML = data.hitokoto</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;)</span><br><span class="line">          .catch(function (err) &#123;</span><br><span class="line">            console.error(err)</span><br><span class="line">          &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">      window.addEventListener(<span class="string">&#x27;load&#x27;</span>, subtitleType)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> source == <span class="string">&#x27;3&#x27;</span></span><br><span class="line">    script.</span><br><span class="line">      <span class="keyword">var</span> subtitleType = function () &#123;</span><br><span class="line">        loadScript(<span class="string">&#x27;http://yijuzhan.com/api/word.php?m=js&#x27;</span>, function () &#123;</span><br><span class="line">          <span class="keyword">var</span> subtitleEffect = !&#123; subtitleEffect &#125;</span><br><span class="line">          <span class="keyword">var</span> con = str[<span class="number">0</span>]</span><br><span class="line">          <span class="keyword">if</span> (subtitleEffect) &#123;</span><br><span class="line">            <span class="keyword">var</span> <span class="keyword">from</span> = <span class="string">&#x27;出自 &#x27;</span> + str[<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">var</span> sub = <span class="string">&#x27;!&#123;theme.subtitle.sub&#125;&#x27;</span>.length == <span class="number">0</span> ? <span class="keyword">new</span> Array() : <span class="string">&#x27;!&#123;theme.subtitle.sub&#125;&#x27;</span>.split(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">            <span class="keyword">var</span> both = sub.unshift(con, <span class="keyword">from</span>)</span><br><span class="line">            <span class="keyword">var</span> typed = <span class="keyword">new</span> Typed(<span class="string">&#x27;#subtitle&#x27;</span>, &#123;</span><br><span class="line">              strings: sub,</span><br><span class="line">              startDelay: <span class="number">300</span>,</span><br><span class="line">              typeSpeed: <span class="number">150</span>,</span><br><span class="line">              loop: !&#123;theme.subtitle.loop&#125;,</span><br><span class="line">              backSpeed: <span class="number">50</span>,</span><br><span class="line">            &#125;)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            document.getElementById(<span class="string">&#x27;subtitle&#x27;</span>).innerHTML = con</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">      window.addEventListener(<span class="string">&#x27;load&#x27;</span>, subtitleType)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> source == <span class="string">&#x27;4&#x27;</span></span><br><span class="line">    script.</span><br><span class="line">      <span class="keyword">var</span> subtitleType = function () &#123;</span><br><span class="line">        loadScript(<span class="string">&#x27;https://sdk.jinrishici.com/v2/browser/jinrishici.js&#x27;</span>,function () &#123;</span><br><span class="line">            <span class="keyword">var</span> subtitleEffect = !&#123; subtitleEffect &#125;</span><br><span class="line">            jinrishici.load(function (result) &#123;</span><br><span class="line">              <span class="keyword">if</span> (subtitleEffect) &#123;</span><br><span class="line">                <span class="keyword">var</span> sub = <span class="string">&#x27;!&#123;theme.subtitle.sub&#125;&#x27;</span>.length == <span class="number">0</span> ? <span class="keyword">new</span> Array() : <span class="string">&#x27;!&#123;theme.subtitle.sub&#125;&#x27;</span>.split(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">                <span class="keyword">var</span> content = result.data.content</span><br><span class="line">                <span class="keyword">var</span> both = sub.unshift(content)</span><br><span class="line">                <span class="keyword">var</span> typed = <span class="keyword">new</span> Typed(<span class="string">&#x27;#subtitle&#x27;</span>, &#123;</span><br><span class="line">                  strings: sub,</span><br><span class="line">                  startDelay: <span class="number">300</span>,</span><br><span class="line">                  typeSpeed: <span class="number">150</span>,</span><br><span class="line">                  loop: !&#123;theme.subtitle.loop&#125;,</span><br><span class="line">                  backSpeed: <span class="number">50</span>,</span><br><span class="line">                &#125;)</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                document.getElementById(<span class="string">&#x27;subtitle&#x27;</span>).innerHTML = result.data.content</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">          &#125;</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">      window.addEventListener(<span class="string">&#x27;load&#x27;</span>, subtitleType)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    script.</span><br><span class="line">      <span class="keyword">var</span> subtitleEffect = !&#123;subtitleEffect&#125;</span><br><span class="line">      <span class="keyword">if</span> (subtitleEffect) &#123; </span><br><span class="line">        <span class="keyword">var</span> typed = <span class="keyword">new</span> Typed(<span class="string">&quot;#subtitle&quot;</span>, &#123;</span><br><span class="line">          strings: <span class="string">&#x27;!&#123;theme.subtitle.sub&#125;&#x27;</span>.split(<span class="string">&quot;,&quot;</span>),</span><br><span class="line">          startDelay: <span class="number">300</span>,</span><br><span class="line">          typeSpeed: <span class="number">150</span>,</span><br><span class="line">          loop: !&#123;theme.subtitle.loop&#125;,</span><br><span class="line">          backSpeed: <span class="number">50</span></span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        document.getElementById(<span class="string">&quot;subtitle&quot;</span>).innerHTML = <span class="string">&#x27;!&#123;theme.subtitle.sub[0]&#125;&#x27;</span></span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>第五步，在主题文件 <code>butterfly.yml</code> 任意位置添加如下代码，启用加载动画，不启用可以设置为 <code>false</code></p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="meta"># 加载动画 Loading Animation</span></span><br><span class="line">preloader: <span class="literal">true</span></span><br></pre></td></tr></table></figure><h2 id="其他主题"><a href="#其他主题" class="headerlink" title="其他主题"></a>其他主题</h2><p>第一步，将以下内容添加到 <code>&lt;head&gt;&lt;/head&gt;</code> 标签内：</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">&lt;link rel=<span class="string">&quot;stylesheet&quot;</span> href=<span class="string">&quot;https://cdn.jsdelivr.net/gh/HCLonely/images@master/others/loading.min.css&quot;</span>&gt;</span><br></pre></td></tr></table></figure><p>第二步，将以下内容添加到<code>&lt;body&gt;</code> 标签后面：</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;loading-box&quot;</span>&gt;</span><br><span class="line">  &lt;div <span class="keyword">class</span>=<span class="string">&quot;loading-left-bg&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">  &lt;div <span class="keyword">class</span>=<span class="string">&quot;loading-right-bg&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">  &lt;div <span class="keyword">class</span>=<span class="string">&quot;spinner-box&quot;</span>&gt;</span><br><span class="line">    &lt;div <span class="keyword">class</span>=<span class="string">&quot;configure-border-1&quot;</span>&gt;</span><br><span class="line">      &lt;div <span class="keyword">class</span>=<span class="string">&quot;configure-core&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div <span class="keyword">class</span>=<span class="string">&quot;configure-border-2&quot;</span>&gt;</span><br><span class="line">      &lt;div <span class="keyword">class</span>=<span class="string">&quot;configure-core&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div <span class="keyword">class</span>=<span class="string">&quot;loading-word&quot;</span>&gt;加载中...&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>第三步，将以下内容添加到 <code>&lt;/body&gt;</code>标签前面：</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">var</span> endLoading = function () &#123;</span><br><span class="line">    document.body.style.overflow = <span class="string">&#x27;auto&#x27;</span>;</span><br><span class="line">    document.getElementById(<span class="string">&#x27;loading-box&#x27;</span>).classList.<span class="keyword">add</span>(<span class="string">&quot;loaded&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  window.addEventListener(<span class="string">&#x27;load&#x27;</span>,endLoading);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><strong>参考博客：</strong></p><p>作者: HCLonely<br>链接: <a href="https://blog.hclonely.com/">https://blog.hclonely.com/</a><br>来源: HCLonely Blog</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【项目总结文档】Vue全家桶开发电商管理系统项目</title>
      <link href="posts/2020704/"/>
      <url>posts/2020704/</url>
      
        <content type="html"><![CDATA[<p><img src= "/img/loading.gif" data-lazy-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL2Nob2NvbGF0ZTE5OTkvY2RuL2ltZy8yMDIwMDcwNDIxNDEyMC5qcGc?x-oss-process=image/format,png" alt=""></p><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>这个项目是我第二次做了，第一次做的时候好多地方不是很懂，而现在学习了基础知识后，回过来再做一次，发现原来不是很懂的地方也弄明白了，然后又在B站找了项目实战撸了一把，想通过这篇文章，对其中的模块实现做一下总结，同时希望能够加深对项目的理解，不断发掘其中的亮点。如果你觉得本文还行，请毫不留情的点赞！</p><h2 id="element-ui篇"><a href="#element-ui篇" class="headerlink" title="element-ui篇"></a>element-ui篇</h2><p><a href="https://element.eleme.cn/#/zh-CN/component/installation">element-ui 官方中文文档传送门</a></p><h3 id="el-form-组件问题"><a href="#el-form-组件问题" class="headerlink" title="el-form 组件问题"></a>el-form 组件问题</h3><p><code>el-form</code> 组件默认是 <code>content-box</code>，我们设置其如下属性时，就会出现长度比我们想象中长一点的情况。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.login_form</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200625151609765.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""><br>解决办法如下，直接设置 <code>box-sizing</code> 为 <code>border-box</code> 即可。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.login_form</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-iconfont-给输入框添加图标"><a href="#使用-iconfont-给输入框添加图标" class="headerlink" title="使用 iconfont 给输入框添加图标"></a>使用 iconfont 给输入框添加图标</h3><p>在 <code>main.js</code> 中导入字体图标<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200625154012230.png" alt=""><br>然后在 <code>el-input</code> 组件中通过 <code>prefix-icon</code> 进行相关图标引用<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200625154538688.png" alt=""><br>最终效果图如下：<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200625154619145.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><h3 id="如何进行表单验证"><a href="#如何进行表单验证" class="headerlink" title="如何进行表单验证"></a>如何进行表单验证</h3><p><code>Form</code> 组件提供了表单验证的功能，只需要通过 <code>rules</code> 属性传入约定的验证规则，并将 <code>Form-Item</code> 的 <code>prop</code> 属性设置为需校验的字段名即可。<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200625160326747.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""><br>通过 <code>rules</code> 属性传入约定的验证规则<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200625160430877.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""><br>将<code>Form-Item</code> 的 <code>prop</code> 属性设置为需校验的字段名<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200625160417847.png" alt=""></p><h3 id="如何重置表单"><a href="#如何重置表单" class="headerlink" title="如何重置表单"></a>如何重置表单</h3><p><code>element-ui</code> 对表单提供了如下方法 <code>resetFields</code>，我们只需要获取表单对象数据即可重置我们的表单。<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200625160907353.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""><br>获取表单对象方式如下：</p><p>直接在表单处添加 <code>ref</code>属性，如下 <code>loginFormRef</code>，此引用即为我们表单实例。<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200625161049896.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""><br>然后，在我们重置按钮处，通过 <code>@click</code> 给按钮绑定一个事件<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200625161224696.png" alt=""><br>下一步，添加方法，我们可以打印一下 <code>this</code><br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200625161531622.png" alt=""><br>不难发现，此时的 <code>this</code> 指向的就是我们当前登录组件 <code>login.vue</code>的实例对象。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200625161715318.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""><br>观察上图，我们看到有一个 <code>$refs</code> 属性，这个就是我们的表单实例。</p><p>此时，我们的方法就可以改写成如下方式：<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200625162008760.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><blockquote><p>最后，我们点击重置按钮后，会发现输入框并不是完全清空了，原因是data数据里面一开始我们设置了默认值，因此resetFields()函数就是清空为默认值。</p></blockquote><h3 id="登录预校验"><a href="#登录预校验" class="headerlink" title="登录预校验"></a>登录预校验</h3><blockquote><p>在我们点击登录按钮，不应该直接发起网络请求，而是应该对表单进行预校验，检验成功才会发送请求。</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200625162900919.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""><br>拿到表单引用对象，即可进行对表单的校验。</p><p>首先，给登录按钮通过 <code>@click</code> 来绑定一个事件<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200625163054420.png" alt=""><br>下一步，在 <code>methods</code> 中添加 <code>login</code> 方法，<code>validate</code>函数参数为一个回调函数。该回调函数会在校验结束后被调用，并传入两个参数：是否校验成功和未通过校验的字段。若不传入回调函数，则会返回一个 <code>promise</code><br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200625163326719.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""><br>此时，我们点击登录按钮，查看是否进行了预校验：</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200625163522941.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""><br>此时，按照之前的校验规则，是存在问题的。所以返回 <code>false</code>。我们来一个正确示例吧：</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/2020062516371351.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><h3 id="配置弹框提示组件"><a href="#配置弹框提示组件" class="headerlink" title="配置弹框提示组件"></a>配置弹框提示组件</h3><p>首先，在 <code>element.js</code> 中导入弹框提示组件，但是它的配置与其它组件不一样，它需要进行全局挂载。<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200625170544575.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""><br>全局导入后，我们就可以在我们的登录组件 <code>login.vue</code> 中通过 <code>this</code>来访问弹框提示组件了。<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200625170523514.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""><br>测试一下，输入 <code>admin</code> 和 <code>123456</code>，此时就会提示输入成功。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200625170502751.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><h3 id="每一个组件都是一个类名"><a href="#每一个组件都是一个类名" class="headerlink" title="每一个组件都是一个类名"></a>每一个组件都是一个类名</h3><blockquote><p>每一个组件都是一个类名，我们可以直接增加效果属性。</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200625204029790.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><h3 id="el-menu-默认会有一个-border-right"><a href="#el-menu-默认会有一个-border-right" class="headerlink" title="el-menu 默认会有一个 border-right"></a>el-menu 默认会有一个 border-right</h3><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200626084738793.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""><br>这样会导致我们的菜单栏右边会有一个若隐若现的线条凸起<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200626084808791.png" alt=""><br>解决办法如下，直接将 <code>el-menu</code> 的<code>border-right</code> 设置为 <code>none</code> 即可。<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200626084841591.png" alt=""></p><h3 id="表格展开页"><a href="#表格展开页" class="headerlink" title="表格展开页"></a>表格展开页</h3><p>只需要将 <code>el-table-column</code> 中 <code>type</code> 属性设为 <code>expand</code> 即能将表格进行展开。<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200626190138903.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""><br>实现效果如下：<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200626190218268.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><h3 id="使用树形控件-el-tree"><a href="#使用树形控件-el-tree" class="headerlink" title="使用树形控件 el-tree"></a>使用树形控件 el-tree</h3><p>对于分配权限一栏，我们需要如下效果：</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200627112742297.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""><br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200627112805759.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><p>相关配置属性：<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200627111555828.png" alt=""><br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200627111606458.png" alt=""><br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200627111856396.png" alt=""></p><p>其中 <code>data</code> 为我们的数据源，<code>props</code> 为我们在 <code>tree</code>组件显示的文本内容。通过设置 <code>node-key</code>可以让每个树节点作为唯一标识的属性，整棵树是唯一的；通过设置 <code>default-expand-all</code> 来默认展开我们的所有节点，不需要每次都让用户去打开，体验感好；通过设置 <code>default-checked-keys</code>勾选我们已有的权限。</p><p>最后，我们通过递归的方式，判断当前 <code>node</code> 节点是否存在 <code>children</code>属性，如果不存在的话，就包含了三级权限，然后添加到我们的数组中，然后通过 <code>:default-checked-keys=&quot;defKeys&quot;</code> 来渲染选中当前已有的权限。<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200627112820403.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""><br>此外，当我们关闭对话框时还需要监听一下关闭事件，不然每次数组都会保存原来的权限数据，导致一些问题。因此，监听 <code>close</code> 事件后，每次对话框关闭时，都将数组进行清空。<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200627113250495.png" alt=""><br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200627113240263.png" alt=""></p><p><strong>获取选中节点的keys：</strong></p><p>首先，给我们对话框的确定按钮绑定一个事件。<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200627115201785.png" alt=""><br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200627115223903.png" alt=""><br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200627115214947.png" alt=""><br>主要使用 <code>tree</code> 组件提供的两个方法 <code>getCheckedKeys</code> 和 <code>getHalfCheckedKeys</code>来分别返回目前被选中的节点的 <code>key</code> 所组成的数组和目前半选中的节点的 <code>key</code> 所组成的数组<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200627115147590.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><h3 id="使用动态编辑标签"><a href="#使用动态编辑标签" class="headerlink" title="使用动态编辑标签"></a>使用动态编辑标签</h3><p>实现效果如下：<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200702213646205.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""><br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200702213736642.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""><br>通过 <code>v-if</code> 的 <code>boolean</code>值来动态变化是否显示文本框还是 <code>button</code> 按钮。通过 <code>v-model</code> 双向绑定来实现文本框内容的监听。</p><p>由于每一行需要设置文本框的显示与隐藏，而且数据是共享的。我们需要通过 <code>scope</code>来获取每一行的值来进行绑定，不然的话，就会导致某个文本框显示了，其它文本框也跟着显示，并且数据是共用的，都会同步变化。而设置 <code>scope</code>后，我们就能实现对一行数据进行更新渲染了。</p><p>为了实现当我们点击按钮后，让本文看自动获取焦点。<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200702214330279.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""><br>通过 <code>this.$refs.saveTagInput.$refs.input.focus()</code> 来获取 <code>input</code> 的 <code>dom</code> 对象，接着调用 <code>focus</code>函数来获取焦点。</p><p><code>$nextTick</code> 作用是当页面元素被重新渲染之后才会执行回调函数中的代码。如果不这样做的话，我们直接通过点击按钮的形式，将该行的 <code>inputVisible</code> 设置为了 <code>true</code>，那么此时直接调用 <code>this.$refs.saveTagInput.$refs.input.focus()</code> 是没办法获取焦点的，此时就会报错。因为我们的 <code>dom</code>节点还没有进行渲染，而先调用 <code>$nextTick</code>  就是为了等待 <code>dom</code>节点渲染之后，我们再获取 <code>input</code>，然后再调用 <code>focus</code> 函数来获取焦点。</p><h2 id="步骤条的使用与美化"><a href="#步骤条的使用与美化" class="headerlink" title="步骤条的使用与美化"></a>步骤条的使用与美化</h2><p>以下就是步骤条使用的核心代码，其中 <code>active</code> 绑定的是每一个 <code>step</code> 的下标，默认从 <code>0</code> 开始。其次，我们可以设置 <code>aligin-center</code> 属性来让我们的步骤条进行居中。<code>el-step</code>就是每一个步骤进度。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!-- 步骤条区域 --&gt;</span><br><span class="line">&lt;el-steps :space=<span class="string">&quot;200&quot;</span> :active=<span class="string">&quot;activeIndex&quot;</span> finish-status=<span class="string">&quot;success&quot;</span> align-center&gt;</span><br><span class="line">   &lt;el-step title=<span class="string">&quot;基本信息&quot;</span>&gt;&lt;/el-step&gt;</span><br><span class="line">   &lt;el-step title=<span class="string">&quot;商品参数&quot;</span>&gt;&lt;/el-step&gt;</span><br><span class="line">   &lt;el-step title=<span class="string">&quot;商品属性&quot;</span>&gt;&lt;/el-step&gt;</span><br><span class="line">   &lt;el-step title=<span class="string">&quot;商品图片&quot;</span>&gt;&lt;/el-step&gt;</span><br><span class="line">   &lt;el-step title=<span class="string">&quot;商品内容&quot;</span>&gt;&lt;/el-step&gt;</span><br><span class="line">   &lt;el-step title=<span class="string">&quot;完成&quot;</span>&gt;&lt;/el-step&gt;</span><br><span class="line">&lt;/el-steps&gt;</span><br></pre></td></tr></table></figure><p>更改原本样式，得到我们想要的效果：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.el-steps</span>&#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">15px</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.el-step__title</span>&#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">13px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终实现效果如下：<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200703094313666.png" alt=""></p><h3 id="阻止页签tabs切换"><a href="#阻止页签tabs切换" class="headerlink" title="阻止页签tabs切换"></a>阻止页签tabs切换</h3><p>主要函数如下：<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200703104547500.png" alt=""><br>在我们的 <code>tabs</code> 标签页添加一个 <code>before-leave</code> 函数<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200703104604112.png" alt=""></p><p>然后在 <code>methods</code> 中定义，根据第一个标签页的逻辑来阻止标签页的切换。<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200703104632688.png" alt=""></p><h3 id="Upload-上传组件"><a href="#Upload-上传组件" class="headerlink" title="Upload 上传组件"></a>Upload 上传组件</h3><blockquote><p>通过点击或者拖拽上传文件</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!-- action表示图片上传后台api地址 --&gt;</span><br><span class="line">&lt;el-upload</span><br><span class="line">    :action=<span class="string">&quot;uploadURL&quot;</span></span><br><span class="line">    :on-preview=<span class="string">&quot;handlePreview&quot;</span></span><br><span class="line">    :on-remove=<span class="string">&quot;handleRemove&quot;</span></span><br><span class="line">    list-type=<span class="string">&quot;picture&quot;</span></span><br><span class="line">&gt;</span><br><span class="line">    &lt;el-button size=<span class="string">&quot;small&quot;</span> type=<span class="string">&quot;primary&quot;</span>&gt;点击上传&lt;/el-button&gt;</span><br><span class="line">    &lt;div slot=<span class="string">&quot;tip&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;el-upload__tip&quot;</span>&gt;只能上传jpg/png文件，且不超过500kb&lt;/div&gt;</span><br><span class="line">&lt;/el-upload&gt;</span><br><span class="line"></span><br><span class="line">data---&gt;</span><br><span class="line"><span class="comment">// 上传图片的url</span></span><br><span class="line">uploadURL: <span class="string">&#x27;http://127.0.0.1:8888/api/private/v1/upload&#x27;</span></span><br></pre></td></tr></table></figure><p>配置如下之后，并不代表就真正上传了，此时，我们打开 <code>Network</code> 查看 <code>Preview</code> ，发现 <code>msg</code> 提示我们 <code>无效 token</code>，状态码为 <code>400</code> ，这代表并没有上传成功。<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200703115410989.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><p>这是因为此时上传控件没有使用 <code>axios</code> 发 <code>ajax</code> 请求，而是组件内部自动封装了一个 <code>ajax</code>，因此也就不会调用下述请求拦截器了。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200703115748622.png" alt=""></p><p>解决办法是 <code>Upload</code> 组件有一个 <code>headers</code> 属性，可以设置上传的请求头部。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/2020070311582168.png" alt=""><br>第一步，在组件处添加 <code>headers</code> 属性<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200703120057485.png" alt=""><br>第二步，在 <code>data</code> 中定义 <code>headersObj</code> ，然后添加请求头对象。<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200703120108511.png" alt=""><br>操作完成后，可以看到提示消息 <code>msg</code> 显示上传成功，并且此时状态码也变为了 <code>200</code>。<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200703120309502.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><h4 id="监听图片上传成功事件"><a href="#监听图片上传成功事件" class="headerlink" title="监听图片上传成功事件"></a>监听图片上传成功事件</h4><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200703143644529.png" alt=""><br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200703144027592.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""><br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200703144007474.png" alt=""></p><h4 id="监听图片删除事件"><a href="#监听图片删除事件" class="headerlink" title="监听图片删除事件"></a>监听图片删除事件</h4><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200703144136607.png" alt=""></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 处理图片移除的操作</span></span><br><span class="line"><span class="function"><span class="title">handleRemove</span>(<span class="params">file</span>)</span> &#123;</span><br><span class="line">  <span class="comment">// 1.获取将要删除的图片的临时路径</span></span><br><span class="line">  <span class="keyword">const</span> filePath = file.response.data.tmp_path</span><br><span class="line">  <span class="comment">// 2.从pics数组中，找到这个图片对应的索引值</span></span><br><span class="line">  <span class="keyword">const</span> idx = <span class="built_in">this</span>.addForm.pics.findIndex(<span class="function"><span class="params">x</span> =&gt;</span> x.pic === filePath)</span><br><span class="line">  <span class="comment">// 3.调用数组的 splice 方法，把图片信息对象，从pics数组中移除</span></span><br><span class="line">  <span class="built_in">this</span>.addForm.pics.splice(idx, <span class="number">1</span>)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h4 id="处理图片预览操作"><a href="#处理图片预览操作" class="headerlink" title="处理图片预览操作"></a>处理图片预览操作</h4><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200703145000386.png" alt=""><br>图片预览窗可以用 <code>el-dialog</code> 组件来做，然后通过 <code>on-preview</code> 函数来处理图片预览的操作。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!-- 图片预览 --&gt;</span><br><span class="line">&lt;el-dialog title=<span class="string">&quot;图片预览&quot;</span> :visible.sync=<span class="string">&quot;previewVisable&quot;</span> width=<span class="string">&quot;50%&quot;</span>&gt;</span><br><span class="line">  &lt;img :src=<span class="string">&quot;previewPath&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;previewImg&quot;</span>&gt;</span><br><span class="line">&lt;/el-dialog&gt;</span><br></pre></td></tr></table></figure><p>通过函数来获取上传图片的真实 <code>url</code> ，然后监听图片预览窗口的打开即可。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 处理图片预览的操作</span></span><br><span class="line"><span class="function"><span class="title">handlePreview</span>(<span class="params">file</span>)</span> &#123;</span><br><span class="line">  <span class="comment">// 获取图片显示的url</span></span><br><span class="line">  <span class="built_in">this</span>.previewPath = file.response.data.url</span><br><span class="line">  <span class="built_in">this</span>.previewVisable = <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终效果如下：<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200703145522946.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><h3 id="使用Timeline-时间线"><a href="#使用Timeline-时间线" class="headerlink" title="使用Timeline 时间线"></a>使用Timeline 时间线</h3><blockquote><p>可视化地呈现时间流信息。</p></blockquote><p>由于 <code>vue-cli-plugin-element</code> 最后更新时间是 <code>2019年1月</code>，而 <code>element-ui</code> 中 <code>Timeline 时间线</code>更新是在 <code>3月份</code>，因此我们没有办法直接进行引用。因此，我们直接通过手动导入的方式。<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200703165248390.png" alt=""></p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200703165415369.png" alt=""><br>然后，我们打开 <code>element.js</code>，进行导入</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Timeline <span class="keyword">from</span> <span class="string">&#x27;./timeline/index&#x27;</span></span><br><span class="line"><span class="keyword">import</span> TimelineItem <span class="keyword">from</span> <span class="string">&#x27;./timeline-item/index&#x27;</span></span><br></pre></td></tr></table></figure><p>同时，我们也需要导入我们的 <code>css</code> 样式</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;style lang=&quot;less&quot; scoped&gt;</span><br><span class="line"><span class="keyword">@import</span> <span class="string">&#x27;../../plugins/timeline/timeline.css&#x27;</span>;</span><br><span class="line"><span class="keyword">@import</span> <span class="string">&#x27;../../plugins/timeline-item/timeline-item.css&#x27;</span>;</span><br><span class="line"><span class="selector-class">.el-cascader</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/<span class="selector-tag">style</span>&gt;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!-- 展示物流进度的对话框 --&gt;</span><br><span class="line">    &lt;el-dialog title=<span class="string">&quot;物流进度&quot;</span> :visible.sync=<span class="string">&quot;progressVisible&quot;</span> width=<span class="string">&quot;45%&quot;</span> @close=<span class="string">&quot;addressDialogClosed&quot;</span>&gt;</span><br><span class="line">      &lt;el-timeline&gt;</span><br><span class="line">        &lt;el-timeline-item</span><br><span class="line">          v-<span class="keyword">for</span>=<span class="string">&quot;(activity, index) in progressInfo&quot;</span></span><br><span class="line">          :key=<span class="string">&quot;index&quot;</span></span><br><span class="line">          :timestamp=<span class="string">&quot;activity.time&quot;</span>&gt;</span><br><span class="line">          &#123;&#123;activity.context&#125;&#125;</span><br><span class="line">        &lt;/el-timeline-item&gt;</span><br><span class="line">      &lt;/el-timeline&gt;</span><br><span class="line">    &lt;/el-dialog&gt;</span><br></pre></td></tr></table></figure><p>最终实现效果：<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200703170551640.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><h2 id="Vue篇"><a href="#Vue篇" class="headerlink" title="Vue篇"></a>Vue篇</h2><h3 id="如何导入全局样式表"><a href="#如何导入全局样式表" class="headerlink" title="如何导入全局样式表"></a>如何导入全局样式表</h3><p>直接在 <code>main.js</code>将相关样式导入即可</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">// 导入全局样式表</span><br><span class="line">import &#x27;./assets/css/global.css&#x27;</span><br></pre></td></tr></table></figure><h3 id="如何重定向路由"><a href="#如何重定向路由" class="headerlink" title="如何重定向路由"></a>如何重定向路由</h3><p>在 <code>router</code>配置页中使用 <code>redirect</code> 属性<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200625152947308.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><h3 id="element-ui-如何按需导入"><a href="#element-ui-如何按需导入" class="headerlink" title="element-ui 如何按需导入"></a>element-ui 如何按需导入</h3><p>在<code>element.js</code> 文件中，按照如下方式，进行按需导入即可。然后通过 <code>Vue.use()</code>方法进行引用。（优化点：也就是将组建导入都放在一起，如果组件过多的话，支持换行）<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200625153050309.png" alt=""></p><h3 id="配置axios"><a href="#配置axios" class="headerlink" title="配置axios"></a>配置axios</h3><p>在 <code>main.js</code> 文件内进行配置<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200625164858343.png" alt=""><br>那么，此时我们就可以通过 <code>this</code>访问登录组件原型上 <code>$http</code> 方法，来发起对后端的请求了。<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200625165149647.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><h3 id="保存token"><a href="#保存token" class="headerlink" title="保存token"></a>保存token</h3><p>将登录成功之后的 <code>token</code>，保存到客户端的 <code>sessionStorage</code> 中</p><ul><li>项目中除了登录之外的其它 <code>api</code> 接口，必须在登录之后才能访问</li><li><code>token</code> 只应在当前网站打开期间生效，所以将 <code>token</code> 保存在 <code>sessionStorage</code> 中</li></ul><p>通过编程式导航跳转到后台主页，路由地址是 <code>/home</code></p><p>在我们进行登录请求时，我们不妨打印一下，请求过来的数据，如下，服务端那边会传过来一个 <code>token</code> 值。<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200625171505466.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""><br>下一步，我们在登录成功后，将服务端返回过来的 <code>token</code>值直接种植到 <code>sessionStorage</code> 中，然后通过编程式导航跳转到后台主页（<code>/home</code>），通过 <code>$router.push()</code>方法即可。<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200625171850873.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""><br>此时，我们打开浏览器 ，通过<code>F12</code> 查看<code>Application</code>属性，找到 <code>sessionStorage</code> 即可查看到我们刚刚种植的 <code>token</code> 值了。<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200625171834597.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><h3 id="路由导航守卫控制访问权限"><a href="#路由导航守卫控制访问权限" class="headerlink" title="路由导航守卫控制访问权限"></a>路由导航守卫控制访问权限</h3><blockquote><p>如果用户没有登录，但是直接通过URL访问特定页面，需要重新导航到登录页面。</p></blockquote><p>在之前的操作中，我们登录之后会种植一个 <code>token</code> 值，表示我们登录成功了，那么此时我们将 <code>token</code> 值去掉呢？<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200625172621914.png" alt=""><br>直接点击上述 <code>clear all</code> 按钮去掉之后，我们依旧是可以访问 <code>/home</code>的路由，没有登录也能访问我们的后台主页，这肯定不是我们想要的结果。</p><p>在 <code>router/index.js</code> 中进行相关配置，具体如下，调用路由实例 <code>router</code>的 <code>beforeEach</code>方法，即可挂载我们的路由导航守卫。<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200625173727414.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><blockquote><p>这里可能会有疑问，我们需要验证 token的正确性吗？<br>答案是不需要，因为前端只需要管要不要给用户呈现这个页面，而我们调用api时，后端会对我们的 token 值进行校验，前端不需要验证。</p></blockquote><h3 id="退出功能"><a href="#退出功能" class="headerlink" title="退出功能"></a>退出功能</h3><blockquote><p>基于 token 的方式实现退出比较简单，只需要销毁本地的 token 即可。这样，后续的请求就不会携带 token ，必须重新登录生成一个新的 token 之后才可以访问页面。</p></blockquote><p>那么，我们仅需要为退出按钮绑定一个事件即可。<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/2020062520094541.png" alt=""><br>然后事件内容就是：先清空  <code>token</code>，然后跳转到我们的登录页面。</p><p>核心代码如下：<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200625200900889.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><h3 id="JSON格式的配置文件"><a href="#JSON格式的配置文件" class="headerlink" title="JSON格式的配置文件"></a>JSON格式的配置文件</h3><p>在项目根目录创建名为 <code>.prettierrc</code> 的文件，增加如下代码：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;semi&quot;: false,</span><br><span class="line">  &quot;<span class="selector-tag">singleQuote</span>&quot;: <span class="selector-tag">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>semi</code>设置 <code>false</code>去掉分号，<code>singleQuote</code> 设置 <code>true</code>使用单引号。</p><p>此外，还可以禁用 <code>function</code> 处空格报错，增加如下代码：</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#x27;space-before-function-paren&#x27;: 0</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200625201939900.png" alt=""></p><h3 id="通过axios请求拦截器添加-token"><a href="#通过axios请求拦截器添加-token" class="headerlink" title="通过axios请求拦截器添加 token"></a>通过axios请求拦截器添加 token</h3><blockquote><p>通过axios请求拦截器添加 token，保证拥有获取数据的权限。</p></blockquote><p>原因是，后台那边除开登录的 <code>api</code>，其它都需要进行授权。<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200625224347531.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><p>因此，我们可以利用 <code>axios</code> 中<code>interceptors</code>属性，其中有一个成员 <code>request</code>，此时我们可以通过 <code>use</code> 函数为请求拦截器挂载一个回调函数，只要向服务器端发送了一个 <code>axios</code> 请求，会优先调用 <code>use</code> 函数。</p><p>首先，在 <code>main.js</code>添加如下代码：<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/2020062522443885.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""><br>此时，打印 <code>config</code>，查看结果如下，发现我们<code>headers</code> 字段并没有一些授权字段。<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200625222518186.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""><br>此时，我们添加如下一行代码，通过 <code>token</code> 来进行授权。<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200625224847574.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""><br>此时，在<code>Network</code>就能查看到有一个 <code>Authorization</code> 字段了，但这里是为 <code>null</code>，因为我们进行的是登录请求，在登录期间，服务器是不会颁发令牌(<code>token</code>)。如果登录之后，调用其它 <code>api</code> 接口的话，就会颁发相应的<code>token</code>令牌。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200625225114413.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><h3 id="左侧菜单栏"><a href="#左侧菜单栏" class="headerlink" title="左侧菜单栏"></a>左侧菜单栏</h3><p>关于这一块的话，由于后台数据已经写好，我们只需要通过双层 <code>for</code> 循环即可渲染我们的菜单栏，注意点：</p><p><code>:index</code> 只能绑定字符串，因此将后台请求过来的 <code>id</code>值与空字符串进行拼接达到此效果，解决了点击某个菜单栏导致其它菜单栏同时打开的问题。<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200626002104223.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""><br>最终实现效果如下：<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200626002121793.png" alt=""></p><h3 id="左侧菜单栏图标设计"><a href="#左侧菜单栏图标设计" class="headerlink" title="左侧菜单栏图标设计"></a>左侧菜单栏图标设计</h3><p>我们想要的效果如下：<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200626083953921.png" alt=""></p><p>如何设计？</p><p>首先，我们可以在 <code>data</code> 中定义一个对象，对应于每一个菜单选项的 <code>id</code><br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200626084013362.png" alt=""><br>然后通过 <code>for</code> 循环遍历每一个菜单选项的 <code>id</code>即可。<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200626084101527.png" alt=""></p><h3 id="保持一个子菜单的展开"><a href="#保持一个子菜单的展开" class="headerlink" title="保持一个子菜单的展开"></a>保持一个子菜单的展开</h3><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200626084309100.png" alt=""><br>直接在侧边栏区域添加上述属性即可<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200626084353999.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><h3 id="让菜单栏展开与折叠"><a href="#让菜单栏展开与折叠" class="headerlink" title="让菜单栏展开与折叠"></a>让菜单栏展开与折叠</h3><blockquote><p>通过点击一个按钮，让侧边栏进行展开与折叠。通过 isCollapse 的值来动态变化侧边栏的宽度。</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200626090702451.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""><br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200626090849580.png" alt=""><br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/2020062609090095.png" alt=""><br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200626090639490.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><blockquote><p>其中 cursor: pointer 设置是为了让鼠标放在折叠与展开处会有一个手指指向。<br>letter-spacing: 0.2em 是为了让 ||| 有一定间隔</p></blockquote><h3 id="实现首页路由重定向"><a href="#实现首页路由重定向" class="headerlink" title="实现首页路由重定向"></a>实现首页路由重定向</h3><p>我们想要在登录之后重定向到 <code>/welcome</code> 路径，于是需要添加子路由<code>children</code> 属性，然后设置 <code>redirect</code>重定向到我们的子路由。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200626092041931.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""><br>然后在我们组件 <code>Home.vue</code> 的右侧主体区域，放置一个路由占位符 <code>router-view</code> 即可。<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200626092331999.png" alt=""></p><h3 id="侧边栏路由改造"><a href="#侧边栏路由改造" class="headerlink" title="侧边栏路由改造"></a>侧边栏路由改造</h3><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200626093427997.png" alt=""><br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200626093553305.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><p>通过给侧边栏设置 <code>router</code> 属性为 <code>true</code>，我们就能开启 <code>vue-router</code> 路由模式，然后将我们二级菜单的 <code>index</code> 属性绑定我们的数据 <code>path</code> 即可。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200626093537398.png" alt=""></p><h3 id="在sessionStorage保存左侧菜单栏的激活状态"><a href="#在sessionStorage保存左侧菜单栏的激活状态" class="headerlink" title="在sessionStorage保存左侧菜单栏的激活状态"></a>在sessionStorage保存左侧菜单栏的激活状态</h3><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200626110659178.png" alt=""></p><blockquote><p>为了让我们点击二级菜单时，会有一个激活效果，而且是保持状态，我们需要将利用 element-ui 菜单栏相关 <code>default-active</code> 属性，来让菜单保持激活。</p></blockquote><p>由于每个二级菜单都有一个路由链接，不妨将路由路径 <code>path</code> 存储在 <code>sessionStorage</code> 中，具体做法就是给二级菜单绑定一个事件：</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200626111037224.png" alt=""><br>每次触发点击事件，我们需要更新当前路由路径，才能让点击的那个按钮高亮。<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200626111005679.png" alt=""><br>然后在我们创建这个组件时，就获取当前的激活状态的路径即可。<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200626111059332.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""><br>查看 <code>sessionStorage</code> ，可以看到我们存储的路由路径。<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200626111210909.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><h3 id="slot插槽使用"><a href="#slot插槽使用" class="headerlink" title="slot插槽使用"></a>slot插槽使用</h3><blockquote><p>项目需求：由于用户列表状态后台返回的是 true/false，无法进行渲染，而我们需要的是有一个Switch开关来控制我们的状态。添加一个<code>template</code> 模板后，此时就可以用 <code>slot-scope</code> 作用域插槽来获取我们数据列表中的每一行数据，具体如下：</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200626115207779.png" alt=""><br>最后，我们就可以得到如下效果图了：<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200626115215887.png" alt=""></p><h3 id="通过switch开关更改用户状态"><a href="#通过switch开关更改用户状态" class="headerlink" title="通过switch开关更改用户状态"></a>通过switch开关更改用户状态</h3><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200626143922934.png" alt=""><br>首先，在 <code>switch</code> 开关添加一个 <code>change</code> 事件，并且通过作用域插槽的形式，将该行数据作为参数传入，目的是为了后续的修改。<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200626143944489.png" alt=""><br>在函数内我们将传递过来的参数作为我们请求的参数，通过 <code>put</code> 方式修改我们的后台数据。<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200626144204184.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><h3 id="input输入框优化"><a href="#input输入框优化" class="headerlink" title="input输入框优化"></a>input输入框优化</h3><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200626144910726.png" alt=""><br>通过增加 <code>clearable</code> 属性，我们的输入框就可以多一个 <code>x</code>，然后通过绑定 <code>clear</code> 事件，当我们进行清除 （即点击由 <code>clearable</code> 属性生成的清空按钮时触发)时，就会重新获取我们的用户列表，不再需要用户再次点击搜索按钮去获取了。<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/2020062614490026.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><h3 id="正则表达式验证邮箱和手机号码"><a href="#正则表达式验证邮箱和手机号码" class="headerlink" title="正则表达式验证邮箱和手机号码"></a>正则表达式验证邮箱和手机号码</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 验证邮箱的规则</span></span><br><span class="line">   <span class="keyword">var</span> checkEmail = <span class="function">(<span class="params">rule, value, cb</span>) =&gt;</span> &#123;</span><br><span class="line">     <span class="keyword">const</span> regEmail = <span class="regexp">/^([a-zA-Z]|[0-9])(\w|-)+@[a-zA-Z0-9]+\.([a-zA-Z]&#123;2,4&#125;)$/</span></span><br><span class="line">     <span class="keyword">if</span> (regEmail.test(value)) &#123;</span><br><span class="line">       <span class="comment">// 合法的邮箱</span></span><br><span class="line">       <span class="keyword">return</span> cb()</span><br><span class="line">     &#125;</span><br><span class="line">     cb(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;请输入合法的邮箱&#x27;</span>))</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 验证手机号码的规则</span></span><br><span class="line">   <span class="keyword">var</span> checkMobile = <span class="function">(<span class="params">rule, value, cb</span>) =&gt;</span> &#123;</span><br><span class="line">     <span class="keyword">const</span> regMobile = <span class="regexp">/^(0|86|17951)?(13[0-9]|15[012356789]|17[678]|18[0-9]|14[57])[0-9]&#123;8&#125;$/</span></span><br><span class="line">     <span class="keyword">if</span> (regMobile.test(value)) &#123;</span><br><span class="line">       <span class="comment">// 合法的手机号码</span></span><br><span class="line">       <span class="keyword">return</span> cb()</span><br><span class="line">     &#125;</span><br><span class="line">     cb(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;手机号码格式不正确&#x27;</span>))</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200626153231594.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><h3 id="使用vue-table-with-tree-grid"><a href="#使用vue-table-with-tree-grid" class="headerlink" title="使用vue-table-with-tree-grid"></a>使用vue-table-with-tree-grid</h3><p>安装新的依赖 <code>vue-tabel-with-tree-grid</code><br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200627164719423.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""><br><a href="https://github.com/MisterTaki/vue-table-with-tree-grid">vue-tabel-with-tree-grid 官方文档</a></p><p>安装完成后，在 <code>main.js</code> 入口文件内先导入 <code>tree-tabel</code><br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200627165055586.png" alt=""><br>然后全局注册组件 <code>tree-tabel</code><br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200627165101828.png" alt=""><br>页面中，我们使用了如下属性：</p><p><code>data</code> 确定我们的数据源，<code>columns</code>定义我们的指定列，<code>selection-type</code> 设置是否打开多选框，<code>expand-type</code> 设置是否展示展开栏，<code>show-index</code> 添加索引列， <code>border</code> 给表格添加边框。<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200627170313347.png" alt=""></p><p><strong>使用模板列：</strong></p><p>通过在<code>columns</code> 设置 <code>type</code> 属性值为 <code>template</code>，即可设置模板列。<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200627203159721.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""><br>然后在我们界面表格区域，添加一个 <code>template</code> 模板，然后设置作用域插槽 <code>slot</code> 为在数据块定义的模板名称 <code>isOk</code><br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200627203244176.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><h3 id="自定义格式化时间的全局过滤器"><a href="#自定义格式化时间的全局过滤器" class="headerlink" title="自定义格式化时间的全局过滤器"></a>自定义格式化时间的全局过滤器</h3><p>在 <code>main.js</code> 入口文件全局注册格式化时间的过滤器，代码如下所示：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自定义格式化时间的全局过滤器</span></span><br><span class="line">Vue.filter(<span class="string">&#x27;dataFormat&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">originVal</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dt = <span class="keyword">new</span> <span class="built_in">Date</span>(originVal)</span><br><span class="line">  <span class="keyword">const</span> year = dt.getFullYear()</span><br><span class="line">  <span class="keyword">const</span> mon = (dt.getMonth() + <span class="number">1</span> + <span class="string">&#x27;&#x27;</span>).padStart(<span class="number">2</span>, <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">  <span class="keyword">const</span> day = (dt.getDate() + <span class="string">&#x27;&#x27;</span>).padStart(<span class="number">2</span>, <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">  <span class="keyword">const</span> hh = (dt.getHours() + <span class="string">&#x27;&#x27;</span>).padStart(<span class="number">2</span>, <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">  <span class="keyword">const</span> mm = (dt.getMinutes() + <span class="string">&#x27;&#x27;</span>).padStart(<span class="number">2</span>, <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">  <span class="keyword">const</span> ss = (dt.getSeconds() + <span class="string">&#x27;&#x27;</span>).padStart(<span class="number">2</span>, <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;year&#125;</span>-<span class="subst">$&#123;mon&#125;</span>-<span class="subst">$&#123;day&#125;</span> <span class="subst">$&#123;hh&#125;</span>:<span class="subst">$&#123;mm&#125;</span>:<span class="subst">$&#123;ss&#125;</span>`</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在我们的组件当中，通过 <code>|</code> 来给我们的时间添加一个过滤器<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200703092217671.png" alt=""></p><p>最终实现效果如下图所示：<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200703092252595.png" alt=""></p><h3 id="添加富文本编辑器"><a href="#添加富文本编辑器" class="headerlink" title="添加富文本编辑器"></a>添加富文本编辑器</h3><p><a href="https://github.com/surmon-china/vue-quill-editor">vue-quill-editor 官方文档传送门</a></p><p>通过 <code>vue-ui</code> 界面，可以安装我们所需要的依赖，或者使用下文 <code>npm</code> 或 <code>yarn</code>安装。<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200703150054951.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><h4 id="NPM"><a href="#NPM" class="headerlink" title="NPM"></a>NPM</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm install vue-quill-editor --save</span><br><span class="line"></span><br><span class="line"># or</span><br><span class="line">yarn add vue-quill-editor</span><br></pre></td></tr></table></figure><h4 id="Mount-with-global"><a href="#Mount-with-global" class="headerlink" title="Mount with global"></a>Mount with global</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> VueQuillEditor <span class="keyword">from</span> <span class="string">&#x27;vue-quill-editor&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;quill/dist/quill.core.css&#x27;</span> <span class="comment">// import styles</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;quill/dist/quill.snow.css&#x27;</span> <span class="comment">// for snow theme</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;quill/dist/quill.bubble.css&#x27;</span> <span class="comment">// for bubble theme</span></span><br><span class="line"></span><br><span class="line">Vue.use(VueQuillEditor, <span class="comment">/* &#123; default global options &#125; */</span>)</span><br></pre></td></tr></table></figure><p>打开 <code>main.js</code> 入口文件，进行全局导入和注册：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导入富文本编辑器</span></span><br><span class="line"><span class="keyword">import</span> VueQuillEditor <span class="keyword">from</span> <span class="string">&#x27;vue-quill-editor&#x27;</span></span><br><span class="line"><span class="comment">// 导入富文本编辑器对应的样式</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;quill/dist/quill.core.css&#x27;</span> <span class="comment">// import styles</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;quill/dist/quill.snow.css&#x27;</span> <span class="comment">// for snow theme</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;quill/dist/quill.bubble.css&#x27;</span> <span class="comment">// for bubble theme</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将富文本编辑器进行全局注册</span></span><br><span class="line">Vue.use(VueQuillEditor<span class="comment">/* &#123; default global options &#125; */</span>)</span><br></pre></td></tr></table></figure><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>通过 <code>quill-editor</code> 标签，然后通过 <code>v-model</code> 双向绑定到 <code>form</code>表单的商品详情描述变量 <code>goods_introduce</code> 上。<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200703151515853.png" alt=""><br>最终实现效果如下：<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200703151525386.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><h3 id="使用-lodash-中-cloneDeep-obj-来实现深拷贝"><a href="#使用-lodash-中-cloneDeep-obj-来实现深拷贝" class="headerlink" title="使用 lodash 中 cloneDeep(obj) 来实现深拷贝"></a>使用 lodash 中 cloneDeep(obj) 来实现深拷贝</h3><p><a href="https://lodash.com/">lodash 官方文档传送门</a><br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200703152709568.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><h4 id="Using-npm"><a href="#Using-npm" class="headerlink" title="Using npm"></a>Using npm</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$ npm i -g npm</span><br><span class="line">$ npm i --save lodash</span><br></pre></td></tr></table></figure><h4 id="cloneDeep-value-使用"><a href="#cloneDeep-value-使用" class="headerlink" title="_.cloneDeep(value) 使用"></a>_.cloneDeep(value) 使用</h4><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200703152824969.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""><br>项目中使用 <code>cloneDeep</code> 需求：由于 <code>addForm</code> 中商品所属的分类数组 <code>goods_cat</code>在商品分类模块需要使用 <code>v-model</code> 进行双向绑定数组形式，而我们调用添加商品 <code>api</code> 时，需要字符串形式的，这就产生了冲突，于是我们可以通过<strong>深拷贝</strong>操作来达到我们的需要。</p><p>首先，导入 <code>lodash</code>。<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200703153150968.png" alt=""><br>然后，直接调用 <code>lodash</code> 中 <code>cloneDeep</code> 方法实现对对象的深拷贝。<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200703153449429.png" alt=""></p><h3 id="使用-echarts"><a href="#使用-echarts" class="headerlink" title="使用 echarts"></a>使用 echarts</h3><p><a href="https://echarts.apache.org/zh/tutorial.html#5%20%E5%88%86%E9%92%9F%E4%B8%8A%E6%89%8B%20ECharts">echarts 官方文档传送门</a><br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200703171208299.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""><br>根据官方文档示例，我们先展示测试数据。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;!-- 面包屑导航区域 --&gt;</span><br><span class="line">    &lt;el-breadcrumb separator=<span class="string">&quot;/&quot;</span>&gt;</span><br><span class="line">      &lt;el-breadcrumb-item :to=<span class="string">&quot;&#123; path: &#x27;/home&#x27; &#125;&quot;</span>&gt;首页&lt;/el-breadcrumb-item&gt;</span><br><span class="line">      &lt;el-breadcrumb-item&gt;数据统计&lt;/el-breadcrumb-item&gt;</span><br><span class="line">      &lt;el-breadcrumb-item&gt;数据报表&lt;/el-breadcrumb-item&gt;</span><br><span class="line">    &lt;/el-breadcrumb&gt;</span><br><span class="line">    &lt;!-- 卡片视图 --&gt;</span><br><span class="line">    &lt;el-card&gt;</span><br><span class="line">      &lt;!-- <span class="number">2.</span>为ECharts准备一个具备大小（宽高）的Dom --&gt;</span><br><span class="line">      &lt;div id=<span class="string">&quot;main&quot;</span> style=<span class="string">&quot;width: 600px;height:400px;&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/el-card&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="comment">// 1.导入echarts</span></span><br><span class="line"><span class="keyword">import</span> echarts <span class="keyword">from</span> <span class="string">&#x27;echarts&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">created</span>(<span class="params"></span>)</span> &#123;&#125;,</span><br><span class="line">  <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 3.基于准备好的dom，初始化echarts实例</span></span><br><span class="line">    <span class="keyword">var</span> myChart = echarts.init(<span class="built_in">document</span>.getElementById(<span class="string">&#x27;main&#x27;</span>))</span><br><span class="line">    <span class="comment">// 4.准备数据和配置项</span></span><br><span class="line">    <span class="keyword">var</span> option = &#123;</span><br><span class="line">      title: &#123;</span><br><span class="line">        text: <span class="string">&#x27;ECharts 入门示例&#x27;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      tooltip: &#123;&#125;,</span><br><span class="line">      legend: &#123;</span><br><span class="line">        data: [<span class="string">&#x27;销量&#x27;</span>]</span><br><span class="line">      &#125;,</span><br><span class="line">      xAxis: &#123;</span><br><span class="line">        data: [<span class="string">&#x27;衬衫&#x27;</span>, <span class="string">&#x27;羊毛衫&#x27;</span>, <span class="string">&#x27;雪纺衫&#x27;</span>, <span class="string">&#x27;裤子&#x27;</span>, <span class="string">&#x27;高跟鞋&#x27;</span>, <span class="string">&#x27;袜子&#x27;</span>]</span><br><span class="line">      &#125;,</span><br><span class="line">      yAxis: &#123;&#125;,</span><br><span class="line">      series: [</span><br><span class="line">        &#123;</span><br><span class="line">          name: <span class="string">&#x27;销量&#x27;</span>,</span><br><span class="line">          type: <span class="string">&#x27;bar&#x27;</span>,</span><br><span class="line">          data: [<span class="number">5</span>, <span class="number">20</span>, <span class="number">36</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">20</span>]</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5.使用刚指定的配置项和数据显示图表。</span></span><br><span class="line">    myChart.setOption(option)</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;&#125;,</span><br><span class="line">  methods: &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang=<span class="string">&quot;less&quot;</span> scoped&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>最终实现效果：</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200703171907263.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><p>由于通过 <code>$http</code>获取得到的数据缺少鼠标跟随的效果，于是需要将 <code>options</code> 进行合并操作，此时使用了 <code>lodash</code>的 <code>merge</code> 函数。核心代码如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 4.准备数据和配置项(res.data)</span></span><br><span class="line"><span class="keyword">const</span> result = _.merge(res.data, <span class="built_in">this</span>.options)</span><br></pre></td></tr></table></figure><p>在此提供数据报表折线图绘制的源代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;!-- 面包屑导航区域 --&gt;</span><br><span class="line">    &lt;el-breadcrumb separator=<span class="string">&quot;/&quot;</span>&gt;</span><br><span class="line">      &lt;el-breadcrumb-item :to=<span class="string">&quot;&#123; path: &#x27;/home&#x27; &#125;&quot;</span>&gt;首页&lt;/el-breadcrumb-item&gt;</span><br><span class="line">      &lt;el-breadcrumb-item&gt;数据统计&lt;/el-breadcrumb-item&gt;</span><br><span class="line">      &lt;el-breadcrumb-item&gt;数据报表&lt;/el-breadcrumb-item&gt;</span><br><span class="line">    &lt;/el-breadcrumb&gt;</span><br><span class="line">    &lt;!-- 卡片视图 --&gt;</span><br><span class="line">    &lt;el-card&gt;</span><br><span class="line">      &lt;!-- <span class="number">2.</span>为ECharts准备一个具备大小（宽高）的Dom --&gt;</span><br><span class="line">      &lt;div id=<span class="string">&quot;main&quot;</span> style=<span class="string">&quot;width: 750px;height:400px;&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/el-card&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="comment">// 1.导入echarts</span></span><br><span class="line"><span class="keyword">import</span> echarts <span class="keyword">from</span> <span class="string">&#x27;echarts&#x27;</span></span><br><span class="line"><span class="keyword">import</span> _ <span class="keyword">from</span> <span class="string">&#x27;lodash&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="comment">/* 需要合并的数据 */</span></span><br><span class="line">      options: &#123;</span><br><span class="line">        title: &#123;</span><br><span class="line">          text: <span class="string">&#x27;用户来源&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        tooltip: &#123;</span><br><span class="line">          trigger: <span class="string">&#x27;axis&#x27;</span>,</span><br><span class="line">          axisPointer: &#123;</span><br><span class="line">            type: <span class="string">&#x27;cross&#x27;</span>,</span><br><span class="line">            label: &#123;</span><br><span class="line">              backgroundColor: <span class="string">&#x27;#E9EEF3&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        grid: &#123;</span><br><span class="line">          left: <span class="string">&#x27;3%&#x27;</span>,</span><br><span class="line">          right: <span class="string">&#x27;4%&#x27;</span>,</span><br><span class="line">          bottom: <span class="string">&#x27;3%&#x27;</span>,</span><br><span class="line">          containLabel: <span class="literal">true</span></span><br><span class="line">        &#125;,</span><br><span class="line">        xAxis: [</span><br><span class="line">          &#123;</span><br><span class="line">            boundaryGap: <span class="literal">false</span></span><br><span class="line">          &#125;</span><br><span class="line">        ],</span><br><span class="line">        yAxis: [</span><br><span class="line">          &#123;</span><br><span class="line">            type: <span class="string">&#x27;value&#x27;</span></span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">created</span>(<span class="params"></span>)</span> &#123;&#125;,</span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 3.基于准备好的dom，初始化echarts实例</span></span><br><span class="line">    <span class="keyword">var</span> myChart = echarts.init(<span class="built_in">document</span>.getElementById(<span class="string">&#x27;main&#x27;</span>))</span><br><span class="line">    <span class="keyword">const</span> &#123; <span class="attr">data</span>: res &#125; = <span class="keyword">await</span> <span class="built_in">this</span>.$http.get(<span class="string">&#x27;reports/type/1&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> (res.meta.status !== <span class="number">200</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.$message.error(<span class="string">&#x27;获取折线图数据失败！&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.准备数据和配置项(res.data)</span></span><br><span class="line">    <span class="keyword">const</span> result = _.merge(res.data, <span class="built_in">this</span>.options)</span><br><span class="line">    <span class="comment">// 5.使用刚指定的配置项和数据显示图表。</span></span><br><span class="line">    myChart.setOption(result)</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;&#125;,</span><br><span class="line">  methods: &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang=<span class="string">&quot;less&quot;</span> scoped&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>最终实现效果如下：<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200703172454508.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><h2 id="项目优化上线"><a href="#项目优化上线" class="headerlink" title="项目优化上线"></a>项目优化上线</h2><blockquote><p>优化Vue项目，部署Vue项目</p></blockquote><h3 id="项目优化"><a href="#项目优化" class="headerlink" title="项目优化"></a>项目优化</h3><h4 id="添加进度条"><a href="#添加进度条" class="headerlink" title="添加进度条"></a>添加进度条</h4><p><a href="https://github.com/rstacruz/nprogress">nprogress 进度条官方文档传送门</a></p><p>打开 <code>vue-ui</code> 面板，选择依赖，输入 <code>nprogress</code> 进行安装相关依赖。<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200703191749286.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><h5 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install --save  nprogress</span><br></pre></td></tr></table></figure><p>在 <code>main.js</code> 入口文件中，进行相关配置。首先先导入包对应的<code>js</code> 和 <code>css</code>：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导入NProgress包对应的js和css</span></span><br><span class="line"><span class="keyword">import</span> NProgress <span class="keyword">from</span> <span class="string">&#x27;nprogress&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;nprogress/nprogress.css&#x27;</span></span><br></pre></td></tr></table></figure><p>配置 <code>request</code> 请求拦截器 和 <code>response</code> 响应拦截器，这样我们就能在每次网络请求时能够展示进度条了。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在 request 拦截器中，显示进度条 NProgress.start()</span></span><br><span class="line"><span class="comment">// 设置axios请求拦截器</span></span><br><span class="line">axios.interceptors.request.use(<span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">  NProgress.start()</span><br><span class="line">  config.headers.Authorization = <span class="built_in">window</span>.sessionStorage.getItem(<span class="string">&#x27;token&#x27;</span>)</span><br><span class="line">  <span class="comment">// console.log(config)</span></span><br><span class="line">  <span class="keyword">return</span> config</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 在 response 拦截器中，隐藏进度条 NProgress.done()</span></span><br><span class="line">axios.interceptors.response.use(<span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">  NProgress.done()</span><br><span class="line">  <span class="keyword">return</span> config</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="执行build-时报错"><a href="#执行build-时报错" class="headerlink" title="执行build 时报错"></a>执行build 时报错</h4><p><code>Error: No module factory available for dependency type: CssDependency</code></p><p>解决办法：</p><p><a href="https://blog.csdn.net/weixin_45615791/article/details/104294458">参考：解决webpack打包报错 No module factory available for dependency type: CssDependency</a></p><h4 id="在执行-build-命令期间移除所有的-console"><a href="#在执行-build-命令期间移除所有的-console" class="headerlink" title="在执行 build 命令期间移除所有的 console"></a>在执行 <code>build</code> 命令期间移除所有的 <code>console</code></h4><p><a href="https://babeljs.io/docs/en/babel-plugin-transform-remove-console">babel-plugin-transform-remove-console 官方文档传送门</a></p><p>可以通过 <code>vue-ui</code> 面板，选择开发依赖，然后输入 <code>babel-plugin-transform-remove-console</code> 进行安装<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/2020070319434356.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><p><strong>npm</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install babel-plugin-transform-remove-<span class="built_in">console</span> --save-dev</span><br></pre></td></tr></table></figure><p>安装依赖之后，打开 <code>babel.config.js</code>文件，在 <code>plugins</code> 插件处，添加一个字符串，<code>&#39;transform-remove-console&#39;</code>，如下图所示位置。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  presets: [</span><br><span class="line">    <span class="string">&#x27;@vue/cli-plugin-babel/preset&#x27;</span></span><br><span class="line">  ],</span><br><span class="line">  plugins: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">&#x27;component&#x27;</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        libraryName: <span class="string">&#x27;element-ui&#x27;</span>,</span><br><span class="line">        styleLibraryName: <span class="string">&#x27;theme-chalk&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&#x27;transform-remove-console&#x27;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述设置好了之后，还存在一个问题，我们只需要在发布阶段才会去除 <code>console</code> ，在开发和测试环境下如果去除了 <code>console</code>，对于我们调试方面不太好。因此，我们需要设置只在<strong>生产环境</strong>下去除 <code>console</code>。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200703195601960.png" alt=""><br>通过上下两个图比较，我们可以发现，在开发环境下 <code>mode</code> 值为 <code>development</code>，而在生产环境下<code>mode</code> 值为 <code>production</code>。<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200703195740375.png" alt=""><br>因此，上述代码就需要进行些微修改，如下所示：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 项目发布阶段需要用到的 babel 插件</span></span><br><span class="line"><span class="keyword">const</span> prodPlugins = []</span><br><span class="line"><span class="comment">// 判断编译模式为生产环境</span></span><br><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV === <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">  prodPlugins.push(<span class="string">&#x27;transform-remove-console&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  presets: [</span><br><span class="line">    <span class="string">&#x27;@vue/cli-plugin-babel/preset&#x27;</span></span><br><span class="line">  ],</span><br><span class="line">  plugins: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">&#x27;component&#x27;</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        libraryName: <span class="string">&#x27;element-ui&#x27;</span>,</span><br><span class="line">        styleLibraryName: <span class="string">&#x27;theme-chalk&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    ...prodPlugins</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="生成打包报告"><a href="#生成打包报告" class="headerlink" title="生成打包报告"></a>生成打包报告</h4><blockquote><p>打包时，为了直观地发现项目中存在的问题，可以在打包时生成报告。生成报告的方式有两种：</p></blockquote><p>① 通过命令行参数的形式生成报告</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过 vue-cli 的命令选项可以生成打包报告</span></span><br><span class="line"><span class="comment">// --report 选项可以生成 report.html 以帮助分析包内容</span></span><br><span class="line">vue-cli-service build --report</span><br></pre></td></tr></table></figure><p>② 通过可视化的UI面板直接查看报告（<strong>推荐</strong>）</p><p>在可视化的UI面板中，通过<strong>控制台</strong>和<strong>分析</strong>面板，可以方便地看到项目中所存在的问题。</p><h4 id="通过-vue-config-js-修改-webpack-的默认配置"><a href="#通过-vue-config-js-修改-webpack-的默认配置" class="headerlink" title="通过 vue.config.js 修改 webpack 的默认配置"></a>通过 vue.config.js 修改 webpack 的默认配置</h4><p>通过 <code>vue-cli 3.0</code> 工具生成的项目，<strong>默认隐藏了所有 webpack 的配置项</strong>，目的是为了屏蔽项目的配置过程，让程<br>序员把工作的重心，放到具体功能和业务逻辑的实现上。</p><p>如果程序员有修改 webpack 默认配置的需求，可以在项目根目录中，按需创建 <code>vue.config.js</code> 这个配置文件，从<br>而对项目的打包发布过程做自定义的配置</p><p>（具体配置参考<a href="https://cli.vuejs.org/zh/config/#vue-config-js">https://cli.vuejs.org/zh/config/#vue-config-js</a>）。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vue.config.js</span></span><br><span class="line"><span class="comment">// 这个文件中，应该导出一个包含了自定义配置选项的对象</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line"><span class="comment">// 选项...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="为开发模式与发布模式指定不同的打包入口"><a href="#为开发模式与发布模式指定不同的打包入口" class="headerlink" title="为开发模式与发布模式指定不同的打包入口"></a>为开发模式与发布模式指定不同的打包入口</h4><p>默认情况下，Vue项目的<strong>开发模式</strong>与<strong>发布模式</strong>，共用同一个打包的入口文件（即 <code>src/main.js</code>）。为了将项目<br>的开发过程与发布过程分离，我们可以为两种模式，各自指定打包的入口文件，即：</p><ul><li>开发模式的入口文件为 <code>src/main-dev.js</code></li><li>发布模式的入口文件为 <code>src/main-prod.js</code></li></ul><p><code>configureWebpack</code> 和 <code>chainWebpack</code></p><p>在 <code>vue.config.js</code> 导出的配置对象中，新增 <code>configureWebpack</code> 或<code>chainWebpack</code>节点，来自定义 <code>webpack</code> 的打包配置。</p><p>在这里， <code>configureWebpack</code> 和 <code>chainWebpack</code> 的作用相同，唯一的区别就是它们修改 webpack 配置的方式不同：</p><p>① <code>chainWebpack</code> 通过链式编程的形式，来修改默认的 <code>webpack</code> 配置<br>② <code>configureWebpack</code> 通过操作对象的形式，来修改默认的 <code>webpack</code> 配置</p><p>两者具体的使用差异，可参考如下网址：</p><p><a href="https://cli.vuejs.org/zh/guide/webpack.html#webpack-%E7%9B%B8%E5%85%B3">传送门</a></p><h5 id="通过-chainWebpack-自定义打包入口"><a href="#通过-chainWebpack-自定义打包入口" class="headerlink" title="通过 chainWebpack 自定义打包入口"></a>通过 chainWebpack 自定义打包入口</h5><p>示例代码如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">chainWebpack: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">config.when(process.env.NODE_ENV === <span class="string">&#x27;production&#x27;</span>, <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">config.entry(<span class="string">&#x27;app&#x27;</span>).clear().add(<span class="string">&#x27;./src/main-prod.js&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">config.when(process.env.NODE_ENV === <span class="string">&#x27;development&#x27;</span>, <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">config.entry(<span class="string">&#x27;app&#x27;</span>).clear().add(<span class="string">&#x27;./src/main-dev.js&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="第三方库使用CDN"><a href="#第三方库使用CDN" class="headerlink" title="第三方库使用CDN"></a>第三方库使用CDN</h4><h5 id="通过-externals-加载外部-CDN-资源"><a href="#通过-externals-加载外部-CDN-资源" class="headerlink" title="通过 externals 加载外部 CDN 资源"></a>通过 externals 加载外部 CDN 资源</h5><p>默认情况下，通过 <code>import</code> 语法导入的第三方依赖包，最终会被打包合并到同一个文件中，从而导致打包成功后，单文件体积过大的问题。<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/2020070323105910.png" alt=""><br>例如上述 <code>chunk-vendors.js</code> 体积很大，原因是全部 <code>import</code> 所依赖的包进行了合并给它。</p><p>为了解决上述问题，可以通过 <code>webpack</code> 的 <code>externals</code> 节点，来配置并加载外部的 <code>CDN</code> 资源。凡是声明在<code>externals</code> 中的第三方依赖包，都不会被打包。</p><p><strong>具体配置代码如下</strong>：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">config.set(<span class="string">&#x27;externals&#x27;</span>, &#123;</span><br><span class="line">vue: <span class="string">&#x27;Vue&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;vue-router&#x27;</span>: <span class="string">&#x27;VueRouter&#x27;</span>,</span><br><span class="line">axios: <span class="string">&#x27;axios&#x27;</span>,</span><br><span class="line">lodash: <span class="string">&#x27;_&#x27;</span>,</span><br><span class="line">echarts: <span class="string">&#x27;echarts&#x27;</span>,</span><br><span class="line">nprogress: <span class="string">&#x27;NProgress&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;vue-quill-editor&#x27;</span>: <span class="string">&#x27;VueQuillEditor&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>同时，需要在 <code>public/index.html</code> 文件的头部，添加如下的 <code>CDN</code> 资源引用：</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!<span class="selector-tag">--</span> <span class="selector-tag">nprogress</span> 的样式表文件 <span class="selector-tag">--</span>&gt;</span><br><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.css&quot; /&gt;</span><br><span class="line">&lt;!<span class="selector-tag">--</span> 富文本编辑器 的样式表文件 <span class="selector-tag">--</span>&gt;</span><br><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.staticfile.org/quill/1.3.4/quill.core.min.css&quot; /&gt;</span><br><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.staticfile.org/quill/1.3.4/quill.snow.min.css&quot; /&gt;</span><br><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.staticfile.org/quill/1.3.4/quill.bubble.min.css&quot; /&gt;</span><br></pre></td></tr></table></figure><p>同时，需要在 <code>public/index.html</code> 文件的头部，添加如下的 <code>CDN</code> 资源引用：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;https://cdn.staticfile.org/vue/2.5.22/vue.min.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=<span class="string">&quot;https://cdn.staticfile.org/vue-router/3.0.1/vue-router.min.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=<span class="string">&quot;https://cdn.staticfile.org/axios/0.18.0/axios.min.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=<span class="string">&quot;https://cdn.staticfile.org/lodash.js/4.17.11/lodash.min.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=<span class="string">&quot;https://cdn.staticfile.org/echarts/4.1.0/echarts.min.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=<span class="string">&quot;https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;!-- 富文本编辑器的 js 文件 --&gt;</span><br><span class="line">&lt;script src=<span class="string">&quot;https://cdn.staticfile.org/quill/1.3.4/quill.min.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue-quill-editor@3.0.4/dist/vue-quill-editor.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="Element-UI-组件按需加载"><a href="#Element-UI-组件按需加载" class="headerlink" title="Element-UI 组件按需加载"></a>Element-UI 组件按需加载</h4><h5 id="通过-CDN-优化-ElementUI-的打包"><a href="#通过-CDN-优化-ElementUI-的打包" class="headerlink" title="通过 CDN 优化 ElementUI 的打包"></a>通过 CDN 优化 ElementUI 的打包</h5><p>虽然在开发阶段，我们启用了 element-ui 组件的按需加载，尽可能的减少了打包的体积，但是那些被按需加载的组件，还是占用了较大的文件体积。此时，我们可以将 <code>element-ui</code> 中的组件，也通过 <code>CDN</code> 的形式来加载，这样能够进一步减小打包后的文件体积。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200704000508793.png" alt=""><br>具体操作流程如下：<br>① 在 <code>main-prod.js</code> 中，注释掉 <code>element-ui</code> 按需加载的代码<br>② 在  <code>public/index.html</code>  的头部区域中，通过 <code>CDN</code> 加载 <code>element-ui</code> 的 <code>js</code> 和 <code>css</code> 样式</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!-- element-ui 的样式表文件 --&gt;</span><br><span class="line">&lt;link rel=<span class="string">&quot;stylesheet&quot;</span> href=<span class="string">&quot;https://cdn.staticfile.org/element-ui/2.8.2/theme-</span></span><br><span class="line"><span class="string">chalk/index.css&quot;</span> /&gt;</span><br><span class="line">&lt;!-- element-ui 的 js 文件 --&gt;</span><br><span class="line">&lt;script src=<span class="string">&quot;https://cdn.staticfile.org/element-ui/2.8.2/index.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200704001002855.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><h4 id="首页内容定制"><a href="#首页内容定制" class="headerlink" title="首页内容定制"></a>首页内容定制</h4><blockquote><p>不同的打包环境下，首页内容可能会有所不同。我们可以通过插件的方式进行定制，插件配置如下：</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">chainWebpack: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">config.when(process.env.NODE_ENV === <span class="string">&#x27;production&#x27;</span>, <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">config.plugin(<span class="string">&#x27;html&#x27;</span>).tap(<span class="function"><span class="params">args</span> =&gt;</span> &#123;</span><br><span class="line">args[<span class="number">0</span>].isProd = <span class="literal">true</span></span><br><span class="line"><span class="keyword">return</span> args</span><br><span class="line">&#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">config.when(process.env.NODE_ENV === <span class="string">&#x27;development&#x27;</span>, <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">config.plugin(<span class="string">&#x27;html&#x27;</span>).tap(<span class="function"><span class="params">args</span> =&gt;</span> &#123;</span><br><span class="line">args[<span class="number">0</span>].isProd = <span class="literal">false</span></span><br><span class="line"><span class="keyword">return</span> args</span><br><span class="line">&#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>public/index.html</code> 首页中，可以根据 <code>isProd</code> 的值，来决定如何渲染页面结构：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!–- 按需渲染页面的标题 --&gt;</span><br><span class="line">&lt;title&gt;&lt;%= htmlWebpackPlugin.options.isProd ? <span class="string">&#x27;&#x27;</span> : <span class="string">&#x27;dev - &#x27;</span> %&gt;电商后台管理系统&lt;/title&gt;</span><br><span class="line">&lt;!–- 按需加载外部的 CDN 资源 --&gt;</span><br><span class="line">&lt;% <span class="keyword">if</span>(htmlWebpackPlugin.options.isProd) &#123; %&gt;</span><br><span class="line">&lt;!—- 通过 externals 加载的外部 CDN 资源--&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure><h4 id="路由懒加载"><a href="#路由懒加载" class="headerlink" title="路由懒加载"></a>路由懒加载</h4><p>当打包构建项目时，<code>JavaScript</code> 包会变得非常大，影响页面加载。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就更加高效了。</p><p>具体需要 3 步：</p><ul><li>安装 <code>@babel/plugin-syntax-dynamic-import</code>包。</li><li>在 <code>babel.config.js</code> 配置文件中声明该插件。</li><li>将路由改为按需加载的形式，示例代码如下：</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// /* webpackChunkName: &quot;group-foo&quot; */表示路由分组</span></span><br><span class="line"><span class="comment">// &#x27;./Foo.vue&#x27; 表示路由存放路径</span></span><br><span class="line"><span class="keyword">const</span> Foo = <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: &quot;group-foo&quot; */</span> <span class="string">&#x27;./Foo.vue&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> Bar = <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: &quot;group-foo&quot; */</span> <span class="string">&#x27;./Bar.vue&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> Baz = <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: &quot;group-boo&quot; */</span> <span class="string">&#x27;./Baz.vue&#x27;</span>)</span><br></pre></td></tr></table></figure><p>分在同一个组内的组件，当请求其中某一个组件时，组内其它组件也会同时请求。</p><p>关于路由懒加载的详细文档，可参考如下链接：</p><p><a href="https://router.vuejs.org/zh/guide/advanced/lazy-loading.html">https://router.vuejs.org/zh/guide/advanced/lazy-loading.html</a></p><p><a href="https://babeljs.io/docs/en/babel-plugin-syntax-dynamic-import/">@babel/plugin-syntax-dynamic-import 插件介绍传送门</a></p><p><strong>npm</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install --save-dev @babel/plugin-syntax-dynamic-<span class="keyword">import</span></span><br></pre></td></tr></table></figure><p>打开 <code>vue-ui</code> 面板，选择开发依赖，输入 <code>@babel/plugin-syntax-dynamic-import</code> 进行安装。<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/2020070410192225.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><p>然后打开 <code>babel.config.js</code> 文件，在 <code>plugins</code> 数组内添加我们安装的依赖: <code>&#39;@babel/plugin-syntax-dynamic-import&#39;</code>，具体位置见下文所示：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 项目发布阶段需要用到的 babel 插件</span></span><br><span class="line"><span class="keyword">const</span> prodPlugins = []</span><br><span class="line"><span class="comment">// 判断编译模式为生产环境</span></span><br><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV === <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">  prodPlugins.push(<span class="string">&#x27;transform-remove-console&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  presets: [</span><br><span class="line">    <span class="string">&#x27;@vue/cli-plugin-babel/preset&#x27;</span></span><br><span class="line">  ],</span><br><span class="line">  plugins: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">&#x27;component&#x27;</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        libraryName: <span class="string">&#x27;element-ui&#x27;</span>,</span><br><span class="line">        styleLibraryName: <span class="string">&#x27;theme-chalk&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    ...prodPlugins,</span><br><span class="line">    <span class="string">&#x27;@babel/plugin-syntax-dynamic-import&#x27;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，将每一个组件更改为懒加载的形式：</p><h3 id="项目上线"><a href="#项目上线" class="headerlink" title="项目上线"></a>项目上线</h3><ol><li>通过 node 创建 web 服务器。</li><li>开启 gzip 配置。</li><li>配置 https 服务。</li><li>使用 pm2 管理应用。</li></ol><h4 id="通过-node-创建-web-服务器"><a href="#通过-node-创建-web-服务器" class="headerlink" title="通过 node 创建 web 服务器"></a>通过 node 创建 web 服务器</h4><p>创建 <code>node</code> 项目，并安装 <code>express</code>，通过 <code>express</code> 快速创建 <code>web</code> 服务器，将 <code>vue</code> 打包生成的 <code>dist</code> 文件夹，托管为静态资源即可，关键代码如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"><span class="comment">// 创建 web 服务器</span></span><br><span class="line"><span class="keyword">const</span> app = express()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 托管静态资源</span></span><br><span class="line">app.use(express.static(<span class="string">&#x27;./dist&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动 web 服务器</span></span><br><span class="line">app.listen(<span class="number">80</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;web server running at http://127.0.0.1&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>第一步，先创建一个文件夹，这里命名为 <code>vue_shop_server</code>，然后通过 <code>Code</code> 打开。<br>新建一个终端，输入 <code>npm init -y</code> 执行，初始化包管理配置文件。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200704103747836.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""><br>初始化完成后，执行 <code>npm install express -S</code> 安装 <code>express</code></p><p>接下来，将我们 <code>vue</code> 项目通过 <code>build</code> 打包得到的 <code>dist</code> 文件夹复制一份，粘贴到我们的 <code>vue_shop_server</code>文件夹内，然后再新建一个 <code>app.js</code> 入口文件，结构图如下图所示。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200704110048836.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><p>测试服务器是否能够运行，新建终端，执行 <code>node .\app.js</code> 命令。如果发现输出了 <code>web server running at http://127.0.0.1</code> 则表示服务已经启动了。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200704104537994.png" alt=""></p><h4 id="开启-gzip-配置"><a href="#开启-gzip-配置" class="headerlink" title="开启 gzip 配置"></a>开启 gzip 配置</h4><p>配置完之前服务之后，我们打开网站后，发现请求网络中文件体积依旧是很大，如下图所示。<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200704105355366.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><p>使用 <code>gzip</code> 可以减小文件体积，使传输速度更快。</p><p> 可以通过服务器端使用 <code>Express</code> 做 <code>gzip</code> 压缩。其配置如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 安装相应包</span></span><br><span class="line">npm install compression -S</span><br><span class="line"><span class="comment">// 导入包</span></span><br><span class="line"><span class="keyword">const</span> compression = <span class="built_in">require</span>(<span class="string">&#x27;compression&#x27;</span>);</span><br><span class="line"><span class="comment">// 启用中间件</span></span><br><span class="line">app.use(compression());</span><br></pre></td></tr></table></figure><p>此时的 <code>app.js</code> 文件代码如下所示，注意，<strong>一定要把启用中间件放在托管静态资源之前！</strong> 不然 <code>gzip</code> 压缩不会生效。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"><span class="comment">// 导入包</span></span><br><span class="line"><span class="keyword">const</span> compression = <span class="built_in">require</span>(<span class="string">&#x27;compression&#x27;</span>);</span><br><span class="line"><span class="comment">// 创建 web 服务器</span></span><br><span class="line"><span class="keyword">const</span> app = express()</span><br><span class="line"><span class="comment">// 启用中间件</span></span><br><span class="line">app.use(compression());</span><br><span class="line"><span class="comment">// 托管静态资源</span></span><br><span class="line">app.use(express.static(<span class="string">&#x27;./dist&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动 web 服务器</span></span><br><span class="line">app.listen(<span class="number">80</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;web server running at http://127.0.0.1&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="配置-HTTPS-服务"><a href="#配置-HTTPS-服务" class="headerlink" title="配置 HTTPS 服务"></a>配置 HTTPS 服务</h4><h5 id="为什么要启用-HTTPS-服务？"><a href="#为什么要启用-HTTPS-服务？" class="headerlink" title="为什么要启用 HTTPS 服务？"></a>为什么要启用 HTTPS 服务？</h5><ul><li>传统的 <code>HTTP</code> 协议传输的数据都是明文，不安全</li><li>采用 <code>HTTPS</code> 协议对传输的数据进行了加密处理，可以防止数据被中间人窃取，使用更安全</li></ul><h5 id="申请-SSL-证书（https-freessl-org）"><a href="#申请-SSL-证书（https-freessl-org）" class="headerlink" title="申请 SSL 证书（https://freessl.org）"></a>申请 SSL 证书（<a href="https://freessl.org）">https://freessl.org）</a></h5><ul><li>进入 <a href="https://freessl.cn/">https://freessl.cn/</a> 官网，输入要申请的域名并选择品牌。</li><li>输入自己的邮箱并选择相关选项。</li><li>验证 DNS（在域名管理后台添加 TXT 记录）。</li><li>验证通过之后，下载 SSL 证书（ <code>full_chain.pem</code> 公钥；<code>private.key</code> 私钥）。</li></ul><h5 id="在后台项目中导入证书"><a href="#在后台项目中导入证书" class="headerlink" title="在后台项目中导入证书"></a>在后台项目中导入证书</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> https = <span class="built_in">require</span>(<span class="string">&#x27;https&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line">cert: fs.readFileSync(<span class="string">&#x27;./full_chain.pem&#x27;</span>),</span><br><span class="line">key: fs.readFileSync(<span class="string">&#x27;./private.key&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">https.createServer(options, app).listen(<span class="number">443</span>);</span><br></pre></td></tr></table></figure><p>此时 <code>app.js</code> 配置代码如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"><span class="comment">// 导入包</span></span><br><span class="line"><span class="keyword">const</span> compression = <span class="built_in">require</span>(<span class="string">&#x27;compression&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> https = <span class="built_in">require</span>(<span class="string">&#x27;https&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="comment">// 创建 web 服务器</span></span><br><span class="line"><span class="keyword">const</span> app = express()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line">cert: fs.readFileSync(<span class="string">&#x27;./full_chain.pem&#x27;</span>),</span><br><span class="line">key: fs.readFileSync(<span class="string">&#x27;./private.key&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启用中间件</span></span><br><span class="line">app.use(compression());</span><br><span class="line"><span class="comment">// 托管静态资源</span></span><br><span class="line">app.use(express.static(<span class="string">&#x27;./dist&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动 web 服务器</span></span><br><span class="line"><span class="comment">// app.listen(80, () =&gt; &#123;</span></span><br><span class="line"><span class="comment">//   console.log(&#x27;web server running at http://127.0.0.1&#x27;)</span></span><br><span class="line"><span class="comment">// &#125;)</span></span><br><span class="line">https.createServer(options, app).listen(<span class="number">443</span>);</span><br></pre></td></tr></table></figure><h4 id="使用-pm2-管理应用"><a href="#使用-pm2-管理应用" class="headerlink" title="使用 pm2 管理应用"></a>使用 pm2 管理应用</h4><p>① 在服务器中安装 <code>pm2</code>：<code>npm i pm2 -g</code><br>② 启动项目：<code>pm2 start</code> 脚本 <code>--name</code> 自定义名称<br>③ 查看运行项目：<code>pm2 ls</code><br>④ 重启项目：<code>pm2 restart</code> 自定义名称<br>⑤ 停止项目：<code>pm2 stop</code> 自定义名称<br>⑥ 删除项目：<code>pm2 delete</code> 自定义名称</p><h4 id="解决Error-ENOENT-no-such-file-or-directory-scandir-‘xxx-node-sass-vendor’"><a href="#解决Error-ENOENT-no-such-file-or-directory-scandir-‘xxx-node-sass-vendor’" class="headerlink" title="解决Error: ENOENT: no such file or directory, scandir ‘xxx\node-sass\vendor’"></a>解决Error: ENOENT: no such file or directory, scandir ‘xxx\node-sass\vendor’</h4><p>解决方案是执行以下方法：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm rebuild node-sass</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://www.bilibili.com/video/BV1EE411B7SU?p=5">项目学习地址</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【后台API接口文档】Vue全家桶开发电商管理系统</title>
      <link href="posts/2020709/"/>
      <url>posts/2020709/</url>
      
        <content type="html"><![CDATA[<h1 id="1-电商管理后台-API-接口文档"><a href="#1-电商管理后台-API-接口文档" class="headerlink" title="1. 电商管理后台 API 接口文档"></a>1. 电商管理后台 API 接口文档</h1><h2 id="1-1-API-V1-接口说明"><a href="#1-1-API-V1-接口说明" class="headerlink" title="1.1. API V1 接口说明"></a>1.1. API V1 接口说明</h2><ul><li>接口基准地址：<code>http://127.0.0.1:8888/api/private/v1/</code></li><li>服务端已开启 CORS 跨域支持</li><li>API V1 认证统一使用 Token 认证</li><li>需要授权的 API ，必须在请求头中使用 <code>Authorization</code> 字段提供 <code>token</code> 令牌</li><li>使用 HTTP Status Code 标识状态</li><li>数据返回格式统一使用 JSON</li></ul><h3 id="1-1-1-支持的请求方法"><a href="#1-1-1-支持的请求方法" class="headerlink" title="1.1.1. 支持的请求方法"></a>1.1.1. 支持的请求方法</h3><ul><li>GET（SELECT）：从服务器取出资源（一项或多项）。</li><li>POST（CREATE）：在服务器新建一个资源。</li><li>PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。</li><li>PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。</li><li>DELETE（DELETE）：从服务器删除资源。</li><li>HEAD：获取资源的元数据。</li><li>OPTIONS：获取信息，关于资源的哪些属性是客户端可以改变的。</li></ul><h3 id="1-1-2-通用返回状态说明"><a href="#1-1-2-通用返回状态说明" class="headerlink" title="1.1.2. 通用返回状态说明"></a>1.1.2. 通用返回状态说明</h3><table><thead><tr><th><em>状态码</em></th><th><em>含义</em></th><th><em>说明</em></th></tr></thead><tbody><tr><td>200</td><td>OK</td><td>请求成功</td></tr><tr><td>201</td><td>CREATED</td><td>创建成功</td></tr><tr><td>204</td><td>DELETED</td><td>删除成功</td></tr><tr><td>400</td><td>BAD REQUEST</td><td>请求的地址不存在或者包含不支持的参数</td></tr><tr><td>401</td><td>UNAUTHORIZED</td><td>未授权</td></tr><tr><td>403</td><td>FORBIDDEN</td><td>被禁止访问</td></tr><tr><td>404</td><td>NOT FOUND</td><td>请求的资源不存在</td></tr><tr><td>422</td><td>Unprocesable entity</td><td>[POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误</td></tr><tr><td>500</td><td>INTERNAL SERVER ERROR</td><td>内部错误</td></tr><tr><td></td><td></td><td></td></tr></tbody></table><hr><h2 id="1-2-登录"><a href="#1-2-登录" class="headerlink" title="1.2. 登录"></a>1.2. 登录</h2><h3 id="1-2-1-登录验证接口"><a href="#1-2-1-登录验证接口" class="headerlink" title="1.2.1. 登录验证接口"></a>1.2.1. 登录验证接口</h3><ul><li>请求路径：login</li><li>请求方法：post</li><li>请求参数</li></ul><table><thead><tr><th>参数名</th><th>参数说明</th><th>备注</th></tr></thead><tbody><tr><td>username</td><td>用户名</td><td>不能为空</td></tr><tr><td>password</td><td>密码</td><td>不能为空</td></tr></tbody></table><ul><li>响应参数</li></ul><table><thead><tr><th>参数名</th><th>参数说明</th><th>备注</th></tr></thead><tbody><tr><td>id</td><td>用户 ID</td><td></td></tr><tr><td>rid</td><td>用户角色 ID</td><td></td></tr><tr><td>username</td><td>用户名</td><td></td></tr><tr><td>mobile</td><td>手机号</td><td></td></tr><tr><td>email</td><td>邮箱</td><td></td></tr><tr><td>token</td><td>令牌</td><td>基于 jwt 的令牌</td></tr></tbody></table><ul><li>响应数据</li></ul><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;data&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;id&quot;</span>: <span class="number">500</span>,</span><br><span class="line">        <span class="attr">&quot;rid&quot;</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">&quot;username&quot;</span>: <span class="string">&quot;admin&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;mobile&quot;</span>: <span class="string">&quot;123&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;email&quot;</span>: <span class="string">&quot;123@qq.com&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;token&quot;</span>: <span class="string">&quot;Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1aWQiOjUwMCwicmlkIjowLCJpYXQiOjE1MTI1NDQyOTksImV4cCI6MTUxMjYzMDY5OX0.eGrsrvwHm-tPsO9r_pxHIQ5i5L1kX9RX444uwnRGaIM&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;meta&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;msg&quot;</span>: <span class="string">&quot;登录成功&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;status&quot;</span>: <span class="number">200</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-3-用户管理"><a href="#1-3-用户管理" class="headerlink" title="1.3. 用户管理"></a>1.3. 用户管理</h2><h3 id="1-3-1-用户数据列表"><a href="#1-3-1-用户数据列表" class="headerlink" title="1.3.1. 用户数据列表"></a>1.3.1. 用户数据列表</h3><ul><li>请求路径：users</li><li>请求方法：get</li><li>请求参数</li></ul><table><thead><tr><th>参数名</th><th>参数说明</th><th>备注</th></tr></thead><tbody><tr><td>query</td><td>查询参数</td><td>可以为空</td></tr><tr><td>pagenum</td><td>当前页码</td><td>不能为空</td></tr><tr><td>pagesize</td><td>每页显示条数</td><td>不能为空</td></tr></tbody></table><ul><li>响应参数</li></ul><table><thead><tr><th>参数名</th><th>参数说明</th><th>备注</th></tr></thead><tbody><tr><td>total</td><td>总记录数</td><td></td></tr><tr><td>pagenum</td><td>当前页码</td><td></td></tr><tr><td>users</td><td>用户数据集合</td><td></td></tr></tbody></table><ul><li>响应数据</li></ul><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;data&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;total&quot;</span>: <span class="number">5</span>,</span><br><span class="line">        <span class="attr">&quot;pagenum&quot;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">&quot;users&quot;</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">&quot;id&quot;</span>: <span class="number">25</span>,</span><br><span class="line">                <span class="attr">&quot;username&quot;</span>: <span class="string">&quot;tige117&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;mobile&quot;</span>: <span class="string">&quot;18616358651&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;type&quot;</span>: <span class="number">1</span>,</span><br><span class="line">                <span class="attr">&quot;email&quot;</span>: <span class="string">&quot;tige112@163.com&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;create_time&quot;</span>: <span class="string">&quot;2017-11-09T20:36:26.000Z&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;mg_state&quot;</span>: <span class="literal">true</span>, <span class="comment">// 当前用户的状态</span></span><br><span class="line">                <span class="attr">&quot;role_name&quot;</span>: <span class="string">&quot;炒鸡管理员&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;meta&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;msg&quot;</span>: <span class="string">&quot;获取成功&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;status&quot;</span>: <span class="number">200</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-2-添加用户"><a href="#1-3-2-添加用户" class="headerlink" title="1.3.2. 添加用户"></a>1.3.2. 添加用户</h3><ul><li>请求路径：users</li><li>请求方法：post</li><li>请求参数</li></ul><table><thead><tr><th>参数名</th><th>参数说明</th><th>备注</th></tr></thead><tbody><tr><td>username</td><td>用户名称</td><td>不能为空</td></tr><tr><td>password</td><td>用户密码</td><td>不能为空</td></tr><tr><td>email</td><td>邮箱</td><td>可以为空</td></tr><tr><td>mobile</td><td>手机号</td><td>可以为空</td></tr></tbody></table><ul><li>响应参数</li></ul><table><thead><tr><th>参数名</th><th>参数说明</th><th>备注</th></tr></thead><tbody><tr><td>id</td><td>用户 ID</td><td></td></tr><tr><td>rid</td><td>用户角色 ID</td><td></td></tr><tr><td>username</td><td>用户名</td><td></td></tr><tr><td>mobile</td><td>手机号</td><td></td></tr><tr><td>email</td><td>邮箱</td><td></td></tr></tbody></table><ul><li>响应数据</li></ul><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;data&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;id&quot;</span>: <span class="number">28</span>,</span><br><span class="line">        <span class="attr">&quot;username&quot;</span>: <span class="string">&quot;tige1200&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;mobile&quot;</span>: <span class="string">&quot;test&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;type&quot;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">&quot;openid&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;email&quot;</span>: <span class="string">&quot;test@test.com&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;create_time&quot;</span>: <span class="string">&quot;2017-11-10T03:47:13.533Z&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;modify_time&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">        <span class="attr">&quot;is_delete&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">&quot;is_active&quot;</span>: <span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;meta&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;msg&quot;</span>: <span class="string">&quot;用户创建成功&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;status&quot;</span>: <span class="number">201</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-3-修改用户状态"><a href="#1-3-3-修改用户状态" class="headerlink" title="1.3.3. 修改用户状态"></a>1.3.3. 修改用户状态</h3><ul><li>请求路径：users/:uId/state/:type</li><li>请求方法：put</li><li>请求参数</li></ul><table><thead><tr><th>参数名</th><th>参数说明</th><th>备注</th></tr></thead><tbody><tr><td>uId</td><td>用户 ID</td><td>不能为空<code>携带在url中</code></td></tr><tr><td>type</td><td>用户状态</td><td>不能为空<code>携带在url中</code>，值为 true 或者 false</td></tr></tbody></table><ul><li>响应数据</li></ul><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;data&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;id&quot;</span>: <span class="number">566</span>,</span><br><span class="line">    <span class="attr">&quot;rid&quot;</span>: <span class="number">30</span>,</span><br><span class="line">    <span class="attr">&quot;username&quot;</span>: <span class="string">&quot;admin&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;mobile&quot;</span>: <span class="string">&quot;123456&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;email&quot;</span>: <span class="string">&quot;bb@itcast.com&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;mg_state&quot;</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;meta&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;msg&quot;</span>: <span class="string">&quot;设置状态成功&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;status&quot;</span>: <span class="number">200</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-4-根据-ID-查询用户信息"><a href="#1-3-4-根据-ID-查询用户信息" class="headerlink" title="1.3.4. 根据 ID 查询用户信息"></a>1.3.4. 根据 ID 查询用户信息</h3><ul><li>请求路径：users/:id</li><li>请求方法：get</li><li>请求参数</li></ul><table><thead><tr><th>参数名</th><th>参数说明</th><th>备注</th></tr></thead><tbody><tr><td>id</td><td>用户 ID</td><td>不能为空<code>携带在url中</code></td></tr></tbody></table><ul><li>响应参数</li></ul><table><thead><tr><th>参数名</th><th>参数说明</th><th>备注</th></tr></thead><tbody><tr><td>id</td><td>用户 ID</td><td></td></tr><tr><td>role_id</td><td>角色 ID</td><td></td></tr><tr><td>mobile</td><td>手机号</td><td></td></tr><tr><td>email</td><td>邮箱</td><td></td></tr></tbody></table><ul><li>响应数据</li></ul><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;data&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;id&quot;</span>: <span class="number">503</span>,</span><br><span class="line">        <span class="attr">&quot;username&quot;</span>: <span class="string">&quot;admin3&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;role_id&quot;</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">&quot;mobile&quot;</span>: <span class="string">&quot;00000&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;email&quot;</span>: <span class="string">&quot;new@new.com&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;meta&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;msg&quot;</span>: <span class="string">&quot;查询成功&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;status&quot;</span>: <span class="number">200</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-5-编辑用户提交"><a href="#1-3-5-编辑用户提交" class="headerlink" title="1.3.5. 编辑用户提交"></a>1.3.5. 编辑用户提交</h3><ul><li>请求路径：users/:id</li><li>请求方法：put</li><li>请求参数</li></ul><table><thead><tr><th>参数名</th><th>参数说明</th><th>备注</th></tr></thead><tbody><tr><td>id</td><td>用户 id</td><td>不能为空 <code>参数是url参数:id</code></td></tr><tr><td>email</td><td>邮箱</td><td>可以为空</td></tr><tr><td>mobile</td><td>手机号</td><td>可以为空</td></tr></tbody></table><ul><li>响应参数</li></ul><table><thead><tr><th>参数名</th><th>参数说明</th><th>备注</th></tr></thead><tbody><tr><td>id</td><td>用户 ID</td><td></td></tr><tr><td>role_id</td><td>角色 ID</td><td></td></tr><tr><td>mobile</td><td>手机号</td><td></td></tr><tr><td>email</td><td>邮箱</td><td></td></tr></tbody></table><ul><li>响应数据</li></ul><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 200表示成功，500表示失败 */</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;data&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;id&quot;</span>: <span class="number">503</span>,</span><br><span class="line">        <span class="attr">&quot;username&quot;</span>: <span class="string">&quot;admin3&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;role_id&quot;</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">&quot;mobile&quot;</span>: <span class="string">&quot;111&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;email&quot;</span>: <span class="string">&quot;123@123.com&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;meta&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;msg&quot;</span>: <span class="string">&quot;更新成功&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;status&quot;</span>: <span class="number">200</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-6-删除单个用户"><a href="#1-3-6-删除单个用户" class="headerlink" title="1.3.6. 删除单个用户"></a>1.3.6. 删除单个用户</h3><ul><li>请求路径：users/:id</li><li>请求方法：delete</li><li>请求参数</li></ul><table><thead><tr><th>参数名</th><th>参数说明</th><th>备注</th></tr></thead><tbody><tr><td>id</td><td>用户 id</td><td>不能为空<code>参数是url参数:id</code></td></tr></tbody></table><ul><li>响应参数</li><li>响应数据</li></ul><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;data&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">&quot;meta&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;msg&quot;</span>: <span class="string">&quot;删除成功&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;status&quot;</span>: <span class="number">200</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-7-分配用户角色"><a href="#1-3-7-分配用户角色" class="headerlink" title="1.3.7. 分配用户角色"></a>1.3.7. 分配用户角色</h3><ul><li>请求路径：users/:id/role</li><li>请求方法：put</li><li>请求参数</li></ul><table><thead><tr><th>参数名</th><th>参数说明</th><th>备注</th></tr></thead><tbody><tr><td>id</td><td>用户 ID</td><td>不能为空<code>参数是url参数:id</code></td></tr><tr><td>rid</td><td>角色 id</td><td>不能为空<code>参数body参数</code></td></tr></tbody></table><ul><li>响应参数</li></ul><table><thead><tr><th>参数名</th><th>参数说明</th><th>备注</th></tr></thead><tbody><tr><td>id</td><td>用户 ID</td><td></td></tr><tr><td>role_id</td><td>角色 ID</td><td></td></tr><tr><td>mobile</td><td>手机号</td><td></td></tr><tr><td>email</td><td>邮箱</td><td></td></tr></tbody></table><ul><li>响应数据</li></ul><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;data&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;id&quot;</span>: <span class="number">508</span>,</span><br><span class="line">        <span class="attr">&quot;rid&quot;</span>: <span class="string">&quot;30&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;username&quot;</span>: <span class="string">&quot;asdf1&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;mobile&quot;</span>: <span class="string">&quot;123123&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;email&quot;</span>: <span class="string">&quot;adfsa@qq.com&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;meta&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;msg&quot;</span>: <span class="string">&quot;设置角色成功&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;status&quot;</span>: <span class="number">200</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-4-权限管理"><a href="#1-4-权限管理" class="headerlink" title="1.4. 权限管理"></a>1.4. 权限管理</h2><h3 id="1-4-1-所有权限列表"><a href="#1-4-1-所有权限列表" class="headerlink" title="1.4.1. 所有权限列表"></a>1.4.1. 所有权限列表</h3><ul><li>请求路径：rights/:type</li><li>请求方法：get</li><li>请求参数</li></ul><table><thead><tr><th>参数名</th><th>参数说明</th><th>备注</th></tr></thead><tbody><tr><td>type</td><td>类型</td><td>值 list 或 tree , list 列表显示权限, tree 树状显示权限,<code>参数是url参数:type</code></td></tr></tbody></table><ul><li>响应参数</li></ul><table><thead><tr><th>参数名</th><th>参数说明</th><th>备注</th></tr></thead><tbody><tr><td>id</td><td>权限 ID</td><td></td></tr><tr><td>authName</td><td>权限说明</td><td></td></tr><tr><td>level</td><td>权限层级</td><td></td></tr><tr><td>pid</td><td>权限父 ID</td><td></td></tr><tr><td>path</td><td>对应访问路径</td><td></td></tr></tbody></table><ul><li>响应数据 type=list</li></ul><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">  &#123;</span><br><span class="line">    <span class="attr">&quot;data&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;id&quot;</span>: <span class="number">101</span>,</span><br><span class="line">            <span class="attr">&quot;authName&quot;</span>: <span class="string">&quot;商品管理&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;level&quot;</span>: <span class="string">&quot;0&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;pid&quot;</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">&quot;path&quot;</span>: <span class="literal">null</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;id&quot;</span>: <span class="number">102</span>,</span><br><span class="line">            <span class="attr">&quot;authName&quot;</span>: <span class="string">&quot;订单管理&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;level&quot;</span>: <span class="string">&quot;0&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;pid&quot;</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">&quot;path&quot;</span>: <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">&quot;meta&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;msg&quot;</span>: <span class="string">&quot;获取权限列表成功&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;status&quot;</span>: <span class="number">200</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>type=tree</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  data: [</span><br><span class="line">    &#123;</span><br><span class="line">      id: 101,</span><br><span class="line">      authName: &#x27;商品管理&#x27;,</span><br><span class="line">      path: null,</span><br><span class="line">      pid: 0,</span><br><span class="line">      children: [</span><br><span class="line">        &#123;</span><br><span class="line">          id: 104,</span><br><span class="line">          authName: &#x27;商品列表&#x27;,</span><br><span class="line">          path: null,</span><br><span class="line">          pid: 101,</span><br><span class="line">          children: [</span><br><span class="line">            &#123;</span><br><span class="line">              id: 105,</span><br><span class="line">              authName: &#x27;添加商品&#x27;,</span><br><span class="line">              path: null,</span><br><span class="line">              pid: &#x27;104,101&#x27;</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  meta: &#123;</span><br><span class="line">    msg: &#x27;获取权限列表成功&#x27;,</span><br><span class="line">    status: 200</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-2-左侧菜单权限"><a href="#1-4-2-左侧菜单权限" class="headerlink" title="1.4.2. 左侧菜单权限"></a>1.4.2. 左侧菜单权限</h3><ul><li>请求路径：menus</li><li>请求方法：get</li><li>响应数据</li></ul><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;data&quot;</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;id&quot;</span>: <span class="number">101</span>,</span><br><span class="line">            <span class="attr">&quot;authName&quot;</span>: <span class="string">&quot;商品管理&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;path&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">            <span class="attr">&quot;children&quot;</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">&quot;id&quot;</span>: <span class="number">104</span>,</span><br><span class="line">                    <span class="attr">&quot;authName&quot;</span>: <span class="string">&quot;商品列表&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;path&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">                    <span class="attr">&quot;children&quot;</span>: []</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="string">&quot;meta&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;msg&quot;</span>: <span class="string">&quot;获取菜单列表成功&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;status&quot;</span>: <span class="number">200</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-5-角色管理"><a href="#1-5-角色管理" class="headerlink" title="1.5. 角色管理"></a>1.5. 角色管理</h2><h3 id="1-5-1-角色列表"><a href="#1-5-1-角色列表" class="headerlink" title="1.5.1. 角色列表"></a>1.5.1. 角色列表</h3><ul><li><p>请求路径：roles</p></li><li><p>请求方法：get</p></li><li><p>响应数据说明</p><ul><li>第一层为角色信息</li></ul><ul><li>第二层开始为权限说明，权限一共有 3 层权限</li><li>最后一层权限，不包含 <code>children</code> 属性</li></ul></li><li><p>响应数据</p></li></ul><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;data&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;id&quot;</span>: <span class="number">30</span>,</span><br><span class="line">            <span class="attr">&quot;roleName&quot;</span>: <span class="string">&quot;主管&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;roleDesc&quot;</span>: <span class="string">&quot;技术负责人&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;children&quot;</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">&quot;id&quot;</span>: <span class="number">101</span>,</span><br><span class="line">                    <span class="attr">&quot;authName&quot;</span>: <span class="string">&quot;商品管理&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;path&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">                    <span class="attr">&quot;children&quot;</span>: [</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="attr">&quot;id&quot;</span>: <span class="number">104</span>,</span><br><span class="line">                            <span class="attr">&quot;authName&quot;</span>: <span class="string">&quot;商品列表&quot;</span>,</span><br><span class="line">                            <span class="attr">&quot;path&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">                            <span class="attr">&quot;children&quot;</span>: [</span><br><span class="line">                                &#123;</span><br><span class="line">                                    <span class="attr">&quot;id&quot;</span>: <span class="number">105</span>,</span><br><span class="line">                                    <span class="attr">&quot;authName&quot;</span>: <span class="string">&quot;添加商品&quot;</span>,</span><br><span class="line">                                    <span class="attr">&quot;path&quot;</span>: <span class="literal">null</span></span><br><span class="line">                                &#125;</span><br><span class="line">                            ]</span><br><span class="line">                        &#125;</span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">&quot;meta&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;msg&quot;</span>: <span class="string">&quot;获取成功&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;status&quot;</span>: <span class="number">200</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-5-2-添加角色"><a href="#1-5-2-添加角色" class="headerlink" title="1.5.2. 添加角色"></a>1.5.2. 添加角色</h3><ul><li>请求路径：roles</li><li>请求方法：post</li><li>请求参数</li></ul><table><thead><tr><th>参数名</th><th>参数说明</th><th>备注</th></tr></thead><tbody><tr><td>roleName</td><td>角色名称</td><td>不能为空</td></tr><tr><td>roleDesc</td><td>角色描述</td><td>可以为空</td></tr></tbody></table><ul><li>响应参数</li></ul><table><thead><tr><th>参数名</th><th>参数说明</th><th>备注</th></tr></thead><tbody><tr><td>roleId</td><td>角色 ID</td><td></td></tr><tr><td>roleName</td><td>角色名称</td><td></td></tr><tr><td>roleDesc</td><td>角色描述</td><td></td></tr></tbody></table><ul><li>响应数据</li></ul><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;data&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;roleId&quot;</span>: <span class="number">40</span>,</span><br><span class="line">        <span class="attr">&quot;roleName&quot;</span>: <span class="string">&quot;admin2&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;roleDesc&quot;</span>: <span class="string">&quot;admin2Desc&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;meta&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;msg&quot;</span>: <span class="string">&quot;创建成功&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;status&quot;</span>: <span class="number">201</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-5-3-根据-ID-查询角色"><a href="#1-5-3-根据-ID-查询角色" class="headerlink" title="1.5.3. 根据 ID 查询角色"></a>1.5.3. 根据 ID 查询角色</h3><ul><li>请求路径：roles/:id</li><li>请求方法：get</li><li>请求参数</li></ul><table><thead><tr><th>参数名</th><th>参数说明</th><th>备注</th></tr></thead><tbody><tr><td>:id</td><td>角色 ID</td><td>不能为空<code>携带在url中</code></td></tr></tbody></table><ul><li>响应参数</li></ul><table><thead><tr><th>参数名</th><th>参数说明</th><th>备注</th></tr></thead><tbody><tr><td>roleId</td><td>角色 ID</td><td></td></tr><tr><td>roleName</td><td>角色名称</td><td></td></tr><tr><td>roleDesc</td><td>角色描述</td><td></td></tr></tbody></table><ul><li>响应数据</li></ul><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;data&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;roleId&quot;</span>: <span class="number">31</span>,</span><br><span class="line">        <span class="attr">&quot;roleName&quot;</span>: <span class="string">&quot;测试角色&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;roleDesc&quot;</span>: <span class="string">&quot;测试负责人&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;meta&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;msg&quot;</span>: <span class="string">&quot;获取成功&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;status&quot;</span>: <span class="number">200</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-5-4-编辑提交角色"><a href="#1-5-4-编辑提交角色" class="headerlink" title="1.5.4. 编辑提交角色"></a>1.5.4. 编辑提交角色</h3><ul><li>请求路径：roles/:id</li><li>请求方法：put</li><li>请求参数</li></ul><table><thead><tr><th>参数名</th><th>参数说明</th><th>备注</th></tr></thead><tbody><tr><td>:id</td><td>角色 ID</td><td>不能为空<code>携带在url中</code></td></tr><tr><td>roleName</td><td>角色名称</td><td>不能为空</td></tr><tr><td>roleDesc</td><td>角色描述</td><td>可以为空</td></tr></tbody></table><ul><li>响应数据</li></ul><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;data&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;roleId&quot;</span>: <span class="number">31</span>,</span><br><span class="line">        <span class="attr">&quot;roleName&quot;</span>: <span class="string">&quot;测试角色&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;roleDesc&quot;</span>: <span class="string">&quot;测试角色描述&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;meta&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;msg&quot;</span>: <span class="string">&quot;获取成功&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;status&quot;</span>: <span class="number">200</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-5-5-删除角色"><a href="#1-5-5-删除角色" class="headerlink" title="1.5.5. 删除角色"></a>1.5.5. 删除角色</h3><ul><li>请求路径：roles/:id</li><li>请求方法：delete</li><li>请求参数</li></ul><table><thead><tr><th>参数名</th><th>参数说明</th><th>备注</th></tr></thead><tbody><tr><td>:id</td><td>角色 ID</td><td>不能为空<code>携带在url中</code></td></tr></tbody></table><ul><li>响应数据</li></ul><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;data&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">&quot;meta&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;msg&quot;</span>: <span class="string">&quot;删除成功&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;status&quot;</span>: <span class="number">200</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-5-6-角色授权"><a href="#1-5-6-角色授权" class="headerlink" title="1.5.6. 角色授权"></a>1.5.6. 角色授权</h3><ul><li>请求路径：roles/:roleId/rights</li><li>请求方法：post</li><li>请求参数：通过 <code>请求体</code> 发送给后端</li></ul><table><thead><tr><th>参数名</th><th>参数说明</th><th>备注</th></tr></thead><tbody><tr><td>:roleId</td><td>角色 ID</td><td>不能为空<code>携带在url中</code></td></tr><tr><td>rids</td><td>权限 ID 列表（字符串）</td><td>以 <code>,</code> 分割的权限 ID 列表（获取所有被选中、叶子节点的key和半选中节点的key, 包括 1，2，3级节点）</td></tr></tbody></table><ul><li>响应数据</li></ul><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;data&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">&quot;meta&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;msg&quot;</span>: <span class="string">&quot;更新成功&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;status&quot;</span>: <span class="number">200</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-5-7-删除角色指定权限"><a href="#1-5-7-删除角色指定权限" class="headerlink" title="1.5.7. 删除角色指定权限"></a>1.5.7. 删除角色指定权限</h3><ul><li><p>请求路径：roles/:roleId/rights/:rightId</p></li><li><p>请求方法：delete</p></li><li><p>请求参数</p><table><thead><tr><th>参数名</th><th>参数说明</th><th>备注</th></tr></thead><tbody><tr><td>:roleId</td><td>角色 ID</td><td>不能为空<code>携带在url中</code></td></tr><tr><td>:rightId</td><td>权限 ID</td><td>不能为空<code>携带在url中</code></td></tr></tbody></table></li><li><p>响应数据说明 </p><ul><li>返回的data, 是当前角色下最新的权限数据</li></ul></li><li><p>响应数据</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;data&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;id&quot;</span>: <span class="number">101</span>,</span><br><span class="line">            <span class="attr">&quot;authName&quot;</span>: <span class="string">&quot;商品管理&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;path&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">            <span class="attr">&quot;children&quot;</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">&quot;id&quot;</span>: <span class="number">104</span>,</span><br><span class="line">                    <span class="attr">&quot;authName&quot;</span>: <span class="string">&quot;商品列表&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;path&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">                    <span class="attr">&quot;children&quot;</span>: [</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="attr">&quot;id&quot;</span>: <span class="number">105</span>,</span><br><span class="line">                            <span class="attr">&quot;authName&quot;</span>: <span class="string">&quot;添加商品&quot;</span>,</span><br><span class="line">                            <span class="attr">&quot;path&quot;</span>: <span class="literal">null</span></span><br><span class="line">                        &#125;,</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="attr">&quot;id&quot;</span>: <span class="number">116</span>,</span><br><span class="line">                            <span class="attr">&quot;authName&quot;</span>: <span class="string">&quot;修改&quot;</span>,</span><br><span class="line">                            <span class="attr">&quot;path&quot;</span>: <span class="literal">null</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">&quot;meta&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;msg&quot;</span>: <span class="string">&quot;取消权限成功&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;status&quot;</span>: <span class="number">200</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-6-商品分类管理"><a href="#1-6-商品分类管理" class="headerlink" title="1.6. 商品分类管理"></a>1.6. 商品分类管理</h2></li></ul><h3 id="1-6-1-商品分类数据列表"><a href="#1-6-1-商品分类数据列表" class="headerlink" title="1.6.1. 商品分类数据列表"></a>1.6.1. 商品分类数据列表</h3><ul><li>请求路径：categories</li><li>请求方法：get</li><li>请求参数</li></ul><table><thead><tr><th>参数名</th><th>参数说明</th><th>备注</th></tr></thead><tbody><tr><td>type</td><td>[1,2,3]</td><td>值：1，2，3 分别表示显示一层二层三层分类列表<br />【可选参数】如果不传递，则默认获取所有级别的分类</td></tr><tr><td>pagenum</td><td>当前页码值</td><td>【可选参数】如果不传递，则默认获取所有分类</td></tr><tr><td>pagesize</td><td>每页显示多少条数据</td><td>【可选参数】如果不传递，则默认获取所有分类</td></tr></tbody></table><ul><li>响应参数</li></ul><table><thead><tr><th>参数名</th><th>参数说明</th><th>备注</th></tr></thead><tbody><tr><td>cat_id</td><td>分类 ID</td><td></td></tr><tr><td>cat_name</td><td>分类名称</td><td></td></tr><tr><td>cat_pid</td><td>分类父 ID</td><td></td></tr><tr><td>cat_level</td><td>分类当前层级</td><td></td></tr></tbody></table><ul><li>响应数据</li></ul><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;data&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;cat_id&quot;</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="attr">&quot;cat_name&quot;</span>: <span class="string">&quot;大家电&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;cat_pid&quot;</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">&quot;cat_level&quot;</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">&quot;cat_deleted&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">&quot;children&quot;</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">&quot;cat_id&quot;</span>: <span class="number">3</span>,</span><br><span class="line">                    <span class="attr">&quot;cat_name&quot;</span>: <span class="string">&quot;电视&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;cat_pid&quot;</span>: <span class="number">1</span>,</span><br><span class="line">                    <span class="attr">&quot;cat_level&quot;</span>: <span class="number">1</span>,</span><br><span class="line">                    <span class="attr">&quot;cat_deleted&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">                    <span class="attr">&quot;children&quot;</span>: [</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="attr">&quot;cat_id&quot;</span>: <span class="number">6</span>,</span><br><span class="line">                            <span class="attr">&quot;cat_name&quot;</span>: <span class="string">&quot;曲面电视&quot;</span>,</span><br><span class="line">                            <span class="attr">&quot;cat_pid&quot;</span>: <span class="number">3</span>,</span><br><span class="line">                            <span class="attr">&quot;cat_level&quot;</span>: <span class="number">2</span>,</span><br><span class="line">                            <span class="attr">&quot;cat_deleted&quot;</span>: <span class="literal">false</span></span><br><span class="line">                        &#125;,</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="attr">&quot;cat_id&quot;</span>: <span class="number">7</span>,</span><br><span class="line">                            <span class="attr">&quot;cat_name&quot;</span>: <span class="string">&quot;海信&quot;</span>,</span><br><span class="line">                            <span class="attr">&quot;cat_pid&quot;</span>: <span class="number">3</span>,</span><br><span class="line">                            <span class="attr">&quot;cat_level&quot;</span>: <span class="number">2</span>,</span><br><span class="line">                            <span class="attr">&quot;cat_deleted&quot;</span>: <span class="literal">false</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">&quot;meta&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;msg&quot;</span>: <span class="string">&quot;获取成功&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;status&quot;</span>: <span class="number">200</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-6-2-添加分类"><a href="#1-6-2-添加分类" class="headerlink" title="1.6.2. 添加分类"></a>1.6.2. 添加分类</h3><ul><li>请求路径：categories</li><li>请求方法：post</li><li>请求参数</li></ul><table><thead><tr><th>参数名</th><th>参数说明</th><th>备注</th></tr></thead><tbody><tr><td>cat_pid</td><td>分类父 ID</td><td>不能为空，如果要添加1级分类，则父分类Id应该设置为  <code>0</code></td></tr><tr><td>cat_name</td><td>分类名称</td><td>不能为空</td></tr><tr><td>cat_level</td><td>分类层级</td><td>不能为空，<code>0</code>表示一级分类；<code>1</code>表示二级分类；<code>2</code>表示三级分类</td></tr></tbody></table><ul><li>响应数据</li></ul><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;data&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;cat_id&quot;</span>: <span class="number">62</span>,</span><br><span class="line">        <span class="attr">&quot;cat_name&quot;</span>: <span class="string">&quot;相框&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;cat_pid&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;cat_level&quot;</span>: <span class="string">&quot;1&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;meta&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;msg&quot;</span>: <span class="string">&quot;创建成功&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;status&quot;</span>: <span class="number">201</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-6-3-根据-id-查询分类"><a href="#1-6-3-根据-id-查询分类" class="headerlink" title="1.6.3. 根据 id 查询分类"></a>1.6.3. 根据 id 查询分类</h3><ul><li>请求路径：categories/:id</li><li>请求方法：get</li><li>请求参数</li></ul><table><thead><tr><th>参数名</th><th>参数说明</th><th>备注</th></tr></thead><tbody><tr><td>:id</td><td>分类 ID</td><td>不能为空<code>携带在url中</code></td></tr></tbody></table><ul><li>响应数据</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;data&quot;: &#123;</span><br><span class="line">        &quot;cat_id&quot;: 3,</span><br><span class="line">        &quot;cat_name&quot;: &quot;厨卫电器&quot;,</span><br><span class="line">        &quot;cat_pid&quot;: 0,</span><br><span class="line">        &quot;cat_level&quot;: 0</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;meta&quot;: &#123;</span><br><span class="line">        &quot;msg&quot;: &quot;获取成功&quot;,</span><br><span class="line">        &quot;status&quot;: 200</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-6-4-编辑提交分类"><a href="#1-6-4-编辑提交分类" class="headerlink" title="1.6.4. 编辑提交分类"></a>1.6.4. 编辑提交分类</h3><ul><li>请求路径：categories/:id</li><li>请求方法：put</li><li>请求参数</li></ul><table><thead><tr><th>参数名</th><th>参数说明</th><th>备注</th></tr></thead><tbody><tr><td>:id</td><td>分类 ID</td><td>不能为空<code>携带在url中</code></td></tr><tr><td>cat_name</td><td>分类名称</td><td>不能为空【此参数，放到请求体中】</td></tr></tbody></table><ul><li>响应数据</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;data&quot;: &#123;</span><br><span class="line">        &quot;cat_id&quot;: 22,</span><br><span class="line">        &quot;cat_name&quot;: &quot;自拍杆&quot;,</span><br><span class="line">        &quot;cat_pid&quot;: 7,</span><br><span class="line">        &quot;cat_level&quot;: 2</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;meta&quot;: &#123;</span><br><span class="line">        &quot;msg&quot;: &quot;更新成功&quot;,</span><br><span class="line">        &quot;status&quot;: 200</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-6-5-删除分类"><a href="#1-6-5-删除分类" class="headerlink" title="1.6.5. 删除分类"></a>1.6.5. 删除分类</h3><ul><li>请求路径：categories/:id</li><li>请求方法：delete</li><li>请求参数</li></ul><table><thead><tr><th>参数名</th><th>参数说明</th><th>备注</th></tr></thead><tbody><tr><td>:id</td><td>分类 ID</td><td>不能为空<code>携带在url中</code></td></tr></tbody></table><ul><li>响应数据</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;data&quot;: null,</span><br><span class="line">    &quot;meta&quot;: &#123;</span><br><span class="line">        &quot;msg&quot;: &quot;删除成功&quot;,</span><br><span class="line">        &quot;status&quot;: 200</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-7-分类参数管理"><a href="#1-7-分类参数管理" class="headerlink" title="1.7. 分类参数管理"></a>1.7. 分类参数管理</h2><h3 id="1-7-1-参数列表"><a href="#1-7-1-参数列表" class="headerlink" title="1.7.1. 参数列表"></a>1.7.1. 参数列表</h3><ul><li>请求路径：categories/:id/attributes</li><li>请求方法：get</li><li>请求参数</li></ul><table><thead><tr><th>参数名</th><th>参数说明</th><th>备注</th></tr></thead><tbody><tr><td>:id</td><td>分类 ID</td><td>不能为空<code>携带在url中</code></td></tr><tr><td>sel</td><td>[only,many]</td><td>不能为空,通过 only 或 many 来获取分类静态参数还是动态参数</td></tr></tbody></table><ul><li>响应参数</li></ul><table><thead><tr><th>参数名</th><th>参数说明</th><th>备注</th></tr></thead><tbody><tr><td>attr_id</td><td>分类参数 ID</td><td></td></tr><tr><td>attr_name</td><td>分类参数名称</td><td></td></tr><tr><td>cat_id</td><td>分类参数所属分类</td><td></td></tr><tr><td>attr_sel</td><td>only:输入框(唯一) many:后台下拉列表/前台单选框</td><td></td></tr><tr><td>attr_write</td><td>manual:手工录入 list:从列表选择</td><td></td></tr><tr><td>attr_vals</td><td>如果 attr_write:list,那么有值，该值以逗号分隔</td><td></td></tr></tbody></table><ul><li>响应数据</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;data&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;attr_id&quot;: 1,</span><br><span class="line">            &quot;attr_name&quot;: &quot;cpu&quot;,</span><br><span class="line">            &quot;cat_id&quot;: 22,</span><br><span class="line">            &quot;attr_sel&quot;: &quot;only&quot;,</span><br><span class="line">            &quot;attr_write&quot;: &quot;manual&quot;,</span><br><span class="line">            &quot;attr_vals&quot;: &quot;ffff&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;meta&quot;: &#123;</span><br><span class="line">        &quot;msg&quot;: &quot;获取成功&quot;,</span><br><span class="line">        &quot;status&quot;: 200</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-7-2-添加动态参数或者静态属性"><a href="#1-7-2-添加动态参数或者静态属性" class="headerlink" title="1.7.2. 添加动态参数或者静态属性"></a>1.7.2. 添加动态参数或者静态属性</h3><ul><li>请求路径：categories/:id/attributes</li><li>请求方法：post</li><li>请求参数</li></ul><table><thead><tr><th>参数名</th><th>参数说明</th><th>备注</th></tr></thead><tbody><tr><td>:id</td><td>分类 ID</td><td>不能为空<code>携带在url中</code></td></tr><tr><td>attr_name</td><td>参数名称</td><td>不能为空</td></tr><tr><td>attr_sel</td><td>[only,many]</td><td>不能为空</td></tr><tr><td>attr_vals</td><td>如果是 many 就需要填写值的选项，以逗号分隔</td><td>【可选参数】</td></tr></tbody></table><ul><li>响应数据</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;data&quot;: &#123;</span><br><span class="line">        &quot;attr_id&quot;: 44,</span><br><span class="line">        &quot;attr_name&quot;: &quot;测试参数&quot;,</span><br><span class="line">        &quot;cat_id&quot;: &quot;1&quot;,</span><br><span class="line">        &quot;attr_sel&quot;: &quot;many&quot;,</span><br><span class="line">        &quot;attr_write&quot;: &quot;list&quot;,</span><br><span class="line">        &quot;attr_vals&quot;: &quot;a,b,c&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;meta&quot;: &#123;</span><br><span class="line">        &quot;msg&quot;: &quot;创建成功&quot;,</span><br><span class="line">        &quot;status&quot;: 201</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-7-3-删除参数"><a href="#1-7-3-删除参数" class="headerlink" title="1.7.3. 删除参数"></a>1.7.3. 删除参数</h3><ul><li>请求路径： categories/:id/attributes/:attrid</li><li>请求方法：delete</li><li>请求参数</li></ul><table><thead><tr><th>参数名</th><th>参数说明</th><th>备注</th></tr></thead><tbody><tr><td>:id</td><td>分类 ID</td><td>不能为空<code>携带在url中</code></td></tr><tr><td>:attrid</td><td>参数 ID</td><td>不能为空<code>携带在url中</code></td></tr></tbody></table><ul><li>响应数据</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;data&quot;: null,</span><br><span class="line">    &quot;meta&quot;: &#123;</span><br><span class="line">        &quot;msg&quot;: &quot;删除成功&quot;,</span><br><span class="line">        &quot;status&quot;: 200</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-7-4-根据-ID-查询参数"><a href="#1-7-4-根据-ID-查询参数" class="headerlink" title="1.7.4. 根据 ID 查询参数"></a>1.7.4. 根据 ID 查询参数</h3><ul><li>请求路径：categories/:id/attributes/:attrId</li><li>请求方法：get</li><li>请求参数</li></ul><table><thead><tr><th>参数名</th><th>参数说明</th><th>备注</th></tr></thead><tbody><tr><td>:id</td><td>分类 ID</td><td>不能为空<code>携带在url中</code></td></tr><tr><td>:attrId</td><td>属性 ID</td><td>不能为空<code>携带在url中</code></td></tr><tr><td>attr_sel</td><td>[only,many]</td><td>不能为空</td></tr><tr><td>attr_vals</td><td>如果是 many 就需要填写值的选项，以逗号分隔</td><td></td></tr></tbody></table><ul><li>响应数据</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;data&quot;: &#123;</span><br><span class="line">        &quot;attr_id&quot;: 1,</span><br><span class="line">        &quot;attr_name&quot;: &quot;cpu&quot;,</span><br><span class="line">        &quot;cat_id&quot;: 22,</span><br><span class="line">        &quot;attr_sel&quot;: &quot;only&quot;,</span><br><span class="line">        &quot;attr_write&quot;: &quot;manual&quot;,</span><br><span class="line">        &quot;attr_vals&quot;: &quot;ffff&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;meta&quot;: &#123;</span><br><span class="line">        &quot;msg&quot;: &quot;获取成功&quot;,</span><br><span class="line">        &quot;status&quot;: 200</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-7-5-编辑提交参数"><a href="#1-7-5-编辑提交参数" class="headerlink" title="1.7.5. 编辑提交参数"></a>1.7.5. 编辑提交参数</h3><ul><li>请求路径：categories/:id/attributes/:attrId</li><li>请求方法：put</li><li>请求参数</li></ul><table><thead><tr><th>参数名</th><th>参数说明</th><th>备注</th></tr></thead><tbody><tr><td>:id</td><td>分类 ID</td><td>不能为空<code>携带在url中</code></td></tr><tr><td>:attrId</td><td>属性 ID</td><td>不能为空<code>携带在url中</code></td></tr><tr><td>attr_name</td><td>新属性的名字</td><td>不能为空，携带在<code>请求体</code>中</td></tr><tr><td>attr_sel</td><td>属性的类型[many或only]</td><td>不能为空，携带在<code>请求体</code>中</td></tr><tr><td>attr_vals</td><td>参数的属性值</td><td>可选参数，携带在<code>请求体</code>中</td></tr></tbody></table><ul><li>响应数据</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;data&quot;: &#123;</span><br><span class="line">        &quot;attr_id&quot;: 9,</span><br><span class="line">        &quot;attr_name&quot;: &quot;测试更新&quot;,</span><br><span class="line">        &quot;cat_id&quot;: &quot;43&quot;,</span><br><span class="line">        &quot;attr_sel&quot;: &quot;only&quot;,</span><br><span class="line">        &quot;attr_write&quot;: &quot;manual&quot;,</span><br><span class="line">        &quot;attr_vals&quot;: &quot;abc&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;meta&quot;: &#123;</span><br><span class="line">        &quot;msg&quot;: &quot;更新成功&quot;,</span><br><span class="line">        &quot;status&quot;: 200</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-8-商品管理"><a href="#1-8-商品管理" class="headerlink" title="1.8. 商品管理"></a>1.8. 商品管理</h2><h3 id="1-8-1-商品列表数据"><a href="#1-8-1-商品列表数据" class="headerlink" title="1.8.1. 商品列表数据"></a>1.8.1. 商品列表数据</h3><ul><li>请求路径：goods</li><li>请求方法：get</li><li>请求参数</li></ul><table><thead><tr><th>参数名</th><th>参数说明</th><th>备注</th></tr></thead><tbody><tr><td>query</td><td>查询参数</td><td>可以为空</td></tr><tr><td>pagenum</td><td>当前页码</td><td>不能为空</td></tr><tr><td>pagesize</td><td>每页显示条数</td><td>不能为空</td></tr></tbody></table><ul><li>响应参数</li></ul><table><thead><tr><th>参数名</th><th>参数说明</th><th>备注</th></tr></thead><tbody><tr><td>total</td><td>总共商品条数</td><td></td></tr><tr><td>pagenum</td><td>当前商品页数</td><td></td></tr><tr><td>goods_id</td><td>商品 ID</td><td></td></tr><tr><td>goods_name</td><td>商品名称</td><td></td></tr><tr><td>goods_price</td><td>价格</td><td></td></tr><tr><td>goods_number</td><td>数量</td><td></td></tr><tr><td>goods_weight</td><td>重量</td><td>不能为空</td></tr><tr><td>goods_state</td><td>商品状态</td><td>商品状态 0: 未通过 1: 审核中 2: 已审核</td></tr><tr><td>add_time</td><td>添加时间</td><td></td></tr><tr><td>upd_time</td><td>更新时间</td><td></td></tr><tr><td>hot_mumber</td><td>热销品数量</td><td></td></tr><tr><td>is_promote</td><td>是否是热销品</td><td></td></tr></tbody></table><ul><li>响应数据</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;data&quot;: &#123;</span><br><span class="line">        &quot;total&quot;: 50,</span><br><span class="line">        &quot;pagenum&quot;: &quot;1&quot;,</span><br><span class="line">        &quot;goods&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;goods_id&quot;: 144,</span><br><span class="line">                &quot;goods_name&quot;: &quot;asfdsd&quot;,</span><br><span class="line">                &quot;goods_price&quot;: 1,</span><br><span class="line">                &quot;goods_number&quot;: 1,</span><br><span class="line">                &quot;goods_weight&quot;: 1,</span><br><span class="line">                &quot;goods_state&quot;: null,</span><br><span class="line">                &quot;add_time&quot;: 1512954923,</span><br><span class="line">                &quot;upd_time&quot;: 1512954923,</span><br><span class="line">                &quot;hot_mumber&quot;: 0,</span><br><span class="line">                &quot;is_promote&quot;: false</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;meta&quot;: &#123;</span><br><span class="line">        &quot;msg&quot;: &quot;获取成功&quot;,</span><br><span class="line">        &quot;status&quot;: 200</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-8-2-添加商品"><a href="#1-8-2-添加商品" class="headerlink" title="1.8.2. 添加商品"></a>1.8.2. 添加商品</h3><ul><li>请求路径：goods</li><li>请求方法：post</li><li>请求参数</li></ul><table><thead><tr><th>参数名</th><th>参数说明</th><th>备注</th></tr></thead><tbody><tr><td>goods_name</td><td>商品名称</td><td>不能为空</td></tr><tr><td>goods_cat</td><td>以为’,’分割的分类列表</td><td>不能为空</td></tr><tr><td>goods_price</td><td>价格</td><td>不能为空</td></tr><tr><td>goods_number</td><td>数量</td><td>不能为空</td></tr><tr><td>goods_weight</td><td>重量</td><td>不能为空</td></tr><tr><td>goods_introduce</td><td>介绍</td><td>可以为空</td></tr><tr><td>pics</td><td>上传的图片临时路径（对象）</td><td>可以为空</td></tr><tr><td>attrs</td><td>商品的参数（数组），包含 <code>动态参数</code> 和 <code>静态属性</code></td><td>可以为空</td></tr></tbody></table><ul><li>请求数据</li></ul><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;goods_name&quot;</span>:<span class="string">&quot;test_goods_name2&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;goods_cat&quot;</span>: <span class="string">&quot;1,2,3&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;goods_price&quot;</span>:<span class="number">20</span>,</span><br><span class="line">  <span class="attr">&quot;goods_number&quot;</span>:<span class="number">30</span>,</span><br><span class="line">  <span class="attr">&quot;goods_weight&quot;</span>:<span class="number">40</span>,</span><br><span class="line">  <span class="attr">&quot;goods_introduce&quot;</span>:<span class="string">&quot;abc&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;pics&quot;</span>:[</span><br><span class="line">    &#123;<span class="attr">&quot;pic&quot;</span>:<span class="string">&quot;/tmp_uploads/30f08d52c551ecb447277eae232304b8&quot;</span>&#125;</span><br><span class="line">    ],</span><br><span class="line">  <span class="attr">&quot;attrs&quot;</span>:[</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;attr_id&quot;</span>:<span class="number">15</span>,</span><br><span class="line">      <span class="attr">&quot;attr_value&quot;</span>:<span class="string">&quot;ddd&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;attr_id&quot;</span>:<span class="number">15</span>,</span><br><span class="line">      <span class="attr">&quot;attr_value&quot;</span>:<span class="string">&quot;eee&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>响应参数</li></ul><table><thead><tr><th>参数名</th><th>参数说明</th><th>备注</th></tr></thead><tbody><tr><td>total</td><td>总共商品条数</td><td></td></tr><tr><td>pagenum</td><td>当前商品页数</td><td></td></tr><tr><td>goods_id</td><td>商品 ID</td><td></td></tr><tr><td>goods_cat</td><td>以为’,’分割的分类列表</td><td></td></tr><tr><td>goods_name</td><td>商品名称</td><td></td></tr><tr><td>goods_price</td><td>价格</td><td></td></tr><tr><td>goods_number</td><td>数量</td><td></td></tr><tr><td>goods_weight</td><td>重量</td><td>不能为空</td></tr><tr><td>goods_state</td><td>商品状态</td><td>商品状态 0: 未通过 1: 审核中 2: 已审核</td></tr><tr><td>add_time</td><td>添加时间</td><td></td></tr><tr><td>upd_time</td><td>更新时间</td><td></td></tr><tr><td>hot_mumber</td><td>热销品数量</td><td></td></tr><tr><td>is_promote</td><td>是否是热销品</td><td></td></tr><tr><td>pics</td><td>上传的图片临时路径（对象）</td><td>pics_id:图片 ID,goods_id:商品 ID,pics_big:大图,pics_mid:中图,pics_sma:小图</td></tr><tr><td>attrs</td><td>商品的参数（数组）</td><td>goods_id:商品 ID,attr_value:当前商品的参数值,add_price:浮动价格,attr_vals:预定义的参数值,attr_sel:手动输入，还是单选,</td></tr></tbody></table><ul><li>响应数据</li></ul><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;data&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;goods_id&quot;</span>: <span class="number">145</span>,</span><br><span class="line">        <span class="attr">&quot;goods_name&quot;</span>: <span class="string">&quot;test_goods_name2&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;goods_price&quot;</span>: <span class="number">20</span>,</span><br><span class="line">        <span class="attr">&quot;cat_id&quot;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">&quot;goods_number&quot;</span>: <span class="number">30</span>,</span><br><span class="line">        <span class="attr">&quot;goods_weight&quot;</span>: <span class="number">40</span>,</span><br><span class="line">        <span class="attr">&quot;goods_introduce&quot;</span>: <span class="string">&quot;abc&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;goods_big_logo&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;goods_small_logo&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;goods_state&quot;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">&quot;add_time&quot;</span>: <span class="number">1512962370</span>,</span><br><span class="line">        <span class="attr">&quot;upd_time&quot;</span>: <span class="number">1512962370</span>,</span><br><span class="line">        <span class="attr">&quot;hot_mumber&quot;</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">&quot;is_promote&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">&quot;pics&quot;</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">&quot;pics_id&quot;</span>: <span class="number">397</span>,</span><br><span class="line">                <span class="attr">&quot;goods_id&quot;</span>: <span class="number">145</span>,</span><br><span class="line">                <span class="attr">&quot;pics_big&quot;</span>: <span class="string">&quot;uploads/goodspics/big_30f08d52c551ecb447277eae232304b8&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;pics_mid&quot;</span>: <span class="string">&quot;uploads/goodspics/mid_30f08d52c551ecb447277eae232304b8&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;pics_sma&quot;</span>: <span class="string">&quot;uploads/goodspics/sma_30f08d52c551ecb447277eae232304b8&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">&quot;attrs&quot;</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">&quot;goods_id&quot;</span>: <span class="number">145</span>,</span><br><span class="line">                <span class="attr">&quot;attr_id&quot;</span>: <span class="number">15</span>,</span><br><span class="line">                <span class="attr">&quot;attr_value&quot;</span>: <span class="string">&quot;ddd&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;add_price&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">                <span class="attr">&quot;attr_name&quot;</span>: <span class="string">&quot;fffffff&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;attr_sel&quot;</span>: <span class="string">&quot;many&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;attr_write&quot;</span>: <span class="string">&quot;list&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;attr_vals&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">&quot;goods_id&quot;</span>: <span class="number">145</span>,</span><br><span class="line">                <span class="attr">&quot;attr_id&quot;</span>: <span class="number">15</span>,</span><br><span class="line">                <span class="attr">&quot;attr_value&quot;</span>: <span class="string">&quot;eee&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;add_price&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">                <span class="attr">&quot;attr_name&quot;</span>: <span class="string">&quot;fffffff&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;attr_sel&quot;</span>: <span class="string">&quot;many&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;attr_write&quot;</span>: <span class="string">&quot;list&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;attr_vals&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;meta&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;msg&quot;</span>: <span class="string">&quot;创建商品成功&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;status&quot;</span>: <span class="number">201</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-8-3-根据-ID-查询商品"><a href="#1-8-3-根据-ID-查询商品" class="headerlink" title="1.8.3. 根据 ID 查询商品"></a>1.8.3. 根据 ID 查询商品</h3><ul><li>请求路径：goods/:id</li><li>请求方法：get</li><li>请求参数</li></ul><table><thead><tr><th>参数名</th><th>参数说明</th><th>备注</th></tr></thead><tbody><tr><td>id</td><td>商品 ID</td><td>不能为空<code>携带在url中</code></td></tr></tbody></table><ul><li>响应参数</li></ul><table><thead><tr><th>参数名</th><th>参数说明</th><th>备注</th></tr></thead><tbody><tr><td>total</td><td>总共商品条数</td><td></td></tr><tr><td>pagenum</td><td>当前商品页数</td><td></td></tr><tr><td>goods_id</td><td>商品 ID</td><td></td></tr><tr><td>goods_name</td><td>商品名称</td><td></td></tr><tr><td>goods_price</td><td>价格</td><td></td></tr><tr><td>goods_number</td><td>数量</td><td></td></tr><tr><td>goods_weight</td><td>重量</td><td>不能为空</td></tr><tr><td>goods_state</td><td>商品状态</td><td>商品状态 0: 未通过 1: 审核中 2: 已审核</td></tr><tr><td>add_time</td><td>添加时间</td><td></td></tr><tr><td>upd_time</td><td>更新时间</td><td></td></tr><tr><td>hot_mumber</td><td>热销品数量</td><td></td></tr><tr><td>is_promote</td><td>是否是热销品</td><td></td></tr><tr><td>pics</td><td>上传的图片临时路径（对象）</td><td>pics_id:图片 ID,goods_id:商品 ID,pics_big:大图,pics_mid:中图,pics_sma:小图</td></tr><tr><td>attrs</td><td>商品的参数（数组）</td><td>goods_id:商品 ID,attr_value:当前商品的参数值,add_price:浮动价格,attr_vals:预定义的参数值,attr_sel:手动输入，还是单选,</td></tr></tbody></table><ul><li>响应数据</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;data&quot;: &#123;</span><br><span class="line">        &quot;goods_id&quot;: 145,</span><br><span class="line">        &quot;goods_name&quot;: &quot;test_goods_name2&quot;,</span><br><span class="line">        &quot;goods_price&quot;: 20,</span><br><span class="line">        &quot;goods_number&quot;: 30,</span><br><span class="line">        &quot;goods_weight&quot;: 40,</span><br><span class="line">        &quot;goods_introduce&quot;: &quot;abc&quot;,</span><br><span class="line">        &quot;goods_big_logo&quot;: &quot;&quot;,</span><br><span class="line">        &quot;goods_small_logo&quot;: &quot;&quot;,</span><br><span class="line">        &quot;goods_state&quot;: 1,</span><br><span class="line">        &quot;add_time&quot;: 1512962370,</span><br><span class="line">        &quot;upd_time&quot;: 1512962370,</span><br><span class="line">        &quot;hot_mumber&quot;: 0,</span><br><span class="line">        &quot;is_promote&quot;: false,</span><br><span class="line">        &quot;pics&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;pics_id&quot;: 397,</span><br><span class="line">                &quot;goods_id&quot;: 145,</span><br><span class="line">                &quot;pics_big&quot;: &quot;uploads&#x2F;goodspics&#x2F;big_30f08d52c551ecb447277eae232304b8&quot;,</span><br><span class="line">                &quot;pics_mid&quot;: &quot;uploads&#x2F;goodspics&#x2F;mid_30f08d52c551ecb447277eae232304b8&quot;,</span><br><span class="line">                &quot;pics_sma&quot;: &quot;uploads&#x2F;goodspics&#x2F;sma_30f08d52c551ecb447277eae232304b8&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        &quot;attrs&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;goods_id&quot;: 145,</span><br><span class="line">                &quot;attr_id&quot;: 15,</span><br><span class="line">                &quot;attr_value&quot;: &quot;ddd&quot;,</span><br><span class="line">                &quot;add_price&quot;: null,</span><br><span class="line">                &quot;attr_name&quot;: &quot;fffffff&quot;,</span><br><span class="line">                &quot;attr_sel&quot;: &quot;many&quot;,</span><br><span class="line">                &quot;attr_write&quot;: &quot;list&quot;,</span><br><span class="line">                &quot;attr_vals&quot;: &quot;&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;goods_id&quot;: 145,</span><br><span class="line">                &quot;attr_id&quot;: 15,</span><br><span class="line">                &quot;attr_value&quot;: &quot;eee&quot;,</span><br><span class="line">                &quot;add_price&quot;: null,</span><br><span class="line">                &quot;attr_name&quot;: &quot;fffffff&quot;,</span><br><span class="line">                &quot;attr_sel&quot;: &quot;many&quot;,</span><br><span class="line">                &quot;attr_write&quot;: &quot;list&quot;,</span><br><span class="line">                &quot;attr_vals&quot;: &quot;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;meta&quot;: &#123;</span><br><span class="line">        &quot;msg&quot;: &quot;创建商品成功&quot;,</span><br><span class="line">        &quot;status&quot;: 201</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-8-4-编辑提交商品"><a href="#1-8-4-编辑提交商品" class="headerlink" title="1.8.4. 编辑提交商品"></a>1.8.4. 编辑提交商品</h3><ul><li>请求路径：goods/:id</li><li>请求方法：put</li><li>请求参数</li></ul><table><thead><tr><th>参数名</th><th>参数说明</th><th>备注</th></tr></thead><tbody><tr><td>id</td><td>商品 ID</td><td>不能为空<code>携带在url中</code></td></tr><tr><td>goods_name</td><td>商品名称</td><td>不能为空</td></tr><tr><td>goods_price</td><td>价格</td><td>不能为空</td></tr><tr><td>goods_number</td><td>数量</td><td>不能为空</td></tr><tr><td>goods_weight</td><td>重量</td><td>不能为空</td></tr><tr><td>goods_introduce</td><td>介绍</td><td>可以为空</td></tr><tr><td>pics</td><td>上传的图片临时路径（对象）</td><td>可以为空</td></tr><tr><td>attrs</td><td>商品的参数（数组）</td><td>可以为空</td></tr></tbody></table><ul><li>请求数据</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;goods_name&quot;:&quot;test_goods_name2&quot;,</span><br><span class="line">  &quot;goods_price&quot;:20,</span><br><span class="line">  &quot;goods_number&quot;:30,</span><br><span class="line">  &quot;goods_weight&quot;:40,</span><br><span class="line">  &quot;goods_introduce&quot;:&quot;abc&quot;,</span><br><span class="line">  &quot;pics&quot;:[</span><br><span class="line">    &#123;&quot;pic&quot;:&quot;&#x2F;tmp_uploads&#x2F;30f08d52c551ecb447277eae232304b8&quot;&#125;</span><br><span class="line">    ],</span><br><span class="line">  &quot;attrs&quot;:[</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;attr_id&quot;:15,</span><br><span class="line">      &quot;attr_value&quot;:&quot;ddd&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;attr_id&quot;:15,</span><br><span class="line">      &quot;attr_value&quot;:&quot;eee&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>响应参数</li></ul><table><thead><tr><th>参数名</th><th>参数说明</th><th>备注</th></tr></thead><tbody><tr><td>total</td><td>总共商品条数</td><td></td></tr><tr><td>pagenum</td><td>当前商品页数</td><td></td></tr><tr><td>goods_id</td><td>商品 ID</td><td></td></tr><tr><td>goods_name</td><td>商品名称</td><td></td></tr><tr><td>goods_price</td><td>价格</td><td></td></tr><tr><td>goods_number</td><td>数量</td><td></td></tr><tr><td>goods_weight</td><td>重量</td><td>不能为空</td></tr><tr><td>goods_state</td><td>商品状态</td><td>商品状态 0: 未通过 1: 审核中 2: 已审核</td></tr><tr><td>add_time</td><td>添加时间</td><td></td></tr><tr><td>upd_time</td><td>更新时间</td><td></td></tr><tr><td>hot_mumber</td><td>热销品数量</td><td></td></tr><tr><td>is_promote</td><td>是否是热销品</td><td></td></tr><tr><td>pics</td><td>上传的图片临时路径（对象）</td><td>pics_id:图片 ID,goods_id:商品 ID,pics_big:大图,pics_mid:中图,pics_sma:小图</td></tr><tr><td>attrs</td><td>商品的参数（数组）</td><td>goods_id:商品 ID,attr_value:当前商品的参数值,add_price:浮动价格,attr_vals:预定义的参数值,attr_sel:手动输入，还是单选,</td></tr></tbody></table><ul><li>响应数据</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;data&quot;: &#123;</span><br><span class="line">        &quot;goods_id&quot;: 145,</span><br><span class="line">        &quot;goods_name&quot;: &quot;test_goods_name2&quot;,</span><br><span class="line">        &quot;goods_price&quot;: 20,</span><br><span class="line">        &quot;goods_number&quot;: 30,</span><br><span class="line">        &quot;goods_weight&quot;: 40,</span><br><span class="line">        &quot;goods_introduce&quot;: &quot;abc&quot;,</span><br><span class="line">        &quot;goods_big_logo&quot;: &quot;&quot;,</span><br><span class="line">        &quot;goods_small_logo&quot;: &quot;&quot;,</span><br><span class="line">        &quot;goods_state&quot;: 1,</span><br><span class="line">        &quot;add_time&quot;: 1512962370,</span><br><span class="line">        &quot;upd_time&quot;: 1512962370,</span><br><span class="line">        &quot;hot_mumber&quot;: 0,</span><br><span class="line">        &quot;is_promote&quot;: false,</span><br><span class="line">        &quot;pics&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;pics_id&quot;: 397,</span><br><span class="line">                &quot;goods_id&quot;: 145,</span><br><span class="line">                &quot;pics_big&quot;: &quot;uploads&#x2F;goodspics&#x2F;big_30f08d52c551ecb447277eae232304b8&quot;,</span><br><span class="line">                &quot;pics_mid&quot;: &quot;uploads&#x2F;goodspics&#x2F;mid_30f08d52c551ecb447277eae232304b8&quot;,</span><br><span class="line">                &quot;pics_sma&quot;: &quot;uploads&#x2F;goodspics&#x2F;sma_30f08d52c551ecb447277eae232304b8&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        &quot;attrs&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;goods_id&quot;: 145,</span><br><span class="line">                &quot;attr_id&quot;: 15,</span><br><span class="line">                &quot;attr_value&quot;: &quot;ddd&quot;,</span><br><span class="line">                &quot;add_price&quot;: null,</span><br><span class="line">                &quot;attr_name&quot;: &quot;fffffff&quot;,</span><br><span class="line">                &quot;attr_sel&quot;: &quot;many&quot;,</span><br><span class="line">                &quot;attr_write&quot;: &quot;list&quot;,</span><br><span class="line">                &quot;attr_vals&quot;: &quot;&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;goods_id&quot;: 145,</span><br><span class="line">                &quot;attr_id&quot;: 15,</span><br><span class="line">                &quot;attr_value&quot;: &quot;eee&quot;,</span><br><span class="line">                &quot;add_price&quot;: null,</span><br><span class="line">                &quot;attr_name&quot;: &quot;fffffff&quot;,</span><br><span class="line">                &quot;attr_sel&quot;: &quot;many&quot;,</span><br><span class="line">                &quot;attr_write&quot;: &quot;list&quot;,</span><br><span class="line">                &quot;attr_vals&quot;: &quot;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;meta&quot;: &#123;</span><br><span class="line">        &quot;msg&quot;: &quot;创建商品成功&quot;,</span><br><span class="line">        &quot;status&quot;: 201</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-8-5-删除商品"><a href="#1-8-5-删除商品" class="headerlink" title="1.8.5. 删除商品"></a>1.8.5. 删除商品</h3><ul><li>请求路径：goods/:id</li><li>请求方法：delete</li><li>请求参数</li></ul><table><thead><tr><th>参数名</th><th>参数说明</th><th>备注</th></tr></thead><tbody><tr><td>id</td><td>商品 ID</td><td>不能为空<code>携带在url中</code></td></tr></tbody></table><ul><li>响应数据</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;data&quot;: null,</span><br><span class="line">    &quot;meta&quot;: &#123;</span><br><span class="line">        &quot;msg&quot;: &quot;删除成功&quot;,</span><br><span class="line">        &quot;status&quot;: 200</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>###同步商品图片</p><ul><li>请求路径：goods/:id/pics</li><li>请求方法：put</li><li>请求参数</li></ul><table><thead><tr><th>参数名</th><th>参数说明</th><th>备注</th></tr></thead><tbody><tr><td>id</td><td>商品 ID</td><td>不能为空<code>携带在url中</code></td></tr><tr><td>pics</td><td>商品图片集合</td><td>如果有 pics_id 字段会保留该图片，如果没有 pics_id 但是有 pic 字段就会新生成图片数据</td></tr></tbody></table><ul><li>请求数据</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">;[</span><br><span class="line">  &#123; pic: &#39;tmp_uploads&#x2F;db28f6316835836e97653b5c75e418be.png&#39; &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    pics_id: 397,</span><br><span class="line">    goods_id: 145,</span><br><span class="line">    pics_big: &#39;uploads&#x2F;goodspics&#x2F;big_30f08d52c551ecb447277eae232304b8&#39;,</span><br><span class="line">    pics_mid: &#39;uploads&#x2F;goodspics&#x2F;mid_30f08d52c551ecb447277eae232304b8&#39;,</span><br><span class="line">    pics_sma: &#39;uploads&#x2F;goodspics&#x2F;sma_30f08d52c551ecb447277eae232304b8&#39;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><ul><li>响应数据</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;data&quot;: &#123;</span><br><span class="line">        &quot;goods_id&quot;: 96,</span><br><span class="line">        &quot;goods_name&quot;: &quot;iphoneXX&quot;,</span><br><span class="line">        &quot;goods_price&quot;: 2,</span><br><span class="line">        &quot;goods_number&quot;: 22,</span><br><span class="line">        &quot;goods_weight&quot;: 22,</span><br><span class="line">        &quot;goods_introduce&quot;: null,</span><br><span class="line">        &quot;goods_big_logo&quot;: &quot;.&#x2F;uploads&#x2F;goods&#x2F;20171113&#x2F;483a3b8e99e534ec3e4312dbbaee7c9d.jpg&quot;,</span><br><span class="line">        &quot;goods_small_logo&quot;: &quot;.&#x2F;uploads&#x2F;goods&#x2F;20171113&#x2F;small_483a3b8e99e534ec3e4312dbbaee7c9d.jpg&quot;,</span><br><span class="line">        &quot;goods_state&quot;: 0,</span><br><span class="line">        &quot;is_del&quot;: &quot;1&quot;,</span><br><span class="line">        &quot;add_time&quot;: 1510045904,</span><br><span class="line">        &quot;upd_time&quot;: 1512635159,</span><br><span class="line">        &quot;delete_time&quot;: 1512635159,</span><br><span class="line">        &quot;hot_mumber&quot;: 0,</span><br><span class="line">        &quot;is_promote&quot;: false,</span><br><span class="line">        &quot;pics&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;pics_id&quot;: 383,</span><br><span class="line">                &quot;goods_id&quot;: 96,</span><br><span class="line">                &quot;pics_big&quot;: &quot;uploads&#x2F;goodspics&#x2F;big_6f5750132abd3f5b2b93dd722fcde653.jpg&quot;,</span><br><span class="line">                &quot;pics_mid&quot;: &quot;uploads&#x2F;goodspics&#x2F;mid_6f5750132abd3f5b2b93dd722fcde653.jpg&quot;,</span><br><span class="line">                &quot;pics_sma&quot;: &quot;uploads&#x2F;goodspics&#x2F;sma_6f5750132abd3f5b2b93dd722fcde653.jpg&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        &quot;attrs&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;goods_id&quot;: 96,</span><br><span class="line">                &quot;attr_id&quot;: 15,</span><br><span class="line">                &quot;attr_value&quot;: &quot;eee&quot;,</span><br><span class="line">                &quot;add_price&quot;: null,</span><br><span class="line">                &quot;attr_name&quot;: &quot;fffffff&quot;,</span><br><span class="line">                &quot;attr_sel&quot;: &quot;many&quot;,</span><br><span class="line">                &quot;attr_write&quot;: &quot;list&quot;,</span><br><span class="line">                &quot;attr_vals&quot;: &quot;&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;goods_id&quot;: 96,</span><br><span class="line">                &quot;attr_id&quot;: 15,</span><br><span class="line">                &quot;attr_value&quot;: &quot;ddd&quot;,</span><br><span class="line">                &quot;add_price&quot;: null,</span><br><span class="line">                &quot;attr_name&quot;: &quot;fffffff&quot;,</span><br><span class="line">                &quot;attr_sel&quot;: &quot;many&quot;,</span><br><span class="line">                &quot;attr_write&quot;: &quot;list&quot;,</span><br><span class="line">                &quot;attr_vals&quot;: &quot;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;meta&quot;: &#123;</span><br><span class="line">        &quot;msg&quot;: &quot;更新成功&quot;,</span><br><span class="line">        &quot;status&quot;: 200</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>###同步商品属性</p><ul><li>请求路径：goods/:id/attributes</li><li>请求方法：put</li><li>请求参数</li></ul><table><thead><tr><th>参数名</th><th>参数说明</th><th>备注</th></tr></thead><tbody><tr><td>id</td><td>商品 ID</td><td>不能为空<code>携带在url中</code></td></tr></tbody></table><ul><li>请求数据</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">;[</span><br><span class="line">  &#123;</span><br><span class="line">    attr_id: 15,</span><br><span class="line">    attr_value: &#39;ddd&#39;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    attr_id: 15,</span><br><span class="line">    attr_value: &#39;eee&#39;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><ul><li>响应数据</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;data&quot;: &#123;</span><br><span class="line">        &quot;goods_id&quot;: 96,</span><br><span class="line">        &quot;goods_name&quot;: &quot;iphoneXX&quot;,</span><br><span class="line">        &quot;goods_price&quot;: 2,</span><br><span class="line">        &quot;goods_number&quot;: 22,</span><br><span class="line">        &quot;goods_weight&quot;: 22,</span><br><span class="line">        &quot;goods_introduce&quot;: null,</span><br><span class="line">        &quot;goods_big_logo&quot;: &quot;.&#x2F;uploads&#x2F;goods&#x2F;20171113&#x2F;483a3b8e99e534ec3e4312dbbaee7c9d.jpg&quot;,</span><br><span class="line">        &quot;goods_small_logo&quot;: &quot;.&#x2F;uploads&#x2F;goods&#x2F;20171113&#x2F;small_483a3b8e99e534ec3e4312dbbaee7c9d.jpg&quot;,</span><br><span class="line">        &quot;goods_state&quot;: 0,</span><br><span class="line">        &quot;is_del&quot;: &quot;1&quot;,</span><br><span class="line">        &quot;add_time&quot;: 1510045904,</span><br><span class="line">        &quot;upd_time&quot;: 1512635159,</span><br><span class="line">        &quot;delete_time&quot;: 1512635159,</span><br><span class="line">        &quot;hot_mumber&quot;: 0,</span><br><span class="line">        &quot;is_promote&quot;: false,</span><br><span class="line">        &quot;pics&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;pics_id&quot;: 383,</span><br><span class="line">                &quot;goods_id&quot;: 96,</span><br><span class="line">                &quot;pics_big&quot;: &quot;uploads&#x2F;goodspics&#x2F;big_6f5750132abd3f5b2b93dd722fcde653.jpg&quot;,</span><br><span class="line">                &quot;pics_mid&quot;: &quot;uploads&#x2F;goodspics&#x2F;mid_6f5750132abd3f5b2b93dd722fcde653.jpg&quot;,</span><br><span class="line">                &quot;pics_sma&quot;: &quot;uploads&#x2F;goodspics&#x2F;sma_6f5750132abd3f5b2b93dd722fcde653.jpg&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        &quot;attrs&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;goods_id&quot;: 96,</span><br><span class="line">                &quot;attr_id&quot;: 15,</span><br><span class="line">                &quot;attr_value&quot;: &quot;eee&quot;,</span><br><span class="line">                &quot;add_price&quot;: null,</span><br><span class="line">                &quot;attr_name&quot;: &quot;fffffff&quot;,</span><br><span class="line">                &quot;attr_sel&quot;: &quot;many&quot;,</span><br><span class="line">                &quot;attr_write&quot;: &quot;list&quot;,</span><br><span class="line">                &quot;attr_vals&quot;: &quot;&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;goods_id&quot;: 96,</span><br><span class="line">                &quot;attr_id&quot;: 15,</span><br><span class="line">                &quot;attr_value&quot;: &quot;ddd&quot;,</span><br><span class="line">                &quot;add_price&quot;: null,</span><br><span class="line">                &quot;attr_name&quot;: &quot;fffffff&quot;,</span><br><span class="line">                &quot;attr_sel&quot;: &quot;many&quot;,</span><br><span class="line">                &quot;attr_write&quot;: &quot;list&quot;,</span><br><span class="line">                &quot;attr_vals&quot;: &quot;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;meta&quot;: &#123;</span><br><span class="line">        &quot;msg&quot;: &quot;更新成功&quot;,</span><br><span class="line">        &quot;status&quot;: 200</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>###商品图片处理必须安装 GraphicsMagick</p><ul><li>linux</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get install GraphicsMagick</span><br></pre></td></tr></table></figure><ul><li>Mac OS X</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install GraphicsMagick</span><br></pre></td></tr></table></figure><ul><li>Windows <a href="https://sourceforge.net/projects/graphicsmagick/files/graphicsmagick-binaries/1.3.27/GraphicsMagick-1.3.27-Q8-win64-dll.exe/download">点击下载</a></li></ul><h2 id="1-9-图片上传"><a href="#1-9-图片上传" class="headerlink" title="1.9. 图片上传"></a>1.9. 图片上传</h2><ul><li>请求路径：upload</li><li>请求方法：post</li><li>请求参数</li></ul><table><thead><tr><th>参数名</th><th>参数说明</th><th>备注</th></tr></thead><tbody><tr><td>file</td><td>上传文件</td><td></td></tr></tbody></table><ul><li>响应数据</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;data&quot;: &#123;</span><br><span class="line">        &quot;tmp_path&quot;: &quot;tmp_uploads&#x2F;ccfc5179a914e94506bcbb7377e8985f.png&quot;,</span><br><span class="line">        &quot;url&quot;: &quot;http:&#x2F;&#x2F;127.0.0.1:8888tmp_uploads&#x2F;ccfc5179a914e94506bcbb7377e8985f.png&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;meta&quot;: &#123;</span><br><span class="line">        &quot;msg&quot;: &quot;上传成功&quot;,</span><br><span class="line">        &quot;status&quot;: 200</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-10-订单管理"><a href="#1-10-订单管理" class="headerlink" title="1.10. 订单管理"></a>1.10. 订单管理</h2><h3 id="1-10-1-订单数据列表"><a href="#1-10-1-订单数据列表" class="headerlink" title="1.10.1. 订单数据列表"></a>1.10.1. 订单数据列表</h3><ul><li>请求路径：orders</li><li>请求方法：get</li><li>请求参数</li></ul><table><thead><tr><th>参数名</th><th>参数说明</th><th>备注</th></tr></thead><tbody><tr><td>query</td><td>查询参数</td><td>可以为空</td></tr><tr><td>pagenum</td><td>当前页码</td><td>不能为空</td></tr><tr><td>pagesize</td><td>每页显示条数</td><td>不能为空</td></tr><tr><td>user_id</td><td>用户 ID</td><td>可以为空</td></tr><tr><td>pay_status</td><td>支付状态</td><td>可以为空</td></tr><tr><td>is_send</td><td>是否发货</td><td>可以为空</td></tr><tr><td>order_fapiao_title</td><td>[‘个人’,’公司’]</td><td>可以为空</td></tr><tr><td>order_fapiao_company</td><td>公司名称</td><td>可以为空</td></tr><tr><td>order_fapiao_content</td><td>发票内容</td><td>可以为空</td></tr><tr><td>consignee_addr</td><td>发货地址</td><td>可以为空</td></tr></tbody></table><ul><li>响应数据</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;data&quot;: &#123;</span><br><span class="line">        &quot;total&quot;: 1,</span><br><span class="line">        &quot;pagenum&quot;: &quot;1&quot;,</span><br><span class="line">        &quot;goods&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;order_id&quot;: 47,</span><br><span class="line">                &quot;user_id&quot;: 133,</span><br><span class="line">                &quot;order_number&quot;: &quot;itcast-59e7502d7993d&quot;,</span><br><span class="line">                &quot;order_price&quot;: 322,</span><br><span class="line">                &quot;order_pay&quot;: &quot;1&quot;,</span><br><span class="line">                &quot;is_send&quot;: &quot;是&quot;,</span><br><span class="line">                &quot;trade_no&quot;: &quot;&quot;,</span><br><span class="line">                &quot;order_fapiao_title&quot;: &quot;个人&quot;,</span><br><span class="line">                &quot;order_fapiao_company&quot;: &quot;&quot;,</span><br><span class="line">                &quot;order_fapiao_content&quot;: &quot;办公用品&quot;,</span><br><span class="line">                &quot;consignee_addr&quot;: &quot;a:7:&#123;s:6:\&quot;cgn_id\&quot;;i:1;s:7:\&quot;user_id\&quot;;i:133;s:8:\&quot;cgn_name\&quot;;s:9:\&quot;王二柱\&quot;;s:11:\&quot;cgn_address\&quot;;s:51:\&quot;北京市海淀区苏州街长远天地大厦305室\&quot;;s:7:\&quot;cgn_tel\&quot;;s:11:\&quot;13566771298\&quot;;s:8:\&quot;cgn_code\&quot;;s:6:\&quot;306810\&quot;;s:11:\&quot;delete_time\&quot;;N;&#125;&quot;,</span><br><span class="line">                &quot;pay_status&quot;: &quot;1&quot;,</span><br><span class="line">                &quot;create_time&quot;: 1508331565,</span><br><span class="line">                &quot;update_time&quot;: 1508331565</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;meta&quot;: &#123;</span><br><span class="line">        &quot;msg&quot;: &quot;获取成功&quot;,</span><br><span class="line">        &quot;status&quot;: 200</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-10-2-修改订单状态"><a href="#1-10-2-修改订单状态" class="headerlink" title="1.10.2. 修改订单状态"></a>1.10.2. 修改订单状态</h3><ul><li>请求路径：orders/:id</li><li>请求方法：put</li><li>请求参数</li></ul><table><thead><tr><th>参数名</th><th>参数说明</th><th>备注</th></tr></thead><tbody><tr><td>id</td><td>订单 ID</td><td>不能为空<code>携带在url中</code></td></tr><tr><td>is_send</td><td>订单是否发货</td><td>1:已经发货，0:未发货</td></tr><tr><td>order_pay</td><td>订单支付</td><td>支付方式 0 未支付 1 支付宝 2 微信 3 银行卡</td></tr><tr><td>order_price</td><td>订单价格</td><td></td></tr><tr><td>order_number</td><td>订单数量</td><td></td></tr><tr><td>pay_status</td><td>支付状态</td><td>订单状态： 0 未付款、1 已付款</td></tr></tbody></table><ul><li>请求数据说明<ul><li>所有请求数据都是增量更新，如果参数不填写，就不会更新该字段</li></ul></li><li>响应数据</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;data&quot;: &#123;</span><br><span class="line">        &quot;order_id&quot;: 67,</span><br><span class="line">        &quot;user_id&quot;: 1,</span><br><span class="line">        &quot;order_number&quot;: &quot;itcast-g7kmck71vjaujfgoi&quot;,</span><br><span class="line">        &quot;order_price&quot;: 20,</span><br><span class="line">        &quot;order_pay&quot;: &quot;0&quot;,</span><br><span class="line">        &quot;is_send&quot;: &quot;否&quot;,</span><br><span class="line">        &quot;trade_no&quot;: &quot;&quot;,</span><br><span class="line">        &quot;order_fapiao_title&quot;: &quot;个人&quot;,</span><br><span class="line">        &quot;order_fapiao_company&quot;: &quot;&quot;,</span><br><span class="line">        &quot;order_fapiao_content&quot;: &quot;&quot;,</span><br><span class="line">        &quot;consignee_addr&quot;: &quot;&quot;,</span><br><span class="line">        &quot;pay_status&quot;: &quot;0&quot;,</span><br><span class="line">        &quot;create_time&quot;: 1512533560,</span><br><span class="line">        &quot;update_time&quot;: 1512533560,</span><br><span class="line">        &quot;goods&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;id&quot;: 82,</span><br><span class="line">                &quot;order_id&quot;: 67,</span><br><span class="line">                &quot;goods_id&quot;: 96,</span><br><span class="line">                &quot;goods_price&quot;: 333,</span><br><span class="line">                &quot;goods_number&quot;: 2,</span><br><span class="line">                &quot;goods_total_price&quot;: 999</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;id&quot;: 83,</span><br><span class="line">                &quot;order_id&quot;: 67,</span><br><span class="line">                &quot;goods_id&quot;: 95,</span><br><span class="line">                &quot;goods_price&quot;: 666,</span><br><span class="line">                &quot;goods_number&quot;: 5,</span><br><span class="line">                &quot;goods_total_price&quot;: 999</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;meta&quot;: &#123;</span><br><span class="line">        &quot;msg&quot;: &quot;获取成功&quot;,</span><br><span class="line">        &quot;status&quot;: 200</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-10-3-查看订单详情"><a href="#1-10-3-查看订单详情" class="headerlink" title="1.10.3. 查看订单详情"></a>1.10.3. 查看订单详情</h3><ul><li>请求路径：orders/:id</li><li>请求方法：get</li><li>请求参数</li></ul><table><thead><tr><th>参数名</th><th>参数说明</th><th>备注</th></tr></thead><tbody><tr><td>id</td><td>订单 ID</td><td>不能为空<code>携带在url中</code></td></tr></tbody></table><ul><li>响应数据</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;data&quot;: &#123;</span><br><span class="line">        &quot;order_id&quot;: 67,</span><br><span class="line">        &quot;user_id&quot;: 1,</span><br><span class="line">        &quot;order_number&quot;: &quot;itcast-g7kmck71vjaujfgoi&quot;,</span><br><span class="line">        &quot;order_price&quot;: 20,</span><br><span class="line">        &quot;order_pay&quot;: &quot;0&quot;,</span><br><span class="line">        &quot;is_send&quot;: &quot;否&quot;,</span><br><span class="line">        &quot;trade_no&quot;: &quot;&quot;,</span><br><span class="line">        &quot;order_fapiao_title&quot;: &quot;个人&quot;,</span><br><span class="line">        &quot;order_fapiao_company&quot;: &quot;&quot;,</span><br><span class="line">        &quot;order_fapiao_content&quot;: &quot;&quot;,</span><br><span class="line">        &quot;consignee_addr&quot;: &quot;&quot;,</span><br><span class="line">        &quot;pay_status&quot;: &quot;0&quot;,</span><br><span class="line">        &quot;create_time&quot;: 1512533560,</span><br><span class="line">        &quot;update_time&quot;: 1512533560,</span><br><span class="line">        &quot;goods&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;id&quot;: 82,</span><br><span class="line">                &quot;order_id&quot;: 67,</span><br><span class="line">                &quot;goods_id&quot;: 96,</span><br><span class="line">                &quot;goods_price&quot;: 333,</span><br><span class="line">                &quot;goods_number&quot;: 2,</span><br><span class="line">                &quot;goods_total_price&quot;: 999</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;id&quot;: 83,</span><br><span class="line">                &quot;order_id&quot;: 67,</span><br><span class="line">                &quot;goods_id&quot;: 95,</span><br><span class="line">                &quot;goods_price&quot;: 666,</span><br><span class="line">                &quot;goods_number&quot;: 5,</span><br><span class="line">                &quot;goods_total_price&quot;: 999</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;meta&quot;: &#123;</span><br><span class="line">        &quot;msg&quot;: &quot;获取成功&quot;,</span><br><span class="line">        &quot;status&quot;: 200</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-10-4-修改地址"><a href="#1-10-4-修改地址" class="headerlink" title="1.10.4. 修改地址"></a>1.10.4. 修改地址</h3><ol><li><a href="https://github.com/iceyangcc/provinces-china">省市区/县联动效果 - 结合ElementUI的 el-cascader 组件</a></li></ol><h3 id="1-10-5-查看物流信息"><a href="#1-10-5-查看物流信息" class="headerlink" title="1.10.5. 查看物流信息"></a>1.10.5. 查看物流信息</h3><ul><li><p>请求路径：/kuaidi/:id</p></li><li><p>请求方法：get</p></li><li><p>供测试的物流单号：1106975712662</p></li><li><p>响应数据：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;data&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;time&quot;</span>: <span class="string">&quot;2018-05-10 09:39:00&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;ftime&quot;</span>: <span class="string">&quot;2018-05-10 09:39:00&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;context&quot;</span>: <span class="string">&quot;已签收,感谢使用顺丰,期待再次为您服务&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;location&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;time&quot;</span>: <span class="string">&quot;2018-05-10 08:23:00&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;ftime&quot;</span>: <span class="string">&quot;2018-05-10 08:23:00&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;context&quot;</span>: <span class="string">&quot;[北京市]北京海淀育新小区营业点派件员 顺丰速运 95338正在为您派件&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;location&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;time&quot;</span>: <span class="string">&quot;2018-05-10 07:32:00&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;ftime&quot;</span>: <span class="string">&quot;2018-05-10 07:32:00&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;context&quot;</span>: <span class="string">&quot;快件到达 [北京海淀育新小区营业点]&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;location&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;time&quot;</span>: <span class="string">&quot;2018-05-10 02:03:00&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;ftime&quot;</span>: <span class="string">&quot;2018-05-10 02:03:00&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;context&quot;</span>: <span class="string">&quot;快件在[北京顺义集散中心]已装车,准备发往 [北京海淀育新小区营业点]&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;location&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;time&quot;</span>: <span class="string">&quot;2018-05-09 23:05:00&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;ftime&quot;</span>: <span class="string">&quot;2018-05-09 23:05:00&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;context&quot;</span>: <span class="string">&quot;快件到达 [北京顺义集散中心]&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;location&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;time&quot;</span>: <span class="string">&quot;2018-05-09 21:21:00&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;ftime&quot;</span>: <span class="string">&quot;2018-05-09 21:21:00&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;context&quot;</span>: <span class="string">&quot;快件在[北京宝胜营业点]已装车,准备发往 [北京顺义集散中心]&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;location&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;time&quot;</span>: <span class="string">&quot;2018-05-09 13:07:00&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;ftime&quot;</span>: <span class="string">&quot;2018-05-09 13:07:00&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;context&quot;</span>: <span class="string">&quot;顺丰速运 已收取快件&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;location&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;time&quot;</span>: <span class="string">&quot;2018-05-09 12:25:03&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;ftime&quot;</span>: <span class="string">&quot;2018-05-09 12:25:03&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;context&quot;</span>: <span class="string">&quot;卖家发货&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;location&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;time&quot;</span>: <span class="string">&quot;2018-05-09 12:22:24&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;ftime&quot;</span>: <span class="string">&quot;2018-05-09 12:22:24&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;context&quot;</span>: <span class="string">&quot;您的订单将由HLA（北京海淀区清河中街店）门店安排发货。&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;location&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;time&quot;</span>: <span class="string">&quot;2018-05-08 21:36:04&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;ftime&quot;</span>: <span class="string">&quot;2018-05-08 21:36:04&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;context&quot;</span>: <span class="string">&quot;商品已经下单&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;location&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;meta&quot;</span>: &#123; <span class="attr">&quot;status&quot;</span>: <span class="number">200</span>, <span class="attr">&quot;message&quot;</span>: <span class="string">&quot;获取物流信息成功！&quot;</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="1-11-数据统计"><a href="#1-11-数据统计" class="headerlink" title="1.11. 数据统计"></a>1.11. 数据统计</h2><h3 id="1-11-1-基于时间统计的折线图"><a href="#1-11-1-基于时间统计的折线图" class="headerlink" title="1.11.1.  基于时间统计的折线图"></a>1.11.1.  基于时间统计的折线图</h3><ul><li><p>请求路径：reports/type/1</p></li><li><p>请求方法：get</p></li><li><p>响应数据</p></li><li><p>需要合并的选项</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">options: &#123;</span><br><span class="line">        title: &#123;</span><br><span class="line">          text: <span class="string">&#x27;用户来源&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        tooltip: &#123;</span><br><span class="line">          trigger: <span class="string">&#x27;axis&#x27;</span>,</span><br><span class="line">          axisPointer: &#123;</span><br><span class="line">            type: <span class="string">&#x27;cross&#x27;</span>,</span><br><span class="line">            label: &#123;</span><br><span class="line">              backgroundColor: <span class="string">&#x27;#E9EEF3&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        grid: &#123;</span><br><span class="line">          left: <span class="string">&#x27;3%&#x27;</span>,</span><br><span class="line">          right: <span class="string">&#x27;4%&#x27;</span>,</span><br><span class="line">          bottom: <span class="string">&#x27;3%&#x27;</span>,</span><br><span class="line">          containLabel: <span class="literal">true</span></span><br><span class="line">        &#125;,</span><br><span class="line">        xAxis: [</span><br><span class="line">          &#123;</span><br><span class="line">            boundaryGap: <span class="literal">false</span></span><br><span class="line">          &#125;</span><br><span class="line">        ],</span><br><span class="line">        yAxis: [</span><br><span class="line">          &#123;</span><br><span class="line">            type: <span class="string">&#x27;value&#x27;</span></span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020 零基础到快速开发  Vue全家桶开发电商管理系统（Element-UI）【目录】</title>
      <link href="posts/34924/"/>
      <url>posts/34924/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>又是一个寒假，曾经一个学霸说过：<code>寒假是用来反超的！</code>，所以这个寒假来和我一起学习Vue把，我会把我做的全部整合在这一个目录当中，算是给自己一个学习记录，也方便读者进行查阅。我的项目其实在1月24日正好过除夕的那天完成了，大约是10天左右的时间，边记录边做项目，后面发现我这个专栏访问量达到了5w，还是有一点人气的，休息三天后，今晚打算来一个总结吧，见证一个从一个不认识Vue是什么的小白到如何快速开发的成长吧~</p><p><font color=red>项目源码我放在码云上保管了,具体地址如下，可进行二次开发:</font><br><a href="https://gitee.com/Chocolate666/vue_shop/tree/master">https://gitee.com/Chocolate666/vue_shop/tree/master</a></p><h2 id="电商后台管理系统的技术选型"><a href="#电商后台管理系统的技术选型" class="headerlink" title="电商后台管理系统的技术选型"></a>电商后台管理系统的技术选型</h2><p>① 前端项目技术栈：</p><ul><li>Vue</li><li>Vue-router</li><li>Element-UI</li><li>Axios</li><li>Echarts</li></ul><p>② 后端项目</p><ul><li>Node.js</li><li>Express</li><li>Jwt</li><li>Mysql</li><li>Sequelize</li></ul><h2 id="快速入门篇"><a href="#快速入门篇" class="headerlink" title="快速入门篇"></a>快速入门篇</h2><blockquote><p>本篇主要是给刚入门Vue的来学习的，里面有一些简单实例，比如记事本，所处城市天气查询，音乐播放配mv等，同时还解决了学习时遇到的问题，学会下面的内容可以算是入门了</p></blockquote><ol><li><a href="https://blog.csdn.net/weixin_42429718/article/details/103952917">2020 零基础 Vue快速入门 Vue基础篇 【详细】</a></li><li><a href="https://blog.csdn.net/weixin_42429718/article/details/103957276">2020 零基础 Vue快速入门 Vue指令 本地应用篇【整理】</a></li><li><a href="https://blog.csdn.net/weixin_42429718/article/details/103964103">2020 零基础 Vue快速入门 教开发一个记事本（激发编程乐趣）【整理+源码】</a></li><li><a href="https://blog.csdn.net/weixin_42429718/article/details/103969483">2020 零基础 Vue快速入门 Vue2.0使用ES6语法的箭头函数=&gt; 对this作用域的理解 【整理】</a></li><li><a href="https://blog.csdn.net/weixin_42429718/article/details/103969923">2020 零基础 Vue快速入门 Vue项目中引入外部css以及js文件的方法 【整理】</a></li><li><a href="https://blog.csdn.net/weixin_42429718/article/details/103967761">2020 零基础 Vue快速入门 网络应用 axios+Vue【整理】</a></li><li><a href="https://blog.csdn.net/weixin_42429718/article/details/103972240">2020 零基础 Vue快速入门 教开发天气查询网页—天知道（激发编程乐趣）【整理+源码】</a></li><li><a href="https://blog.csdn.net/weixin_42429718/article/details/103974082">2020 零基础 Vue综合应用 教开发音乐播放器—悦听（激发编程乐趣）【整理+源码】</a></li></ol><h2 id="电商管理系统开发（百科全书）"><a href="#电商管理系统开发（百科全书）" class="headerlink" title="电商管理系统开发（百科全书）"></a>电商管理系统开发（百科全书）</h2><ol><li><a href="https://blog.csdn.net/weixin_42429718/article/details/103983409">2020 零基础到快速开发 Vue全家桶开发电商管理系统（Element-UI）项目概述篇</a></li><li><a href="https://blog.csdn.net/weixin_42429718/article/details/103983723">2020 零基础到快速开发 Vue全家桶开发电商管理系统（Element-UI）项目初始化篇</a></li><li><a href="https://blog.csdn.net/weixin_42429718/article/details/103990497">2020 零基础到快速开发 Vue全家桶开发电商管理系统（Element-UI）使用码云托管项目篇</a></li><li><a href="https://blog.csdn.net/weixin_42429718/article/details/103995613">2020 零基础到快速开发 Vue全家桶开发电商管理系统（Element-UI）配置MySQL</a></li><li><a href="https://blog.csdn.net/weixin_42429718/article/details/103996682">2020 零基础到快速开发 Vue全家桶开发电商管理系统（Element-UI）登录退出功能实现</a></li><li><a  href="https://blog.csdn.net/weixin_42429718/article/details/104012018">2020 零基础到快速开发 Vue全家桶开发电商管理系统（Element-UI）主页布局开发</a></li><li><a href="https://blog.csdn.net/weixin_42429718/article/details/104018448">2020 零基础到快速开发 Vue全家桶开发电商管理系统（Element-UI）用户列表开发</a></li><li><a href="https://blog.csdn.net/weixin_42429718/article/details/104023786">2020 零基础到快速开发 Vue全家桶开发电商管理系统（Element-UI）【添加用户】</a></li><li><a href="https://blog.csdn.net/weixin_42429718/article/details/104024379">2020 零基础到快速开发 Vue全家桶开发电商管理系统（Element-UI）【修改用户】</a></li><li><a href="https://blog.csdn.net/weixin_42429718/article/details/104031033">2020 零基础到快速开发 Vue全家桶开发电商管理系统（Element-UI）【删除用户】</a> </li><li><a href="https://blog.csdn.net/weixin_42429718/article/details/104031835">2020 零基础到快速开发 Vue全家桶开发电商管理系统（Element-UI）【权限列表】</a></li><li><a href="https://blog.csdn.net/weixin_42429718/article/details/104033075">2020 零基础到快速开发 Vue全家桶开发电商管理系统（Element-UI）【角色列表】</a></li><li><a href="https://blog.csdn.net/weixin_42429718/article/details/104044038">2020 零基础到快速开发 Vue全家桶开发电商管理系统（Element-UI）【分配权限】</a></li><li><a href="https://blog.csdn.net/weixin_42429718/article/details/104044630">2020 零基础到快速开发 Vue全家桶开发电商管理系统（Element-UI）【分配角色】</a></li><li><a href="https://blog.csdn.net/weixin_42429718/article/details/104045709">2020 零基础到快速开发 Vue全家桶开发电商管理系统（Element-UI）商品分类篇</a></li><li><a href="https://blog.csdn.net/weixin_42429718/article/details/104056728">2020 零基础到快速开发 Vue全家桶开发电商管理系统（Element-UI）分类参数篇</a></li><li><a href="https://blog.csdn.net/weixin_42429718/article/details/104063899">2020 零基础到快速开发 Vue全家桶开发电商管理系统（Element-UI）商品列表篇</a></li><li><a href="https://blog.csdn.net/weixin_42429718/article/details/104077321">2020 零基础到快速开发 Vue全家桶开发电商管理系统（Element-UI）订单管理篇</a></li><li><a href="https://blog.csdn.net/weixin_42429718/article/details/104078211">2020 零基础到快速开发 Vue全家桶开发电商管理系统（Element-UI）数据统计篇</a></li><li><a href="https://blog.csdn.net/weixin_42429718/article/details/104079409">2020 Vue零基础 基于Element-UI开发 （全）项目优化与部署上线（npm，基于vue ui） 上篇</a></li><li><a href="https://blog.csdn.net/weixin_42429718/article/details/104079909">2020 Vue零基础 基于Element-UI开发 （全）项目优化与部署上线（npm，基于vue ui） 下篇</a></li></ol><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><hr><p><strong><font color=DeepPink>最后，看完本篇博客后，觉得挺有帮助的话，可以继续查看专栏其它内容嗷，一起来学习Vue吧~</font></strong><br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/2020011511203890.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="点击进入Vue❤学习专栏"><a href="#点击进入Vue❤学习专栏" class="headerlink" title=" 点击进入Vue❤学习专栏~"></a><a href="https://blog.csdn.net/weixin_42429718/category_9656024.html"> 点击进入Vue❤学习专栏~</a></h4>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「秋招清单」2020 秋招前端の投递清单 时间计划汇总</title>
      <link href="posts/20200902/"/>
      <url>posts/20200902/</url>
      
        <content type="html"><![CDATA[<h2 id="秋招投递清单"><a href="#秋招投递清单" class="headerlink" title="秋招投递清单"></a>秋招投递清单</h2><blockquote><p>成功是一个过程，并不是一个结果。</p></blockquote><table><thead><tr><th>投递清单</th><th>时间</th><th>状态</th></tr></thead><tbody><tr><td>触宝内推</td><td>8月9日（周日）</td><td>简历石沉大海</td></tr><tr><td>京东内推</td><td>8月9日（周日）</td><td>已投</td></tr><tr><td>京东笔试</td><td>8月27日（周日）</td><td>做的不好，与字节面试冲突</td></tr><tr><td>网易互娱前端内推</td><td>8月11日（周二）</td><td>简历通过</td></tr><tr><td>网易互娱笔试</td><td>9月11日（周五）晚7点</td><td>通过</td></tr><tr><td>网易互娱笔试</td><td>9月11日（周五）晚7点</td><td>通过</td></tr><tr><td>网易互娱一面-CC直播事业群</td><td>9月23日（周三）下午5点</td><td>时长26分钟 已面</td></tr><tr><td>网易互娱二面-CC直播事业群</td><td>10月13日（周二）上午11点</td><td>时长30分钟 已面</td></tr><tr><td>网易互娱HR面-CC直播事业群</td><td>10月16日（周五）下午2点30</td><td>时长30分钟 等待11月正式offer</td></tr><tr><td>网易校招前端笔试</td><td>9月12日（周六）下午3点</td><td>接受</td></tr><tr><td>哔哩哔哩笔试</td><td>8月13日（周四）</td><td>笔试完后石沉大海</td></tr><tr><td>虎牙直播内推</td><td>8月14日（周日）</td><td>简历石沉大海</td></tr><tr><td>爱奇艺内推</td><td>8月14日（周日）</td><td>简历石沉大海</td></tr><tr><td>腾讯第一轮笔试</td><td>8月23日（周日）晚8点</td><td>做的不好</td></tr><tr><td>腾讯第二轮笔试</td><td>8月23日（周日）晚8点-10点</td><td>未做</td></tr><tr><td>腾讯一面（电话）</td><td>8月28日（周五）早10点30</td><td>继续努力</td></tr><tr><td>字节跳动广告系统商业平台一面</td><td>8月27日（周四）晚8点</td><td>时长1小时26分 通过</td></tr><tr><td>字节跳动广告系统商业平台二面</td><td>9月1日（周二）下午4点</td><td>时长1小时8分  继续努力</td></tr><tr><td>字节跳动-飞书-杭州笔试</td><td>9月20日（周日）晚7点</td><td>接受（结果：AK）</td></tr><tr><td>字节跳动-飞书-杭州一面</td><td>9月29日（周二）下午5点</td><td>继续努力</td></tr><tr><td>阿里-达摩院-机器智能技术部一面</td><td>8月29日（周六）下午3点</td><td>时长30分 继续努力</td></tr><tr><td>滴滴笔试</td><td>8月21日（周五）晚7点</td><td>通过</td></tr><tr><td>滴滴-橙心优选一面</td><td>9月5日（周六）下午1点</td><td>通过</td></tr><tr><td>滴滴-橙心优选二面</td><td>9月5日（周六）下午2点</td><td>通过</td></tr><tr><td>滴滴-橙心优选三面</td><td>9月5日（周六）下午3点</td><td>继续努力</td></tr><tr><td>米哈游内推</td><td>8月25日（周二）</td><td>简历通过</td></tr><tr><td>米哈游笔试</td><td>9月19日（周六）晚8点</td><td>接受</td></tr><tr><td>百度</td><td>8月25日（周二）</td><td>已投</td></tr><tr><td>百度笔试</td><td>9月3日（周四）晚7点-9点</td><td>接受</td></tr><tr><td>快手内推</td><td>8月25日（周二）</td><td>简历通过</td></tr><tr><td>快手一面</td><td>9月10日（周四）上午11点</td><td>时长1小时 待确认</td></tr><tr><td>拼多多笔试</td><td>9月1日（周二）晚7点-8点半</td><td>待确认</td></tr><tr><td>小米集团</td><td>9月11日（周五）</td><td>网申投递</td></tr><tr><td>小米集团笔试</td><td>9月15日（周二）晚7点</td><td>接受</td></tr><tr><td>老虎集团</td><td>9月12日（周六）</td><td>网申投递</td></tr><tr><td>吉比特</td><td>9月12日（周六）</td><td>简历通过</td></tr><tr><td>吉比特笔试</td><td>9月23日（周三）</td><td>时间待确认</td></tr><tr><td>吉比特笔试</td><td>9月25日（周五）晚8点30</td><td>接受</td></tr><tr><td>搜狗-网页搜索</td><td>9月12日（周六）</td><td>网申投递</td></tr><tr><td>搜狗-商业平台</td><td>9月12日（周六）</td><td>网申投递</td></tr><tr><td>搜狗笔试</td><td>9月25日（周五）晚7点</td><td>接受</td></tr><tr><td>好未来</td><td>9月12日（周六）</td><td>网申投递</td></tr><tr><td>好未来笔试</td><td>9月20日（周日）下午1点30</td><td>接受</td></tr><tr><td>同花顺</td><td>9月12日（周六）</td><td>内推投递</td></tr><tr><td>同花顺笔试</td><td>9月18日（周五）晚7点</td><td>接受</td></tr><tr><td>美团-到家事业群</td><td>9月22日（周二）</td><td>内推投递</td></tr><tr><td>平安科技内推</td><td>9月24日（周四）</td><td>内推投递</td></tr><tr><td>杭州有赞内推</td><td>9月24日（周四）</td><td>内推投递</td></tr><tr><td>有赞科技笔试</td><td>10月11日（周四）晚7点</td><td>接受</td></tr><tr><td>美团笔试</td><td>9月27日（周日）上午10点</td><td>接受</td></tr><tr><td>涂鸦智能</td><td>10月9日（周五）</td><td>内推投递</td></tr><tr><td>陌陌MoMo</td><td>10月9日（周五）</td><td>内推投递</td></tr><tr><td>阅文集团前端笔试</td><td>10月21日（周三）晚7点-8点半</td><td>未做</td></tr><tr><td>美团点评-两轮车部门一面</td><td>10月23日（周五）下午3点</td><td>通过</td></tr><tr><td>美团点评-两轮车部门二面</td><td>10月23日（周五）下午6点</td><td>通过</td></tr><tr><td>美团点评-两轮车部门HR面</td><td>时间待确认</td><td>状态待确认</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 面试整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 秋招 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「不进则退」2020 Chocolate 同学秋招前端の大厂面经&amp;心路历程&amp;个人经验分享</title>
      <link href="posts/20201024/"/>
      <url>posts/20201024/</url>
      
        <content type="html"><![CDATA[<h2 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h2><p>本人双非本科，目前大四在读，JS，TS，LeetCode，Vue，React，算法爱好者。 座右铭：学如逆水行舟，不进则退！在今年7月份在某电子公司实习过，有过一段前端开发实习经历，8月份正式踏入秋招的征途，投递了许许多多的公司，面试过腾讯、字节、滴滴、美团、快手、网易、阿里等公司，也面过一些中小型公司，整个过程也是坎坷，在此简述一下秋招结果：</p><ul><li>腾讯多次倒在一面</li><li>字节跳动跳到二面截止</li><li>滴滴三连面，倒在最后一面</li><li>快手倒在一面</li><li>网易互娱流程走完，等待OC</li><li>美团技术面走完，等待HR面</li></ul><blockquote><p>我们的征途是星辰大海！</p></blockquote><h2 id="阅读须知"><a href="#阅读须知" class="headerlink" title="阅读须知"></a>阅读须知</h2><p>从10月23日结束了美团技术面后，我也宣布自己秋招彻底结束了，推掉了其它公司相关的笔试面试邀请，给自己放了一个周末假期，我想我也应该给自己一点时间放松一下，去洋湖走了一遍，新兴的洋湖水街还挺不错的~</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20201026230058782.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70#pic_center" alt=""></p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20201026230045201.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70#pic_center" alt=""></p><p>原本呢我是没打算写下这篇文章的，一方面整个秋招下来我有了一点疲惫，在结束的那一刻，我瞬间感觉压力少了很多，终于能结束秋招了；另一方面，人都是有一定惰性的，休息了一段时间，状态方面也没调整过来，那么这篇总结性文章就一直鸽着。</p><p>其次，整个秋招可谓是一言难尽，正如一句话：<code>&quot;一个人就是一支军队&quot;</code>。在秋招征途中，几乎每天都是笔试面试这样的安排，面完之后复盘总结，查漏补缺，输出博客。</p><blockquote><p>成功是一个过程，并不是一个结果。</p></blockquote><p>既然我决定要写下这篇文章，那么这篇文章定属 <strong>精华</strong>，用这一篇文章来好好总结一下秋招之路。</p><p>在此，我想对阅读这篇博客的你说几句话：</p><p>首先，我会把我自己的大厂面试经验分享给大家，但是由于技术水平与个人经历的区别，可能这些面经对你没有太多帮助，也不敢保证你通过我的面经问题就能获得成功，我能做的就是保证它的完整性和真实性。</p><p>其次，我想和各位备战秋招的同志们说说我对于秋招的一些看法，以及我的面试经验。并且希望你能有一定的耐心能够看完本篇博客，我会尽量控制文章内容篇幅，给你一个不错的阅读体验，希望能够对你有所启发和感悟。</p><p>然后，我希望各位读者能够 <code>海纳百川，有容乃大</code>，对于本篇博客中表述不太准确的地方读者们可以提出指正，也是学习和接纳的机会~</p><p>最后，本文主体内容更多的会与前端学习挂钩，但并不代表其它岗位没有参考价值，下文会包含对于面试经验，春秋招时间安排等等干货内容。</p><h2 id="一言难尽の秋招"><a href="#一言难尽の秋招" class="headerlink" title="一言难尽の秋招"></a>一言难尽の秋招</h2><p>我想，备战秋招的伙伴们应该感同身受，确实是一言难尽，秋招不仅是比学习能力，更是比体力和心态，这些都是成功之前不可或缺的部分。我仅仅用两样东西来总结一下秋招我做了啥：</p><p>1、从实习那段时间开始，我就一直折腾着 github，从下图中提交记录应该就能明白整个秋招备战之路了，通过笔试面试，也是一个查漏补缺的过程，我将遇到的一些问题，进行了复盘总结，然后整合到这个笔记仓库里面 <a href="https://github.com/Chocolate1999/Front-end-learning-to-organize-notes">小狮子前端の学习整理笔记</a> ，<strong>一图胜千言</strong>（已获200+ star，如若您觉得不错，也可以 star 收藏支持一下）</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20201026143339128.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70#pic_center" alt=""><br><a href="https://github.com/Chocolate1999">ChocolateのGithub仓库传送门（欢迎 Follow）</a></p><p>2、有的时候，没有备忘录这个东西，我都不知道自己有投递过多少数目的公司，参加过多少次笔试面试，因此，在这个时间段里，我给自己列了一份秋招清单，好让自己随时更新秋招进度，也比较建议小伙伴们这样做，一份清单一目了然，也能随时知道自己的进度，省去官网一个一个查。</p><p><a href="https://yangchaoyi.vip/posts/20200902/">「秋招清单」2020 秋招前端の投递清单 时间计划汇总</a></p><h2 id="Chocolate-同学の面经"><a href="#Chocolate-同学の面经" class="headerlink" title="Chocolate 同学の面经"></a>Chocolate 同学の面经</h2><p>由于篇幅所限，这里我就不逐一在这篇文章整理表述了，小伙伴们可以按需查阅，下面都是我面试过程中遇到的一些问题，但中间多少都掺杂了一些个人的一些表现以及和面试官的互动，另外，对于大厂面试官，都比较喜欢从一个点切入往深了问，并且从下列文章中，我也有写对于面试整个过程的体验，我个人比较喜欢有引导性的面试。</p><p>我觉得面试嘛，是一个双向选择的过程，面试也是要与面试官有一些互动，而不是单纯你问我答，答不出来直接拒掉的结果，这样与做一套试卷有啥区别呢？同时，我也有询问过字节跳动飞书的面试官，我询问：字节跳动对于校招生的一些要求，希望招一个怎样的校招生？</p><blockquote><p>面试官答复说：简单来说，我们招优秀的人，我们更加考察地是面试者的综合能力，比如沟通表达能力，强有力的学习能力等等。</p></blockquote><p>简而言之，面试是一场综合能力的考察，而非你问我答做试卷的形式。在此不得不说字节跳动的面试体验是非常不错的，面试官对于你不太清楚的问题，都会有一个引导，我当时在面试的时候遇到遗忘的地方，通过面试官的引导，自然也回答了出来。</p><ul><li><a href="https://yangchaoyi.vip/posts/20209023/">「字节跳动-广告系统」秋招面试复盘总结</a></li><li><a href="https://yangchaoyi.vip/posts/20209021"/>「腾讯-QQ音乐」秋招面试复盘总结</a></li><li><a href="https://yangchaoyi.vip/posts/20209022/">「阿里智能事业群-达摩院-机器智能技术部」秋招面试复盘总结</a></li><li><a href="https://yangchaoyi.vip/posts/2020906/">「滴滴-橙心优选」秋招面试复盘总结</a></li><li><a href="https://yangchaoyi.vip/posts/2020910/">「快手-效率工程」秋招面试复盘总结</a></li><li><a href="https://yangchaoyi.vip/posts/2020923/">「网易互娱-CC直播事业群」秋招面试复盘总结【已走完流程】</a></li><li><a href="https://yangchaoyi.vip/posts/20209029/">「字节跳动-飞书」秋招面试复盘总结</a></li><li><a href="https://yangchaoyi.vip/posts/20201023/">「美团-两轮车部门」秋招面试复盘总结</a></li></ul><hr/><p>接下来，将是满满的干货正文了，诚意满满，大家可以根据目录选择阅读~</p><h2 id="面试整体流程"><a href="#面试整体流程" class="headerlink" title="面试整体流程"></a>面试整体流程</h2><p>在介绍春招和秋招之前，我有必要和小伙伴们说一下整个面试流程，让大家清晰地认识面试。</p><p>春招和秋招的整体流程基本差不多，我只做简单介绍，比如有哪些投递网站，怎么投递这些我就不再赘述了，网上一搜就是一片。实在不行的话，你也可以评论区留言，我会为你解答，大致流程如下：</p><p><strong>（1）投递简历</strong></p><p>一般情况下以官网投递为主，找内推，能早一点投尽量早一点投，最好是参与提前批。</p><p><strong>（2）内推</strong></p><p>对于参与校招来说的话，我个人觉得有没有内推区别是不大的，你投递的时候填了内推码，并不会对于你的笔试和面试有很大帮助，既然这样，是不是不用这个内推码了，这个我觉得的话，既然大家都有填写内推码，还是可以并且必要填一下的。比如在牛客网上找了内推码，就可以询问自己的面试流程，查看简历状态等。</p><p>因此，不要认为有人给你内推了，校招面试或笔试流程就有很大优势了，据说是参与内推的话，HR会有一个强提醒，一周之内必须查阅你的简历，这样就能更快筛选到你的简历，好给你发笔试或者面试邀请。故我推荐大家投递时最好是找相关师兄/师姐或者学长学姐来内推一下，尽管好处和优势不是很大，至少没啥坏处是吧。</p><p><strong>（3）提前批</strong></p><p>对于大厂来说，都会有提前批。在此说说提前批的好处：如果准备充足的话，提前批正如字面意思，你会比同一批校招的人更早拿到 offer ，提前拿到 offer 结束春/秋招难道不香么？</p><p>其次，提前批投递了，相当于多了一次机会，一般来说，提前批面试就算没有通过，你还有一次正式批的面试机会，比没有参与提前批的同学多了一次机会。</p><p>然后，提前批往往都不会有笔试，因此，面试难度会相对高一点，但是对于准备充足的大佬来说，都一样。而往往大厂笔试都会刷掉好大一部分校招生，提前批没有笔试直通面试难道不香么？</p><h2 id="备战春招（时间-目的）"><a href="#备战春招（时间-目的）" class="headerlink" title="备战春招（时间 + 目的）"></a>备战春招（时间 + 目的）</h2><p>每年春招开始的大致时间是：每年3月份到5月份，投递时间越早越吃香（前提是准备充足）</p><p><strong>目的</strong></p><p><strong>（1）实习的机会</strong></p><p>对于大三/研二的同学来说，春招就是一次很好的找实习的机会，一般学校在这个时间段都是允许同学们外出实习的，这个实习经历也是非常重要的：</p><ul><li>大三/研二同学有了实习机会，对于不错的公司，可以秋招的时候直接转正，那么就无需备战秋招了，就不必担忧自己工作问题。</li><li>对于大三/研二同学，当你拿到了大厂实习offer，一般情况下，公司不会要求你很早的就去报到，多数以暑假那段时间为主，并且一般大三结束了，大四很少有课程，可以实习好几个月的时间。</li><li>对于大三/研二同学，就算没有转正机会，但是这一份实习经历，一定会在秋招帮助你，为你的秋招保驾护航。</li><li>对于大三/研二同学，你可以获得面试经历，增长见识。</li></ul><p>因此，对于大三/研二同学，我建议不管能不能拿到这一份实习 offer ，你都要去参加一次春招，这对于你找工作很有帮助！</p><p><strong>（2）毕业生的最后一次机会</strong></p><p>对于大四/研三的同学来说，春招可能就是最后一次机会了，因为并不是所有人秋招都能得到满意的工作，各种因素情况发生都有可能，那么春招就显得格外重要了，但是春招岗位相对于秋招就少了很多了，毕竟你已经错过了一次机会了。</p><p>可是，反过来说，大佬已经在秋招都确定好自己的去向了，因此也不会在春招与你竞争了，那么对于准备好的你来说，找到一份不错的工作机会还是挺大的。</p><p><strong>额外补充</strong></p><p>春招时间段，大家都习惯称 <code>金三银四铜五</code>，那么如果你准备充足，3月份就是<strong>黄金时期</strong>，可不要等到5月份了才开始投递简历，那时基本上都是捡漏了。</p><h2 id="备战秋招（时间-目的）"><a href="#备战秋招（时间-目的）" class="headerlink" title="备战秋招（时间 + 目的）"></a>备战秋招（时间 + 目的）</h2><p>每年秋招开始的大致时间是：每年8月份到10月份，投递时间越早越吃香（前提是准备充足）</p><p><strong>目的</strong></p><p><strong>（1）毕业生的黄金时间</strong></p><p>对于准大四/研三的同学来说，秋招无非是黄金时期，这个时候就不是拿实习 offer 了，而是找工作的 <strong>正式 offer</strong>，这个可千万不能错过，而且也是能够提前批拿到的话是再好不过了。</p><p><strong>（2）还在实习怎么办</strong></p><p>可能在春招的时候会有一批校招生拿到了实习 offer，7~8月份可能还在实习，但其实影响不是很大，一般公司对于实习生的话，不会要求加班，而且校招的笔试多半会选择周末晚上7点-9点。面试的话一般都是可以沟通的，因此，完全有时间参加的，只是需要调整一下时间。</p><p>不过，当前实习的公司本来就是大厂或者自己还算满意，并且感觉自己转正概率比较大的话，推荐好好准备转正答辩相关的工作，如果转正成功，就不必踏入秋招的征途了，轻松很多，工资也拿了，工作也顺利得到了，岂不美哉。</p><h2 id="一份优秀的简历"><a href="#一份优秀的简历" class="headerlink" title="一份优秀的简历"></a>一份优秀的简历</h2><p>在你投递之前，一份优秀的简历能够让你通过HR筛选，直达笔试/面试。而对于如何书写一份简历这一块，本文是不会教你怎样写一份简历，不会定下你的简历应该是怎样的，因为每个人经历和信息都有区别，并且每个人的简历风格也会不一样，因此，本文就不赘述一份简历应该写哪些模块。</p><p>在这里我想要说的是，一份简历不是自己觉得怎样就怎样，这份简历是要给面试官和HR看的哇，太过花里胡哨肯定是不行的。另外，简历上面要体现一下重点，比如你的 <strong>专业技能</strong> 模块，对于你比较熟悉的部分，你可以进行加粗一下，引导面试官去看，让这场面试一小部分时间是由你来主导，而非你问我答的形式。</p><p>其次，有的同学可能觉得自己在校做的项目与自己岗位不相关，然后就没有写上，最后项目经历那一块空很多，整个简历一页都不够，看起来很空。这显然也是不行的，如果这个项目很有价值，比如获得了服务外包奖项，省级奖项，那么是很有必要写上去的，反过来想一想，如果不写的话，那么这份奖项岂不是很廉价，关键是自己付出过的。</p><p>我们动用逆向思维想一想，面试官难道真的很在意你的项目经历嘛，就我个人而言，整个秋招过程中，很少有面试官对于一个项目问题问的特别深，往往都是从这个项目挖掘一点基础知识来提问，比如经典的<strong>登录那一块你怎么实现的</strong>，<strong>跨域通信项目怎么做的</strong>，介绍你在这个项目中遇到了什么问题，怎么解决的？如果是一个团队项目，可能会问你在团队中你的<strong>角色定位</strong>等等一系列问题。</p><p>其实，站在面试官的角度来看的话，对于校招生的在校项目都是比较简单的，往往都是通过学习跟着视频做的，而对于团队型项目，尤其是获奖过的项目，面试官是比较感兴趣的，他们会询问你的角色定位，团队是如何分工协作的等等，具体问题牛客面经很多，读者可以详细查阅。</p><blockquote><p>当然，项目经历丰富的大佬可以完全忽视下述文字。</p></blockquote><p>在这里，我想说的是既然这个项目你获奖了，就很能体现出团队的合作能力，而对于团队中的你来说，足以证明自己的团队合作以及学习能力了，在上文我提到过了，校招招怎样的校招生呢？没错，<strong>综合能力优秀</strong>的人。虽然这个项目可能与我做的岗位不太匹配，比如我做前端的，但是这个项目又是用基于<code>IOS</code> 开发的，那是不是我就放弃这个让我获奖的项目经历不写呢？</p><p>答案是否定的，既然技术不匹配，那我们动用逆向思维，反之通过我们的个人表达能力，向面试官展示我对于这个项目的熟练，通过例举我在团队中做了什么，我又为了团队付出了什么，调查了哪些文献等等来体现自己的 <strong>学习能力和团队协作能力</strong>。因为作为程序员来说，我们没办法脱离一个团队干事，而一个项目的成功少不了一个团队的合作能力，面试官也当然想招一个好融入团队的面试者。</p><h2 id="数据结构与算法真的很难吗"><a href="#数据结构与算法真的很难吗" class="headerlink" title="数据结构与算法真的很难吗"></a>数据结构与算法真的很难吗</h2><p>相对于后端来说，前端的算法考察说真的没有那么高要求，就我整个秋招面试经历来看，更多的还是笔试的时候做做算法题，当然，如果笔试没有通过，何来面试之言？</p><p>对于前端，我在笔试的时候很少有遇到特别难的题目，我感觉都还算比较常规，大多数都是基于 <code>leetcode</code> 上面的题目改编的，有时候直接搬过来的原题。而在我的面经中几乎没有提到笔试题目是哪些，一方面，笔试的时候时间是有限的，给定的时间一般来说与题目难度相关，所以很少有时间整理习题。另一方面，笔试题目最好不要公开，这与公司题库挂钩。</p><p>而在面试过程中，比如某跳动公司特别爱考察算法，我遇到的也是经典的 <code>最大子段和</code>，然后更多的还是考察对于 <code>js</code> 能力，比如让你手撕 <code>深拷贝</code>，手写 <code>ES5继承</code>，还有就是一些业务相关的问题了，都是基于 <code>js</code> 能力，但这些都需要<strong>扎实的算法基础</strong>。而对于滴滴面试，考察的算法也不过是经典的排序算法，这些难道很难吗？</p><p>可能大多数人觉得算法太难了，我觉得我不应该挂在大厂的笔试上面，我宁愿输在面试流程中。但我要说的是，<strong>没有算法是万万不能的！</strong></p><p>可能有些小伙伴会提出：<code>面试造火箭，工作拧螺丝</code>，学习算法就是为了应对面试，这一点我并不完全否认。但是我想说的是，如果你一直是一个拧螺丝的程序员，比如让你在页面写一个 <code>Button</code>，绘制一个表格，刚入职的前端就能完成，甚至有些后端同学也能包教包会，或者还有人会说我会了 <code>Vue</code>，我会了 <code>React</code>，我就是初级以上开发工程师了，这也是不对的。</p><p>我觉得 <code>Vue</code> 或者 <code>React</code> 只是一个工具而已，正如它们介绍而言，用于构建用户界面的 <code>JavaScript</code> 库，并不是你会了你就真正很牛了，比如说 <code>React</code>，你觉得状态需要管理，你可能需要了解 <code>Redux</code>，你觉得需要路由功能，你可能需要了解 <code>React-Router</code>，你觉得需要维护单向数据流，你可能需要了解 <code>Immutable 数据流</code>，对于函数式编程，你可能还需要了解 <code>React Hooks</code>，而对于性能优化方面，你可能还需要了解 <code>React Fiber</code> 等等一系列拓展知识。到此，你觉得还符合一名初级工程师吗？</p><p>而真正体现自己能力所在的还是 <code>js</code> 能力，回到算法本身，对于业务中比较复杂的部分，一个优秀的程序员，会结合算法来进行优化。此外，如果你完全没有接触 <code>深度优先遍历</code> ，<code>树形结构</code>，<code>递归</code>等概念，没有看过相应代码，那么，你将很难理解<code>虚拟 DOM</code> ，<code>数据劫持</code>等相关 <code>Vue</code> 源码，为啥我们要学习源码呢？学习源码的目标是学习其中的设计思路，在工作业务中就可利用这些思路编写我们的项目。</p><p>算法的重要性我就不再赘述了，下面我将分享一下我对于算法这一块做的准备：</p><h3 id="系统的练习"><a href="#系统的练习" class="headerlink" title="系统的练习"></a>系统的练习</h3><p>想必了解的同学一定知道做算法题得要系统的刷题，如果你是按着 <code>leetcode</code> 一题一题来刷的话，往往会花费很长的周期去准备算法，并且题目联系不够大，经常性刷完这道，之前刷的几道题解法就忘记了。因此，系统的练习就显得格外重要了。</p><p>以我自己为例，我参考了大佬的刷题路线，然后自己建了一个仓库，来提交自己的解题思路，记载自己刷题的过程，然后将自己做过的图通过 <code>label</code> 进行分类，然后做一份思维导图，如下：</p><p>传送门：<a href="https://github.com/Chocolate1999/leetcode-javascript">https://github.com/Chocolate1999/leetcode-javascript</a></p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/img_convert/77299a6a0651c7942af18b564e9edc04.png" alt=""><br>从上述脑图来看，我并没有像一些大佬一样，动不动就是好几百道题，应对面试的话，我觉得自己刷的题已经足够了，对于前端来说的话，算法题我觉得还是相对容易一点的。况且自己也有一段 <code>acm</code> 经历，所以我觉得没必要为了刷题而刷题，题不在多。</p><p>如果你没有刷题路线，或者需要一套前端刷题路线，你可以跟着我创建的这个 <code>github</code> 仓库路线刷题，本仓库将全程使用的语言是 <code>JavaScript</code>，是一个纯前端刷题路线，对于前端刷题没有方向的小伙伴简直是福音。解题代码会记录在本仓库的 <code>Issues</code> 中，会按照 <code>label</code> 进行分类。比如想查看 「递归与回溯」 分类下的问题，那么选择标签进行筛选即可。</p><blockquote><p>Give a ⭐️ if this project helped you !</p></blockquote><h3 id="推荐学习"><a href="#推荐学习" class="headerlink" title="推荐学习"></a>推荐学习</h3><ul><li><a href="https://juejin.im/post/6844904061947346957">(1.8w字)负重前行，前端工程师如何系统练习数据结构和算法？【上】</a></li><li><a href="https://juejin.im/post/6844903919722692621">前端该如何准备数据结构和算法？</a></li></ul><h2 id="一份提升技术世界观的文章"><a href="#一份提升技术世界观的文章" class="headerlink" title="一份提升技术世界观的文章"></a>一份提升技术世界观的文章</h2><p>在整个秋招过程中，我有迷茫过，每当面试之前，我处于一种紧张状态，尤其是面试前一天，我会担心这也记不住那也记不住，我不知道阅读在这里的你是否有相同的感受。而通过好几次失败的面试后，大概在9月份下旬的时候，我看了几篇文章，不再是关于前端基础知识那些，而是《CSS世界》一书的作者 <code>张鑫旭</code>的文章：</p><ul><li><a href="https://juejin.im/post/6844903694597619726">有容乃大的技术世界观</a></li><li><a href="https://juejin.im/post/6844903689010806798">校招面试心得看得再多也没用</a></li><li><a href="https://juejin.im/post/6844903743553536014">坚定你选择的前端技术方向</a></li></ul><p>我比较推荐大家阅读一下，我想能够放下自己浮躁的心态，我比较理解在秋招过程中屡战屡败的堕落感，人之常情，自己努力了很久，看不到前进的希望时确实很容易浮躁起来，而我很庆幸自己调整了过来，我做了这样的转变：</p><p>首先，在9月下旬几场面试下，我发现我有了一点浮躁，连笔试都做的不太顺手了，有的时候一天要连续做两场笔试，第一场做完了，几乎没有余力去做下一场，基本上两场中选择一场，这也导致我后面收到面试的机会也少了一些。</p><p>其次，几场面试下来，我复盘总结的时候，发现相同的问题我还是不知道如何最优的去回答，而是每次面试前疯狂抢记知识点，我发现这一点用处也没有，就这样持续了2周左右，总结下来啥也没做，没得到任何增长，反而多了一点浮躁，面试通过的概率也变的越来越低。</p><p>好在自己每隔一段时间会有一个复盘，回想这两周来，我确实做的不太行，我想我应该先放下这面对面试的沉重包袱，扎实的学习，而非靠着面经背题这样，这样对我面试一点帮助也没有，我能进这家公司应该是我本身能力具备，实力够强，就像上述提到文章里面说到的：<code>BAT这样的厂子，你就算挤破头也是进不去的，如果你能进去，与所谓面试技巧关系并不大，而是你本身够硬，所谓面试技巧的作用就像是公主头上多插了根羽毛，锦上添花而已。</code></p><h3 id="双节期间，我做了什么"><a href="#双节期间，我做了什么" class="headerlink" title="双节期间，我做了什么"></a>双节期间，我做了什么</h3><p>到了国庆那段时间，我提前调整了自己的状态，我不再刷着面经了，我觉得我也不需要所谓的面经了，我放下自己的包袱沉下来专研知识点，每天坚持按照自己的专题刷 <code>leetcode</code>。</p><p>在此，也感谢有情怀的小野老师的视频，很多知识点都是跟着他学习的，在国庆期间从老师那里学习了很多，跟着学习了Vue相关源码。</p><ul><li><a href="https://www.bilibili.com/video/BV1ga4y1a7Ca">你的人生不应该只有技术 - 献给『前端开发』的前行者</a></li></ul><p>另外，在国庆期间，我也系统学习了 <code>React</code>，从 <code>React16版基础</code>到学习 <code>Redux</code>，然后再学习 <code>React Router</code>，最后学习了 <code>React Hooks</code>，基本上按照学习路线来，从一个最简单的 <code>todoList</code>到以 <code>todoList</code> 结束，顺畅无比。</p><ul><li><a href="https://space.bilibili.com/165659472/">技术胖老师の个人空间</a></li><li><a href="https://jspang.com/detailed?id=56">React学习路线-按此路线学习顺畅无比</a></li></ul><h3 id="双节过后，我的感受"><a href="#双节过后，我的感受" class="headerlink" title="双节过后，我的感受"></a>双节过后，我的感受</h3><p>短短几周时间，我感觉不论是我的技术世界观，还是基础知识我都感觉比前一个月好了很多，对于面试，我发现我已经能够从容面对，不再是面试前抢记一下，然后结束面试后焦虑自己的结果。</p><p>而在之前，我也有幸阅读到了一篇文章，至于出处我不知道在哪了，但文章大致内容如下：</p><blockquote><p>秋招得要坚持下来，8月份如果没有成功，那就9月份稳扎稳打坚持下去，如果9月份没有成功，那就冲击10月份，坚持下去，会有机遇的。秋招还没有结束！</p></blockquote><p>是的，有的时候是我们给自己定了一个结束时间，我不知道阅读到这里的你会不会和原来的我一样，认为9月份就是倒计时，9月份过去了，那么宣布秋招结束了。现在的我就不会这么想了，我们要做的是坚持下去，隔绝外界干扰的声音，就算别人提早拿到了 offer ，我们不能因为这个而焦虑，找工作是自己的事情，我们可以晚一点，但不能心急。秋招的结束一方面是时间上确实结束了，另一方面是我们备战心态发生了变化导致的结束。<code>我们要做的是稳扎稳打，坚持下来，就算到10月份还是有机会的，机遇永远是给有准备的人！</code></p><p>就我而言，10月份简直就是一个大变化，9月份屡战屡败，10月份双节过后，我很幸运地收到了网易互娱的二面邀请，而在二面过后两天后，又收到了HR面试邀请。而后又几天，我又被美团捞起来了，一天连续两轮技术面，面试官的评价都还不错，这也许就是<code>越努力越幸运</code>。而在10月份我的面试体验也是越来越好，我变得更加自信了，我能很好的和面试官交流，也和面试官一起探讨工作中业务和技术的取舍等问题。我觉得这就是秋招带来的蜕变，褪去了我的焦虑。</p><h2 id="个人经验分享"><a href="#个人经验分享" class="headerlink" title="个人经验分享"></a>个人经验分享</h2><p>我希望阅读到这里的你能够 <code>海纳百川有容乃大</code>，就像上述<a href="https://juejin.im/post/6844903694597619726">有容乃大的技术世界观</a>文章里面提到的：</p><blockquote><p>“任何能够自圆其说的理论都能称为科学！”</p></blockquote><p>比方说中医理论，比方说阴阳理论，如果这些理论能够自圆其说，我们就可以认为其是科学。估计有人会对上面的话表示嗤之以鼻，中医也算科学真TM见鬼了！请记住本文的“有容乃大”！我们其实不必执着于字面的意思，这句话其实是引导我们从不一样的角度，用不一样的方式看待问题。不能拘泥于自己原本狭隘的世界观认知中，跳出来看待，用更为哲学的眼光看待，你对世界的认识则会更加的丰满。</p><p>每个人的内心世界都是不同的，对待事物的看法也不一样，所以我们就不能强行按照自己的技术世界观去随意批判他人，而应该用更包容的态度，去看待他人的理解，说不定可以从中得到很多启示，获得不少灵感。</p><p>在此，我将自述我学习前端的一些心路历程，而我作为此次校招生而言，许多地方也是不够成熟的，我觉得一直不够那个资格去分享自己学习前端的方式，而现在通过一轮又一轮面试的检验，我觉得也应该总结一下了，给自己一个对秋招的回顾，关于学习的文章以及准备方法上文我基本上有提及到了，因此，在下文就不赘述了。</p><h3 id="个人经历"><a href="#个人经历" class="headerlink" title="个人经历"></a>个人经历</h3><p>大学期间，大二参与了 <code>acm</code>，从那个时候喜欢上了写博客，渐渐地养成了一个写博客习惯，我感觉我的春招找实习，秋招找工作，这份经历给了我很大帮助，大多数公司招聘信息或多或少的提及：<code>有优秀博客或github的优先</code>，这两方面我觉得我还是坚持下来了，也收获了它们给我带来的好处。</p><p>而我们学校很少有前端相关课程，从大二就开始学习 <code>java</code>，大三学习了javaee，但通过学习，我发现我对于 java 并不是很感兴趣，而我真正确定我自己未来职业方向还是在大三的课程项目上，是 <code>javaee+软件工程</code>两门课程期末设计项目，那个时候开始接触了前端框架 <code>Vue</code>，更多的了解了 <code>nodejs</code>这一块，我发现，这才是我想折腾的，于是就在今年3月份的时候，我开始了自学前端之路。</p><p>可能大部分人，在校期间或多或少的参与了一些项目设计大赛，获得过了一些奖项，但是我没有，我大二/大三期间参与 <code>acm</code> 相关竞赛，尽管没有取得比较优秀的成绩，但是这对我后续笔试方面省了不少时间，我不需要花费很长的时间在算法这一块，我只需要系统的练习一下，从 <code>C++</code> 语法转到 <code>js</code> 语法即可，所以对于算法这一块来说我准备的时间不是很长，还是那一段刷题时光带来的结果，对于字节跳动校招笔试，我有一次全A，自然也就收获了面试邀请。</p><p>上文提到过，我没有相关项目比赛，那么简单来说就是我的项目经验不足，这对于找工作来说优势就少了很多，于是我就从<code>黑马</code>那里学习跟着做了一个 <a href="https://github.com/Chocolate1999/vue-shop">Vue电商管理系统</a>，为了巩固自己<code>Vue</code> 技术栈，这个项目我还做了两遍。为了拓展自己的技术栈，我又做了一个 <code>Vue+SSR+Koa2开发仿美团网</code>的<a href="https://github.com/Chocolate1999/Vue-family-bucket-SSR-Koa2-full-stack-development-from-Meituan">项目</a>，为此我还做了一个<a href="https://www.bilibili.com/video/BV1gp4y1y7VY">视频介绍</a>。</p><p>然后到了春招阶段，我积极投递简历，整个春招几乎屡战屡败，直到6月份，拿到了某电子公司的实习 offer，为此，我写下了我对于春招的一份总结 ，其中包含了我在春招查阅的相关资料，以及一些个人感想，可能当时想法不太成熟，还望读者 <code>海纳百川有容乃大</code>。</p><p><a href="https://yangchaoyi.vip/posts/520521/">【春招&amp;实习】前端学习の优质资料整理&amp;心路历程</a></p><p>实习过后，我还没有总结这段实习带来的体会，这个后续我会补充回来。接下来，返校后，就是我对于秋招的征途了，然后就带来了这篇文章。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后，祝愿阅读到这里的你，在秋招之路能够顺利拿到满意的 offer，还处在大一大二的同学们，尽早确定自己的方向，不论是考研还是找工作，保持初心，坚持下去！</p><p>文章产出不易，还望各位小伙伴们支持一波！</p><p>往期精选：</p><p><a href="https://github.com/Chocolate1999/Front-end-learning-to-organize-notes">小狮子前端の笔记仓库</a></p><p><a href="https://github.com/Chocolate1999/leetcode-javascript">leetcode-javascript：LeetCode 力扣的 JavaScript 解题仓库，前端刷题路线（思维导图）</a></p><p>小伙伴们可以在Issues中提交自己的解题代码，🤝 欢迎Contributing，可打卡刷题，Give a ⭐️ if this project helped you!</p><p><a href="https://yangchaoyi.vip/">访问超逸の博客</a>，方便小伙伴阅读玩耍~</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/2020090211491121.png#pic_center" alt=""></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">学如逆水行舟，不进则退</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 秋招 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「查漏补缺」2020 秋招前端の面试记录&amp;心路历程（整理）</title>
      <link href="posts/20200812/"/>
      <url>posts/20200812/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文会记录我秋招过程中一些面试经验和感受，大部分问题是没有答案的，但是可以在我博客页面进行翻阅，对应公司面经都有解答。感谢您的阅读~</p></blockquote><blockquote><p>没有比脚更远的路，没有比人更高的山！</p></blockquote><h2 id="字节跳动-广告系统-商业平台"><a href="#字节跳动-广告系统-商业平台" class="headerlink" title="字节跳动-广告系统-商业平台"></a>字节跳动-广告系统-商业平台</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>春招那会面了一次字节，看我往期博客就造了，那时候一面就凉了，但秋招提前批的时候，也是在恒生那边实习的时候，北京HR打电话过来约面试，于是约到了8月27日晚上。</p><h3 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h3><h4 id="面经"><a href="#面经" class="headerlink" title="面经"></a>面经</h4><p> 1、自我介绍</p><p> 2、手撕防抖（如果滚动条判断一个div是否存在会用什么来做？节流）</p><p> 3、CSS实现三角形</p><p> 4、了解伪元素和伪类吗？</p><p> 5、 盒模型</p><p> 6、Vue双向绑定实现 Object.defineProperty()  它有哪些不足点？</p><p> 7、Koa 中间件 passport </p><p>8、仿美团项目登录怎么实现的</p><p>9、cookie 和 session 区别（session 存放哪）</p><p>10、如何保护cookie</p><p>11、浏览器缓存 强缓存 和 协商缓存 状态码</p><p>12、HTTPS中 TLS握手过程简述</p><p> 13、 询问输出结果</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; alert (<span class="number">1</span>); &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">Foo.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; alert (<span class="number">2</span>);&#125;;</span><br><span class="line">Foo.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; alert (<span class="number">3</span>);&#125;;</span><br><span class="line"><span class="keyword">var</span> getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; alert (<span class="number">4</span>);&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123; alert (<span class="number">5</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//请写出以下输出结果：</span></span><br><span class="line">Foo.getName();</span><br><span class="line">getName();</span><br><span class="line">Foo().getName();</span><br><span class="line">getName();</span><br><span class="line"><span class="keyword">new</span> Foo.getName();</span><br><span class="line"><span class="keyword">new</span> Foo().getName();</span><br><span class="line"><span class="keyword">new</span> <span class="keyword">new</span> Foo().getName();</span><br></pre></td></tr></table></figure><p>14、 promise相关，下面代码输出结果</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.reject(<span class="number">2</span>).catch(<span class="function"><span class="params">e</span> =&gt;</span> e).then(<span class="function"><span class="params">d</span> =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(d);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 输出</span></span><br></pre></td></tr></table></figure><p>15、你还有什么要问我的吗？</p><h4 id="感受"><a href="#感受" class="headerlink" title="感受"></a>感受</h4><p>自认为前一部分答的还不错，手撕防抖那里没啥问题，与面试官进行了交流。但后面有点拉胯。询问结果那块答的不是很好，没想到还是让我过了一面。</p><h3 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h3><h4 id="面经-1"><a href="#面经-1" class="headerlink" title="面经"></a>面经</h4><blockquote><p>开篇没有自我介绍，面试官直接说一面问的比较简单，我来考察一下。</p></blockquote><p>1、考你一点操作系统知识，你知道进程和线程吗？它们有什么区别联系？</p><p>2、进程间通信有了解过吗？</p><p>3、说说网络吧，你知道子网掩码这个概念吗？这个出错了会怎么办？是访问不了内网还是外网还是怎么？</p><p>4、刚刚说了ABC类地址，你知道这个是怎么区分的吗？</p><p>5、你怎么学习前端的？</p><p>6、那你有了解过 BOM 和 DOM吗？</p><p>7、有了解过 map 吗？那你知道 Map和 WeakMap的区别吗？</p><p>8、你刚刚讲到了垃圾回收，那你知道v8垃圾回收机制吗？说说</p><p>9、你了解class吗？你能模拟实现它的私有属性吗？让他具有 private 功能</p><p>10、ES5中的继承实现方式</p><p>11、提供类似框架，实现时间过滤器</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DateHelper</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将 UNIX timestamp 时间标签转换成 formatter 格式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param <span class="type">&#123;Number&#125;</span> </span>时间标签 e.g. 1463368789</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param <span class="type">&#123;String&#125;</span> </span>格式 e.g. &#x27;yyyy-mm-dd hh:MM&#x27;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@returns <span class="type">&#123;String&#125;</span> </span>e.g. &#x27;2016-05-16 18:17&#x27;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    timestampConverter (timestamp: number, <span class="attr">formatter</span>: string): string &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>12、算法题</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">给定一个整数数组nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</span><br><span class="line"></span><br><span class="line">示例: 输入: [-<span class="number">2</span>,<span class="number">1</span>,-<span class="number">3</span>,<span class="number">4</span>,-<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,-<span class="number">5</span>,<span class="number">4</span>], 输出: <span class="number">6</span></span><br></pre></td></tr></table></figure><blockquote><p>这道题卡了一小会，但最后还是以O(n)时间做出来了</p></blockquote><p>13、设计题</p><p>微信扫描二维码登录网页是什么原理，前后两个事件是如何联系的？</p><blockquote><p>场景是一台手机（已经登录了微信），PC端服务器，微信服务器，网页二维码。你怎么处理这四者的关系，不牵扯到网络，中间人攻击层面来讲。</p></blockquote><blockquote><p>这题想了挺久，不断尝试去套面试官的话，不过后面面试官说我还是猜到了一点点。</p></blockquote><p>14、你还有什么要问我的吗？</p><blockquote><p>请教了一下最后那个设计题的简单思路，我是最后结束了才明白场景居然是那样，不过面试官那边确实有点吵，一些点也没抓住。</p></blockquote><p><a href="https://www.zhihu.com/question/20368066">参考知乎：微信扫描二维码登录网页是什么原理，前后两个事件是如何联系的？</a></p><h4 id="感受-1"><a href="#感受-1" class="headerlink" title="感受"></a>感受</h4><p>这…我原本以为二面也会是一些基础题，毕竟看了那么多面经，但发现事情没这么简单，上来就聊了操作系统，然后逐步深入，计算机网络那块，我主要是准备了HTTP、TCP那些网络协议相关，子网那些没怎么看都忘了。</p><blockquote><p>甚至觉得这位面试官操作系统、网络这块挺6的，底层那些东西都能扯到，很少见到前端面试官会谈及这些问题，受教了受教了。</p></blockquote><p>另外，还是有一点紧张，毕竟这是我第一次二面，我以为二面会扯到我的项目，我还准备了许久，但没有牵扯到这块，看别人面经都会问许多HTTP、TCP、握手、缓存这块，这块我真的是熟的不能再熟悉了，也许运气不太好。不管最后结果如何，我也增加了一次二面的经验，后续也会越来越好的。</p><h2 id="腾讯-QQ音乐"><a href="#腾讯-QQ音乐" class="headerlink" title="腾讯-QQ音乐"></a>腾讯-QQ音乐</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>腾讯这块也是误打误撞，原本我只是想在官网更新一下简历，没想到跟着春招那会直接又投了，于是收到了8月28日（周五）早10点30电话面试，春招那会也有一次电话面试，面完就GG了，这次同样…</p><h3 id="一面-1"><a href="#一面-1" class="headerlink" title="一面"></a>一面</h3><h4 id="面经-2"><a href="#面经-2" class="headerlink" title="面经"></a>面经</h4><p>1、自我介绍</p><p>2、了解ajax跨域嘛？</p><p>3、cors跨域怎么做？</p><p>4、说说jsonp原理</p><p>5、如果是用node来做跨域的话，你会怎么做？</p><p>6、怎样给一个新增的dom节点绑定事件？（询问事件代理的作用）</p><p>7、了解浏览器缓存吗？（强缓存、协商缓存）你怎样更新强缓存呢？</p><p>8、如何检测JS错误，如何保证你的产品质量？（错误监控）（仅仅答了window.onerror）跨域的js运行错误可以捕获吗，错误提示什么，应该怎么处理？</p><h4 id="感受-2"><a href="#感受-2" class="headerlink" title="感受"></a>感受</h4><p>腾讯给我面试体验依旧不是很好，字节一面会有一个引导的过程，原本我不太清楚的地方，但面试官引导了一下，一下就想起来了。况且这次面试，一上来就怼跨域，项目中怎么做的，难度一个台阶一个台阶的涨，最后面试官回应：了解差不多了，后续有通知再联系。 也没有常用语：你还有什么要问我的吗？ 总之，面试体验不是很好，但面试官提出的几个问题却很经典，后续又学习整理了一下。</p><h2 id="阿里智能事业群-达摩院-机器智能技术部"><a href="#阿里智能事业群-达摩院-机器智能技术部" class="headerlink" title="阿里智能事业群-达摩院-机器智能技术部"></a>阿里智能事业群-达摩院-机器智能技术部</h2><h3 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h3><p>这个是来自BOSS直聘上的内推，一位前端主管邀请的我投递，反正都是试一试，增加面试经验，于是在8月29日（周六）下午3点进行了30分钟左右的短暂面试。</p><h3 id="一面-2"><a href="#一面-2" class="headerlink" title="一面"></a>一面</h3><h4 id="面经-3"><a href="#面经-3" class="headerlink" title="面经"></a>面经</h4><p>1、自我介绍</p><p>2、聊实习经历</p><p>3、项目中有用到SSR，说说对SSR的理解，目前为什么要用SSR？</p><p>4、对CDN的理解</p><p>5、说一个最近刷的印象比较深刻的 leetcode 题目，讲讲思路</p><p>6、大学里面学的一些课程哪门最熟悉？</p><p>7、说说五层、七层 计算机网络模型</p><p>8、举例传输层和应用层</p><p>9、HTTP1.0 和 HTTP2.0区别有了解吗？</p><p>10、自己搭的博客目的是什么？主要写的内容是？</p><p>11、询问了大学里面图像处理课程</p><p>12、如何学习前端（或者说是如何学习计算机领域知识）</p><p>13、对未来的职业规划</p><p>14、你还有什么要问我的吗</p><h4 id="感受-3"><a href="#感受-3" class="headerlink" title="感受"></a>感受</h4><p>相对于字节二面来说，这一面我没有很紧张，反而在面试之前是一个很放松的状态。与面试官交流的也是比较流畅，对我了解了一些大学课程学习，然后对于图像处理那块细问了一下，毕竟部门研究的就是那一块。</p><h2 id="滴滴-橙心优选-面经"><a href="#滴滴-橙心优选-面经" class="headerlink" title="滴滴-橙心优选 面经"></a>滴滴-橙心优选 面经</h2><h3 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h3><p>先说一下最终结果吧，第三面凉了。9月5号下午1点开始，一直到下午4点20样子，持续三轮面试，最终倒在了第三轮。感受与总结我就放在最后吧。总体来说问的比较基础，没有深度挖掘知识点。另外，已经过了一天了，还是三面一起来的，可能会有问题遗漏掉，一般来说遗漏掉的都是比较简单，能轻松说出来的那种。</p><h3 id="一面-3"><a href="#一面-3" class="headerlink" title="一面"></a>一面</h3><h4 id="面经-4"><a href="#面经-4" class="headerlink" title="面经"></a>面经</h4><p>1、自我介绍<br>2、JS基本数据类型（怎么判断基本数据类型）<br>3、说说你对原型和原型链的理解<br>4、水平垂直居中的几种方式，说一说<br>5、说说你对深浅拷贝的理解（要求手撕深拷贝）<br>6、输入一个URL到渲染页面的整个过程<br>7、浏览器缓存有了解过嘛？说说看<br>8、说一个你熟悉的排序算法，然后手写一下（简单写了一个冒泡）</p><h4 id="感受-4"><a href="#感受-4" class="headerlink" title="感受"></a>感受</h4><p>一面问的比较基础，也是比较顺利收到了二面通知</p><h3 id="二面-1"><a href="#二面-1" class="headerlink" title="二面"></a>二面</h3><h4 id="面经-5"><a href="#面经-5" class="headerlink" title="面经"></a>面经</h4><p>1、自我介绍<br>2、CSS选择器优先级的理解<br>3、CSS定位的几种方式<br>4、CSS怎么清除浮动<br>5、display几种属性说一说<br>6、水平垂直居中的几种方式<br>7、父容器已知宽高，子容器宽高未知，怎样让子容器水平垂直居中<br>8、css modules你有了解过吗<br>9、如果组件css命名冲突，你怎么解决<br>10、设计模式你有了解过吗？说说单例模式<br>11、call、apply、bind的区别<br>12、普通函数和箭头函数的区别<br>13、项目中有用到 <code>debounce</code>，那你写一下防抖吧<br>14、实现如下效果：当点击 <code>aaa</code> 时输出 0 ，当点击 <code>bbb</code> 输出 1，当点击<code>ccc</code> 输出 2</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">&lt;li&gt;aaa&lt;/li&gt;</span><br><span class="line">&lt;li&gt;bbb&lt;/li&gt;</span><br><span class="line">&lt;li&gt;ccc&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure><p>15、for 遍历时，如果用 <code>var</code> 来声明变量 <code>i</code> 会有什么问题，怎么解决这个问题？<br>16、浏览器缓存你了解多少，说说看<br>17、谈谈你对 <code>cookie</code> 的理解，<code>cookie</code> 有哪些字段，说说看<br>18、<code>cookie</code> 和 <code>session</code> 的区别</p><h4 id="感受-5"><a href="#感受-5" class="headerlink" title="感受"></a>感受</h4><p>感觉有些问题，答的不是很好，但过了二面，手撕那块没啥问题。</p><h3 id="三面"><a href="#三面" class="headerlink" title="三面"></a>三面</h3><h4 id="面经-6"><a href="#面经-6" class="headerlink" title="面经"></a>面经</h4><p>1、自我介绍<br>2、聊大学经历<br>3、你觉得学的最好的一门课</p><blockquote><p>因为网络这块知识准备的比较充足，就选了计算机网络，其它的与前端不太挂钩，也不太好扯。</p></blockquote><p>4、面试官对网络这门课教学方式很感兴趣，于是扯了挺久，扯到了网络建设项目（校运动会举行），扯到了最后排名，与第一名的差距在哪<br>5、如果要你给一个非科班的人，讲网络这门课，你会怎么讲？<br>6、网络里面你认为的最熟悉的章节（说了HTTP、TCP这块）<br>7、那你说一下对称加密和非对称加密。为什么非对称加密更好，现在还是有用对称加密，你能说出原因吗？最好举一下生活中的例子<br>8、你算法和数据结构咋样，做一道题吧</p><blockquote><p>上来就来了一道动态规划的题，想了一下，没啥思路，面试官就换了一道题</p></blockquote><p>9、算法题：求两个数组的交集</p><h4 id="感受-6"><a href="#感受-6" class="headerlink" title="感受"></a>感受</h4><p>10分钟后收到了感谢信，这效率是真高啊。原以为秋招以收到滴滴意向书结束，但没想到还是倒在了三面这最后一步了。收到后不甘心是当然的，但是面试后的复盘是很重要的。</p><h2 id="快手-效率工程面经"><a href="#快手-效率工程面经" class="headerlink" title="快手-效率工程面经"></a>快手-效率工程面经</h2><h3 id="介绍-4"><a href="#介绍-4" class="headerlink" title="介绍"></a>介绍</h3><p>8月25日（周二）投递，在9月8日上午收到 HR 电话，告知简历通过了，约9月10日上午11点面试，整个面试时间1个小时左右。</p><h3 id="一面-4"><a href="#一面-4" class="headerlink" title="一面"></a>一面</h3><h4 id="面经-7"><a href="#面经-7" class="headerlink" title="面经"></a>面经</h4><p>1、自我介绍<br>2、你刚刚提到了项目中防抖 <code>debounce</code> ，你知道实现原理是什么吗？说一说<br>3、你家乡在哪？面试岗位在北京，有没有城市要求吗？<br>4、实现一个函数，以字符串形式返回参数类型 </p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// null =&gt; &#x27;null&#x27; undefined=&gt;&#x27;undefined&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getArgType</span>(<span class="params">arg</span>)</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、给你一个数组 <code>[1,3,2,5]</code> 你有多少种方法，求得最大值，说一说<br>6、实现如下效果：当你点击 <code>ul</code> 下面某个 <code>li</code>后，打印对应索引值（可以为 <code>0</code> 或 <code>1</code>）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;ul&gt;<span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span>........&lt;/ul&gt;</span><br><span class="line">&lt;ul&gt;<span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span>........&lt;/ul&gt;</span><br><span class="line">&lt;ul&gt;<span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span>........&lt;/ul&gt;</span><br></pre></td></tr></table></figure><p>7、使用 <code>vue</code> 封装一个组件，实现倒计时的功能</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">倒计时（一个 button 按钮，有下述三种状态）</span><br><span class="line">（开始-》暂停-》继续）</span><br><span class="line"></span><br><span class="line">&#123;count&#125;</span><br><span class="line">按钮</span><br></pre></td></tr></table></figure><p>8、你还有什么想问我的吗？</p><h4 id="感受-7"><a href="#感受-7" class="headerlink" title="感受"></a>感受</h4><p>问了部门是效率工程，然后主要业务是做公司内部系统，比如各种流程处理，请假那些，然后还提到了公司封装内部聊天工具，类似于企业微信那种。然后还问了技术栈，主要用 <code>React + Ts</code> ，然后面试官说了技术栈都不是太大问题，主要还是 <code>js</code> 能力</p><p>最后，问了一下多久会有面试结果，面试官说一天之内给结果。</p>]]></content>
      
      
      <categories>
          
          <category> 面试整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 秋招 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>腾讯云COS前端一面凉经</title>
      <link href="posts/2055151/"/>
      <url>posts/2055151/</url>
      
        <content type="html"><![CDATA[<ol><li>自我介绍（介绍了自己的博客）</li><li>写博客带来了最大的收获</li><li>最近写了哪些方面的博客</li><li>Vue你用在了哪些项目</li><li>你对Vue的理解</li><li>Vue中双向绑定的实现原理 </li><li>Vue响应式实现原理（分Vue2.0和Vue3.0）</li><li>Vue3.0你还了解哪些特性？有没有上手过？</li><li>Vuex了解过吗？能解决什么问题</li><li>组件通信还有哪些方式？</li><li><code>event.$on</code> 和 <code>event.$off</code> </li><li>自定义事件和 Vuex 在通信这一块有什么区别？</li><li>Vuex如何实现父子组件通信</li><li>vue-router有使用过吗？有哪几种模式</li><li>history模式是怎样实现的？</li><li>了解虚拟dom吗？和真实dom有什么区别？</li><li>diff算法匹配机制了解吗？</li><li>diff算法比对时有哪些优化？能讲述一下过程嘛</li><li>工程里面有没有使用过webpack？有没有自己修改过相关配置？</li><li>大概介绍一下webpack中配置入口，构建结果，性能优化？</li><li>你目前用的什么CDN？</li><li>写代码过程中有用过TypeScript？</li><li>有使用过ES6之类的嘛？用了哪些特性？</li><li>async 和 await 有使用过吗？解决什么问题？</li><li>await 和 promise 有什么关系？</li><li>async 和 await 如何捕获异常？</li><li>rejected出来异常 await 拿得到吗？怎么拿到内部抛出的异常？</li><li>有使用过 koa 是吧？除了这个，还有使用过其它框架嘛？这些框架做了什么事情？</li><li>nuxt.js你觉得使用有什么特点？</li><li>除了koa2，你有了解node嘛？</li><li>有没有听说过express？</li><li>使用element-ui有没有遇到什么问题？</li><li>对element-ui按需加载怎样做？引用路径有什么区别？</li><li>你写博客的频率？</li><li>有没有参加或者看过一些开源源码？</li><li>你清楚前端闭包是什么东西吗？会导致什么问题</li><li>最后两道代码题：浅拷贝和深拷贝</li><li>如何快速简单得实现深拷贝（JSON.parse(JSON.stringify(obj));）</li></ol>]]></content>
      
      
      <categories>
          
          <category> 面试整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 春招 </tag>
            
            <tag> 腾讯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【腾讯】记录腾讯一面（IMWeb团队）</title>
      <link href="posts/tencentOne/"/>
      <url>posts/tencentOne/</url>
      
        <content type="html"><![CDATA[<h2 id="写在开头"><a href="#写在开头" class="headerlink" title="写在开头"></a>写在开头</h2><p>面试总时长大约100分钟，下午3点面试，结束接近5点样子。总体感觉就是体会到了差距，但也算是一次历练吧，大场面我都经历过了，也无惧小场面了。下面就将面经分享一下，主要是分享一下题目把，答案网上应该都能找到。</p><p>PS：<code>题目肯定是不唯一的，写这篇博客的原因：</code></p><ul><li>记录总结这次面试</li><li>分享一下面经</li><li>体会差距，努力学习</li></ul><p>注：不代表这套题就是你会被问到的，可以学习一下面试模式</p><p>此次面试官：<font color=chocolate>IMWeb团队 前端架构师</font></p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>（关注下面题目，如果有dalao在，可以评论区答复，欢迎交流，我会以数字序号标注题目）</p><h3 id="1、自我介绍"><a href="#1、自我介绍" class="headerlink" title="1、自我介绍"></a>1、自我介绍</h3><p>开场多半都是这样</p><h3 id="2、询问你在大学学了哪些课程，你觉得你学得最好的是哪一门？"><a href="#2、询问你在大学学了哪些课程，你觉得你学得最好的是哪一门？" class="headerlink" title="2、询问你在大学学了哪些课程，你觉得你学得最好的是哪一门？"></a>2、询问你在大学学了哪些课程，你觉得你学得最好的是哪一门？</h3><p>这里的话，接下来的话题就会围绕你觉得学的最好的课程来展开</p><h3 id="3、先用js手写一个冒泡排序"><a href="#3、先用js手写一个冒泡排序" class="headerlink" title="3、先用js手写一个冒泡排序"></a>3、先用js手写一个冒泡排序</h3><p>这期间还问了时间复杂度和空间复杂度，空间复杂度与什么因素有关</p><h3 id="4、你知道打开https-www-qq-com经历了什么吗？"><a href="#4、你知道打开https-www-qq-com经历了什么吗？" class="headerlink" title="4、你知道打开https:www.qq.com经历了什么吗？"></a>4、你知道打开https:<a href="http://www.qq.com经历了什么吗？">www.qq.com经历了什么吗？</a></h3><p>这个就是关于输入网址到显示页面的步骤</p><h3 id="5、js基本数据类型"><a href="#5、js基本数据类型" class="headerlink" title="5、js基本数据类型"></a>5、js基本数据类型</h3><p>之前答的不是很好，面试官就回到了简单一点的题</p><h3 id="6、Vue生命周期你有了解过吗？你用到过哪些？"><a href="#6、Vue生命周期你有了解过吗？你用到过哪些？" class="headerlink" title="6、Vue生命周期你有了解过吗？你用到过哪些？"></a>6、Vue生命周期你有了解过吗？你用到过哪些？</h3><p>beforeCreate 、created 等等</p><h3 id="7、你知道cookie吗？请描述一下-cookies，sessionStorage-和-localStorage-的区别？"><a href="#7、你知道cookie吗？请描述一下-cookies，sessionStorage-和-localStorage-的区别？" class="headerlink" title="7、你知道cookie吗？请描述一下 cookies，sessionStorage 和 localStorage 的区别？"></a>7、你知道cookie吗？请描述一下 cookies，sessionStorage 和 localStorage 的区别？</h3><p>这里也问了cookies里面重要属性有哪些，有什么用</p><h3 id="8、你了解SEO吗？知道怎么做吗？"><a href="#8、你了解SEO吗？知道怎么做吗？" class="headerlink" title="8、你了解SEO吗？知道怎么做吗？"></a>8、你了解SEO吗？知道怎么做吗？</h3><p>这里我就答了html5一些，以及搭建hexo博客用的优化，还提及到了SEO有什么用</p><h3 id="9、谈谈你对this的理解"><a href="#9、谈谈你对this的理解" class="headerlink" title="9、谈谈你对this的理解"></a>9、谈谈你对this的理解</h3><p>因为提及到了apply和call，面试官就反问了apply和call的知识</p><h3 id="10、你了解跨域吗？"><a href="#10、你了解跨域吗？" class="headerlink" title="10、你了解跨域吗？"></a>10、你了解跨域吗？</h3><p>我在谈及的时候，提及到了前后端分离模式，于是下一题…</p><h3 id="11、说说你对前后端分离的理解"><a href="#11、说说你对前后端分离的理解" class="headerlink" title="11、说说你对前后端分离的理解"></a>11、说说你对前后端分离的理解</h3><p>我就从JSONP时代讲到了nginx反向代理，也从原本不需要考虑跨域问题谈到现在比较主流的前后端分离模式</p><h3 id="12、你对浏览器的理解，本地打开浏览器经历了什么？"><a href="#12、你对浏览器的理解，本地打开浏览器经历了什么？" class="headerlink" title="12、你对浏览器的理解，本地打开浏览器经历了什么？"></a>12、你对浏览器的理解，本地打开浏览器经历了什么？</h3><p>这个当时有点懵…</p><h3 id="13、谈谈你所了解的前端性能优化？"><a href="#13、谈谈你所了解的前端性能优化？" class="headerlink" title="13、谈谈你所了解的前端性能优化？"></a>13、谈谈你所了解的前端性能优化？</h3><p>代码压缩，SEO、缓存等等</p><h3 id="14、你知道gulp吗？"><a href="#14、你知道gulp吗？" class="headerlink" title="14、你知道gulp吗？"></a>14、你知道gulp吗？</h3><p>流…</p><h3 id="15、你用过git吗？常见哪些指令？你知道回退是什么指令吗？"><a href="#15、你用过git吗？常见哪些指令？你知道回退是什么指令吗？" class="headerlink" title="15、你用过git吗？常见哪些指令？你知道回退是什么指令吗？"></a>15、你用过git吗？常见哪些指令？你知道回退是什么指令吗？</h3><h3 id="16、你了解React吗？"><a href="#16、你了解React吗？" class="headerlink" title="16、你了解React吗？"></a>16、你了解React吗？</h3><p>因为不是很了解，这里我就谈及了mvvm和mvc的区别，也说明了为啥选择学习Vue，作为学生目前了解不是很深入</p><h3 id="17、你知道怎么不传cookied吗？你了解过http-only吗？"><a href="#17、你知道怎么不传cookied吗？你了解过http-only吗？" class="headerlink" title="17、你知道怎么不传cookied吗？你了解过http:only吗？"></a>17、你知道怎么不传cookied吗？你了解过http:only吗？</h3><p>这个我就有点熟悉，但不记得了</p><h3 id="18、你了解Webpack吗？"><a href="#18、你了解Webpack吗？" class="headerlink" title="18、你了解Webpack吗？"></a>18、你了解Webpack吗？</h3><p>打包方面</p><h3 id="19、对于之前打开本地浏览器那一块，你了解过dom树吗？"><a href="#19、对于之前打开本地浏览器那一块，你了解过dom树吗？" class="headerlink" title="19、对于之前打开本地浏览器那一块，你了解过dom树吗？"></a>19、对于之前打开本地浏览器那一块，你了解过dom树吗？</h3><p>好像他也想问AST语法树方面，但我也不记得了</p><h3 id="20、你了解CDN吗？在哪里你用过"><a href="#20、你了解CDN吗？在哪里你用过" class="headerlink" title="20、你了解CDN吗？在哪里你用过"></a>20、你了解CDN吗？在哪里你用过</h3><h3 id="21、说说你对原型链的理解？"><a href="#21、说说你对原型链的理解？" class="headerlink" title="21、说说你对原型链的理解？"></a>21、说说你对原型链的理解？</h3><h3 id="22、谈谈你对响应式原理的理解"><a href="#22、谈谈你对响应式原理的理解" class="headerlink" title="22、谈谈你对响应式原理的理解"></a>22、谈谈你对响应式原理的理解</h3><p>我提及到了Vue2.0和Vue3.0 区别 以及proxy还能做些什么</p><h3 id="23、你了解闭包吗？"><a href="#23、你了解闭包吗？" class="headerlink" title="23、你了解闭包吗？"></a>23、你了解闭包吗？</h3><h3 id="24、leetcode-电话号码的字母组合"><a href="#24、leetcode-电话号码的字母组合" class="headerlink" title="24、leetcode  电话号码的字母组合"></a>24、leetcode  电话号码的字母组合</h3><p>题目</p><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。<br>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200327100131518.png" alt=""></p><p>示例:<br>输入：”23”<br>输出：[“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”].</p><h3 id="25、最后，出了4到题"><a href="#25、最后，出了4到题" class="headerlink" title="25、最后，出了4到题"></a>25、最后，出了4到题</h3><p>① 异步、事件循环方面，具体题不急得了，但你能把下面这道题做出来，基本上没问题</p><p><a href="https://chocolate.blog.csdn.net/article/details/104907304">原题地址及解析</a></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;en&quot;</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;挑战js面试题&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;async1 start&#x27;</span>);</span><br><span class="line">            <span class="keyword">await</span> async2();</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;async1 end&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;async2&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;script start&#x27;</span>);</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout&#x27;</span>);</span><br><span class="line">        &#125;,<span class="number">0</span>)</span><br><span class="line">        async1();</span><br><span class="line">        <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;promise1&#x27;</span>);</span><br><span class="line">            resolve();</span><br><span class="line">        &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;promise2&#x27;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;script end&#x27;</span>);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>② 你如何将arguments参数改变为数组</p><p>③ box-sizing中content和border的区别</p><p>讲解各种盒模型：标准盒模型、IE（怪异）盒模型、flex、分列布局</p><p>④ 请你用正则表达式来解析腾讯qq或者腾讯其它网页的域名</p><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>好了，距离上次面试也过了两天了，我才打算写一份面经，有些题目可能不太记得了，如果后续学习的时候想到了，我会在评论区进行补充，100多分钟，想不到还问了这么多题…而且有些题目我还进行了深入探讨，比如对闭包，对v8引擎，Vue中响应式原理那一块探索设计模式。</p><p>尽管凉了，但也是一次不错的体验吧，<code>跌倒了一次，爬起来，继续走下去</code>…</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">学如逆水行舟，不进则退</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 春招 </tag>
            
            <tag> 腾讯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【深信服】星耀实习生（前端开发）笔试&amp;面试分享</title>
      <link href="posts/2020616/"/>
      <url>posts/2020616/</url>
      
        <content type="html"><![CDATA[<h2 id="投递初"><a href="#投递初" class="headerlink" title="投递初"></a>投递初</h2><p>原本我自己是不想参与笔试的，如标题所示，这是第二批笔试了。因为当初搜了搜关于深信服前端岗位，貌似有网友说前端框架比较老套，然后当初我看招聘信息上有这一点：熟悉ejs优先。关于这点，我没怎么了解过。第一次笔试，我室友就在我旁边进行的笔试，他是投的后端，一共就三道算法编程题。</p><p>原本以为我第一次没有参与笔试，应该就没有后续内容了，没想到前几天又发了邮件邀请我参与第二批笔试，我想了想，反正都是几道算法题，我就当做练练手好了，结果，打开题库，一共四个大题，分选择填空题25道，还有3道编程题，让我一下震惊地是三道编程题没有一个是算法题，全是手撕源码方面的，奈何最近又没怎么准备这方面的…</p><p>结果我想我已经心知肚明了，我交了白卷，但我把一些我感觉不太会的题目记录了下来，正好通过这次笔试，对自己查漏补缺一下。下面就是题目介绍环节了。</p><h2 id="笔试过程"><a href="#笔试过程" class="headerlink" title="笔试过程"></a>笔试过程</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>整套题25道多选题，3道编程题（已存在Promise实现Promise.all、手撕IOS按钮switch、自定义querySelector，要求保存状态）</p><h3 id="小题"><a href="#小题" class="headerlink" title="小题"></a>小题</h3><h4 id="代码题"><a href="#代码题" class="headerlink" title="代码题"></a>代码题</h4><p>下述代码会输出什么？</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> arr)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">of</span> arr)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200616183821466.png" alt=""></p><p><code>for in</code> 遍历的是数组的索引（即键名），而 <code>for of</code> 遍历的是数组元素值。 所以 <code>for in</code> 更适合遍历对象，不要使用 <code>for in</code> 遍历数组。</p><p><a href="https://juejin.im/post/5aea83c86fb9a07aae15013b">推荐阅读：Js中for in 和for of的区别</a></p></div></div><h4 id="理论题"><a href="#理论题" class="headerlink" title="理论题"></a>理论题</h4><p>哪些情况会导致 <code>HTTPS</code> 证书警告</p><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>通常情况下，出现 <strong>https证书安全警告</strong> 的原因无非就是两种，一种是https证书错误，一种是https证书风险。第一种错误还好点，最大的结果就是进不去，我们只要查找原因，消除错误就行，第二种https证书风险就会问题大一些，因为我们不知道证书的安全性是否收到了影响，一旦安全性收到影响，那么就得迅速更换证书，因为极有可能造成更多的安全风险。</p><p><strong>https证书错误</strong> 的原因有很多，通常最长见的原因就是 <code>证书过期</code>，过了这个时间，你再用的时候，系统就会提示你证书错误，这个时候，可查看该证书信息的有效起止日期，确定证书是否在有效期内，如在的话需查看电脑日期是否正确。否则就是第二种原因，<code>ssl证书不在有效期内</code>，需尽快联系证书颁发厂商，进行续费。</p><p><strong>https证书安全警告</strong> 的另一种原因就是https证书风险，出现这种状况的情况也很多，比如：</p><ul><li>当你的电脑收到来自网络的攻击的时候，这个时候证书验证就会给你发出安全警示</li><li>当你的电脑存在病毒的时候也会发出安全警示</li><li>当你的防火墙关闭状态下也会出现类似的警告。</li></ul><blockquote><p>通常情况下，https加密网页在验证你的证书之前，会对整个网络环境进行分析，就像机器自检一样，检查没有毛病了再认证，如果有问题，就会及时的提醒用户哪里存在问题，用户根据提示，及时的进行风险修复，当网络环境达到要求后就可以开启后续的认证了。</p></blockquote></div></div><h4 id="代码题-1"><a href="#代码题-1" class="headerlink" title="代码题"></a>代码题</h4><p>下述代码会输出什么？</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log,i,i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200616191336995.png" alt=""><br>本题考察：</p><p><code>setTimeout(func, delay, param1, param2, ...)</code>第三个参数及以后的参数都可以作为 func 函数的参数，比如下面这个例题：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log,i,i,<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p><a href="https://www.cnblogs.com/xjnotxj/p/7452698.html">推荐阅读：for循环 + setTimeout 结合的烂大街的面试题</a></p></div></div><h4 id="代码题-2"><a href="#代码题-2" class="headerlink" title="代码题"></a>代码题</h4><p>下述代码会输出什么？</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">load</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;chocolate&#x27;</span>)</span><br><span class="line">    .then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> res;</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="params">res</span>=&gt;</span><span class="string">&#x27;error&#x27;</span>);  </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">await</span> load());</span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200616215620478.png" alt=""><br><code>await</code> 会一直等待着 <code>Promise</code> 对象执行完，然后调用 <code>.then</code> 方法，那里 <code>throw</code>回调到 <code>.catch</code>，因此输出 <code>error</code></p></div></div><h4 id="代码题-3"><a href="#代码题-3" class="headerlink" title="代码题"></a>代码题</h4><p>怎么将字符串 <code>&quot;1.20&quot;</code> 转换成 <code>1.2</code></p><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(+<span class="string">&quot;1.20&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="string">&quot;1.20&quot;</span>));</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200616215752530.png" alt=""></p></div></div><h4 id="理论题-1"><a href="#理论题-1" class="headerlink" title="理论题"></a>理论题</h4><p>列举一下行内元素有哪些？</p><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>行内元素列表<br>下面的元素都是行内元素：</p><ul><li>b, big, i, small, tt</li><li>abbr, acronym, cite, code, dfn, em, kbd, strong, samp, var</li><li>a, bdo, br, img, map, object, q, script, span, sub, sup</li><li>button, input, label, select, textarea</li></ul><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Block-level_elements">推荐阅读：块级元素 - HTML（超文本标记语言）</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Inline_elements">推荐阅读：行内元素 - HTML（超文本标记语言）</a></p></div></div><h3 id="编程题"><a href="#编程题" class="headerlink" title="编程题"></a>编程题</h3><h4 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h4><p>已存在Promise实现Promise.all</p><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all = <span class="function"><span class="keyword">function</span>(<span class="params">promises</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(promises.length);</span><br><span class="line">    <span class="keyword">let</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        promises.forEach(<span class="function">(<span class="params">val,index</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">Promise</span>.resolve(val).then(<span class="function"><span class="params">val</span>=&gt;</span>&#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                arr[index] = val;</span><br><span class="line">                <span class="keyword">if</span>(cnt === promises.length)&#123;</span><br><span class="line">                    resolve(promises);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">                reject(err);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h4 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h4><p>手撕IOS按钮switch</p><p>要求：纯CSS实现，只能有HTML+CSS且 switch 按钮能够点击切换，要有效果。</p><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>实现IOS<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.switch-box</span> &#123;</span></span><br><span class="line">            position: relative;</span><br><span class="line">            height: 30px;</span><br><span class="line">            display: inline-block;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.switch-input</span> &#123;</span></span><br><span class="line">            position: absolute;</span><br><span class="line">            top: 0;</span><br><span class="line">            left: 0;</span><br><span class="line">            z-index: 1;</span><br><span class="line">            display: block;</span><br><span class="line">            width: 100%;</span><br><span class="line">            height: 100%;</span><br><span class="line">            opacity: 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.switch-label</span> &#123;</span></span><br><span class="line">            position: relative;</span><br><span class="line">            display: inline-block;</span><br><span class="line">            width: 60px;</span><br><span class="line">            height: 30px;</span><br><span class="line"><span class="css">            <span class="selector-tag">background</span>: <span class="selector-id">#e3e3e3</span>;</span></span><br><span class="line">            border-radius: 20px;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.switch-label</span><span class="selector-pseudo">::after</span> &#123;</span></span><br><span class="line">            position: absolute;</span><br><span class="line">            top: 3px;</span><br><span class="line">            left: 3px;</span><br><span class="line">            width: 24px;</span><br><span class="line">            height: 24px;</span><br><span class="line">            border-radius: 50%;</span><br><span class="line"><span class="css">            <span class="selector-tag">background-color</span>: <span class="selector-id">#fff</span>;</span></span><br><span class="line">            content: &quot;&quot;;</span><br><span class="line">            transition: .3s;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.switch-input</span><span class="selector-pseudo">:checked</span> + <span class="selector-class">.switch-label</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">background</span>:<span class="selector-id">#66CC33</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.switch-input</span><span class="selector-pseudo">:checked</span> + <span class="selector-class">.switch-label</span><span class="selector-pseudo">::after</span> &#123;</span></span><br><span class="line">            left: 33px;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;switch-box&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">&quot;switch-input&quot;</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">checked</span> <span class="attr">id</span>=<span class="string">&quot;switch-input&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">&quot;switch-label&quot;</span> <span class="attr">for</span>=<span class="string">&quot;switch-input&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><a href="https://juejin.im/post/5c8322a9e51d452fee00b70f">大志前端：【前端帮帮忙】第4期 使用纯CSS制作一个开关按钮</a></p><p><a href="https://codepen.io/chocolate1999/pen/eYJvOwz">Chocolate：CSS制作开关按钮源码（演示）</a></p></div></div><h4 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h4><p>自定义querySelector，要求保存状态</p><p>编写 <code>customQuery</code> 函数，实现类似于 <code>querySelector</code> 函数的功能，但只实现类选择器与后代选择器的查询（其它的选择器情况不需要考虑）接受参数为一个字符串，如：<code>&#39;.class-a .class-b&#39;</code>，要求调用 <code>customQuery(&#39;.class-a .class-b&#39;)</code> 可以查找到对应的元素节点。</p><blockquote><p>待更新…</p></blockquote><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"></div></div><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>我就好奇的搜了搜 <code>深信服ejs</code>，然后就给我推荐了一篇博客：2020.6.1 深信服前端实习一轮笔试+面试，我好奇地点了进去，然后我：WTF? 这不就是我这次笔试的题目吗… 我当时就留下了没有准备好的泪水…</p><p><a href="https://blog.csdn.net/weixin_43336545/article/details/106477642">2020.6.1 深信服前端实习一轮笔试+面试</a></p><p>然后在我打算写错题笔记时，在<code>牛客招聘助手</code> 上又收到了 <strong>简历-不合适</strong> 通知，我就很奇怪了，毕竟我的简历是通过了 <code>腾讯</code> 和 <code>字节跳动</code> HR的筛选了的。然后我就去牛客网找原因，我就打开了自己的附件简历，又是一句：WTF？我简历居然是老版本的，应该是我最初的那一批简历了，目前版本的都是迭代了好多次了，我又留下了没有细心的泪水…我之前还是投了好几家公司，有字节，有虎牙等。因为这个我最近几天的简历应该都没通过…</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>尽管今天看上去挺倒霉的，但还是不错的一天，<strong>顺风不骄傲，逆风不放弃</strong>，是我最近看到的一句话。又总结了一次，知识又<strong>扎实</strong>了一点，继续努力！</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">学如逆水行舟，不进则退</span><br></pre></td></tr></table></figure><blockquote><p>没想到深信服居然捞了我，感动到哭了，呜呜呜~<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200620172958392.png" alt=""><br>赶快写一个面经吧！</p></blockquote><h2 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h2><blockquote><p>下午15点10准时来电话，面试时长25分40秒（毕竟录了音，能有个准确时间…）面试官是一个小姐姐，挺温柔的哈哈哈。</p></blockquote><h3 id="自我介绍（经典开头）"><a href="#自我介绍（经典开头）" class="headerlink" title="自我介绍（经典开头）"></a>自我介绍（经典开头）</h3><h3 id="询问博客主要内容介绍"><a href="#询问博客主要内容介绍" class="headerlink" title="询问博客主要内容介绍"></a>询问博客主要内容介绍</h3><h3 id="再问笔试题相关，因为之前做的不是很好…"><a href="#再问笔试题相关，因为之前做的不是很好…" class="headerlink" title="再问笔试题相关，因为之前做的不是很好…"></a>再问笔试题相关，因为之前做的不是很好…</h3><h4 id="哪些情况会导致-HTTPS-证书警告"><a href="#哪些情况会导致-HTTPS-证书警告" class="headerlink" title="哪些情况会导致 HTTPS 证书警告"></a>哪些情况会导致 <code>HTTPS</code> 证书警告</h4><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>通常情况下，出现 <strong>https证书安全警告</strong> 的原因无非就是两种，一种是https证书错误，一种是https证书风险。第一种错误还好点，最大的结果就是进不去，我们只要查找原因，消除错误就行，第二种https证书风险就会问题大一些，因为我们不知道证书的安全性是否收到了影响，一旦安全性收到影响，那么就得迅速更换证书，因为极有可能造成更多的安全风险。</p><p><strong>https证书错误</strong> 的原因有很多，通常最长见的原因就是 <code>证书过期</code>，过了这个时间，你再用的时候，系统就会提示你证书错误，这个时候，可查看该证书信息的有效起止日期，确定证书是否在有效期内，如在的话需查看电脑日期是否正确。否则就是第二种原因，<code>ssl证书不在有效期内</code>，需尽快联系证书颁发厂商，进行续费。</p><p><strong>https证书安全警告</strong> 的另一种原因就是https证书风险，出现这种状况的情况也很多，比如：</p><ul><li>当你的电脑收到来自网络的攻击的时候，这个时候证书验证就会给你发出安全警示</li><li>当你的电脑存在病毒的时候也会发出安全警示</li><li>当你的防火墙关闭状态下也会出现类似的警告。</li></ul><blockquote><p>通常情况下，https加密网页在验证你的证书之前，会对整个网络环境进行分析，就像机器自检一样，检查没有毛病了再认证，如果有问题，就会及时的提醒用户哪里存在问题，用户根据提示，及时的进行风险修复，当网络环境达到要求后就可以开启后续的认证了。</p></blockquote></div></div><h4 id="Promise-all的原理（还是之前笔试的题）"><a href="#Promise-all的原理（还是之前笔试的题）" class="headerlink" title="Promise.all的原理（还是之前笔试的题）"></a>Promise.all的原理（还是之前笔试的题）</h4><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all = <span class="function"><span class="keyword">function</span>(<span class="params">promises</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(promises.length);</span><br><span class="line">    <span class="keyword">let</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        promises.forEach(<span class="function">(<span class="params">val,index</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">Promise</span>.resolve(val).then(<span class="function"><span class="params">val</span>=&gt;</span>&#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                arr[index] = val;</span><br><span class="line">                <span class="keyword">if</span>(cnt === promises.length)&#123;</span><br><span class="line">                    resolve(promises);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">                reject(err);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h4 id="手撕IOS按钮switch（仅提供思路）"><a href="#手撕IOS按钮switch（仅提供思路）" class="headerlink" title="手撕IOS按钮switch（仅提供思路）"></a>手撕IOS按钮switch（仅提供思路）</h4><p>要求：纯CSS实现，只能有HTML+CSS且 switch 按钮能够点击切换，要有效果。</p><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>实现IOS<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.switch-box</span> &#123;</span></span><br><span class="line">            position: relative;</span><br><span class="line">            height: 30px;</span><br><span class="line">            display: inline-block;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.switch-input</span> &#123;</span></span><br><span class="line">            position: absolute;</span><br><span class="line">            top: 0;</span><br><span class="line">            left: 0;</span><br><span class="line">            z-index: 1;</span><br><span class="line">            display: block;</span><br><span class="line">            width: 100%;</span><br><span class="line">            height: 100%;</span><br><span class="line">            opacity: 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.switch-label</span> &#123;</span></span><br><span class="line">            position: relative;</span><br><span class="line">            display: inline-block;</span><br><span class="line">            width: 60px;</span><br><span class="line">            height: 30px;</span><br><span class="line"><span class="css">            <span class="selector-tag">background</span>: <span class="selector-id">#e3e3e3</span>;</span></span><br><span class="line">            border-radius: 20px;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.switch-label</span><span class="selector-pseudo">::after</span> &#123;</span></span><br><span class="line">            position: absolute;</span><br><span class="line">            top: 3px;</span><br><span class="line">            left: 3px;</span><br><span class="line">            width: 24px;</span><br><span class="line">            height: 24px;</span><br><span class="line">            border-radius: 50%;</span><br><span class="line"><span class="css">            <span class="selector-tag">background-color</span>: <span class="selector-id">#fff</span>;</span></span><br><span class="line">            content: &quot;&quot;;</span><br><span class="line">            transition: .3s;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.switch-input</span><span class="selector-pseudo">:checked</span> + <span class="selector-class">.switch-label</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">background</span>:<span class="selector-id">#66CC33</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.switch-input</span><span class="selector-pseudo">:checked</span> + <span class="selector-class">.switch-label</span><span class="selector-pseudo">::after</span> &#123;</span></span><br><span class="line">            left: 33px;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;switch-box&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">&quot;switch-input&quot;</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">checked</span> <span class="attr">id</span>=<span class="string">&quot;switch-input&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">&quot;switch-label&quot;</span> <span class="attr">for</span>=<span class="string">&quot;switch-input&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><a href="https://juejin.im/post/5c8322a9e51d452fee00b70f">大志前端：【前端帮帮忙】第4期 使用纯CSS制作一个开关按钮</a></p><p><a href="https://codepen.io/chocolate1999/pen/eYJvOwz">Chocolate：CSS制作开关按钮源码（演示）</a></p></div></div><h3 id="Vue-双向绑定的实现原理"><a href="#Vue-双向绑定的实现原理" class="headerlink" title="Vue 双向绑定的实现原理"></a>Vue 双向绑定的实现原理</h3><h3 id="谈谈你对BFC的理解"><a href="#谈谈你对BFC的理解" class="headerlink" title="谈谈你对BFC的理解"></a>谈谈你对BFC的理解</h3><h3 id="css实现倒三角"><a href="#css实现倒三角" class="headerlink" title="css实现倒三角"></a>css实现倒三角</h3><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>画倒三角形<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.triggle</span>&#123;</span></span><br><span class="line">            width: 0px;</span><br><span class="line">            height: 0px;</span><br><span class="line">            border-top: 40px solid red;</span><br><span class="line">            border-left: 40px solid transparent;</span><br><span class="line">            border-bottom: 40px solid transparent;</span><br><span class="line">            border-right: 40px solid transparent;</span><br><span class="line">            margin: 40px;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;triggle&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200620165930147.png" alt=""></p></div></div><h3 id="谈谈你对cookie的理解"><a href="#谈谈你对cookie的理解" class="headerlink" title="谈谈你对cookie的理解"></a>谈谈你对cookie的理解</h3><h3 id="谈谈你对sessionstorage的理解"><a href="#谈谈你对sessionstorage的理解" class="headerlink" title="谈谈你对sessionstorage的理解"></a>谈谈你对sessionstorage的理解</h3><h3 id="ajax的工作流程"><a href="#ajax的工作流程" class="headerlink" title="ajax的工作流程"></a>ajax的工作流程</h3><h3 id="谈谈你对闭包的理解"><a href="#谈谈你对闭包的理解" class="headerlink" title="谈谈你对闭包的理解"></a>谈谈你对闭包的理解</h3><h3 id="for-of-和-for-in的区别"><a href="#for-of-和-for-in的区别" class="headerlink" title="for of 和 for in的区别"></a>for of 和 for in的区别</h3><p>下述代码会输出什么？</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> arr)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">of</span> arr)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200616183821466.png" alt=""></p><p><code>for in</code> 遍历的是数组的索引（即键名），而 <code>for of</code> 遍历的是数组元素值。 所以 <code>for in</code> 更适合遍历对象，不要使用 <code>for in</code> 遍历数组。</p><p><a href="https://juejin.im/post/5aea83c86fb9a07aae15013b">推荐阅读：Js中for in 和for of的区别</a></p></div></div><h3 id="HTTP的状态码"><a href="#HTTP的状态码" class="headerlink" title="HTTP的状态码"></a>HTTP的状态码</h3><h3 id="算法题1：单链表反转"><a href="#算法题1：单链表反转" class="headerlink" title="算法题1：单链表反转"></a>算法题1：单链表反转</h3><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;  </span><br><span class="line">    ListNode prev = <span class="keyword">null</span>;   </span><br><span class="line">    ListNode curr = head;   </span><br><span class="line">    <span class="keyword">while</span> (curr != <span class="keyword">null</span>) &#123;  </span><br><span class="line">        ListNode nextTemp = curr.next;</span><br><span class="line">        curr.next = prev;</span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = nextTemp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://juejin.im/post/5e3d3f25e51d45270c276fe3">推荐阅读——Jay_huaxiao：看一遍就理解，图解单链表反转</a></p></div></div><h3 id="算法题2：有一个仅由0和1组成的01串，找到其中最长的一段子串，使得该子串中0和1的数目相等"><a href="#算法题2：有一个仅由0和1组成的01串，找到其中最长的一段子串，使得该子串中0和1的数目相等" class="headerlink" title="算法题2：有一个仅由0和1组成的01串，找到其中最长的一段子串，使得该子串中0和1的数目相等"></a>算法题2：有一个仅由0和1组成的01串，找到其中最长的一段子串，使得该子串中0和1的数目相等</h3><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><ul><li><p>如果将0看做-1，则我们要找的子串是最长的和为0的子串。</p></li><li><p>这种子串求和的问题，一般采用前缀和的方法来解决。</p></li><li><p>用Sum[i]代表前i个数的和，问题的模型转换为，找到i和j，满足Sum[i] 与Sum[j]相等，且|i-j|最大。</p></li><li><p>使用Hash表作为辅助数据结构，Hash表中记录了获得某个Sum时最小的i。从左到右遍历Sum[i]，在Hash表中查找是否存在，如果存在，则记录下Hash[Sum[i]] 和i的距离差，否则Hash[Sum[i]] = i。一次遍历结束后得到最大的距离差，同时也可以得到具体是哪一段。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&#x27;\n&#x27;</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(a,b) memset(a,b,sizeof(a));</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="keyword">int</span> n,m,t;</span><br><span class="line"><span class="keyword">int</span> dp[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;str)&#123;</span><br><span class="line">        <span class="keyword">int</span> zeroIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = str.length();</span><br><span class="line">        dp[<span class="number">1</span>] = (str[<span class="number">0</span>]-<span class="string">&#x27;0&#x27;</span>) == <span class="number">1</span>? <span class="number">1</span>:<span class="number">-1</span>;  <span class="comment">//将0转变成-1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=len;i++)&#123;</span><br><span class="line">            dp[i] = (str[i<span class="number">-1</span>]-<span class="string">&#x27;0&#x27;</span>) == <span class="number">1</span>? <span class="number">1</span>:<span class="number">-1</span>; <span class="comment">//将0转变成-1</span></span><br><span class="line">            dp[i]+=dp[i<span class="number">-1</span>];   <span class="comment">//求前缀和</span></span><br><span class="line">            <span class="keyword">if</span>(dp[i]==<span class="number">0</span>) zeroIndex=i;  <span class="comment">//记录当前前缀和为0的下标位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span> ,maxnlen = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!mp.count(dp[i]))&#123;  <span class="comment">//记录首次出现的前缀和的位置</span></span><br><span class="line">                mp[dp[i]]=i;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                start = mp[dp[i]];  <span class="comment">//如果有相同的前缀和，求出最长长度</span></span><br><span class="line">                maxnlen = i-start;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> ans;</span><br><span class="line">        <span class="keyword">if</span>(zeroIndex&gt;=maxnlen)&#123;  <span class="comment">//对于前缀和为0的情况特殊考虑</span></span><br><span class="line">            maxnlen = zeroIndex;   <span class="comment">//与相同前缀和的长度取最大值</span></span><br><span class="line">            ans = str.substr(<span class="number">0</span>,maxnlen);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ans = str.substr(start,maxnlen);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;maxnlen&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果需要详细的步骤介绍，可以参考如下博文：</p></li></ul><p><a href="https://blog.csdn.net/SunnyYoona/article/details/41910519">推荐阅读——SunnyYoona ：[经典面试题]最长01子串</a></p></div></div><h3 id="你还有什么要问我的吗？（经典结尾）"><a href="#你还有什么要问我的吗？（经典结尾）" class="headerlink" title="你还有什么要问我的吗？（经典结尾）"></a>你还有什么要问我的吗？（经典结尾）</h3><h4 id="询问城市"><a href="#询问城市" class="headerlink" title="询问城市"></a>询问城市</h4><h4 id="深信服那边前端主要技术栈"><a href="#深信服那边前端主要技术栈" class="headerlink" title="深信服那边前端主要技术栈"></a>深信服那边前端主要技术栈</h4><h4 id="询问前端框架-ext-js，毕竟有点老了"><a href="#询问前端框架-ext-js，毕竟有点老了" class="headerlink" title="询问前端框架 ext.js，毕竟有点老了"></a>询问前端框架 ext.js，<del>毕竟有点老了</del></h4><h4 id="询问面试结果的时间"><a href="#询问面试结果的时间" class="headerlink" title="询问面试结果的时间"></a>询问面试结果的时间</h4><h2 id="一面总结"><a href="#一面总结" class="headerlink" title="一面总结"></a>一面总结</h2><p>总体来说，是体验比较好的一次面试了，题目都比较简单（<del>都是常见的基础题</del> ），然后是小姐姐面试，感觉还是不错的，自我介绍完后我就很有底气，毕竟最近我准备了很久，关于网络方面的问题还有 <code>Vue</code> 源码我准备了和面试官扯40分钟的知识点。但本次一面是电话面的话，我知道一般就20-30分钟，所以我就保留了一些知识点，说不定来二面了呢是吧。</p><p>后面询问了面试官相关技术栈，也是 <code>Vue</code>。我连忙回答：可以！起初春招那时候我就看到前端需要熟悉  <code>ext.js</code>，我那时候就百度了下，原来这都比较老了…所以我有一段时间都没有想法考虑深信服了，因为觉得可能技术栈和我不太符合，因此一轮笔试我就没参加，具体本文开头就提及了。后面面试官是说因为有一些老的项目需要维护，现在都是主流用<code>Vue</code>了。<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200620172310265.png" alt=""></p><blockquote><p>好了，本次一面到此分享结束，后续有二面的话，再进行补充了。</p></blockquote><h2 id="结尾：努力不一定成功"><a href="#结尾：努力不一定成功" class="headerlink" title="结尾：努力不一定成功"></a>结尾：努力不一定成功</h2><p>今天刚做完笔试题，然后6月21日晚10点27收到了来自深信服的邮件，我原本很期待选择下一次面试时间的，看到邮件标题 <code>很遗憾</code> 三个字，一下子就沉浸了下来。<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200621225124417.png" alt=""><br><strong>努力不一定成功</strong>，是我看完邮件后立即想到的句子。对于一面我其实是比较有信心的，但最后还是被刷了，我立即想了想为什么我会被刷？有这几个原因在：</p><ul><li>笔试做的太差了，我甚至后面编程题几乎白卷，首先从态度上就已经做的不是很好了</li><li>一面也是运气比较好，收到了面试邀约，在面试开头，面试官就和我说了笔试<strong>很一般</strong> </li><li>最后面试官给的算法题，后续补提地时候才发现我居然听错题目了，呜呜呜…我以为是求1构成的最长子串。</li><li>简历不是最新的，我看了下我的投递时间，是4月30日，那个时候简历还是有一些问题的，当时还把自己搭的 <code>hexo</code> 博客写了进去，为什么后面的简历选择撤掉了呢？因为搭的博客显得比较不成熟。</li><li>核心的编程题没写出来，可能就是被刷掉的主要原因吧，因为只懂得一点知识点是满足不了公司业务需求的。</li></ul><p>ok，总结完毕，也不是一次受打击了，现在也逐渐习惯了，老一面了。后续还有恒生电子的面试，继续保持干劲吧！</p><p><img src= "/img/loading.gif" data-lazy-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL2Nob2NvbGF0ZTE5OTkvY2RuL2ltZy8yMDIwMDYyMTIzMDgzNy5qcGc?x-oss-process=image/format,png" alt=""></p><blockquote><p>2020年6月21日晚，深信服实习笔试&amp;面试分享结束</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 面试整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 春招 </tag>
            
            <tag> 深信服 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【恒生电子】2021实习（前端） 笔试&amp;面试分享</title>
      <link href="posts/2020621/"/>
      <url>posts/2020621/</url>
      
        <content type="html"><![CDATA[<h2 id="投递初"><a href="#投递初" class="headerlink" title="投递初"></a>投递初</h2><p>还是源自于学校里发了一个恒生招聘的pdf文件，首先看文件，就明确了会招前端，为什么说是会招呢？请看下图吧。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200621212312692.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""><br>本次预计就招380人，而对于前端来说，只招20个，你没看错，就20名，这比例我刚开始看的时候就感觉有点离谱。可想这次招聘的难度了…</p><h2 id="投递后"><a href="#投递后" class="headerlink" title="投递后"></a>投递后</h2><p>我不知道简历会不会刷人，你简历通过了的话，会发一个邮件邀请你加入恒生招聘群聊，我起初那时候加入的时候才400左右的人数，到今天6月21日晚早已经达到了群的容量2000人了，虽然期间有小部分退群的。但基本上这次招聘的话投递恒生的都是1000人以上了，而这1000多人中，我想搞 <code>Java</code> 的应该挺多的，毕竟招的人最多。不管怎样，这个群里投前端的也得有好几百人吧，还包括一些硕士研究生，而我得从这好几百人里面挤进前20。但我依旧还是觉得有希望的，相信自己！</p><blockquote><p>我想既然投的也这么多，而看群里的话，应该很少有人会因为简历被刷掉。那么，这次笔试的话，就会刷掉很多人了，因为恒生这次就一次技术面，而且招聘会上也是说了会在端午节之前（22、23、24号三天）面完所有人，然后就是发放Offer了，可想这次笔试是多么重要了！</p></blockquote><h2 id="笔试过程"><a href="#笔试过程" class="headerlink" title="笔试过程"></a>笔试过程</h2><blockquote><p>6月19日收到了来自恒生的笔试邀请，也是确定自己会参与笔试了，然后在下午6点开始笔试，两小时时间。</p></blockquote><h3 id="题目类型"><a href="#题目类型" class="headerlink" title="题目类型"></a>题目类型</h3><p>本次考察了单选题、不定项选择题（可能多选或单选）、问答题、编程题、算法题、逻辑测试题。</p><blockquote><p>我就记录了一些比较重要有价值的题，其它可能比较基础，就没记录了。</p></blockquote><h3 id="单选题"><a href="#单选题" class="headerlink" title="单选题"></a>单选题</h3><h4 id="代码题"><a href="#代码题" class="headerlink" title="代码题"></a>代码题</h4><p>下述代码会输出什么？</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[[<span class="number">1</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">1</span>]].reduce(<span class="function">(<span class="params">acc,cur</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> acc.concat(cur);</span><br><span class="line">&#125;,[<span class="number">0</span>,<span class="number">1</span>]);</span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> res = [[<span class="number">1</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">1</span>]].reduce(<span class="function">(<span class="params">acc,cur</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> acc.concat(cur);</span><br><span class="line">&#125;,[<span class="number">0</span>,<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(res);</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200621221613192.png" alt=""></p></div></div><h4 id="理论题"><a href="#理论题" class="headerlink" title="理论题"></a>理论题</h4><p>插入排序的定义？</p><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>直接插入排序（Straight Insertion Sort）是一种最简单的排序方法，其基本操作是将一条记录插入到已排好的有序表中，从而得到一个新的、记录数量增1的有序表</p></div></div><h4 id="理论题-1"><a href="#理论题-1" class="headerlink" title="理论题"></a>理论题</h4><p>进程间的通信方式</p><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>进程（Linux）间的通信方式有：</p><ul><li>管道</li><li>消息队列</li><li>共享内存</li><li>信号量</li><li>Socket</li></ul><p><a href="https://juejin.im/post/5d515c7551882511ed7c273c">参考：happyjava—进程间通信方式总结</a></p></div></div><h4 id="判断题"><a href="#判断题" class="headerlink" title="判断题"></a>判断题</h4><p>移动端要想动画性能流畅，应该使用3D硬件加速，因此最好给页面中的元素尽量添加 <code>translate3d</code> 或者 <code>translateZ(0)</code> 来触发3D硬件加速。</p><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p><strong>错误</strong>。</p><blockquote><p>滥用硬件加速会导致严重性能问题，因为它增加了内存使用，并且它会导致移动端电池寿命减少。</p></blockquote><ul><li>A: 浏览器渲染页面时会根据DOM通过不同的图层来叠加呈现出页面,对于某些属性如3D属性、硬件加速的 <code>&lt;video&gt;</code> 等都会创建新图层</li><li>B: 盒子属性、内部结构属性、定位属性、浮动等.这些可能修改节点的大小和位置,都会触发重布局</li><li>C:  <code>translate3d</code> 会添加新图层,过多的图层会使浏览器崩溃</li><li>D: 层的重绘和重排是浏览器性能问题的很大影响因素</li></ul><p><a href="https://www.nowcoder.com/questionTerminal/0260851028b740a1a58370495fe1077d">参考：牛客网试题广场某单选题</a></p></div></div><h4 id="代码题-1"><a href="#代码题-1" class="headerlink" title="代码题"></a>代码题</h4><p>下面代码会输出什么？</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    #number = <span class="number">10</span></span><br><span class="line">    <span class="function"><span class="title">increment</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.#number++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">getNum</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.#number</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> counter = <span class="keyword">new</span> Counter()</span><br><span class="line">counter.increment()</span><br><span class="line"><span class="built_in">console</span>.log(counter.#number)</span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p><code>SyntaxError</code></p><p>在 ES2020 中，通过 <code>#</code> 我们可以给 <code>class</code> 添加私有变量。在 <code>class</code> 的外部我们无法获取该值。当我们尝试输出 <code>counter.#number</code>，语法错误被抛出：我们无法在 <code>class Counter</code> 外部获取它!</p></div></div><h4 id="判断题-1"><a href="#判断题-1" class="headerlink" title="判断题"></a>判断题</h4><p><code>localStroage</code> API不支持设置过期时间</p><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>很遗憾，<code>localstorage</code> 原生是不支持设置过期时间的，想要设置的话，就只能自己来封装一层逻辑来实现</p><p><a href="https://blog.csdn.net/zhaoxiang66/article/details/86703438">参考：三哥玩前端——localStorage设置过期时间</a></p><p><a href="https://juejin.im/post/5a9fcc5e51882555602074e3">参考：array_huang——localstorage 必知必会</a></p></div></div><h4 id="理论题-2"><a href="#理论题-2" class="headerlink" title="理论题"></a>理论题</h4><p>进程和线程的区别</p><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><ul><li>进程是运行中的程序，线程是进程的内部的一个执行序列</li><li>进程是资源分配的单元，线程是执行单元</li><li>进程间切换代价大，线程间切换代价小</li><li>进程拥有资源多，线程拥有资源少</li><li>多个线程共享进程的资源</li></ul><p><a href="https://www.nowcoder.com/questionTerminal/234895a70e0b40e19db7f3fbaabc5fa3">参考：牛客网试题广场某问答题</a></p><p><a href="https://blog.csdn.net/mxsgoden/article/details/8821936">参考：森森向上——腾讯面试题04.进程和线程的区别？</a></p></div></div><h3 id="问答题"><a href="#问答题" class="headerlink" title="问答题"></a>问答题</h3><h4 id="原型与原型链的考察"><a href="#原型与原型链的考察" class="headerlink" title="原型与原型链的考察"></a>原型与原型链的考察</h4><p>问如下代码输出结果？</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> foo(<span class="string">&#x27;chocolate&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(c.__proto__);</span><br><span class="line"><span class="built_in">console</span>.log(foo.__proto__);</span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200621223730237.png" alt=""></p></div></div><h4 id="从url输入到页面渲染经历了什么？"><a href="#从url输入到页面渲染经历了什么？" class="headerlink" title="从url输入到页面渲染经历了什么？"></a>从url输入到页面渲染经历了什么？</h4><blockquote><p>最近一直在记的知识点，直接上手700字左右。</p></blockquote><h3 id="编程题"><a href="#编程题" class="headerlink" title="编程题"></a>编程题</h3><blockquote><p>这道题是最后做的，没有写出来，但写了解题思路，求解了大概30%样例吧，不知道影响大不大…这道题以前是做过的，奈何最近全都是记知识点了。</p></blockquote><p>n代表括号的对数，生成所有可能并且有效的括号组合</p><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200622204304634.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><p>画图以后，可以分析出的结论：</p><ul><li><p>当前左右括号都有大于 0 个可以使用的时候，才产生分支；</p></li><li><p>产生左分支的时候，只看当前是否还有左括号可以使用；</p></li><li><p>产生右分支的时候，还受到左分支的限制，<strong>右边剩余可以使用的括号数量一定得在严格大于左边剩余的数量</strong>的时候，才可以产生分支；</p></li><li><p>在左边和右边剩余的括号数都等于 0 的时候结算。</p></li></ul><p><strong>C++代码：</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> res; <span class="comment">//特判</span></span><br><span class="line">        dfs(<span class="string">&quot;&quot;</span>,n,n,res); <span class="comment">// 执行深度优先遍历，搜索可能的结果</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">string</span> str,<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; res)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 因为每一次尝试，都使用新的字符串变量，所以无需回溯</span></span><br><span class="line">        <span class="comment">// 在递归终止的时候，直接把它添加到结果集即可</span></span><br><span class="line">        <span class="keyword">if</span>(left==<span class="number">0</span>&amp;&amp;right==<span class="number">0</span>) res.push_back(str);</span><br><span class="line">        <span class="comment">// 剪枝（如图，左括号可以使用的个数严格大于右括号</span></span><br><span class="line">        <span class="comment">//可以使用的个数，才剪枝，注意这个细节）</span></span><br><span class="line">        <span class="keyword">if</span>(left&gt;right) <span class="keyword">return</span>; </span><br><span class="line">        <span class="keyword">if</span>(left&gt;<span class="number">0</span>)</span><br><span class="line">            dfs(str+<span class="string">&quot;(&quot;</span>,left<span class="number">-1</span>,right,res);</span><br><span class="line">        <span class="keyword">if</span>(right&gt;<span class="number">0</span>)</span><br><span class="line">            dfs(str+<span class="string">&quot;)&quot;</span>,left,right<span class="number">-1</span>,res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/generate-parentheses/solution/hui-su-suan-fa-by-liweiwei1419/">参考：leetcode大佬题解</a></p></div></div><h3 id="算法题"><a href="#算法题" class="headerlink" title="算法题"></a>算法题</h3><blockquote><p>怎么说呢，正常的前端算法题吧…</p></blockquote><p>1、使用 <code>javascript</code> 实现冒泡排序</p><p>2、分析冒泡排序的时间复杂度、空间复杂度、稳定性</p><h3 id="逻辑测试题"><a href="#逻辑测试题" class="headerlink" title="逻辑测试题"></a>逻辑测试题</h3><blockquote><p>此类就是一些测评，比如说给你一组图片，然后让你找出最合适的，符合题目规律；还有就是一些计算题，比较简单，例如一些解二元一次方程，等比数列求和等。其次，还有就是给你一段话，进行简单分析，选择最符合逻辑的一句话。</p></blockquote><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>整场下来，答的不是特别顺畅，有些题目还是第一次遇到，比如移动端想要动画性能流畅，应该使用3D硬件加速；进程和线程区别。另外，就是不定项选择题，不确定自己的选的对不对，希望如下图牛牛所述，<strong>蒙的全对！</strong><br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200621222949873.png" alt=""></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这次恒生招聘，对于我前端来说的话，还是有一定挑战的，我的编程题和部分选择题答的不是很好。然后明天或后天应该就会有笔试结果了（应该会刷掉很多人样子…）如果有后续面试邀请的话，再来进行补充了，熟悉的结尾：</p><blockquote><p>学如逆水行舟，不进则退</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200621224006274.png" alt=""></p><h2 id="收获实习offer"><a href="#收获实习offer" class="headerlink" title="收获实习offer"></a>收获实习offer</h2><p>2020年6月29日下午，原本还在学校机房做着数字图像处理的实验，然后电脑右下角突然弹窗，显示 <strong>实习录用</strong> 几个字，我一下就激动起来了，它来了！它来了！它来了！<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200629171540597.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""><br>原本这个offer应该会早一点下来的，正好卡在了端午节前面试，然后就等到了端午节和周末假期过后，也就是周一下午，我这个部门才正式下发offer。下面就来分享一下我面试恒生电子的过程与一些心得吧：</p><h3 id="笔试过后"><a href="#笔试过后" class="headerlink" title="笔试过后"></a>笔试过后</h3><p>笔试相关题目我都总结在上面了，笔试的话我一开始以为会直接被刷掉，恒生的面试时间是23号和24号，大部分人在6月22号就陆续收到了面试邀请，有23号面试的，也有24号面试的。等了一天后，我邮件一点消息也没有，看着实习群里人陆续都收到了面试邀请，我感觉应该是被直接刷掉了。</p><p>后续，好在hr说面试邀请还没发完，我还是抱着一点希望，个人觉得面试机会我至少得有吧，不然也太扎心了…</p><p>在6月23日下午，早早地做完网络工程实验后，回到宿舍，就收到了面试邀请：</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200629172833941.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><h3 id="面试阶段"><a href="#面试阶段" class="headerlink" title="面试阶段"></a>面试阶段</h3><p>笔试还是如愿过了，恒生的面试就只有一轮技术面。在23号面试环节，许多人都说面试不怎么样，每个人几乎就25分钟，而且任何技术问题都没问…</p><p>我当时就很懵，如果只是用笔试来区别刷人的话，那这场面试岂不是没啥意义。一直到23号晚上，居然就有dalao收到了实习offer，我当时一惊，这么快的嘛..我都还没开始面，这名额怎么就开始少了…</p><p>此时，大多数拿到实习offer的 dalao 都说是全程几乎问的技术问题，不是纯聊天。那么，我觉得如果面试不纯聊天的话，收到offer的概率应该特别高。</p><p>24号下午2点，准时进入了腾讯会议，首先，简单地自我介绍，其中提到了自己的获奖经历，项目经历，如何学前端，CSDN博客专家，平常习惯：善于总结，写博客、github活跃，对恒生的了解，未来职业规划等等。</p><p>整场面试下来，几乎纯技术问题交流，也与面试官进行了互动，探讨一些问题。问的大部分是简历上的东西。（还是简单整理一下问题吧）</p><p><strong>万能开头：</strong></p><p>你先来一个自我介绍吧，介绍完毕后，面试官说：我看过你的 <code>github</code> 与博客，挺好的，总结的不错！</p><p><a href="https://chocolate.blog.csdn.net/">CSDN博客</a></p><p><a href="https://github.com/chocolate1999">Github</a></p><p><strong>技术问题：</strong></p><ul><li>http状态码你了解哪些？</li><li>http相关你所了解的有哪些，讲一讲？</li><li>简历上面写了你对浏览器渲染机制比较熟悉，来讲讲</li></ul><p><strong>HR方面问题：</strong></p><ul><li>你所期望的公司员工关系是怎样的？</li><li>如果领导和你在某些方面，比如技术点上有一些冲突，你会怎么做？</li></ul><p><strong>万能结尾：</strong></p><p>你还有什么想问我的？</p><blockquote><p>整场面试下来，把自己准备的知识点都讲了一遍，也和面试官有说有笑的。其中对于浏览器渲染机制我展示了我的专业知识能力与自信，讲完后面试官对我笑了一下，此时我对收到offer更加自信了一点。</p></blockquote><p>最后，努力还是收获了回报，成功收到 <code>offer</code> </p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200629171540597.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><blockquote><p>2020年6月29日 恒生电子实习经验分享完结 ✿✿ヽ(°▽°)ノ✿</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 面试整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 春招 </tag>
            
            <tag> 恒生电子 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【字节跳动】前端面试准备（一）</title>
      <link href="posts/200610/"/>
      <url>posts/200610/</url>
      
        <content type="html"><![CDATA[<h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><h3 id="什么是原生开发？什么是混合开发？两者有什么区别？"><a href="#什么是原生开发？什么是混合开发？两者有什么区别？" class="headerlink" title="什么是原生开发？什么是混合开发？两者有什么区别？"></a>什么是原生开发？什么是混合开发？两者有什么区别？</h3><p><strong>原生开发(NativeApp开发)</strong>：像盖房子一样，先打地基然后浇地梁、房屋结构、一砖一瓦、钢筋水泥、电路走向等，原生APP同理：通过代码从每个页面、每个功能、每个效果、每个逻辑、每个步骤全部用代码写出来，一层层，一段段全用代码写出来</p><p>此种APP的<strong>数据都保存在本地</strong>，APP能及时调取，所以相应速度及流畅性有保障</p><p><strong>混合开发(HTML5开发)</strong>：这个就相当于一种框架开发，说白了就是网页;该模式通常由“HTML5云网站+APP应用客户端”两部份构成，APP应用客户端只需安装应用的框架部份，而应用的数据则是每次打开APP的时候，去云端取数据呈现给手机用户。</p><p>　　混合APP还有一种是套壳APP，套壳APP就是用H5的网页打包成APP，虽然是APP能安装到手机上，但是每个界面，全部是网页</p><p>　　此种APP数据都保存在云端，用户每次访问都需要从云端调取全部内容，这样就容易导致反应慢，每打开一个网页或点一个按钮都需要等半天。</p><h3 id="什么是小程序？"><a href="#什么是小程序？" class="headerlink" title="什么是小程序？"></a>什么是小程序？</h3><p>小程序是一个不需要下载安装就可使用的应用，它实现了应用触手可及的梦想，用户扫一扫或者搜一下即可打开应用。也体现了用完即走的理念，用户不用关心是否安装太多应用的问题。应用将无处不在，随时可用，但又无需安装卸载。</p><p>简单来说，小程序不用安装就能使用；它的体积也非常小，每一个都不超过 1 M。<br>小程序的来到，将给我们带来许多便利和好处：</p><ul><li>少了安装 App 的麻烦</li><li>释放手机内存</li><li>让手机桌面更简洁</li><li>对于开发者来说，相比 HTML 5，小程序可以节省大量的服务器资源。</li><li>小程序和 HTML 5 本质上是两种不同的东西：小程序是<strong>计算机程序</strong>，而HTML 5 则是互联网网页。</li></ul><h3 id="假设存在一个长度为1000（非常大）的数据列表，在v-for中渲染必然造成卡顿，如何优化"><a href="#假设存在一个长度为1000（非常大）的数据列表，在v-for中渲染必然造成卡顿，如何优化" class="headerlink" title="假设存在一个长度为1000（非常大）的数据列表，在v-for中渲染必然造成卡顿，如何优化"></a>假设存在一个长度为1000（非常大）的数据列表，在v-for中渲染必然造成卡顿，如何优化</h3><p>在后端优化，分页请求</p><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><h3 id="vue-router实现原理-hash跟histroy具体指什么"><a href="#vue-router实现原理-hash跟histroy具体指什么" class="headerlink" title="vue-router实现原理;hash跟histroy具体指什么"></a>vue-router实现原理;hash跟histroy具体指什么</h3><p>Vue中会使用官方提供的vue-router插件来使用单页面，原理就是通过检测地址栏变化后将对应的路由组件进行切换（卸载和安装）。</p><h3 id="路由模式"><a href="#路由模式" class="headerlink" title="路由模式"></a>路由模式</h3><p>hash和history这两个方法应用于浏览器的历史记录站，在当前已有的back、forward、go 的基础之上，它们提供了对历史记录进行修改的功能。只是当它们执行修改时，虽然改变了当前的URL，但你浏览器不会立即向后端发送请求。</p><p><strong>hash：即地址栏URL中的#符号（此hsah 不是密码学里的散列运算）</strong></p><p>路由有两种模式：hash、history，默认会使用hash模式</p><p>比如这个URL：<code>www.baidu.com/#/hello</code>, hash 的值为<code>#/hello</code>。它的特点在于：hash 虽然出现URL中，但不会被包含在HTTP请求中，对后端完全没有影响，因此改变hash不会重新加载页面。</p><p>history：利用了<code>HTML5 History Interface</code> 中新增的 <strong>pushState() 和replaceState()</strong> 方法。（需要特定浏览器支持）</p><blockquote><p>history模式，会出现404 的情况，需要后台配置。</p></blockquote><p>history模式下，前端的url必须和实际向后端发起请求的url 一致，因为我们的应用是个单页客户端应用，如果后台没有正确的配置，当用户在浏览器直接访问 <code>www.baidu.com/home/detail…</code> 404错误，这就不好看了。</p><p>所以呢，你要在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。</p><p><strong>hash哈希路由的原理</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//当hash发生变化的时候， 会产生一个事件 onhashchange</span></span><br><span class="line">    <span class="built_in">window</span>.onhashchange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log( <span class="string">&#x27;你的hash改变了&#x27;</span> );</span><br><span class="line">        <span class="comment">//location对象是 javascript内置的(自带的)</span></span><br><span class="line">        <span class="built_in">console</span>.log( location );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上例，我们已经通过hash( 就是锚文本 ) 变化， 触发了onhashchange事件， 就可以把hash变化与内容切换对应起来，就实现了单页路由的应用！</p><p>监控hash值变化，hash一旦变化，页面内容变化，实现无刷新切换。</p><h3 id="路由的懒加载"><a href="#路由的懒加载" class="headerlink" title="路由的懒加载"></a>路由的懒加载</h3><p>当打包构建应用时，JavaScript 包会变得非常大，影响页面加载。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就更加高效了。结合 Vue 的异步组件和 Webpack 的代码分割功能，轻松实现路由组件的懒加载。</p><p>懒加载也叫延迟加载，即在需要的时候进行加载，随用随载。在单页应用中，如果没有应用懒加载，运用webpack打包后的文件将会异常的大，造成进入首页时，需要加载的内容过多，延时过长，会出现长时间的白屏，即使做了loading也是不利于用户体验，而运用懒加载则可以将页面进行划分，需要的时候加载页面，可以有效的分担首页所承担的加载压力，减少首页加载用时。简单的说就是：进入首页时不用一次加载过多资源，造成页面加载用时过长。</p><p><strong>懒加载写法：</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 路由的懒加载方式</span></span><br><span class="line">&#123; <span class="attr">path</span> :<span class="string">&quot;/home&quot;</span>,<span class="attr">component</span>:<span class="function">()=&gt;</span><span class="keyword">import</span>(<span class="string">&quot;../views/Home&quot;</span>)&#125;,<span class="comment">// 当我访问/home首页时，页面才去加载Home组件，减少首页加载的时长</span></span><br><span class="line">&#123; <span class="attr">path</span> :<span class="string">&quot;/list&quot;</span>,<span class="attr">component</span>:<span class="function">()=&gt;</span><span class="keyword">import</span>(<span class="string">&quot;../views/List&quot;</span>)&#125;,</span><br><span class="line">&#123; <span class="attr">path</span> :<span class="string">&quot;/mine&quot;</span>,<span class="attr">component</span>:<span class="function">()=&gt;</span><span class="keyword">import</span>(<span class="string">&quot;../views/Mine&quot;</span>)&#125;</span><br></pre></td></tr></table></figure><p>非按需加载则会把所有的路由组件块的js包打在一起。当业务包很大的时候建议用路由的按需加载（懒加载）。 按需加载会在页面第一次请求的时候，把相关路由组件块的js添加上。</p><h2 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h2><h3 id="介绍一下vuex以及使用场景；更改state的方法"><a href="#介绍一下vuex以及使用场景；更改state的方法" class="headerlink" title="介绍一下vuex以及使用场景；更改state的方法"></a>介绍一下vuex以及使用场景；更改state的方法</h3><h3 id="什么是Vuex？"><a href="#什么是Vuex？" class="headerlink" title="什么是Vuex？"></a>什么是Vuex？</h3><p>vuex是一个专门为vue构建的状态集管理工具，vue和react都是基于组件化开发的，项目中包含很多的组件，组件都会有组件嵌套，想让组件中的数据被其他组件也可以访问到就需要使用到Vuex。</p><h3 id="Vuex主要解决了什么问题？"><a href="#Vuex主要解决了什么问题？" class="headerlink" title="Vuex主要解决了什么问题？"></a>Vuex主要解决了什么问题？</h3><p>Vuex主要是为了解决多组件之间状态共享问题，它强调的是集中式管理（组件与组件之间的关系变成了组件与仓库之间的关系）把数据都放在一个仓库中管理，使用数据的时候直接从仓库中获取，如果仓库中一个数据改变了， 那么所有使用这个数据的组件都会更新。Vuex把组件与组件之间的关系解耦成组件与仓库之间的关系，方便数据维护。</p><h3 id="Vuex的流程？Vuex的核心？"><a href="#Vuex的流程？Vuex的核心？" class="headerlink" title="Vuex的流程？Vuex的核心？"></a>Vuex的流程？Vuex的核心？</h3><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200606235904478.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""><br>（1）将需要共享的状态挂载到state上：this.$store.state来调用</p><p>创建store，将状态挂载到state上，在根实例里面配置store，之后我们在组件中就可以通过 this.$store.state 来使用 state 中管理的数据，但是这样使用时，当state的数据更改的时候，vue组件并不会重新渲染，所以我们要通过计算属性computed来使用，但是当我们使用多个数据的时候这种写法比较麻烦，vuex提供了<strong>mapState辅助函数</strong>，帮助我们在组件中获取并使用vuex的store中保存的状态。</p><p>（2）我们通过 <code>getters</code> 来创建状态：通过<code>this.$store.getters</code>来调用</p><p>可以根据某一个状态派生出一个新状态，vuex也提供了 <strong>mapGetters辅助函数</strong> 来帮助我们在组件中使用getters里的状态。</p><p>（3）使用 <code>mutations</code> 来更改state：通过 <code>this.$store.commit</code> 来调用</p><p>我们不能直接在组件中更改state，而是需要使用 <strong>mutations</strong> 来更改，mutations也是一个纯对象，里面包含很多更改state的方法，这些方法的形参接收到state，在函数体里更改，这时，组件用到的数据也会更改，实现响应式。vuex提供了<strong>mapMutations方法</strong>来帮助我们在组件中调用mutations 的方法。</p><p>（4）使用 <code>actions</code> 来处理异步操作：this.$store.dispatch来调用</p><p>Actions类似于mutations，不同在于：Actions提交的是mutations，而不是直接变更状态。Actions可以包含任意异步操作。也就是说，如果有这样的需求：在一个异步操作处理之后，更改状态，我们在组件中应该先调用actions，来进行异步动作，然后由actions调用mutations来更改数据。在组件中通过this.$store.dispatch方法调用actions的方法，当然也可以使用mapMutations来辅助使用。</p><p><strong>简便版流程：</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">组件使用数据且通过异步动作更改数据的一系列事情：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>生成store,设置state</span><br><span class="line"><span class="number">2.</span>在根实例中注入store</span><br><span class="line"><span class="number">3.</span>组件通过计算属性或者mapState来使用状态</span><br><span class="line"><span class="number">4.</span>用户产生操作，调用actions的方法，然后进行异步动作</span><br><span class="line"><span class="number">5.</span>异步动作之后，通过commit调用mutations的方法</span><br><span class="line"><span class="number">6.</span>mutations方法被调用后，更改state</span><br><span class="line"><span class="number">7.</span>state中的数据更新之后，计算属性重新执行来更改在页面中使用的状态</span><br><span class="line"><span class="number">8.</span>组件状态被更改，创建新的虚拟dom</span><br><span class="line"><span class="number">9.</span>组件的模板更新之后重新渲染在dom中</span><br></pre></td></tr></table></figure><h3 id="项目中使用到vuex的一些场景？"><a href="#项目中使用到vuex的一些场景？" class="headerlink" title="项目中使用到vuex的一些场景？"></a>项目中使用到vuex的一些场景？</h3><p>（1）购物车数据共享<br>（2）用户登录<br>（3）打开窗口，出现一个表单数据，然后关闭窗口，再次打开还想出现，就使用vuex</p><h3 id="Vuex的项目结构"><a href="#Vuex的项目结构" class="headerlink" title="Vuex的项目结构"></a>Vuex的项目结构</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">├── index.html</span><br><span class="line">├── main.js</span><br><span class="line">├── api</span><br><span class="line">│   └── ... # 抽取出API请求</span><br><span class="line">├── components</span><br><span class="line">│   ├── App.vue</span><br><span class="line">│   └── ...</span><br><span class="line">└── store</span><br><span class="line">    ├── index.js          # 我们组装模块并导出 store 的地方</span><br><span class="line">    ├── actions.js        # 根级别的 action</span><br><span class="line">    ├── mutations.js      # 根级别的 mutation</span><br><span class="line">    └── modules</span><br><span class="line">        ├── cart.js       # 购物车模块</span><br><span class="line">        └── products.js   # 产品模块</span><br></pre></td></tr></table></figure><h3 id="vuex与local-storage有什么区别"><a href="#vuex与local-storage有什么区别" class="headerlink" title="vuex与local storage有什么区别"></a>vuex与local storage有什么区别</h3><ul><li>区别：vuex存储在内存，localstorage（本地存储）则以文件的方式存储在本地，永久保存；sessionstorage( 会话存储 ) ，临时保存。localStorage和sessionStorage只能存储字符串类型，对于复杂的对象可以使用ECMAScript提供的JSON对象的stringify和parse来处理。</li><li>应用场景：vuex用于组件之间的传值，localstorage，sessionstorage则主要用于不同页面之间的传值。</li><li>永久性：当刷新页面（这里的刷新页面指的是 –&gt; F5刷新,属于清除内存了）时vuex存储的值会丢失，sessionstorage页面关闭后就清除掉了，localstorage不会。</li></ul><p>注：觉得用localstorage可以代替vuex,  对于不变的数据确实可以，但是当两个组件共用一个数据源（对象或数组）时，如果其中一个组件改变了该数据源，希望另一个组件响应该变化时，localstorage，sessionstorage无法做到，原因就是区别1。</p><h3 id="vue组件之间的通信"><a href="#vue组件之间的通信" class="headerlink" title="vue组件之间的通信"></a>vue组件之间的通信</h3><p>在vue中。组件间进行数据传递、通信很频繁，而父子组件和非父子组件的通信功能也比较完善，但是，唯一困难的就是多组件间的数据共享，这个问题由vuex来处理</p><p><a href="https://juejin.im/post/5deac42d518825124a05ae98#heading-13">推荐阅读：VUE组件通信的十种姿势</a></p><h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><h3 id="storge介绍一下，有什么区别？和cookie的区别是什么？cookie的字段介绍一下；"><a href="#storge介绍一下，有什么区别？和cookie的区别是什么？cookie的字段介绍一下；" class="headerlink" title="storge介绍一下，有什么区别？和cookie的区别是什么？cookie的字段介绍一下；"></a>storge介绍一下，有什么区别？和cookie的区别是什么？cookie的字段介绍一下；</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">cookie  4kb 随http请求发送到服务端 后端可以帮助前端设置cookie </span><br><span class="line">session 放在服务端  一般存放用户比较重要的信息</span><br><span class="line">        （token 令牌  token ==&gt; cookie /localstorage）  vuex</span><br><span class="line"></span><br><span class="line"><span class="built_in">localStorage</span> 本地存储（h5的新特性 draggable canvas svg）</span><br><span class="line">             5M     纯粹在本地客户端  多个标签页共享数据</span><br><span class="line">             sessionStorage  会话级别的存储</span><br><span class="line">             往本地页面中存值的方法（<span class="built_in">localStorage</span>.setItem(key,value))</span><br></pre></td></tr></table></figure><h3 id="讲一下cookie、sessionstorage、localstorage"><a href="#讲一下cookie、sessionstorage、localstorage" class="headerlink" title="讲一下cookie、sessionstorage、localstorage"></a>讲一下cookie、sessionstorage、localstorage</h3><p>相同点：都存储在客户端</p><p>不同点：</p><p>1.存储大小</p><ul><li>cookie数据大小不能超过4k。</li><li>sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。</li></ul><p>2.有效时间</p><ul><li>localStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；</li><li>sessionStorage 数据在当前浏览器窗口关闭后自动删除。</li><li>cookie 设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭</li></ul><p>3.数据与服务器之间的交互方式</p><ul><li>cookie的数据会自动的传递到服务器，服务器端也可以写cookie到客户端</li><li>sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。</li></ul><h3 id="定义一个对象，里面包含用户名、电话，然后将其存入localStorage的代码"><a href="#定义一个对象，里面包含用户名、电话，然后将其存入localStorage的代码" class="headerlink" title="定义一个对象，里面包含用户名、电话，然后将其存入localStorage的代码"></a>定义一个对象，里面包含用户名、电话，然后将其存入localStorage的代码</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> json = &#123;<span class="attr">username</span>:<span class="string">&quot;张三&quot;</span>,<span class="attr">phone</span>:<span class="number">17650246248</span>&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> json)&#123;</span><br><span class="line">    <span class="built_in">localStorage</span>.setItem(key,json[key]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://hanxueqing.github.io/Web-Front-end-Interview-Q-A/#/?id=cookie%e5%92%8csession%e7%9a%84%e5%8c%ba%e5%88%ab">推荐阅读：cookie和session的区别</a></p><h3 id="介绍一下同源策略"><a href="#介绍一下同源策略" class="headerlink" title="介绍一下同源策略"></a>介绍一下同源策略</h3><p>所谓同源是指：域名、协议、端口相同。</p><p>下表是相对于 <code>http://www.laixiangran.cn/home/index.html</code>的同源检测结果：</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/2020060708574199.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""><br>另外，同源策略又分为以下两种：</p><ul><li>DOM 同源策略：禁止对不同源页面 DOM 进行操作。这里主要场景是 iframe 跨域的情况，不同域名的 iframe 是限制互相访问的。</li><li>XMLHttpRequest 同源策略：禁止使用 XHR 对象向不同源的服务器地址发起 HTTP 请求。</li></ul><p><a href="https://juejin.im/post/5ba1d4fe6fb9a05ce873d4ad">推荐阅读：浏览器同源策略及跨域的解决方法</a></p><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><h3 id="TCP和UDP区别，UDP怎么保证传输可靠"><a href="#TCP和UDP区别，UDP怎么保证传输可靠" class="headerlink" title="TCP和UDP区别，UDP怎么保证传输可靠"></a>TCP和UDP区别，UDP怎么保证传输可靠</h3><p><strong>TCP与UDP区别总结</strong>：</p><p>1、TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接</p><p>2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付<br>3、TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的<br>UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）<br>4、每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信<br>5、TCP首部开销20字节;UDP的首部开销小，只有8个字节<br>6、TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道</p><p><strong>UDP如何实现可靠传输</strong></p><p>由于在传输层UDP已经是不可靠的连接，那就要在应用层自己实现一些保障可靠传输的机制</p><p>简单来讲，要使用UDP来构建可靠的面向连接的数据传输，就要实现类似于TCP协议的</p><ul><li>超时重传（定时器）</li><li>有序接受 （添加包序号）</li><li>应答确认 （Seq/Ack应答机制）</li><li>滑动窗口流量控制等机制 （滑动窗口协议）</li></ul><p>等于说要在传输层的上一层（或者直接在应用层）实现TCP协议的可靠数据传输机制，比如使用UDP数据包+序列号，UDP数据包+时间戳等方法。</p><p>目前已经有一些实现UDP可靠传输的机制，比如</p><p><strong>UDT（UDP-based Data Transfer Protocol）</strong></p><p>基于UDP的数据传输协议（UDP-based Data Transfer Protocol，简称UDT）是一种互联网数据传输协议。UDT的主要目的是支持高速广域网上的海量数据传输，而互联网上的标准数据传输协议TCP在高带宽长距离网络上性能很差。 顾名思义，UDT建于UDP之上，并<strong>引入新的拥塞控制和数据可靠性控制机制</strong>。UDT是<strong>面向连接的双向的应用层协议</strong>。它同时<strong>支持可靠的数据流传输和部分可靠的数据报传输</strong>。 由于UDT完全在UDP上实现，它也可以应用在除了高速数据传输之外的其它应用领域，例如点到点技术（P2P），防火墙穿透，多媒体数据传输等等。</p><h3 id="用户登陆后如何记住用户的登录状态"><a href="#用户登陆后如何记住用户的登录状态" class="headerlink" title="用户登陆后如何记住用户的登录状态"></a>用户登陆后如何记住用户的登录状态</h3><p><a href="https://segmentfault.com/a/1190000019065025">推荐阅读：Cookie、Session是如何保持登录状态的？</a></p><h3 id="cookie字段说明"><a href="#cookie字段说明" class="headerlink" title="cookie字段说明"></a>cookie字段说明</h3><ul><li><p>name字段为一个cookie的名称。</p></li><li><p>value字段为一个cookie的值。</p></li><li><p>domain字段为可以访问此cookie的域名。<br>非顶级域名，如二级域名或者三级域名，设置的cookie的domain只能为顶级域名或者二级域名或者三级域名本身，不能设置其他二级域名的cookie，否则cookie无法生成。<br>顶级域名只能设置domain为顶级域名，不能设置为二级域名或者三级域名，否则cookie无法生成。<br>二级域名能读取设置了domain为顶级域名或者自身的cookie，不能读取其他二级域名domain的cookie。所以要想cookie在多个二级域名中共享，需要设置domain为顶级域名，这样就可以在所有二级域名里面或者到这个cookie的值了。<br>顶级域名只能获取到domain设置为顶级域名的cookie，其他domain设置为二级域名的无法获取。</p></li><li><p>path字段为可以访问此cookie的页面路径。 比如domain是abc.com,path是/test，那么只有/test路径下的页面可以读取此cookie。</p></li><li><p>expires/Max-Age 字段为此cookie超时时间。若设置其值为一个时间，那么当到达此时间后，此cookie失效。不设置的话默认值是Session，意思是cookie会和session一起失效。当浏览器关闭(不是浏览器标签页，而是整个浏览器) 后，此cookie失效。</p></li><li><p>Size字段 此cookie大小。</p></li><li><p>http字段 cookie的httponly属性。若此属性为true，则只有在http请求头中会带有此cookie的信息，而不能通过document.cookie来访问此cookie。</p></li><li><p>secure 字段 设置是否只能通过https来传递此条cookie</p></li></ul><h3 id="浏览器怎么识别cookie是否过期？不同网站如何获取不同的cookie"><a href="#浏览器怎么识别cookie是否过期？不同网站如何获取不同的cookie" class="headerlink" title="浏览器怎么识别cookie是否过期？不同网站如何获取不同的cookie"></a>浏览器怎么识别cookie是否过期？不同网站如何获取不同的cookie</h3><p><a href="https://juejin.im/entry/5a29fffa51882531ba10da1c">推荐阅读：这一次带你彻底了解Cookie</a></p><p><a href="https://zhuanlan.zhihu.com/p/42370557">推荐阅读：计算机网络|Cookie全方面总结</a></p><p><a href="https://zhuanlan.zhihu.com/p/79819678">推荐阅读：一文带你超详细了解Cookie</a></p><h3 id="CSRF攻击知道吗？原理是什么？在后端如何防范？"><a href="#CSRF攻击知道吗？原理是什么？在后端如何防范？" class="headerlink" title="CSRF攻击知道吗？原理是什么？在后端如何防范？"></a>CSRF攻击知道吗？原理是什么？在后端如何防范？</h3><p><a href="https://www.jianshu.com/p/b99dc31f1e9f">推荐阅读：CSRF 攻击是什么？如何防范?</a></p><p><a href="https://juejin.im/post/5bc009996fb9a05d0a055192">推荐阅读：前端安全系列之二：如何防止CSRF攻击？</a></p><p><strong>后端如何防范：</strong></p><p><strong>同源检测</strong></p><p>既然CSRF大多来自第三方网站，那么我们就直接禁止外域（或者不受信任的域名）对我们发起请求。</p><p>在HTTP协议中，每一个异步请求都会携带两个Header，用于标记来源域名：</p><ul><li>Origin Header</li><li>Referer Header</li></ul><p>这两个Header在浏览器发起请求时，大多数情况会自动带上，并且不能由前端自定义内容。 服务器可以通过解析这两个Header中的域名，确定请求的来源域。</p><h3 id="网络分层模型，协议，TCP与UDP，TCP三次握手，四次挥手"><a href="#网络分层模型，协议，TCP与UDP，TCP三次握手，四次挥手" class="headerlink" title="网络分层模型，协议，TCP与UDP，TCP三次握手，四次挥手"></a>网络分层模型，协议，TCP与UDP，TCP三次握手，四次挥手</h3><p><a href="https://juejin.im/post/5c8d1d7951882501c817b2b6">推荐阅读：不要再让TCP协议及三次握手、四次挥手掉分了</a></p><p><a href="https://juejin.im/post/5eabcfde5188256d72314515#heading-58">推荐阅读：TCP三次握手，两次行不行，四次行不行，四次挥手？</a></p><h3 id="https，对称加密，非对称加密，怎么检测公钥"><a href="#https，对称加密，非对称加密，怎么检测公钥" class="headerlink" title="https，对称加密，非对称加密，怎么检测公钥"></a>https，对称加密，非对称加密，怎么检测公钥</h3><p><a href="https://juejin.im/post/5e6c4458518825491b11e082">推荐阅读：看完这篇 HTTPS，和面试官扯皮就没问题了</a></p><h2 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h2><h3 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h3><p><a href="https://juejin.im/entry/5ad86c16f265da505a77dca4">推荐阅读：彻底理解浏览器的缓存机制</a></p><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><h3 id="Promises-A-规范"><a href="#Promises-A-规范" class="headerlink" title="Promises/A+ 规范"></a>Promises/A+ 规范</h3><p><a href="https://juejin.im/post/5c4b0423e51d4525211c0fbc">推荐阅读：【译】 Promises/A+ 规范</a></p><p><a href="https://juejin.im/post/5d37abf7e51d45108223fd49">推荐阅读：如何优雅地处理 Async / Await 的异常？</a></p><h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><h3 id="JSON数据格式介绍一下，JS转JSON时要注意什么？对象转为JSON什么情况下JSON-stringfy会报错？"><a href="#JSON数据格式介绍一下，JS转JSON时要注意什么？对象转为JSON什么情况下JSON-stringfy会报错？" class="headerlink" title="JSON数据格式介绍一下，JS转JSON时要注意什么？对象转为JSON什么情况下JSON.stringfy会报错？"></a>JSON数据格式介绍一下，JS转JSON时要注意什么？对象转为JSON什么情况下JSON.stringfy会报错？</h3><p><a href="https://juejin.im/post/5be5b9f8518825512f58ba0e">推荐阅读：有意思的JSON.parse（）、JSON.stringify（）<br></a></p><p><a href="https://blog.csdn.net/u011277123/article/details/53055479">推荐阅读：使用JSON.parse()转化成json对象需要注意的地方</a></p><p>简单说一下JSON格式,JSON格式就是一种表示一系列的“值”的方法，这些值包含在数组或对象之中，是它们的成员。<br>对于这一系列的“值”，有如下几点格式规定：</p><ul><li>数组或对象的每个成员的值，可以是简单值，也可以是复合值。</li><li>简单值分为四种：字符串、数值（必须以十进制表示）、布尔值和<code>null（NaN, Infinity, -Infinity和undefined都会被转为null）</code>。</li><li>复合值分为两种：符合<code>JSON</code>格式的对象和符合<code>JSON</code>格式的数组。</li><li>数组或对象最后一个成员的后面，不能加逗号。</li><li>数组或对象之中的字符串必须使用双引号，不能使用单引号。</li><li>对象的成员名称必须使用双引号。</li></ul><p>以下是合格的<code>JSON</code>值:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>]</span><br><span class="line"></span><br><span class="line">&#123; <span class="string">&quot;one&quot;</span>: <span class="number">1</span>, <span class="string">&quot;two&quot;</span>: <span class="number">2</span>, <span class="string">&quot;three&quot;</span>: <span class="number">3</span> &#125;</span><br><span class="line"></span><br><span class="line">&#123;<span class="string">&quot;names&quot;</span>: [<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;李四&quot;</span>] &#125;</span><br><span class="line"></span><br><span class="line">[ &#123; <span class="string">&quot;name&quot;</span>: <span class="string">&quot;张三&quot;</span>&#125;, &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;李四&quot;</span>&#125; ]</span><br></pre></td></tr></table></figure><p><strong>注意</strong>⚠️：</p><blockquote><p>空数组和空对象都是合格的JSON值，null本身也是一个合格的JSON值。</p></blockquote><p>如下定义(原文中的例子)是无法通过编译的：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = &#123; <span class="attr">b</span>: foo &#125;;</span><br></pre></td></tr></table></figure><p>错误信息：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ReferenceError</span>: foo is not defined</span><br><span class="line">    at repl:<span class="number">1</span>:<span class="number">14</span></span><br></pre></td></tr></table></figure><p>例子：<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200607092956548.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><h3 id="为什么有些属性无法被-stringify-呢？"><a href="#为什么有些属性无法被-stringify-呢？" class="headerlink" title="为什么有些属性无法被 stringify 呢？"></a>为什么有些属性无法被 stringify 呢？</h3><p>因为 JSON 是一个通用的文本格式，和语言无关。设想如果将函数定义也 stringify 的话，如何判断是哪种语言，并且通过合适的方式将其呈现出来将会变得特别复杂。特别是和语言相关的一些特性，比如 JavaScript 中的 Symbol。</p><p>ECMASCript 官方也特意强调了这一点：</p><blockquote><p>It does not attempt to impose ECMAScript’s internal data representations on other programming languages. Instead, it shares a small subset of ECMAScript’s textual representations with all other programming languages.</p></blockquote><h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><h3 id="CSS的尺寸单位，分别介绍一下；移动端适配可以用哪些单位？"><a href="#CSS的尺寸单位，分别介绍一下；移动端适配可以用哪些单位？" class="headerlink" title="CSS的尺寸单位，分别介绍一下；移动端适配可以用哪些单位？"></a>CSS的尺寸单位，分别介绍一下；移动端适配可以用哪些单位？</h3><p><a href="https://zhuanlan.zhihu.com/p/47693900">推荐阅读：对于前端页面适配，你应该使用px还是rem</a></p><p>css中的单位很多，%、px、em、rem，以及比较新的vw、vh等。每个单位都有特定的用途，比如当需要设置一个矩形的宽高比为16:9，并且随屏幕宽度自适应时，除了用%，其他单位是很难做到的。所以不存在说某个单位是错误的，某个单位是最好的这种说法。</p><p>页面适配的方式有很多：</p><ul><li>使用px，结合Media Query进行阶梯式的适配；</li><li>使用%，按百分比自适应布局；</li><li>使用rem，结合html元素的font-size来根据屏幕宽度适配；</li><li>使用vw、vh，直接根据视口宽高适配。</li></ul><p><strong>经验之道</strong>：</p><p>在视觉稿要求固定尺寸的元素上使用px。比如1px线，4px的圆角边框。<br>在字号、（大多数）间距上使用rem。<br>慎用em（em会<strong>叠加计算</strong>。在这个机制下太容易犯错了，因为你不知道这段css指定的字号具体是多少。）</p><h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><h3 id="dom事件流，事件监听在什么阶段触发？dom上直接设置onclick跟addeventlistener的区别"><a href="#dom事件流，事件监听在什么阶段触发？dom上直接设置onclick跟addeventlistener的区别" class="headerlink" title="dom事件流，事件监听在什么阶段触发？dom上直接设置onclick跟addeventlistener的区别"></a>dom事件流，事件监听在什么阶段触发？dom上直接设置onclick跟addeventlistener的区别</h3><p><code>addEventListener</code> 默认 <code>false</code> 冒泡</p><p><a href="https://segmentfault.com/a/1190000018454775">推荐阅读：Dom 事件详解</a></p><p><a href="https://juejin.im/post/5c71e80d51882562547bb0ce">推荐阅读：深入理解DOM事件机制</a></p><p><a href="https://juejin.im/post/5d25c4cbe51d454f71439d6f">推荐阅读：一篇文章能否解决你事件监听的许多疑问</a></p><h2 id="编程题"><a href="#编程题" class="headerlink" title="编程题"></a>编程题</h2><h3 id="EventEmitter的实现"><a href="#EventEmitter的实现" class="headerlink" title="EventEmitter的实现"></a>EventEmitter的实现</h3><p>EventEmitter的实现。要求：两个方法on(eventname,callback),trigger(eventname,params)，on绑定可以给eventname绑定多个callback，trigger触发eventname的callback，params是参数。另外口述了如何实现once功能（callback只允许调用一次）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">EventEmitter</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.eventList = &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">EventEmitter.prototype.on = <span class="function"><span class="keyword">function</span>(<span class="params">eventname, callback</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">this</span>.eventList[eventname]) &#123;</span><br><span class="line">       <span class="built_in">this</span>.eventList[eventname] = [callback]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.eventList[eventname].push(callback)</span><br><span class="line">&#125;</span><br><span class="line">EventEmitter.prototype.trigger = <span class="function"><span class="keyword">function</span>(<span class="params">eventname, params</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">this</span>.eventList[eventname])&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.eventList[eventname].length; i++) &#123;</span><br><span class="line">            <span class="built_in">this</span>.eventList[eventname][i](params)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><h3 id="Vue生命周期"><a href="#Vue生命周期" class="headerlink" title="Vue生命周期"></a>Vue生命周期</h3><p><a href="https://hanxueqing.github.io/Web-Front-end-Interview-Q-A/#/?id=%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f">推荐阅读：生命周期</a></p><h3 id="Vue中的computed和watch的区别"><a href="#Vue中的computed和watch的区别" class="headerlink" title="Vue中的computed和watch的区别"></a>Vue中的computed和watch的区别</h3><p><a href="https://juejin.im/post/5c9990d6f265da60ea146d21">推荐阅读：面试题： Vue中的 computed 和 watch的区别</a></p><h2 id="WebPack"><a href="#WebPack" class="headerlink" title="WebPack"></a>WebPack</h2><h3 id="webpack实现代码拆分的方式有哪些"><a href="#webpack实现代码拆分的方式有哪些" class="headerlink" title="webpack实现代码拆分的方式有哪些"></a>webpack实现代码拆分的方式有哪些</h3><p>webpack通过下面三种方式来达到以上目的</p><ul><li>Entry Points: 多入口分开打包</li><li>Prevent Duplication:去重，抽离公共模块和第三方库（通过CommonsChunkPlugin插件）</li><li>Dynamic Imports:动态加载（ECMAScript中出于提案状态的import()）</li></ul><p><a href="https://juejin.im/post/5a6d7eeef265da3e4d72f1f9">推荐阅读：webpack之代码拆分</a></p><h2 id="移动端"><a href="#移动端" class="headerlink" title="移动端"></a>移动端</h2><h3 id="移动端适配，rem原理"><a href="#移动端适配，rem原理" class="headerlink" title="移动端适配，rem原理"></a>移动端适配，rem原理</h3><p><a href="https://juejin.im/post/5da82357518825486c66f5e1">推荐阅读：移动端rem、vw等手机适配原理详解</a></p><p>什么是rem？<br>REM是相对单位，是相对HTML根元素，rem就是根元素html的字体大小，其他元素调用rem，能统一根据这个适配比例进行调整。</p><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="手撕发布订阅模式-EventEmitter"><a href="#手撕发布订阅模式-EventEmitter" class="headerlink" title="手撕发布订阅模式 EventEmitter"></a>手撕发布订阅模式 EventEmitter</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 发布订阅模式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventEmitter</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 事件对象，存放订阅的名字和事件  如:  &#123; click: [ handle1, handle2 ]  &#125;</span></span><br><span class="line">    <span class="built_in">this</span>.events = &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 订阅事件的方法</span></span><br><span class="line">  <span class="function"><span class="title">on</span>(<span class="params">eventName, callback</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.events[eventName]) &#123;</span><br><span class="line">      <span class="comment">// 一个名字可以订阅多个事件函数</span></span><br><span class="line">      <span class="built_in">this</span>.events[eventName] = [callback]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 存在则push到指定数组的尾部保存</span></span><br><span class="line">      <span class="built_in">this</span>.events[eventName].push(callback)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 触发事件的方法</span></span><br><span class="line">  <span class="function"><span class="title">emit</span>(<span class="params">eventName, ...rest</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 遍历执行所有订阅的事件</span></span><br><span class="line">    <span class="built_in">this</span>.events[eventName] &amp;&amp;</span><br><span class="line">      <span class="built_in">this</span>.events[eventName].forEach(<span class="function"><span class="params">f</span> =&gt;</span> f.apply(<span class="built_in">this</span>, rest))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 移除订阅事件</span></span><br><span class="line">  <span class="function"><span class="title">remove</span>(<span class="params">eventName, callback</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.events[eventName]) &#123;</span><br><span class="line">      <span class="built_in">this</span>.events[eventName] = <span class="built_in">this</span>.events[eventName].filter(<span class="function"><span class="params">f</span> =&gt;</span> f != callback)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 只执行一次订阅的事件，然后移除</span></span><br><span class="line">  <span class="function"><span class="title">once</span>(<span class="params">eventName, callback</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 绑定的时fn, 执行的时候会触发fn函数</span></span><br><span class="line">    <span class="keyword">const</span> fn = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      callback() <span class="comment">// fn函数中调用原有的callback</span></span><br><span class="line">      <span class="built_in">this</span>.remove(eventName, fn) <span class="comment">// 删除fn, 再次执行的时候之后执行一次</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.on(eventName, fn)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;~~删除线格式~~ </span><br></pre></td></tr></table></figure><h2 id="介绍项目及难题"><a href="#介绍项目及难题" class="headerlink" title="介绍项目及难题"></a>介绍项目及难题</h2><p><a href="https://juejin.im/post/5a5d926cf265da3e3f4cb030">推荐阅读：Nuxt.js实战</a></p><h3 id="Nuxt-js"><a href="#Nuxt-js" class="headerlink" title="Nuxt.js"></a>Nuxt.js</h3><p>Nuxt.js 是一个基于 Vue.js 的通用应用框架，它预设了利用 Vue.js 开发 <strong>服务端渲染（SSR, Server Side Render）</strong> 的应用所需要的各种配置，同时也可以一键生成静态站点。</p><p>作为框架，Nuxt.js 为 客户端/服务端 这种典型的应用架构模式提供了许多有用的特性，例如异步数据加载、中间件支持、布局支持等。区别于其他 vue SSR 框架，Nuxt.js 有以下比较明显的特性。</p><ul><li>自动代码分层</li><li>强大的路由功能，支持异步数据（路由无需额外配置）</li><li>HTML头部标签管理（依赖 vue-meta 实现）</li><li>内置 webpack 配置，无需额外配置</li></ul><h3 id="Express-VS-Koa"><a href="#Express-VS-Koa" class="headerlink" title="Express VS Koa"></a>Express VS Koa</h3><p><a href="https://juejin.im/entry/58a11f61128fe1005823a257">推荐阅读：Node.js 框架对比之 Express VS Koa（2017）</a></p><h3 id="服务端渲染-SSR"><a href="#服务端渲染-SSR" class="headerlink" title="服务端渲染 SSR"></a>服务端渲染 SSR</h3><p><a href="https://juejin.im/post/5c068fd8f265da61524d2abc">推荐阅读：服务端渲染（SSR)</a></p><h2 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h2><h3 id="script中defer和async的区别"><a href="#script中defer和async的区别" class="headerlink" title="script中defer和async的区别"></a>script中defer和async的区别</h3><p><a href="https://juejin.im/post/5a1229596fb9a0451704cae8">推荐阅读：script中defer和async的区别</a></p><ul><li><p>对于defer，我们可以认为是将外链的js放在了页面底部。js的加载不会阻塞页面的渲染和资源的加载。不过defer会按照原本的js的顺序执行，所以如果前后有依赖关系的js可以放心使用。</p></li><li><p>对于async，这个是html5中新增的属性，它的作用是能够异步的加载和执行脚本，不因为加载脚本而阻塞页面的加载。一旦加载到就会立刻执行在有async的情况下，js一旦下载好了就会执行，所以很有可能不是按照原本的顺序来执行的。如果js前后有依赖性，用async，就很有可能出错。</p></li></ul><p>简单的来说，使用这两个属性会有三种可能的情况</p><ul><li>如果async为true，那么脚本在下载完成后异步执行。</li><li>如果async为false，defer为true，那么脚本会在页面解析完毕之后执行。</li><li>如果async和defer都为false，那么脚本会在页面解析中，停止页面解析，立刻下载并且执行。</li></ul><p>最后给一点个人的建议，无论使用defer还是async属性，都需要首先将页面中的js文件进行整理，哪些文件之间有依赖性，哪些文件可以延迟加载等等，做好js代码的合并和拆分，然后再根据页面需要使用这两个属性。</p>]]></content>
      
      
      <categories>
          
          <category> 面试整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 春招 </tag>
            
            <tag> 字节跳动 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【字节跳动】前端一面面经</title>
      <link href="posts/2020611/"/>
      <url>posts/2020611/</url>
      
        <content type="html"><![CDATA[<h2 id="投递初"><a href="#投递初" class="headerlink" title="投递初"></a>投递初</h2><p>春招过去了，面了两次腾讯，两次一面直接gg，但这两份经历对我是有很大帮助的，体会到了一定差距。但在6月份，看了牛客网讨论区，又发现了字节跳动一直在招人，从未停止过，而且正好某天瞧见了内推码，于是乎，我又想尝试一下了，赶紧迭代一下简历，投！投！投！</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200608220737688.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><h3 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h3><p>1、计算机、软件相关专业；<br>2、熟悉HTML, CSS, JavaScript和HTTP协议基本知识；<br>3、熟悉常用的数据结构以及其使用场景；<br>4、有参与设计和实现的项目（无论大小）；<br>5、了解浏览器调试工具；<br>6、有强烈的求知欲和进取心，具有扎实的编程功底，良好的编程习惯。</p><h3 id="加分项："><a href="#加分项：" class="headerlink" title="加分项："></a>加分项：</h3><p>1、有过数据可视化相关经验；<br>2、了解JavaScript依赖管理；<br>3、了解Webpack, React, SASS, ES6基本原理以及它们解决的问题；<br>4、了解过不限于Node.js, Python, Ruby的任意一门脚本语言；<br>5、有Github账号并有项目。</p><h2 id="投递完"><a href="#投递完" class="headerlink" title="投递完"></a>投递完</h2><p>不得不说，字节的处理效率真的是高，2号投的，3号就收到了HR小姐姐的电话询问，简单询问做过什么项目，用的是什么技术栈，然后有没有用过React，最后一句：如果后续简历通过了，我们会联系您进行面试。</p><p>然后再5号，下午还在做网络安全的实验，就收到微信消息，HR小姐姐加我然后跟我约下周面试时间。最后，选择了8号（周一）晚上7点30约一面，话不多说，我们进入正题。</p><h2 id="面经"><a href="#面经" class="headerlink" title="面经"></a>面经</h2><h3 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h3><p>熟悉的开头，这里就不多说了，跳过…</p><h3 id="地址栏输入url，然后经历了什么，浏览器此时又经历了什么"><a href="#地址栏输入url，然后经历了什么，浏览器此时又经历了什么" class="headerlink" title="地址栏输入url，然后经历了什么，浏览器此时又经历了什么"></a>地址栏输入url，然后经历了什么，浏览器此时又经历了什么</h3><h4 id="从URL输入到页面展现到底发生什么？"><a href="#从URL输入到页面展现到底发生什么？" class="headerlink" title="从URL输入到页面展现到底发生什么？"></a>从URL输入到页面展现到底发生什么？</h4><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p><a href="https://segmentfault.com/a/1190000017184701">推荐阅读：从URL输入到页面展现到底发生什么？</a></p><p><a href="https://juejin.im/post/5ed0d289e51d45783d0ea4b7">推荐阅读：前端面试：http专场，你需要懂的知识</a></p><p><a href="https://juejin.im/post/5e76bd516fb9a07cce750746">推荐阅读：（建议精读）HTTP灵魂之问，巩固你的 HTTP 知识体系</a></p></div></div><h4 id="浏览器解析渲染页面"><a href="#浏览器解析渲染页面" class="headerlink" title="浏览器解析渲染页面"></a>浏览器解析渲染页面</h4><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>浏览器解析渲染页面分为一下五个步骤：</p><ul><li>根据 HTML 解析出 DOM 树</li><li>根据 CSS 解析生成 CSS 规则树</li><li>结合 DOM 树和 CSS 规则树，生成渲染树</li><li>根据渲染树计算每一个节点的信息</li><li>根据计算好的信息绘制页面</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200611195126904.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""><br><a href="https://segmentfault.com/a/1190000017184701">推荐阅读：从URL输入到页面展现到底发生什么？</a></p></div></div><h3 id="看了我的简历，说使用过Koa2，提出为什么要使用Koa2，怎么不用express呢？"><a href="#看了我的简历，说使用过Koa2，提出为什么要使用Koa2，怎么不用express呢？" class="headerlink" title="看了我的简历，说使用过Koa2，提出为什么要使用Koa2，怎么不用express呢？"></a>看了我的简历，说使用过Koa2，提出为什么要使用Koa2，怎么不用express呢？</h3><p><a href="https://github.com/Chocolate1999/Vue-family-bucket-SSR-Koa2-full-stack-development-from-Meituan">项目地址（传送门）</a></p><h3 id="Koa2中间件你了解过嘛？"><a href="#Koa2中间件你了解过嘛？" class="headerlink" title="Koa2中间件你了解过嘛？"></a>Koa2中间件你了解过嘛？</h3><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"></div></div><h3 id="项目中有提到用户数据-amp-状态，然后问：你登录拦截有具体了解怎么实现的么？"><a href="#项目中有提到用户数据-amp-状态，然后问：你登录拦截有具体了解怎么实现的么？" class="headerlink" title="项目中有提到用户数据&amp;状态，然后问：你登录拦截有具体了解怎么实现的么？"></a>项目中有提到用户数据&amp;状态，然后问：你登录拦截有具体了解怎么实现的么？</h3><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>其实，面试官就是看到了这样一句话：</p><blockquote><p>浏览器发送一个 request 请求，根据 cookie ，服务器通过 passport 与 redis来验证当前是否是登录状态，返回 username。</p></blockquote><p>主要是项目忘了，我就提了一句用了passport中的一个函数，isAu…来着的，<del>单词不会读</del>  </p></div></div><p>面试官也是觉得可能再问下去没啥必要了，就说，我们来搞点基础吧~</p><p>主要是三大模块，CSS，JS，算法</p><h3 id="考察CSS"><a href="#考察CSS" class="headerlink" title="考察CSS"></a>考察CSS</h3><h4 id="css样式优先级，以及渲染过程"><a href="#css样式优先级，以及渲染过程" class="headerlink" title="css样式优先级，以及渲染过程"></a>css样式优先级，以及渲染过程</h4><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><ul><li>内联样式(例如, style=”…”)</li><li>ID选择器(例如, #example)</li><li>类选择器(例如, .example)、属性选择器(例如, [type=”radio”])、伪类(例如, :hover)</li><li>类型选择器(例如, h1)、伪元素(例如, ::before)</li><li>继承的样式</li></ul><p><a href="https://juejin.im/post/5c7003e8f265da2d864b3e3c">推荐阅读：CSS 技巧篇(五)：理解CSS优先级</a></p></div></div><h4 id="下面样式是怎样渲染的"><a href="#下面样式是怎样渲染的" class="headerlink" title="下面样式是怎样渲染的"></a>下面样式是怎样渲染的</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">.container .inner div&#123;</span><br><span class="line">width: 100px;</span><br><span class="line">height: 100px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>我说的是从右到左，这确实是没有问题的，面试官反问，为什么？ 其实道理很简单，如果先渲染container，怎么找inner呢？我说了全部遍历一遍，然后又说了如果是从右到左的话，就会少一些查找。</p></div></div><h4 id="下面代码，父级元素container高度是多少？"><a href="#下面代码，父级元素container高度是多少？" class="headerlink" title="下面代码，父级元素container高度是多少？"></a>下面代码，父级元素container高度是多少？</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;container&quot;</span>&gt;</span><br><span class="line">        &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;inner&quot;</span>/&gt;</span><br><span class="line">        &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;inner&quot;</span>/&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">.container &#123;</span><br><span class="line">    border: 1px;</span><br><span class="line">&#125;</span><br><span class="line">.inner &#123;</span><br><span class="line">    margin: 10px;</span><br><span class="line">    height=width: 10px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>我自己重新写了一个比较好理解的代码，具体如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;en&quot;</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;meta name=<span class="string">&quot;viewport&quot;</span> content=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;    </span><br><span class="line">    .container &#123;</span><br><span class="line">        border: 1px;</span><br><span class="line">    &#125;</span><br><span class="line">    .inner1 &#123;</span><br><span class="line">        margin: 10px;</span><br><span class="line">        height: 10px;</span><br><span class="line">        width: 10px;</span><br><span class="line">        background: red;</span><br><span class="line">    &#125;</span><br><span class="line">    .inner2 &#123;</span><br><span class="line">        margin: 10px;</span><br><span class="line">        height: 10px;</span><br><span class="line">        width: 10px;</span><br><span class="line">        background: blue;</span><br><span class="line">    &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;container&quot;</span>&gt;</span><br><span class="line">        &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;inner1&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">        &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;inner2&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>查看结果，高度为50px</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200608232207780.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><p>面试官然后又添加了浮动，再问父级元素高度</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;container&quot;</span>&gt;</span><br><span class="line">        &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;inner&quot;</span>/&gt;</span><br><span class="line">        &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;inner&quot;</span>/&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">.container &#123;</span><br><span class="line">    border: 1px;</span><br><span class="line">&#125;</span><br><span class="line">.inner &#123;</span><br><span class="line">    float: left;</span><br><span class="line">    margin: 10px;</span><br><span class="line">    height=width: 10px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看结果，高度为0px，此时就出现了一个高度塌陷问题。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200610213703597.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><p>因为子元素设置了浮动，导致父级元素高度没有算进去。通过以下方式即可清楚浮动，形成一个BFC，就会加上子集元素的高度。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span>;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新打开开发者工具（F12），可以看到父级元素有了高度。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200610214802572.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p></div></div><h4 id="100px直径的圆你怎么画？"><a href="#100px直径的圆你怎么画？" class="headerlink" title="100px直径的圆你怎么画？"></a>100px直径的圆你怎么画？</h4><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p><a href="https://juejin.im/post/5d3810fd6fb9a07ed13716d9#heading-6">推荐阅读：趣味CSS3效果挑战小汇总</a></p><p><a href="https://juejin.im/post/5c0f6b9df265da614b11d63c">推荐阅读：css绘制特殊图形</a></p><p><a href="https://www.zhangxinxu.com/study/201511/demo-border-radius.html">推荐：CSS3 border-radius圆角各个属性值作用演示实例页面</a></p></div></div><h3 id="考察-JS"><a href="#考察-JS" class="headerlink" title="考察 JS"></a>考察 JS</h3><h4 id="下面代码会输出什么？（考察变量提升）"><a href="#下面代码会输出什么？（考察变量提升）" class="headerlink" title="下面代码会输出什么？（考察变量提升）"></a>下面代码会输出什么？（考察变量提升）</h4><p><a href="https://juejin.im/post/5d79b9f351882507ba226047">推荐阅读：JavaScript变量提升运行机制</a></p><h5 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a);</span><br></pre></td></tr></table></figure><p>此时会报错，因为a未定义。<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200611101610780.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><h5 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="keyword">var</span> a=<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>会输出 <code>undefined</code><br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/2020061110442013.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""><br>上述代码中，变量 <code>a</code> 用 <code>var</code> 命令声明，会发生变量提升，即脚本开始运行时，变量 <code>a</code> 已经存在了，但是没有值，所以会输出 <code>undefined</code> 。</p><h5 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="keyword">var</span> a=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>上述代码会输出一个函数 <code>a</code><br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200611114402620.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""><br>考察知识点：当有多个同名变量声明的时候，函数声明会覆盖其他的声明。如果有多个函数声明，则是由最后的一个函数声明覆盖之前所有的声明。</p><h5 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a>第四步</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="keyword">var</span> a=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">a=<span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>上述代码结果与知识点与 <code>第三步</code> 一样</p><h5 id="第五步"><a href="#第五步" class="headerlink" title="第五步"></a>第五步</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="keyword">var</span> a=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">a=<span class="number">2</span>;</span><br><span class="line">a();</span><br></pre></td></tr></table></figure><p><a href="https://juejin.im/post/5bd465b4f265da0ac07c9b96">推荐阅读：javascript变量提升详解</a><br><a href="https://juejin.im/post/5afcf1b96fb9a07abd0ddc43">推荐阅读：深入浅出JS - 变量提升（函数声明提升）</a></p><p>输出结果：<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200611115346130.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" alt=""></p><p>上述代码，首先进行函数声明提升，然后再进行变量提升，此时 <code>a</code>已经是一个变量了，不再是一个函数了，所以就会 <code>throw error</code> 。</p><h4 id="下面代码会输出什么？（考察事件循环）"><a href="#下面代码会输出什么？（考察事件循环）" class="headerlink" title="下面代码会输出什么？（考察事件循环）"></a>下面代码会输出什么？（考察事件循环）</h4><p><a href="https://juejin.im/post/5c60e090f265da2dd8687013">推荐阅读：Javascript 事件循环event loop</a></p><h5 id="第一步-1"><a href="#第一步-1" class="headerlink" title="第一步"></a>第一步</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">&#125;,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line"><span class="comment">// 输出结果：2 1</span></span><br></pre></td></tr></table></figure><h5 id="第二步-1"><a href="#第二步-1" class="headerlink" title="第二步"></a>第二步</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">&#125;,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">    resolve(<span class="number">4</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">val</span> =&gt;</span> <span class="built_in">console</span>.log(val))</span><br><span class="line"><span class="comment">// 输出结果：2 3 4 1</span></span><br></pre></td></tr></table></figure><h5 id="第三步-1"><a href="#第三步-1" class="headerlink" title="第三步"></a>第三步</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="number">1</span>))</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="number">3</span>))</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure><p>之前那几题答完后，这道题，我毫不犹豫的直接说了 2 4 1 3 ，然后面试官给了我下面这代码提示，啪，直接被拍醒…</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.body.click()</span><br></pre></td></tr></table></figure><p>答案是 <code>2 1 4 3</code> </p><blockquote><p>谢谢评论区小伙伴提醒，现已修改。</p></blockquote><p>后面搜了相关资料，原来是设计模式中的<strong>发布-订阅模式</strong>，之前就看了面经，知道字节喜欢考这个设计模式，原来真的又考到了，不过题型不一样罢了。</p><p><a href="https://juejin.im/post/5a9108b6f265da4e7527b1a4">推荐阅读：Javascript设计模式之发布-订阅模式</a></p><p><a href="https://juejin.im/post/5cd7b3ea6fb9a0324a08c933">推荐阅读：前端JavaScript的发布-订阅模式</a></p><h3 id="算法题"><a href="#算法题" class="headerlink" title="算法题"></a>算法题</h3><h4 id="你了解回文字符串吗？例如abba，写一下代码吧（不限语言）"><a href="#你了解回文字符串吗？例如abba，写一下代码吧（不限语言）" class="headerlink" title="你了解回文字符串吗？例如abba，写一下代码吧（不限语言）"></a>你了解回文字符串吗？例如abba，写一下代码吧（不限语言）</h4><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;str;</span><br><span class="line">    <span class="keyword">int</span> len=str.length();</span><br><span class="line">    <span class="keyword">int</span> mid=(len+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">string</span> ans1=str.substr(<span class="number">0</span>,mid); <span class="comment">//取前半段字符串</span></span><br><span class="line">    <span class="keyword">if</span>(len&amp;<span class="number">1</span>) mid--;</span><br><span class="line">    <span class="built_in">string</span> ans2=str.substr(mid,len-mid); <span class="comment">//取后半段字符串</span></span><br><span class="line">    reverse(ans2.begin(),ans2.end()); <span class="comment">//取反</span></span><br><span class="line">    <span class="keyword">if</span>(ans1==ans2) <span class="built_in">cout</span>&lt;&lt;<span class="number">1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于不限语言，我就用了 <code>C++</code> 编写了，当时忘记对第二个字符串取反了，也<del>没有验证是否可行，就直接上代码了</del> … </p></div></div><h4 id="那你可以求出字符串中最长回文子串吗？例如给你abbac，得到abba"><a href="#那你可以求出字符串中最长回文子串吗？例如给你abbac，得到abba" class="headerlink" title="那你可以求出字符串中最长回文子串吗？例如给你abbac，得到abba"></a>那你可以求出字符串中最长回文子串吗？例如给你abbac，得到abba</h4><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>我当时提到了马拉车算法（<code>Manacher</code>），面试官要我手写一下，还是吃了过去的亏啊，打比赛还遇到过，没有怎么使用就忘了，今天又重新温习一下吧…</p><p>话不多说，先贴参考博客：</p><p><a href="https://www.jianshu.com/p/392172762e55">推荐阅读：马拉车算法（Manacher’s Algorithm）</a></p><p>贴上代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define endl <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int maxn=<span class="number">1e3</span>+<span class="number">5</span>;</span><br><span class="line">int p[maxn];</span><br><span class="line">int <span class="function"><span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    string str;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;str)&#123;</span><br><span class="line">        string s=<span class="string">&quot;$&quot;</span>;<span class="comment">//第一步:预处理，将原字符串转换为新字符串</span></span><br><span class="line">        <span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;str.length();i++)</span><br><span class="line">            s+=<span class="string">&quot;#&quot;</span>,s+=str[i];</span><br><span class="line">        s+=<span class="string">&quot;#@&quot;</span>; <span class="comment">//尾部再加上字符@，将偶数长度变为奇数长度</span></span><br><span class="line">        int n=s.length();</span><br><span class="line">        int id=<span class="number">0</span>,mx=<span class="number">0</span>; <span class="comment">//初始化中心位置和最右端位置</span></span><br><span class="line">        int maxlen=-<span class="number">1</span>,idx=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(int j=<span class="number">1</span>;j&lt;n-<span class="number">1</span>;j++)&#123;</span><br><span class="line">            p[j]=mx&gt;j? min(p[<span class="number">2</span>*id-j],mx-j):<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(s.at(j+p[j]) == s.at(j-p[j])) <span class="comment">//向左右两边拓展</span></span><br><span class="line">                p[j]++;</span><br><span class="line">            <span class="keyword">if</span>(mx&lt;p[j]+j)&#123; <span class="comment">//如果超过右边界，进行更新</span></span><br><span class="line">                mx=p[j]+j;</span><br><span class="line">                id=j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(maxlen&lt;p[j]-<span class="number">1</span>)&#123; <span class="comment">//更新最大长度和中心索引位置</span></span><br><span class="line">                maxlen=p[j]-<span class="number">1</span>;</span><br><span class="line">                idx=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int start=(idx-maxlen)/<span class="number">2</span>;  <span class="comment">//求起始点索引</span></span><br><span class="line">        string ans=str.substr(start,maxlen); <span class="comment">//字符串截取得到最长回文子串</span></span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用两种数据，进行测试，得到如下结果：<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200611194734180.png" alt=""></p></div></div><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>每次面完之后，都要好好总结一下。当我写完这篇文章之后，我发现本次面试难度算很低了，没有考察要你手撕各种设计模式，还有手撕 <code>Promise</code>、手撕 <code>new</code>等等。这些我在面试前还做了准备，但是我发现我又遗忘了…原因很简单，只是第一次接触那些手撕，用的也不是很多，还有更多的知识也是在面试前抢记的。看的特别广而杂，反而知识没有连通性，记着记着自然遗忘了。</p><p>其次，对于字节跳动，经历过这一次面试后，我也逐渐发现面试都差不多，面试官都挺好的，期间还会暗示你（当然你懂他意思的话…），面之前，一看是头条我一下觉得没啥自信了，都说头条很在意算法，但本次考察的算法好像没有 <code>acm</code> 那样的难度，而是自己把自己给吓住了，信心自然没了…</p><p>过了好几天了，也没有收到感谢信，当然，也没有收到下次面试通知，估计是 “入库” 了吧，在此，写下今后的安排：</p><ul><li>无需惧怕算法题，难度真的没有 <code>acm</code> 那个高度 </li><li>将知识重新捡起来，不要在要面试的时候，才临时抢记知识</li><li>安静地努力，每篇文章写完后就要消化，不要没弄懂就发布</li><li>文章不在于多，而在于精，将每篇文章都要认真书写，让读者都能一读即懂</li></ul><p>发现每次只有把知识点讲出来才会印象深刻，今后的日子也要这样做！</p><p>最后，本次面经书写完毕，算是一次不错的体验了，还要继续加油~</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">学如逆水行舟，不进则退</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 春招 </tag>
            
            <tag> 字节跳动 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【春招&amp;实习】前端学习の优质资料整理&amp;心路历程</title>
      <link href="posts/520521/"/>
      <url>posts/520521/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><h3 id="写这篇博客原因"><a href="#写这篇博客原因" class="headerlink" title="写这篇博客原因"></a>写这篇博客原因</h3><p>我就简单谈谈我为什么要整理这份学习资料吧，首先，春招遗憾没有上岸，可以说没抓住机遇，准备也不够好，但我努力的轨迹还在，运气或许没到，但我坚持下来的勇气一直都在！每一份坚持都是成功的积累，我还是相信自己，总会遇到惊喜，因为我觉得在成功成长之前，还有一个 <strong>“扎根”</strong> 的过程积累。</p><p>那么，以上废话少说，多做！6月份，听了班里若峰dalao面试经验分享后，我发现了一位前端掘金dalao——<strong>神三元</strong>，他整理的文章和他的经验分享简直太棒了~，然后又从他所关注点赞的文章，我又发现了更多优质的前端学习文章，也就是我这篇博客所要分享的内容了。以下部分内容引自 <a href="https://juejin.im/post/5e7d4e8b6fb9a03c6422f112"><strong>神三元大佬</strong></a> 的经验：</p><h3 id="三元大佬经验分享"><a href="#三元大佬经验分享" class="headerlink" title="三元大佬经验分享"></a>三元大佬经验分享</h3><p>谁的人生不是这么误打误撞过来的呢？那你可能就会问了，你凭什么能够把基础学的那么扎实，通过这些大厂的面试呢？</p><p>我觉得有两点，一点是 <code>外在</code> 的因素，一点是 <code>内在</code> 的因素。</p><blockquote><p>对外在的方面，我在输入一些信息的同时，会加入自己的思考和推敲，然后用自己的方式来输出，整理成博客，这使得我能够对知识体系本身有更加深刻的理解，同时也能在忘记这部分知识点之后，重新回顾的时候能够很快捡起来，节省了非常多复习的时间。<br>对内在的方面，我觉得自驱力是一个比较重要的因素，即自己驱动自己学习的能力。其实说起来容易，做起来是非常难的，因为外界的诱惑实在是太多，而且学习本身就是脱离舒适区的活动，是一种反人性的活动，本身就是让人不舒服的，因此很多人不愿意主动学习，这是完全可以理解的。那我为什么会有这种强烈的自驱力呢？<br>因为危机感，危机感随之带来了恐惧。</p></blockquote><p>为什么这么说？</p><p>以前听《得到》APP上的梁宁老师讲过，人性其实只有两大痛点: 一个是愉悦，一个是恐惧。 <strong>愉悦感可以让人沉浸在一件事情当中干一万小时，成为高手，而恐惧带来的动力更加显著。</strong> 对产品来说，要么就让用户爆爽，要么就去帮助他抵御恐惧，否则就不是一个优秀的产品。那么对于个人的成长而言，你做一件事情，没有找到任何愉悦的感觉，也没有产生过任何恐惧，那么他基本上在这个领域一事无成。<br>换句话说，<strong>如果一件事情让你非常疯狂地去做，要么这件事让你爆爽，要么它帮助你抵御恐惧。</strong></p><blockquote><p>对我来讲，真正驱动我的是后者。危机意识让我挖掘出真正的痛点，发现自己的恐惧所在，从而带来强大的自驱力。如果说仅仅是学一些东西来炫耀一番，或者只是去迎合外界的期望，这种动力可以有，但仅仅只是暂时的。当你走出舒适区，面对外界无数诱惑的时候，真正能 carry 你继续学习的是你内心的痛点。</p></blockquote><blockquote><p>我觉得明白这一点，比所谓的学习路径、学习方法重要得多。因为大多数时候我们不是缺少学习资料，或者没有掌握什么高效的学习方法，只是因为你动力不足、容易懈怠罢了。每个人情况都各不相同，但我觉得想要成长，挖掘自己真正的痛点是最重要的一件事情。</p></blockquote><h3 id="心得与体会"><a href="#心得与体会" class="headerlink" title="心得与体会"></a>心得与体会</h3><p>看完他的经验分享，我直呼 （tql ！Orz），读完他的文章后，受到了鼓舞。我也赞同他的观点，驱动我的也是<strong>危机感</strong>，坚持自己的努力轨迹，走出舒适区，我想，我也会收到一次<strong>惊喜</strong>。</p><blockquote><p>暂时就写到这了，还有很多资料也还在学习当中，后续进行补充…</p></blockquote><blockquote><p>关于前端体系知识点本人也还在学习当中，此文分享本人学习发现的优质博客和github，如若有更优质的文章，可以在文末评论区留言，或者你可以推荐自己的优质博客都可~</p></blockquote><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><blockquote><p>本篇博客只做推荐，多为本人学习过程中发现的优质博客，觉得不错，就进行了整理，方便后续自己回顾。但本文部分文字或多或少引用了dalao们的总结，感谢本文所有dalao们的优质博客！文章内容均属于原作者。如若链接少了作者名或着失效，可以在评论区联系博客，谢谢合作~</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL2Nob2NvbGF0ZTE5OTkvY2RuL2ltZy8yMDIwMDYyOTE3MTMyNC5qcGc?x-oss-process=image/format,png" alt=""></p><h2 id="CSS篇"><a href="#CSS篇" class="headerlink" title="CSS篇"></a>CSS篇</h2><p><a href="https://juejin.im/post/5da282015188257d2a1c9e1d">神三元：剖析一些经典的CSS布局问题，为前端开发+面试保驾护航</a></p><p><a href="https://yangchaoyi.vip/posts/2055211/">超逸の博客：前端知识梳理之CSS篇</a></p><p><a href="https://juejin.im/post/5a957bcf6fb9a0635b535812">CodeDeer：纯CSS画三角原理解析</a></p><p><a href="https://juejin.im/post/5d4d0ec651882549594e7293">JowayYoung：灵活运用CSS开发技巧</a></p><p><a href="https://juejin.im/post/5c8322a9e51d452fee00b70f">大志前端：【前端帮帮忙】第4期 使用纯CSS制作一个开关按钮</a></p><p><a href="https://codepen.io/chocolate1999/pen/eYJvOwz">Chocolate：CSS制作开关按钮源码（演示）</a></p><h2 id="JS篇"><a href="#JS篇" class="headerlink" title="JS篇"></a>JS篇</h2><p><a href="https://juejin.im/entry/589be5b1b123db16a3bec5c2">追梦子：彻底理解 JS 中 this 的指向</a></p><p><a href="https://www.cnblogs.com/pssp/p/5215621.html">追梦子：JavaScript中call,apply,bind方法的总结</a></p><p><a href="https://github.com/lydiahallie/javascript-questions/blob/master/zh-CN/README-zh_CN.md">JavaScript 进阶问题列表（测测你有多了解 javascript）</a></p><p><a href="https://juejin.im/post/5ebb68796fb9a0435432df8e">金色小芝麻：想自学JS吗？想提升JS底层原理吗？76张脑图带你彻底搞懂原生JS</a></p><h2 id="ES6-ES10篇"><a href="#ES6-ES10篇" class="headerlink" title="ES6-ES10篇"></a>ES6-ES10篇</h2><p><a href="https://juejin.im/post/5c7e6ccbe51d4541e479db21">榴莲布丁:【ES6基础】 Map用法总结</a></p><p><a href="https://juejin.im/post/5dfa5cb86fb9a0165721db1d">陈大鱼头：从ES6到ES10的新特性万字大总结（不得不收藏）</a></p><h2 id="虚拟DOM（diff算法）"><a href="#虚拟DOM（diff算法）" class="headerlink" title="虚拟DOM（diff算法）"></a>虚拟DOM（diff算法）</h2><p><a href="https://juejin.im/post/5e7ac6365188255de700f7ed">txm：大厂面试官：请阐述一下你对虚拟DOM和Dom-Diff的理解？</a></p><p><a href="https://juejin.im/post/5c4a76b4e51d4526e57da225#heading-0">noobakong：虚拟DOM和Diff算法 - 入门级</a></p><p><a href="https://juejin.im/post/5d5ffad2518825258a772fa8">vdk：Vue中的虚拟DOM及diff算法</a></p><p><a href="https://juejin.im/post/5eac3babf265da7bcd5c4d8b#heading-0">小小晴:【React】深入理解虚拟dom和diff算法</a></p><h2 id="Node-js篇"><a href="#Node-js篇" class="headerlink" title="Node.js篇"></a>Node.js篇</h2><p><a href="https://www.nodejs.red/#/">Node.js技术栈</a></p><h2 id="计算机网络篇"><a href="#计算机网络篇" class="headerlink" title="计算机网络篇"></a>计算机网络篇</h2><p><a href="https://juejin.im/post/5e76bd516fb9a07cce750746">神三元：(建议精读）HTTP灵魂之问，巩固你的 HTTP 知识体系</a></p><p><a href="https://juejin.im/post/5e527c58e51d4526c654bf41">神三元：(建议收藏）TCP协议灵魂之问，巩固你的网路底层基础</a></p><p><a href="https://juejin.im/post/5ca6a109e51d4544e27e3048">浪里行舟：深入理解HTTPS工作原理</a></p><h2 id="浏览器篇"><a href="#浏览器篇" class="headerlink" title="浏览器篇"></a>浏览器篇</h2><p><a href="https://juejin.im/post/5df5bcea6fb9a016091def69#heading-25">神三元：(1.6w字）浏览器灵魂之问，请问你能接得住几个？</a></p><p><a href="https://juejin.im/post/5b1cebece51d4506ae71addf">浪里行舟：Ajax原理一篇就够了</a></p><h2 id="数据结构与算法篇"><a href="#数据结构与算法篇" class="headerlink" title="数据结构与算法篇"></a>数据结构与算法篇</h2><p><a href="http://www.conardli.top/docs/dataStructure/">awesome-coding-js：用JS玩转数据结构与算法</a></p><p><a href="http://scriptoj.mangojuice.top/problems?tag=%E7%BB%8F%E5%85%B8%E7%AC%94%E8%AF%95%E9%A2%98">ScriptOJ：前端首个 Web 前端开发评测系统</a></p><p><a href="https://juejin.im/post/5d5b307b5188253da24d3cd1">ConardLi：前端该如何准备数据结构和算法？</a></p><p><a href="https://github.com/trekhleb/javascript-algorithms/blob/master/README.zh-CN.md">JavaScript 算法与数据结构</a></p><p><a href="https://juejin.im/post/5ee6d9026fb9a047e60815f1">晨曦时梦见兮：前端电商 sku 的全排列算法很难吗？学会这个套路，彻底掌握排列组合。</a></p><p><a href="https://juejin.im/post/5e3d3f25e51d45270c276fe3">Jay_huaxiao：看一遍就理解，图解单链表反转</a></p><h2 id="Vue篇"><a href="#Vue篇" class="headerlink" title="Vue篇"></a>Vue篇</h2><p><a href="https://juejin.im/post/5ee4965a6fb9a047dd27695a">金色小芝麻：30张脑图带你从零开始学VUE｜VUE基础知识篇</a></p><p><a href="https://juejin.im/post/5e1b37f6f265da3e51530a39">小明同学哟：彻底理解Vue组件间通信(6种方式)</a></p><p><a href="https://juejin.im/post/5cde0b43f265da03867e78d3">浪里行舟：Vue 组件间通信六种方式（完整版）</a></p><p><a href="https://juejin.im/post/5b82bcfcf265da4345153343#heading-33">shotCat：可能比文档还详细–VueRouter完全指北</a></p><p><a href="https://blog.csdn.net/qq_37816525/article/details/101261248">柚子233：如何在一个页面使用多个router-view显示不同的内容</a></p><p><a href="https://juejin.im/post/5ecb8d9b51882543034918fe">一叶知秋666：vue-router 基本使用</a></p><p><a href="https://juejin.im/post/5e89f867f265da47dd3982f8">晨曦时梦见兮：请你说说 Vue 中 slot 和 slot-scope 的原理（2.6.11 深度解析）</a></p><p><a href="https://juejin.im/post/5e88953b6fb9a03c4e6468a5">晨曦时梦见兮：Vue 的生命周期之间到底做了什么事清？（源码详解，带你从头梳理组件化流程）</a></p><p><a href="https://juejin.im/post/5e8694b75188257372503722">晨曦时梦见兮：为什么 Vue 中不要用 index 作为 key？（diff 算法详解）</a></p><p><a href="https://juejin.im/post/5e8dd5266fb9a03c703fb168">晨曦时梦见兮：驳《前端常见的Vue面试题目汇总》</a></p><h2 id="React篇"><a href="#React篇" class="headerlink" title="React篇"></a>React篇</h2><p><a href="https://juejin.im/post/5eeb1fcdf265da02ec0bbf51">wangly19：一天学习React入门后的千字基础总结</a></p><h2 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h2><p><a href="https://juejin.im/post/5e13ea6a6fb9a0482b297e8e">晨曦时梦见兮：Koa的洋葱中间件，Redux的中间件，Axios的拦截器让你迷惑吗？实现一个精简版的就彻底搞懂了。</a></p><p><a href="https://juejin.im/post/5e63479ae51d4526cb162bfc">小畅叙：Koa2 简单入门</a></p><p><a href="https://juejin.im/post/5c6eb4ac6fb9a049d4426ab2">xiangzhihong：Koa2开发快速入门</a></p><h2 id="源码篇（手撕原理）"><a href="#源码篇（手撕原理）" class="headerlink" title="源码篇（手撕原理）"></a>源码篇（手撕原理）</h2><p><a href="https://mp.weixin.qq.com/s/jLe09cxuRI_10q95yePkiw">小鹿动画学编程：动手实践去实现 Vue 2.0 的核心原理</a></p><p><a href="https://blog.csdn.net/qq_36903042/article/details/106405688">小鹿动画学编程：阿里面试官让我手写 Vue 2.0核心原理，我都整理好了！</a></p><p><a href="https://juejin.im/post/5e77888ff265da57187c7278">小明同学哟：手写源码系列</a></p><p><a href="https://juejin.im/post/5e8153bf6fb9a03c840d509d#heading-22">txm：面试时，你被要求手写常见原理了吗？</a></p><p><a href="https://juejin.im/post/5d845ecdf265da03ce3a122f">蓝莓圣代：手写jsonp实现原理</a></p><p><a href="https://juejin.im/post/5e4d41025188254963275929">迪迪同学：call, apply, bind 区别及原理</a></p><p><a href="https://juejin.im/post/5e1b3144f265da3e4b5be2e3">txm：手写一套完整的基于Vue的MVVM原理</a></p><h2 id="Promise篇"><a href="#Promise篇" class="headerlink" title="Promise篇"></a>Promise篇</h2><p><a href="https://juejin.im/post/5e2168626fb9a0300d619c9e">小明同学哟：一步步教你实现Promise/A+ 规范 完整版</a></p><p><a href="https://juejin.im/post/5ea6201de51d4546eb52660f#heading-15">小明同学哟：Promise系列</a></p><h2 id="优秀公众号推文"><a href="#优秀公众号推文" class="headerlink" title="优秀公众号推文"></a>优秀公众号推文</h2><p><a href="https://mp.weixin.qq.com/s/bHclDpsGdfaZQT8u9VRAAw">前端瓶子君：前端面试基础题集合！赶紧上车！</a></p><h2 id="前端面经大全"><a href="#前端面经大全" class="headerlink" title="前端面经大全"></a>前端面经大全</h2><p><a href="https://juejin.im/post/5e7d4e8b6fb9a03c6422f112#heading-8">神三元：2020三元同学春招阿里淘系、阿里云、字节跳动面经 &amp; 个人成长经验分享 | 掘金技术征文</a></p><p><a href="https://juejin.im/post/5eb55ceb6fb9a0436748297d">LinDaiDai_霖呆呆：霖呆呆的近期面试128题汇总(含超详细答案) | 掘金技术征文</a></p><p><a href="https://juejin.im/post/5d87985d6fb9a06add4e6ac3">小明同学哟：初中级前端面试题</a></p><p><a href="https://juejin.im/post/5e4c0b856fb9a07ccb7e8eca#heading-24">txm：初中级前端面试题（万字长文）</a></p><p><strong>字节跳动2020面试算法题+场景题+智力题100题</strong></p><p><a href="https://www.nowcoder.com/discuss/425581?source_id=profile_create&channel=666">题集：字节跳动2020面试算法题+场景题+智力题100题 </a></p><p><a href="https://www.nowcoder.com/discuss/428158?source_id=profile_create&channel=666">（答案1）字节跳动算法题+场景题+智力题100题</a></p><p><a href="https://www.nowcoder.com/discuss/428774?type=2&channel=666&source_id=discuss_terminal_discuss_jinghua">（答案2）字节跳动算法题+场景题+智力题100题</a></p><h2 id="前端优质博客-Github"><a href="#前端优质博客-Github" class="headerlink" title="前端优质博客/Github"></a>前端优质博客/Github</h2><p><a href="https://yuchengkai.cn/docs/frontend/browser.html">yck掘金小册：前端进阶之道</a></p><p><a href="http://www.conardli.top/blog/article/">ConardLi的blog</a></p><p><a href="https://blog.poetries.top/FE-Interview-Questions/base/">FE-Interview 前端面试题整理</a></p><p><a href="https://lucifer.ren/fe-interview/#/">大前端面试宝典 - 图解前端</a></p><h2 id="心路历程-大佬经验分享"><a href="#心路历程-大佬经验分享" class="headerlink" title="心路历程 / 大佬经验分享"></a>心路历程 / 大佬经验分享</h2><p><a href="https://juejin.im/post/5e9ac2006fb9a03c763d174c">Bestbven：双非院校，成绩不好的他，怎么突然拿到大厂offer了？| 掘金技术征文</a></p><p><a href="https://juejin.im/post/5e85ec79e51d4547153d0738">LienJack：艺术喵 2 年前端面试心路历程（字节跳动、YY、虎牙、BIGO）| 掘金技术征文</a></p><p><a href="https://juejin.im/post/5dfb9d6cf265da339856335b">LienJack：2019学习学到失恋但是还要继续|2019 与我的技术之路</a></p><p><a href="https://juejin.im/post/5c36fe50518825253b5e94f4">LienJack：一位前端 2018 绝地求生记 | 掘金年度征文</a></p><p><a href="https://juejin.im/post/5cfbcb5951882568862d69f0">txm：生日之际，记录自己前端拼搏之路~</a></p><p><a href="https://juejin.im/post/5e7c08bde51d455c4c66ddad">晨曦时梦见兮：写给初中级前端的高级进阶指南</a></p><p><a href="https://juejin.im/post/5e7af0685188255dcf4a497e">晨曦时梦见兮：写给女朋友的中级前端面试秘籍（含详细答案，15k级别）</a></p><p><a href="https://juejin.im/post/5dfef50751882512444027eb">yck：看完跳槽少说涨 5 K，前端面试从准备到谈薪完全指南（近万字精华）</a></p><h2 id="未来展望与实习经历"><a href="#未来展望与实习经历" class="headerlink" title="未来展望与实习经历"></a>未来展望与实习经历</h2><p>从春招到现在，陆陆续续也面了一些公司，我以时间线形式整理到了下面，整条路也是经历了挺多，零基础学习前端，从2月份准备到6月份，最终拿下恒生的 <code>offer</code> ，努力终究得到了回报。</p><p><a href="https://yangchaoyi.vip/posts/tencentOne/">【腾讯】记录腾讯一面（IMWeb团队）</a></p><p><a href="https://yangchaoyi.vip/posts/2055151/">【腾讯】腾讯云COS前端一面凉经</a></p><p><a href="https://yangchaoyi.vip/posts/2020611/">【字节跳动】前端一面面经</a></p><p><a href="https://yangchaoyi.vip/posts/2020616/">【深信服】星耀实习生（前端开发）笔试&amp;面试分享</a></p><p><a href="https://yangchaoyi.vip/posts/2020621/">【恒生电子】2021实习（前端） 笔试&amp;面试分享</a></p><p>关于未来展望的话，还是等实习之后再继续编写吧，到时候再来分享一下实习经历与心得</p><blockquote><p>后续待补充…</p></blockquote><h2 id="鸣谢"><a href="#鸣谢" class="headerlink" title="鸣谢"></a>鸣谢</h2><p>本篇博客知识点与相关文字都参照了各位大佬的博客，由于大佬太多了，也不太方便一个一个感谢了，但在本文已经都注明了各位大佬的博客出处，在此表示感谢，感谢各位大佬的优质文章 ✿✿ヽ(°▽°)ノ✿，小伙伴们都可以去他们主页逛逛，总会有一些好的内容等待着你去发掘~</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p>以下部分引用三元大佬经验分享</p></blockquote><h3 id="面试阶段"><a href="#面试阶段" class="headerlink" title="面试阶段"></a>面试阶段</h3><p>从上面的面经中可以看到不同方向、不同级别的面试官各自的偏好不一样，因此对于不同的面试官，采取的策略也应有所不同。但我更想分享的是一些具有共性的地方，这些策略可以适用于绝大部分的面试场景，让自己获得更大的竞争优势。当然，所谓的面试策略，都是基于你前期充分的准备，不然都只是天方夜谭，毫无可行性。</p><h4 id="策略一-备好杀手锏"><a href="#策略一-备好杀手锏" class="headerlink" title="策略一: 备好杀手锏"></a>策略一: 备好杀手锏</h4><p>面试官一天可能要面5-6人，甚至十几人，那么你是否想过: 他凭什么对你印象更加深刻？</p><p>心理学有一个效应叫 <strong>峰终效应</strong> ，就是人在一个有限的活动当中，对一件陌生事物的看法大致由两个时间点所决定: 一个是高潮点，一个是结尾的点。<br>对面试而言，我认为同样是适用，具体来讲，和面试官的交流，其实也就是和一个陌生人的交流，如何来给他留下更深刻的印象？需要在高潮点展现自己，在结尾点保护自己，在面试的过程中适当给面试官一些和别人不一样的回答和见解，使之感到惊艳，而在结尾的时候，你说的话其实更容易被面试官记住，这个时候由于面试已经接近尾声，你可能没有当时那么紧张，这个时候需要适当的谨慎一些，不要彻底放松，避免不小心说出一些对自己处境不利的话。</p><p>其实，我更想强调的是前者，即如何将面试带上一个高潮点，并且让面试官感到惊艳。其实这并不是什么简单的事情，毕竟能惊艳的只是少数，那么如果才能做到这一点呢？<br>在面试前，不妨准备好自己的<code>杀手锏</code>。什么是杀手锏？就是每当面试官问到相关的问题的时候，你能够有自信比 90% 的人理解得更深刻，回答更出色。以我自己为例，我准备的杀手锏并不少，<code>HTTPS 所有加密算法</code>，<code>chromium 进程 IPC 原理</code>，<code>斐波拉契第 n 数的 logn 解法</code>，<code>浏览器渲染过程</code>，<code>vue 编译器架构</code>，<code>vue 双向绑定</code>，<code>快排以及手写 V8 排序</code> ……</p><p>在其它基础知识都 OK 的前提下，这些杀手锏是你技术上的核心竞争力，这是你和其他人相比体现不可替代性的地方。当然，时间有限，不可能每个角度都能研究很深入，但如果你不准备，跟大家背一样的答案，很难从人群当中脱颖而出。</p><h4 id="策略二-适当暗示"><a href="#策略二-适当暗示" class="headerlink" title="策略二: 适当暗示"></a>策略二: 适当暗示</h4><p>面试的过程其实就是一个和面试官互相试探的过程，一方面是他对你提问，另一方面你需要给他一些信号，引导他去挖掘你的闪光点。</p><p>其实有两个时机可以发一些暗示的信号，一个是自我介绍的环节，这个环节中可以向面试官展示出你之前深入研究过哪一块的技术，指引他往那个方向问，另一个是技术细节的提问，可以在回答的时候适当发挥，大部分面试官是愿意听你展开的。</p><h3 id="个人经验分享"><a href="#个人经验分享" class="headerlink" title="个人经验分享"></a>个人经验分享</h3><p>说实在，大佬的经验已经足够我学习了，已经整理在了 <strong>心路历程 / 大佬经验分享</strong> 模块，想必阅读到此的你应该已经看了部分大佬的经验分享了。这里，我就说说我整个找实习的过程吧。</p><h4 id="梦初"><a href="#梦初" class="headerlink" title="梦初"></a>梦初</h4><p>起初，我对于实习这块是完全不知道的，应该与大多数人一样的感觉，好像也没有人告诉我们什么时候要实习了，实习的重要性，到底要不要实习，貌似没有人解答我这个问题。也许是巧合又或者是机遇，我在寒假期间找到了16级志杰学长，他是我们学校ACM队dalao，依旧还记得去年省赛他说手撕伸展树（虽然到现在我也不知道这是啥玩意，反正很强就是了！），我询问大三下我是否还要继续打acm，因为我感觉我想要到达我想要的阶梯还是有很大差距。和学长交流了之后呢，他就简单问了我一句：开始找实习了吗？我一脸懵，我说我现在就要找了吗？这么快吗？我还啥都不会诶… 后面又与学长沟通了许久关于实习的话题。</p><p>此刻，就这么一句话，就是我整个找实习路程的开始。我确实是要开始准备了！</p><h4 id="梦中"><a href="#梦中" class="headerlink" title="梦中"></a>梦中</h4><p>就是关于我的一些面试经历了：</p><p><a href="https://yangchaoyi.vip/posts/tencentOne/">【腾讯】记录腾讯一面（IMWeb团队）</a></p><p><a href="https://yangchaoyi.vip/posts/2055151/">【腾讯】腾讯云COS前端一面凉经</a></p><p><a href="https://yangchaoyi.vip/posts/2020611/">【字节跳动】前端一面面经</a></p><p><a href="https://yangchaoyi.vip/posts/2020616/">【深信服】星耀实习生（前端开发）笔试&amp;面试分享</a></p><p><a href="https://yangchaoyi.vip/posts/2020621/">【恒生电子】2021实习（前端） 笔试&amp;面试分享</a></p><p>确定了自己要走前端开发后，我从2月份就开始学习前端，道路也是坎坷，甚至也走了点弯路。在整理好自己感觉不错的简历后，我最开始就投了 <strong>深信服</strong>，我以为我这个CSDN博客专家称号能让我提分很多，可是现实却拍醒了我，我的简历直接被拒了。我也庆幸自己被拒了，因为当时特别紧张，紧张到睡不着觉的那种，晚上睡前都在想明天会不会突然来个电话要我面试怎么办，我还没有准备好…</p><p>深信服被拒了之后，我在 <code>BOSS直聘</code> 上收到了腾讯前端架构师的面试邀约，当时给我激动的，毫不夸张地说，我甚至还联想到了自己到腾讯入职的样子。也就是上述第一份面试经验了，我又被啪啪打脸了，原来我与大厂的差距挺大的，而且我特别紧张，一点也不自信。<strong>第一次就面腾讯，我真佩服我自己！</strong></p><p>后续正式批到了，之前都是提前批，正式批收到了腾讯云的内推，于是我又去面了一次腾讯。结果也是可想而知，知识点还是不够深入，尽管我已经总结了很多知识点，但一到问我的时候，我没办法联想到相关知识点，或者说我不能举一反三，只能问我什么答什么，当然，大部分都答的很简单，可能不是面试官想要的答案。<strong>相关问题在面经里面都可以看到，这里我就不举例说明了。</strong></p><p>5月份，开学了，在学校里面，又有幸拿到了字节跳动的内推，于是我又开始了字节的面试，面完又是一面就结束了，整体下来体验不是很好，还是老问题，知识点还是不全面，就连基础题也会卡住。如果是要我找这些问题出在哪里，我能在我的整理博客里面找到，但真正到我说的时候，我就卡壳了… 这证明我的前端思维还是没打通，没有真正形成一个知识体系。<strong>字节也是与我无缘了…</strong></p><p>6月份，我鼓起勇气，开始投递恒生电子，四次宣讲会我都有参加。这个是了解一个公司比较好的方式，宣讲会有介绍他们的技术栈，主要业务。比如他们常说的：<code>恒生，让金融变简单！</code> 也正是参加了这次宣讲会，我也有幸中奖了，抽到了 <code>恒生雨伞</code>，不得不说，还真是缘分！而且通过宣讲会了解到了恒生可以说是是一家以程序员起手的公司，公司 <code>70%</code> 左右都是程序员，更关注的一点是没有那种上下级关系，员工关系的话都挺好的。而且在杭州，不错的城市，公司周围的环境也还是不错的，说是后面走 <code>10分钟</code> 就会看到樱花跑道，还说甚至可以和武汉的樱花比一比！此时的我，已经被这公司给吸引住了，我想去！我想再次尝试一下！</p><p>而在面试恒生电子之前，有很长一段时间过渡，我又收到了深信服的笔试邀请，原来当初我的简历并没有被刷掉，而是疫情影响进行了推迟，都是等到了5月份才正式开通实习招聘。疫情还真是影响了挺多的，愿早日过去。</p><p>关于深信服的笔试与面试就是我面恒生前的一次热身，当初我也是这么想的，如果能去深信服我也愿意去，反正也在长沙，如果没有缘分的话，那就好好准备恒生电子。深信服的笔试实在做的太差了，这里可以去看一看那篇面经，后面编程题几乎交了白卷。我原本以为没有笔试邀请了，想不到后面还捞了我，给了我面试机会。关于这次面试的总结，已经在面经码上了，可以去瞧瞧，这里就不再赘述了。</p><h4 id="梦醒"><a href="#梦醒" class="headerlink" title="梦醒"></a>梦醒</h4><blockquote><p>2020年6月29日 收到恒生电子 offer</p></blockquote><p>收到邮件时，当然是很开心的，准备了这么久，如愿收到回报，越努力越幸运！</p><p><strong>我们的征途是星辰大海！</strong> 在上文经验分享处，我说我佩服自己第一次就面腾讯，其实想说自己真的挺傻的，在没有准备好的情况下，直接去面自己想去的公司，相当于当了一次炮灰一样。而且大多数公司都是有面试记录的，太差了也会影响后续面试邀请，比如说字节跳动，自从一面凉了之后，之后所有的投递都投入 <code>“人才库”</code>里。其次，整个面试过程给了我一些毒打，但又让我成长了许多。比如我们去面试，与面试官交流，并不是我们单方面的一问一答，而是 <strong>交流</strong>，你怎么通过交流体现出你简历上面的能力，比如你的自学能力，你的表达沟通能力，你的领导能力等等。</p><p>另外，<strong>面试也是一次双向选择的过程</strong>，面试官让你通过面试，也是觉得你可以做它的同事，因为公司拉人，多数也是部门招人，招你过去很有可能就是他的同事了，后续一些工作安排，业务等等都会打交道的。当然面试官要进行筛选，选最合适的那一批人。</p><p>其次，<code>面试官都是挺好的</code>，可能个别会感觉有点高冷，甚至感觉与你不搭，这也是正常的。面试过程应该是一个轻松的过程，而不是那种一遇到问题就紧张说不出话的那种，尽管有些面试官会为难你，来个难题，也是为了考察你在高压的情况下你会如何判断处理。此时，对于你完全不会的地方，例如你可以这样回答：面试官，关于这一点的话，我本科阶段没有进行了解过，但与这个相关的另外一个知识点我知道，然后xxx，又或者说是关于这一点的话，你可以给我一点提示吗？又或者说是这一点我在本科阶段没有怎么了解过，但是我可以尝试解答一下，然后xxx。通过上述三种回答都比直接说不会要好很多！</p><p>经历几个月的历练，我也打通了前端思维了，好像面试就是那么回事，面着面着自信就来了，我甚至也可以和面试官吹吹牛，直接和他扯上20-30分钟知识点。</p><p>每一次面试都是好的经验，通过写博客总结的形式也是一个输入和输出的过程。这样也可以让自己知识点记得更加牢固一点，这里不得不说两年写博客经历还真是让我收获许多，我想恒生这次也是多亏了这个加分吧。其次， <strong>心态和自信方面挺重要的，尽管自己走的很慢，但是不会停下自己的脚步。</strong> 关于本篇博客知识点，我想应对实习也差不多了。关键是学习前端思维，明白自己要学什么，该怎么学，如何学。那么对于一份好的工作到来，也只是时间问题了。</p><blockquote><p>学如逆水行舟，不进则退！2020年6月29日晚，找实习的心路历程总结完毕，实习过后，再来一次实习经历总结吧。</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/chocolate1999/cdn/img/20200705153410.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 春招 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
